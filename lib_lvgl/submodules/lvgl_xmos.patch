diff --git a/demos/benchmark/lv_demo_benchmark.c b/demos/benchmark/lv_demo_benchmark.c
index 7c0d41abd..448887109 100644
--- a/demos/benchmark/lv_demo_benchmark.c
+++ b/demos/benchmark/lv_demo_benchmark.c
@@ -38,6 +38,7 @@
 
 typedef struct {
     const char * name;
+    __attribute__(( fptrgroup("lv_scene_create_cb") ))
     void (*create_cb)(void);
     uint32_t scene_time;
     uint32_t cpu_avg_usage;
@@ -72,11 +73,13 @@ static void arc_anim(lv_obj_t * obj);
 
 static lv_obj_t * card_create(void);
 
+__attribute__(( fptrgroup("lv_scene_create_cb") ))
 static void empty_screen_cb(void)
 {
     color_anim(lv_screen_active());
 }
 
+__attribute__(( fptrgroup("lv_scene_create_cb") ))
 static void moving_wallpaper_cb(void)
 {
     lv_obj_set_style_pad_all(lv_screen_active(), 0, 0);
@@ -89,6 +92,7 @@ static void moving_wallpaper_cb(void)
     shake_anim(img, - lv_display_get_vertical_resolution(NULL) / 3);
 }
 
+__attribute__(( fptrgroup("lv_scene_create_cb") ))
 static void single_rectangle_cb(void)
 {
     lv_obj_t * obj = lv_obj_create(lv_screen_active());
@@ -101,6 +105,7 @@ static void single_rectangle_cb(void)
 
 }
 
+__attribute__(( fptrgroup("lv_scene_create_cb") ))
 static void multiple_rectangles_cb(void)
 {
     lv_obj_set_flex_flow(lv_screen_active(), LV_FLEX_FLOW_ROW_WRAP);
@@ -117,6 +122,7 @@ static void multiple_rectangles_cb(void)
     }
 }
 
+__attribute__(( fptrgroup("lv_scene_create_cb") ))
 static void multiple_rgb_images_cb(void)
 {
     lv_obj_set_flex_flow(lv_screen_active(), LV_FLEX_FLOW_ROW_WRAP);
@@ -143,6 +149,7 @@ static void multiple_rgb_images_cb(void)
     }
 }
 
+__attribute__(( fptrgroup("lv_scene_create_cb") ))
 static void multiple_argb_images_cb(void)
 {
     lv_obj_set_flex_flow(lv_screen_active(), LV_FLEX_FLOW_ROW_WRAP);
@@ -169,6 +176,7 @@ static void multiple_argb_images_cb(void)
     }
 }
 
+__attribute__(( fptrgroup("lv_scene_create_cb") ))
 static void rotated_argb_image_cb(void)
 {
     lv_obj_set_flex_flow(lv_screen_active(), LV_FLEX_FLOW_ROW_WRAP);
@@ -196,6 +204,7 @@ static void rotated_argb_image_cb(void)
     }
 }
 
+__attribute__(( fptrgroup("lv_scene_create_cb") ))
 static void multiple_labels_cb(void)
 {
     lv_obj_set_flex_flow(lv_screen_active(), LV_FLEX_FLOW_ROW_WRAP);
@@ -219,6 +228,7 @@ static void multiple_labels_cb(void)
     }
 }
 
+__attribute__(( fptrgroup("lv_scene_create_cb") ))
 static void screen_sized_text_cb(void)
 {
     const char * txt =
@@ -239,6 +249,7 @@ static void screen_sized_text_cb(void)
     scroll_anim(scr, lv_obj_get_scroll_bottom(scr));
 }
 
+__attribute__(( fptrgroup("lv_scene_create_cb") ))
 static void multiple_arcs_cb(void)
 {
     lv_obj_set_flex_flow(lv_screen_active(), LV_FLEX_FLOW_ROW_WRAP);
@@ -274,6 +285,7 @@ static void multiple_arcs_cb(void)
     }
 }
 
+__attribute__(( fptrgroup("lv_scene_create_cb") ))
 static void containers_cb(void)
 {
 
@@ -297,6 +309,7 @@ static void containers_cb(void)
     }
 }
 
+__attribute__(( fptrgroup("lv_scene_create_cb") ))
 static void containers_with_overlay_cb(void)
 {
     lv_obj_set_flex_flow(lv_screen_active(), LV_FLEX_FLOW_ROW_WRAP);
@@ -322,6 +335,7 @@ static void containers_with_overlay_cb(void)
     color_anim(lv_layer_top());
 }
 
+__attribute__(( fptrgroup("lv_scene_create_cb") ))
 static void containers_with_opa_cb(void)
 {
     lv_obj_set_flex_flow(lv_screen_active(), LV_FLEX_FLOW_ROW_WRAP);
@@ -345,6 +359,7 @@ static void containers_with_opa_cb(void)
     }
 }
 
+__attribute__(( fptrgroup("lv_scene_create_cb") ))
 static void containers_with_opa_layer_cb(void)
 {
     lv_obj_set_flex_flow(lv_screen_active(), LV_FLEX_FLOW_ROW_WRAP);
@@ -368,6 +383,7 @@ static void containers_with_opa_layer_cb(void)
     }
 }
 
+__attribute__(( fptrgroup("lv_scene_create_cb") ))
 static void containers_with_scrolling_cb(void)
 {
     lv_obj_t * scr = lv_screen_active();
@@ -384,6 +400,7 @@ static void containers_with_scrolling_cb(void)
     scroll_anim(scr, lv_obj_get_scroll_bottom(scr));
 }
 
+__attribute__(( fptrgroup("lv_scene_create_cb") ))
 static void widgets_demo_cb(void)
 {
     lv_obj_t * scr = lv_screen_active();
@@ -431,7 +448,7 @@ static uint32_t rnd_act;
 /**********************
  *   GLOBAL FUNCTIONS
  **********************/
-
+__attribute__(( fptrgroup("lv_demo_entry_cb") ))
 void lv_demo_benchmark(void)
 {
     scene_act = 0;
@@ -470,6 +487,7 @@ void lv_demo_benchmark(void)
  *   STATIC FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 static void load_scene(uint32_t scene)
 {
     lv_obj_t * scr = lv_screen_active();
@@ -493,6 +511,7 @@ static void load_scene(uint32_t scene)
     if(scenes[scene].create_cb) scenes[scene].create_cb();
 }
 
+LV_FUNC_SECTION
 static void next_scene_timer_cb(lv_timer_t * timer)
 {
     LV_UNUSED(timer);
@@ -510,6 +529,7 @@ static void next_scene_timer_cb(lv_timer_t * timer)
 }
 
 #if LV_USE_PERF_MONITOR
+LV_FUNC_SECTION
 static void sysmon_perf_observer_cb(lv_observer_t * observer, lv_subject_t * subject)
 {
     const lv_sysmon_perf_info_t * info = lv_subject_get_pointer(subject);
@@ -548,6 +568,7 @@ static void sysmon_perf_observer_cb(lv_observer_t * observer, lv_subject_t * sub
 }
 #endif
 
+LV_FUNC_SECTION
 static void table_draw_task_event_cb(lv_event_t * e)
 {
     lv_draw_task_t * t = lv_event_get_draw_task(e);
@@ -580,6 +601,7 @@ static void table_draw_task_event_cb(lv_event_t * e)
 
 }
 
+LV_FUNC_SECTION
 static void summary_create(void)
 {
     lv_obj_clean(lv_screen_active());
@@ -684,6 +706,7 @@ static void summary_create(void)
  * SCENE HELPERS
  *----------------*/
 
+LV_FUNC_SECTION
 static void color_anim_cb(void * var, int32_t v)
 {
     LV_UNUSED(v);
@@ -691,6 +714,7 @@ static void color_anim_cb(void * var, int32_t v)
     lv_obj_set_style_text_color(var, lv_color_hex3(lv_rand(0x00f, 0xff0)), 0);
 }
 
+LV_FUNC_SECTION
 static void color_anim(lv_obj_t * obj)
 {
     lv_anim_t a;
@@ -703,11 +727,13 @@ static void color_anim(lv_obj_t * obj)
     lv_anim_start(&a);
 }
 
+LV_FUNC_SECTION
 static void arc_anim_cb(void * var, int32_t v)
 {
     lv_arc_set_value(var, v);
 }
 
+LV_FUNC_SECTION
 static void arc_anim(lv_obj_t * obj)
 {
     uint32_t t1 = rnd_next(1000, 3000);
@@ -723,11 +749,13 @@ static void arc_anim(lv_obj_t * obj)
     lv_anim_start(&a);
 }
 
+LV_FUNC_SECTION
 static void scroll_anim_y_cb(void * var, int32_t v)
 {
     lv_obj_scroll_to_y(var, v, LV_ANIM_OFF);
 }
 
+LV_FUNC_SECTION
 static void scroll_anim(lv_obj_t * obj, int32_t y_max)
 {
     uint32_t t = lv_anim_speed(lv_display_get_dpi(NULL));
@@ -743,11 +771,13 @@ static void scroll_anim(lv_obj_t * obj, int32_t y_max)
     lv_anim_start(&a);
 
 }
+LV_FUNC_SECTION
 static void shake_anim_y_cb(void * var, int32_t v)
 {
     lv_obj_set_style_translate_y(var, v, 0);
 }
 
+LV_FUNC_SECTION
 static void shake_anim(lv_obj_t * obj, int32_t y_max)
 {
     uint32_t t1 = rnd_next(300, 3000);
@@ -764,6 +794,7 @@ static void shake_anim(lv_obj_t * obj, int32_t y_max)
     lv_anim_start(&a);
 }
 
+LV_FUNC_SECTION
 static lv_obj_t * card_create(void)
 {
     lv_obj_t * panel = lv_obj_create(lv_screen_active());
@@ -794,11 +825,13 @@ static lv_obj_t * card_create(void)
     return panel;
 }
 
+LV_FUNC_SECTION
 static void rnd_reset(void)
 {
     rnd_act = 0;
 }
 
+LV_FUNC_SECTION
 static int32_t rnd_next(int32_t min, int32_t max)
 {
     static const uint32_t rnd_map[] = {
diff --git a/demos/flex_layout/lv_demo_flex_layout_ctrl_pad.c b/demos/flex_layout/lv_demo_flex_layout_ctrl_pad.c
index 4a836cb34..b744d7370 100644
--- a/demos/flex_layout/lv_demo_flex_layout_ctrl_pad.c
+++ b/demos/flex_layout/lv_demo_flex_layout_ctrl_pad.c
@@ -49,6 +49,7 @@ static void ctrl_pad_btn_event_attach(view_t * ui);
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 void ctrl_pad_attach(view_t * ui)
 {
     ctrl_pad_btn_event_attach(ui);
@@ -76,6 +77,7 @@ void ctrl_pad_attach(view_t * ui)
  *   STATIC FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 static void ctrl_pad_btn_remove_event_handler(lv_event_t * e)
 {
     view_t * ui = lv_event_get_user_data(e);
@@ -90,6 +92,7 @@ static void ctrl_pad_btn_remove_event_handler(lv_event_t * e)
     }
 }
 
+LV_FUNC_SECTION
 void ctrl_pad_obj_update(lv_obj_t * obj, view_t * ui)
 {
     lv_obj_t * spinbox = ui->ctrl_pad.tab.layout.spinbox_width;
@@ -117,6 +120,7 @@ void ctrl_pad_obj_update(lv_obj_t * obj, view_t * ui)
     }
 }
 
+LV_FUNC_SECTION
 static void ctrl_pad_spinbox_event_handler(lv_event_t * e)
 {
     view_t * ui = lv_event_get_user_data(e);
@@ -132,12 +136,14 @@ static void ctrl_pad_spinbox_event_handler(lv_event_t * e)
     }
 }
 
+LV_FUNC_SECTION
 static void ctrl_pad_btn_add_event_handler(lv_event_t * e)
 {
     view_t * ui = lv_event_get_user_data(e);
     obj_child_node_create(ui->obj_cur, ui);
 }
 
+LV_FUNC_SECTION
 static void ctrl_pad_checkbox_event_handler(lv_event_t * e)
 {
     view_t * ui = lv_event_get_user_data(e);
@@ -148,6 +154,7 @@ static void ctrl_pad_checkbox_event_handler(lv_event_t * e)
     }
 }
 
+LV_FUNC_SECTION
 static void ctrl_pad_btn_event_attach(view_t * ui)
 {
     lv_obj_add_event_cb(
diff --git a/demos/flex_layout/lv_demo_flex_layout_flex_loader.c b/demos/flex_layout/lv_demo_flex_layout_flex_loader.c
index 9493b250b..61f38f155 100644
--- a/demos/flex_layout/lv_demo_flex_layout_flex_loader.c
+++ b/demos/flex_layout/lv_demo_flex_layout_flex_loader.c
@@ -87,6 +87,7 @@ static const lv_flex_align_t flex_align_map[] = {
  **********************/
 
 FLEX_ALIGN_EVENT_DEF(main)
+LV_FUNC_SECTION
 FLEX_ALIGN_EVENT_DEF(cross)
 FLEX_ALIGN_EVENT_DEF(track)
 
@@ -108,6 +109,7 @@ void flex_loader_attach(view_t * ui)
     FLEX_ALIGN_EVENT_ATTACH(track);
 }
 
+LV_FUNC_SECTION
 void flex_loader_obj_update(lv_obj_t * obj, view_t * ui)
 {
     lv_flex_flow_t flex_flow = lv_obj_get_style_flex_flow(obj, 0);
@@ -128,6 +130,7 @@ void flex_loader_obj_update(lv_obj_t * obj, view_t * ui)
  *   STATIC FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 static void flex_flow_event_handler(lv_event_t * e)
 {
     view_t * ui = lv_event_get_user_data(e);
diff --git a/demos/flex_layout/lv_demo_flex_layout_main.c b/demos/flex_layout/lv_demo_flex_layout_main.c
index e6bfd352d..670f58342 100644
--- a/demos/flex_layout/lv_demo_flex_layout_main.c
+++ b/demos/flex_layout/lv_demo_flex_layout_main.c
@@ -37,7 +37,7 @@ static view_t view;
 /**********************
  *   GLOBAL FUNCTIONS
  **********************/
-
+__attribute__(( fptrgroup("lv_demo_entry_cb") ))
 void lv_demo_flex_layout(void)
 {
     view_create(lv_screen_active(), &view);
diff --git a/demos/flex_layout/lv_demo_flex_layout_view.c b/demos/flex_layout/lv_demo_flex_layout_view.c
index 944e6643c..640957e44 100644
--- a/demos/flex_layout/lv_demo_flex_layout_view.c
+++ b/demos/flex_layout/lv_demo_flex_layout_view.c
@@ -39,6 +39,7 @@ static void obj_child_node_checked_style_init(lv_style_t * style);
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 void view_create(lv_obj_t * par, view_t * ui)
 {
     /* layout */
@@ -112,6 +113,7 @@ void view_create(lv_obj_t * par, view_t * ui)
  *   STATIC FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 static lv_obj_t * btn_create(lv_obj_t * par, const char * str, lv_color_t color)
 {
     lv_obj_t * btn = lv_button_create(par);
@@ -128,6 +130,7 @@ static lv_obj_t * btn_create(lv_obj_t * par, const char * str, lv_color_t color)
     return btn;
 }
 
+LV_FUNC_SECTION
 static void obj_child_node_def_style_init(lv_style_t * style)
 {
     lv_style_init(style);
@@ -137,6 +140,7 @@ static void obj_child_node_def_style_init(lv_style_t * style)
     lv_style_set_radius(style, 0);
 }
 
+LV_FUNC_SECTION
 static void obj_child_node_checked_style_init(lv_style_t * style)
 {
     lv_style_init(style);
diff --git a/demos/flex_layout/lv_demo_flex_layout_view_child_node.c b/demos/flex_layout/lv_demo_flex_layout_view_child_node.c
index 3f3db9d9f..ed534a889 100644
--- a/demos/flex_layout/lv_demo_flex_layout_view_child_node.c
+++ b/demos/flex_layout/lv_demo_flex_layout_view_child_node.c
@@ -37,6 +37,7 @@ static void obj_child_node_event_handler(lv_event_t * e);
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 lv_obj_t * obj_child_node_create(lv_obj_t * par, view_t * ui)
 {
     if(par == NULL) {
@@ -63,6 +64,7 @@ lv_obj_t * obj_child_node_create(lv_obj_t * par, view_t * ui)
  *   STATIC FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 static void obj_child_node_event_handler(lv_event_t * e)
 {
     view_t * ui = (view_t *)lv_event_get_user_data(e);
diff --git a/demos/flex_layout/lv_demo_flex_layout_view_ctrl_pad.c b/demos/flex_layout/lv_demo_flex_layout_view_ctrl_pad.c
index 836986a2d..6e4c91f9d 100644
--- a/demos/flex_layout/lv_demo_flex_layout_view_ctrl_pad.c
+++ b/demos/flex_layout/lv_demo_flex_layout_view_ctrl_pad.c
@@ -52,6 +52,7 @@ static void tab_layout_create(lv_obj_t * tab, view_t * ui);
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 void view_ctrl_pad_create(lv_obj_t * par, view_t * ui)
 {
     lv_obj_t * tv = lv_tabview_create(par);
@@ -82,6 +83,7 @@ void view_ctrl_pad_create(lv_obj_t * par, view_t * ui)
  *   STATIC FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 static lv_obj_t * ddlist_create(lv_obj_t * par, const char * name, const char * options)
 {
     lv_obj_t * cont = lv_obj_create(par);
@@ -98,6 +100,7 @@ static lv_obj_t * ddlist_create(lv_obj_t * par, const char * name, const char *
     return ddlist;
 }
 
+LV_FUNC_SECTION
 static void tab_flex_create(lv_obj_t * tab, view_t * ui)
 {
     lv_obj_set_flex_flow(tab, LV_FLEX_FLOW_COLUMN);
@@ -126,6 +129,7 @@ static void tab_flex_create(lv_obj_t * tab, view_t * ui)
     ui->ctrl_pad.tab.flex.checkbox_scrl = cb;
 }
 
+LV_FUNC_SECTION
 static void tab_align_create(lv_obj_t * tab, view_t * ui)
 {
     lv_obj_set_flex_flow(tab, LV_FLEX_FLOW_COLUMN);
@@ -141,6 +145,7 @@ static void tab_align_create(lv_obj_t * tab, view_t * ui)
     DDLIST_ALIGN_CREATE_DEF(track);
 }
 
+LV_FUNC_SECTION
 static void btn_inc_event_handler(lv_event_t * e)
 {
     lv_obj_t * spinbox = lv_event_get_user_data(e);
@@ -150,6 +155,7 @@ static void btn_inc_event_handler(lv_event_t * e)
     }
 }
 
+LV_FUNC_SECTION
 static void btn_dec_event_handler(lv_event_t * e)
 {
     lv_obj_t * spinbox = lv_event_get_user_data(e);
@@ -159,6 +165,7 @@ static void btn_dec_event_handler(lv_event_t * e)
     }
 }
 
+LV_FUNC_SECTION
 static lv_obj_t * spinbox_ctrl_create(lv_obj_t * par, lv_style_prop_t prop, lv_obj_t ** cont_)
 {
     lv_obj_t * cont_main = par;
@@ -222,6 +229,7 @@ static lv_obj_t * spinbox_ctrl_create(lv_obj_t * par, lv_style_prop_t prop, lv_o
     return spinbox;
 }
 
+LV_FUNC_SECTION
 static void tab_layout_create(lv_obj_t * tab, view_t * ui)
 {
     lv_obj_set_flex_flow(tab, LV_FLEX_FLOW_COLUMN);
diff --git a/demos/keypad_encoder/lv_demo_keypad_encoder.c b/demos/keypad_encoder/lv_demo_keypad_encoder.c
index 26979ef52..9c0dd3deb 100644
--- a/demos/keypad_encoder/lv_demo_keypad_encoder.c
+++ b/demos/keypad_encoder/lv_demo_keypad_encoder.c
@@ -43,7 +43,7 @@ static lv_obj_t * t2;
 /**********************
  *   GLOBAL FUNCTIONS
  **********************/
-
+__attribute__(( fptrgroup("lv_demo_entry_cb") ))
 void lv_demo_keypad_encoder(void)
 {
     g = lv_group_create();
@@ -81,6 +81,7 @@ void lv_demo_keypad_encoder(void)
  *   STATIC FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 static void selectors_create(lv_obj_t * parent)
 {
     lv_obj_set_flex_flow(parent, LV_FLEX_FLOW_COLUMN);
@@ -139,6 +140,7 @@ static void selectors_create(lv_obj_t * parent)
     lv_list_add_button(list, LV_SYMBOL_PASTE, "Paste");
 }
 
+LV_FUNC_SECTION
 static void text_input_create(lv_obj_t * parent)
 {
     lv_obj_set_flex_flow(parent, LV_FLEX_FLOW_COLUMN);
@@ -160,6 +162,7 @@ static void text_input_create(lv_obj_t * parent)
     lv_obj_add_event_cb(ta2, ta_event_cb, LV_EVENT_ALL, kb);
 }
 
+LV_FUNC_SECTION
 static void msgbox_create(void)
 {
     lv_obj_t * mbox = lv_msgbox_create(NULL);
@@ -179,6 +182,7 @@ static void msgbox_create(void)
     lv_obj_set_style_bg_color(bg, lv_palette_main(LV_PALETTE_GREY), 0);
 }
 
+LV_FUNC_SECTION
 static void msgbox_event_cb(lv_event_t * e)
 {
     lv_obj_t * msgbox = lv_event_get_user_data(e);
@@ -189,6 +193,7 @@ static void msgbox_event_cb(lv_event_t * e)
     lv_obj_scroll_to(t1, 0, 0, LV_ANIM_OFF);
 }
 
+__attribute__(( fptrgroup("lv_event_cb") ))
 static void ta_event_cb(lv_event_t * e)
 {
     lv_indev_t * indev = lv_indev_active();
diff --git a/demos/lv_demos.c b/demos/lv_demos.c
index 56af19994..bca5582f6 100644
--- a/demos/lv_demos.c
+++ b/demos/lv_demos.c
@@ -21,6 +21,7 @@ typedef void (*demo_method_cb)(void);
 
 typedef struct  {
     const char * name;
+    __attribute__(( fptrgroup("lv_demo_entry_cb") ))
     demo_method_cb entry_cb;
 } demo_entry_info_t;
 
@@ -86,6 +87,7 @@ static const demo_entry_info_t demos_entry_info[] = {
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 bool lv_demos_create(char * info[], int size)
 {
     const int demos_count = LV_DEMOS_COUNT;
@@ -121,6 +123,7 @@ bool lv_demos_create(char * info[], int size)
     return false;
 }
 
+LV_FUNC_SECTION
 void lv_demos_show_help(void)
 {
     int i;
diff --git a/demos/multilang/lv_demo_multilang.c b/demos/multilang/lv_demo_multilang.c
index 8bf2de930..5c6c8c1c0 100644
--- a/demos/multilang/lv_demo_multilang.c
+++ b/demos/multilang/lv_demo_multilang.c
@@ -99,6 +99,7 @@ static card_info_t card_info[] = {
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 static const void * get_imgfont_path(const lv_font_t * font,
                                      uint32_t unicode, uint32_t unicode_next,
                                      int32_t * offset_y, void * user_data)
@@ -153,6 +154,7 @@ static const void * get_imgfont_path(const lv_font_t * font,
 
 lv_font_t * emoji_font;
 
+__attribute__(( fptrgroup("lv_demo_entry_cb") ))
 void lv_demo_multilang(void)
 {
     emoji_font = lv_imgfont_create(20, get_imgfont_path, NULL);
@@ -234,6 +236,7 @@ void lv_demo_multilang(void)
  *   STATIC FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 static void inactive_timer_cb(lv_timer_t * t)
 {
     LV_UNUSED(t);
@@ -257,6 +260,7 @@ static void inactive_timer_cb(lv_timer_t * t)
     }
 }
 
+LV_FUNC_SECTION
 static void shrink_anim_cb(void * var, int32_t v)
 {
     lv_obj_t * cont = var;
@@ -264,6 +268,7 @@ static void shrink_anim_cb(void * var, int32_t v)
     lv_obj_set_style_opa(cont, v, 0);
 }
 
+LV_FUNC_SECTION
 static void scroll_event_cb(lv_event_t * e)
 {
     lv_indev_t * indev = lv_indev_active();
@@ -290,6 +295,7 @@ static void scroll_event_cb(lv_event_t * e)
     }
 }
 
+LV_FUNC_SECTION
 static void card_create(lv_obj_t * parent, card_info_t * info)
 {
     lv_obj_t * cont = lv_obj_create(parent);
diff --git a/demos/music/assets/img_lv_demo_music_btn_list_pause.c b/demos/music/assets/img_lv_demo_music_btn_list_pause.c
index adf274a47..5f88c0023 100644
--- a/demos/music/assets/img_lv_demo_music_btn_list_pause.c
+++ b/demos/music/assets/img_lv_demo_music_btn_list_pause.c
@@ -5,7 +5,7 @@
     #define LV_ATTRIBUTE_MEM_ALIGN
 #endif
 
-const LV_ATTRIBUTE_MEM_ALIGN uint8_t img_lv_demo_music_btn_list_pause_map[] = {
+const LV_ATTRIBUTE_MEM_ALIGN LV_ATTRIBUTE_LARGE_CONST uint8_t img_lv_demo_music_btn_list_pause_map[] = {
     0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00,
     0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00,
     0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00,
diff --git a/demos/music/assets/img_lv_demo_music_btn_list_play.c b/demos/music/assets/img_lv_demo_music_btn_list_play.c
index d50fb5cc9..af16b6141 100644
--- a/demos/music/assets/img_lv_demo_music_btn_list_play.c
+++ b/demos/music/assets/img_lv_demo_music_btn_list_play.c
@@ -5,7 +5,7 @@
     #define LV_ATTRIBUTE_MEM_ALIGN
 #endif
 
-const LV_ATTRIBUTE_MEM_ALIGN uint8_t img_lv_demo_music_btn_list_play_map[] = {
+const LV_ATTRIBUTE_MEM_ALIGN LV_ATTRIBUTE_LARGE_CONST uint8_t img_lv_demo_music_btn_list_play_map[] = {
     0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00,
     0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00,
     0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00,
diff --git a/demos/music/assets/img_lv_demo_music_btn_loop.c b/demos/music/assets/img_lv_demo_music_btn_loop.c
index 6af031f45..2558f9261 100644
--- a/demos/music/assets/img_lv_demo_music_btn_loop.c
+++ b/demos/music/assets/img_lv_demo_music_btn_loop.c
@@ -5,7 +5,7 @@
     #define LV_ATTRIBUTE_MEM_ALIGN
 #endif
 
-const LV_ATTRIBUTE_MEM_ALIGN uint8_t img_lv_demo_music_btn_loop_map[] = {
+const LV_ATTRIBUTE_MEM_ALIGN LV_ATTRIBUTE_LARGE_CONST uint8_t img_lv_demo_music_btn_loop_map[] = {
     0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00,
     0xff, 0xff, 0xff, 0x00, 0x6d, 0x4d, 0x50, 0x00, 0x6d, 0x4d, 0x50, 0x00, 0x6d, 0x4d, 0x50, 0x00, 0x6d, 0x4d, 0x50, 0x00, 0x6d, 0x4d, 0x50, 0x00, 0x6d, 0x4d, 0x50, 0x00, 0x6d, 0x4d, 0x50, 0x03, 0x6d, 0x4d, 0x50, 0x4b, 0x6d, 0x4d, 0x50, 0x94, 0x6d, 0x4d, 0x50, 0xc7, 0x6d, 0x4d, 0x50, 0xdc, 0x6d, 0x4d, 0x50, 0xdc, 0x6d, 0x4d, 0x50, 0xbf, 0x6d, 0x4d, 0x50, 0x84, 0x6d, 0x4d, 0x50, 0x34, 0x6d, 0x4d, 0x50, 0x00, 0x6d, 0x4d, 0x50, 0x00, 0x6d, 0x4d, 0x50, 0x00, 0x6d, 0x4d, 0x50, 0x00, 0x6d, 0x4d, 0x50, 0x00, 0x6d, 0x4d, 0x50, 0x00, 0x6d, 0x4d, 0x50, 0x00, 0xff, 0xff, 0xff, 0x00,
     0xff, 0xff, 0xff, 0x00, 0x6d, 0x4d, 0x50, 0x00, 0x6d, 0x4d, 0x50, 0x00, 0x6d, 0x4d, 0x50, 0x00, 0x6d, 0x4d, 0x50, 0x00, 0x6d, 0x4d, 0x50, 0x00, 0x6d, 0x4d, 0x50, 0x4b, 0x6d, 0x4d, 0x50, 0xd4, 0x6d, 0x4d, 0x50, 0xff, 0x6d, 0x4d, 0x50, 0xff, 0x6d, 0x4d, 0x50, 0xff, 0x6d, 0x4d, 0x50, 0xff, 0x6d, 0x4d, 0x50, 0xff, 0x6d, 0x4d, 0x50, 0xff, 0x6d, 0x4d, 0x50, 0xff, 0x6d, 0x4d, 0x50, 0xff, 0x6d, 0x4d, 0x50, 0xbf, 0x6d, 0x4d, 0x50, 0x37, 0x6d, 0x4d, 0x50, 0x00, 0x6d, 0x4d, 0x50, 0x00, 0x6d, 0x4d, 0x50, 0x00, 0x6d, 0x4d, 0x50, 0x00, 0x6d, 0x4d, 0x50, 0x00, 0xff, 0xff, 0xff, 0x00,
diff --git a/demos/music/assets/img_lv_demo_music_btn_next.c b/demos/music/assets/img_lv_demo_music_btn_next.c
index 5f45a316f..c9b81136c 100644
--- a/demos/music/assets/img_lv_demo_music_btn_next.c
+++ b/demos/music/assets/img_lv_demo_music_btn_next.c
@@ -5,7 +5,7 @@
     #define LV_ATTRIBUTE_MEM_ALIGN
 #endif
 
-const LV_ATTRIBUTE_MEM_ALIGN uint8_t img_lv_demo_music_btn_next_map[] = {
+const LV_ATTRIBUTE_MEM_ALIGN LV_ATTRIBUTE_LARGE_CONST uint8_t img_lv_demo_music_btn_next_map[] = {
     0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00,
     0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00,
     0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00,
diff --git a/demos/music/assets/img_lv_demo_music_btn_pause.c b/demos/music/assets/img_lv_demo_music_btn_pause.c
index 06b011c90..3068c265f 100644
--- a/demos/music/assets/img_lv_demo_music_btn_pause.c
+++ b/demos/music/assets/img_lv_demo_music_btn_pause.c
@@ -5,7 +5,7 @@
     #define LV_ATTRIBUTE_MEM_ALIGN
 #endif
 
-const LV_ATTRIBUTE_MEM_ALIGN uint8_t img_lv_demo_music_btn_pause_map[] = {
+const LV_ATTRIBUTE_MEM_ALIGN LV_ATTRIBUTE_LARGE_CONST uint8_t img_lv_demo_music_btn_pause_map[] = {
     0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00,
     0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00,
     0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00,
diff --git a/demos/music/assets/img_lv_demo_music_btn_play.c b/demos/music/assets/img_lv_demo_music_btn_play.c
index 1eecc60fe..2fb0d9347 100644
--- a/demos/music/assets/img_lv_demo_music_btn_play.c
+++ b/demos/music/assets/img_lv_demo_music_btn_play.c
@@ -5,7 +5,7 @@
     #define LV_ATTRIBUTE_MEM_ALIGN
 #endif
 
-const LV_ATTRIBUTE_MEM_ALIGN uint8_t img_lv_demo_music_btn_play_map[] = {
+const LV_ATTRIBUTE_MEM_ALIGN LV_ATTRIBUTE_LARGE_CONST uint8_t img_lv_demo_music_btn_play_map[] = {
     0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00,
     0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00,
     0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00,
diff --git a/demos/music/assets/img_lv_demo_music_btn_prev.c b/demos/music/assets/img_lv_demo_music_btn_prev.c
index 72f46ebcc..17f9abe16 100644
--- a/demos/music/assets/img_lv_demo_music_btn_prev.c
+++ b/demos/music/assets/img_lv_demo_music_btn_prev.c
@@ -5,7 +5,7 @@
     #define LV_ATTRIBUTE_MEM_ALIGN
 #endif
 
-const LV_ATTRIBUTE_MEM_ALIGN uint8_t img_lv_demo_music_btn_prev_map[] = {
+const LV_ATTRIBUTE_MEM_ALIGN LV_ATTRIBUTE_LARGE_CONST uint8_t img_lv_demo_music_btn_prev_map[] = {
     0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00,
     0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00,
     0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00, 0xf2, 0x6c, 0x9c, 0x00,
diff --git a/demos/music/assets/img_lv_demo_music_btn_rnd.c b/demos/music/assets/img_lv_demo_music_btn_rnd.c
index 349944e69..fd1777980 100644
--- a/demos/music/assets/img_lv_demo_music_btn_rnd.c
+++ b/demos/music/assets/img_lv_demo_music_btn_rnd.c
@@ -5,7 +5,7 @@
     #define LV_ATTRIBUTE_MEM_ALIGN
 #endif
 
-const LV_ATTRIBUTE_MEM_ALIGN uint8_t img_lv_demo_music_btn_rnd_map[] = {
+const LV_ATTRIBUTE_MEM_ALIGN LV_ATTRIBUTE_LARGE_CONST uint8_t img_lv_demo_music_btn_rnd_map[] = {
     0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00,
     0xff, 0xff, 0xff, 0x00, 0x6d, 0x4d, 0x50, 0x00, 0x6d, 0x4d, 0x50, 0x00, 0x6d, 0x4d, 0x50, 0x00, 0x6d, 0x4d, 0x50, 0x00, 0x6d, 0x4d, 0x50, 0x00, 0x6d, 0x4d, 0x50, 0x00, 0x6d, 0x4d, 0x50, 0x03, 0x6d, 0x4d, 0x50, 0x47, 0x6d, 0x4d, 0x50, 0x93, 0x6d, 0x4d, 0x50, 0xc7, 0x6d, 0x4d, 0x50, 0xdc, 0x6d, 0x4d, 0x50, 0xd4, 0x6d, 0x4d, 0x50, 0xbb, 0x6d, 0x4d, 0x50, 0x8f, 0x6d, 0x4d, 0x50, 0x3f, 0x6d, 0x4d, 0x50, 0x00, 0x6d, 0x4d, 0x50, 0x00, 0x6d, 0x4d, 0x50, 0x00, 0x6d, 0x4d, 0x50, 0x00, 0x6d, 0x4d, 0x50, 0x00, 0x6d, 0x4d, 0x50, 0x00, 0x6d, 0x4d, 0x50, 0x00, 0xff, 0xff, 0xff, 0x00,
     0xff, 0xff, 0xff, 0x00, 0x6d, 0x4d, 0x50, 0x00, 0x6d, 0x4d, 0x50, 0x00, 0x6d, 0x4d, 0x50, 0x00, 0x6d, 0x4d, 0x50, 0x00, 0x6d, 0x4d, 0x50, 0x00, 0x6d, 0x4d, 0x50, 0x47, 0x6d, 0x4d, 0x50, 0xd0, 0x6d, 0x4d, 0x50, 0xff, 0x6d, 0x4d, 0x50, 0xff, 0x6d, 0x4d, 0x50, 0xff, 0x6d, 0x4d, 0x50, 0xff, 0x6d, 0x4d, 0x50, 0xff, 0x6d, 0x4d, 0x50, 0xff, 0x6d, 0x4d, 0x50, 0xff, 0x6d, 0x4d, 0x50, 0xff, 0x6d, 0x4d, 0x50, 0xc4, 0x6d, 0x4d, 0x50, 0x38, 0x6d, 0x4d, 0x50, 0x00, 0x6d, 0x4d, 0x50, 0x00, 0x6d, 0x4d, 0x50, 0x00, 0x6d, 0x4d, 0x50, 0x00, 0x6d, 0x4d, 0x50, 0x00, 0xff, 0xff, 0xff, 0x00,
diff --git a/demos/music/assets/img_lv_demo_music_corner_left.c b/demos/music/assets/img_lv_demo_music_corner_left.c
index 67e27ef92..565d78e6b 100644
--- a/demos/music/assets/img_lv_demo_music_corner_left.c
+++ b/demos/music/assets/img_lv_demo_music_corner_left.c
@@ -5,7 +5,7 @@
     #define LV_ATTRIBUTE_MEM_ALIGN
 #endif
 
-const LV_ATTRIBUTE_MEM_ALIGN uint8_t img_lv_demo_music_corner_left_map[] = {
+const LV_ATTRIBUTE_MEM_ALIGN LV_ATTRIBUTE_LARGE_CONST uint8_t img_lv_demo_music_corner_left_map[] = {
     0x47, 0x32, 0x34, 0x07, 0x47, 0x32, 0x34, 0x00, 0x47, 0x32, 0x34, 0x00, 0x47, 0x32, 0x34, 0x00, 0x47, 0x32, 0x34, 0x00, 0x47, 0x32, 0x34, 0x00, 0x47, 0x32, 0x34, 0x00, 0x47, 0x32, 0x34, 0x00, 0x47, 0x32, 0x34, 0x00, 0x47, 0x32, 0x34, 0x00, 0x47, 0x32, 0x34, 0x00, 0x47, 0x32, 0x34, 0x00, 0x47, 0x32, 0x34, 0x00, 0x47, 0x32, 0x34, 0x00, 0x47, 0x32, 0x34, 0x00, 0x47, 0x32, 0x34, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00,
     0x47, 0x32, 0x34, 0x1b, 0x47, 0x32, 0x34, 0x00, 0x47, 0x32, 0x34, 0x00, 0x47, 0x32, 0x34, 0x00, 0x47, 0x32, 0x34, 0x00, 0x47, 0x32, 0x34, 0x00, 0x47, 0x32, 0x34, 0x00, 0x47, 0x32, 0x34, 0x00, 0x47, 0x32, 0x34, 0x00, 0x47, 0x32, 0x34, 0x00, 0x47, 0x32, 0x34, 0x00, 0x47, 0x32, 0x34, 0x00, 0x47, 0x32, 0x34, 0x00, 0x47, 0x32, 0x34, 0x00, 0x47, 0x32, 0x34, 0x00, 0x47, 0x32, 0x34, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00,
     0x47, 0x32, 0x34, 0x3c, 0x47, 0x32, 0x34, 0x00, 0x47, 0x32, 0x34, 0x00, 0x47, 0x32, 0x34, 0x00, 0x47, 0x32, 0x34, 0x00, 0x47, 0x32, 0x34, 0x00, 0x47, 0x32, 0x34, 0x00, 0x47, 0x32, 0x34, 0x00, 0x47, 0x32, 0x34, 0x00, 0x47, 0x32, 0x34, 0x00, 0x47, 0x32, 0x34, 0x00, 0x47, 0x32, 0x34, 0x00, 0x47, 0x32, 0x34, 0x00, 0x47, 0x32, 0x34, 0x00, 0x47, 0x32, 0x34, 0x00, 0x47, 0x32, 0x34, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00,
diff --git a/demos/music/assets/img_lv_demo_music_corner_right.c b/demos/music/assets/img_lv_demo_music_corner_right.c
index a21415754..eb8eefe02 100644
--- a/demos/music/assets/img_lv_demo_music_corner_right.c
+++ b/demos/music/assets/img_lv_demo_music_corner_right.c
@@ -5,7 +5,7 @@
     #define LV_ATTRIBUTE_MEM_ALIGN
 #endif
 
-const LV_ATTRIBUTE_MEM_ALIGN uint8_t img_lv_demo_music_corner_right_map[] = {
+const LV_ATTRIBUTE_MEM_ALIGN LV_ATTRIBUTE_LARGE_CONST uint8_t img_lv_demo_music_corner_right_map[] = {
     0x47, 0x32, 0x34, 0x00, 0x47, 0x32, 0x34, 0x00, 0x47, 0x32, 0x34, 0x00, 0x47, 0x32, 0x34, 0x00, 0x47, 0x32, 0x34, 0x00, 0x47, 0x32, 0x34, 0x00, 0x47, 0x32, 0x34, 0x00, 0x47, 0x32, 0x34, 0x00, 0x47, 0x32, 0x34, 0x00, 0x47, 0x32, 0x34, 0x00, 0x47, 0x32, 0x34, 0x00, 0x47, 0x32, 0x34, 0x00, 0x47, 0x32, 0x34, 0x00, 0x47, 0x32, 0x34, 0x00, 0x47, 0x32, 0x34, 0x00, 0x47, 0x32, 0x34, 0x00, 0xff, 0xff, 0xff, 0x00, 0x47, 0x32, 0x34, 0x04,
     0x47, 0x32, 0x34, 0x00, 0x47, 0x32, 0x34, 0x00, 0x47, 0x32, 0x34, 0x00, 0x47, 0x32, 0x34, 0x00, 0x47, 0x32, 0x34, 0x00, 0x47, 0x32, 0x34, 0x00, 0x47, 0x32, 0x34, 0x00, 0x47, 0x32, 0x34, 0x00, 0x47, 0x32, 0x34, 0x00, 0x47, 0x32, 0x34, 0x00, 0x47, 0x32, 0x34, 0x00, 0x47, 0x32, 0x34, 0x00, 0x47, 0x32, 0x34, 0x00, 0x47, 0x32, 0x34, 0x00, 0x47, 0x32, 0x34, 0x00, 0x47, 0x32, 0x34, 0x00, 0xff, 0xff, 0xff, 0x00, 0x47, 0x32, 0x34, 0x13,
     0x47, 0x32, 0x34, 0x00, 0x47, 0x32, 0x34, 0x00, 0x47, 0x32, 0x34, 0x00, 0x47, 0x32, 0x34, 0x00, 0x47, 0x32, 0x34, 0x00, 0x47, 0x32, 0x34, 0x00, 0x47, 0x32, 0x34, 0x00, 0x47, 0x32, 0x34, 0x00, 0x47, 0x32, 0x34, 0x00, 0x47, 0x32, 0x34, 0x00, 0x47, 0x32, 0x34, 0x00, 0x47, 0x32, 0x34, 0x00, 0x47, 0x32, 0x34, 0x00, 0x47, 0x32, 0x34, 0x00, 0x47, 0x32, 0x34, 0x00, 0x47, 0x32, 0x34, 0x00, 0xff, 0xff, 0xff, 0x00, 0x47, 0x32, 0x34, 0x2f,
diff --git a/demos/music/assets/img_lv_demo_music_cover_1.c b/demos/music/assets/img_lv_demo_music_cover_1.c
index d54e06667..5f8d69f82 100644
--- a/demos/music/assets/img_lv_demo_music_cover_1.c
+++ b/demos/music/assets/img_lv_demo_music_cover_1.c
@@ -5,7 +5,7 @@
     #define LV_ATTRIBUTE_MEM_ALIGN
 #endif
 
-const LV_ATTRIBUTE_MEM_ALIGN uint8_t img_lv_demo_music_cover_1_map[] = {
+const LV_ATTRIBUTE_MEM_ALIGN LV_ATTRIBUTE_LARGE_CONST uint8_t img_lv_demo_music_cover_1_map[] = {
   /*Pixel format: Fix 0xFF: 8 bit, Red: 8 bit, Green: 8 bit, Blue: 8 bit*/
     0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,
     0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,
diff --git a/demos/music/assets/img_lv_demo_music_cover_2.c b/demos/music/assets/img_lv_demo_music_cover_2.c
index 6865cb6df..70b309f57 100644
--- a/demos/music/assets/img_lv_demo_music_cover_2.c
+++ b/demos/music/assets/img_lv_demo_music_cover_2.c
@@ -5,7 +5,7 @@
     #define LV_ATTRIBUTE_MEM_ALIGN
 #endif
 
-const LV_ATTRIBUTE_MEM_ALIGN uint8_t img_lv_demo_music_cover_2_map[] = {
+const LV_ATTRIBUTE_MEM_ALIGN LV_ATTRIBUTE_LARGE_CONST uint8_t img_lv_demo_music_cover_2_map[] = {
   /*Pixel format: Fix 0xFF: 8 bit, Red: 8 bit, Green: 8 bit, Blue: 8 bit*/
     0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,
     0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,
diff --git a/demos/music/assets/img_lv_demo_music_cover_3.c b/demos/music/assets/img_lv_demo_music_cover_3.c
index 683b7c9f4..82a802967 100644
--- a/demos/music/assets/img_lv_demo_music_cover_3.c
+++ b/demos/music/assets/img_lv_demo_music_cover_3.c
@@ -5,7 +5,7 @@
     #define LV_ATTRIBUTE_MEM_ALIGN
 #endif
 
-const LV_ATTRIBUTE_MEM_ALIGN uint8_t img_lv_demo_music_cover_3_map[] = {
+const LV_ATTRIBUTE_MEM_ALIGN LV_ATTRIBUTE_LARGE_CONST uint8_t img_lv_demo_music_cover_3_map[] = {
   /*Pixel format: Fix 0xFF: 8 bit, Red: 8 bit, Green: 8 bit, Blue: 8 bit*/
     0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,
     0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,
diff --git a/demos/music/assets/img_lv_demo_music_icon_1.c b/demos/music/assets/img_lv_demo_music_icon_1.c
index dfcab6e78..5d17fa245 100644
--- a/demos/music/assets/img_lv_demo_music_icon_1.c
+++ b/demos/music/assets/img_lv_demo_music_icon_1.c
@@ -5,7 +5,7 @@
     #define LV_ATTRIBUTE_MEM_ALIGN
 #endif
 
-const LV_ATTRIBUTE_MEM_ALIGN uint8_t img_lv_demo_music_icon_1_map[] = {
+const LV_ATTRIBUTE_MEM_ALIGN LV_ATTRIBUTE_LARGE_CONST uint8_t img_lv_demo_music_icon_1_map[] = {
     /*Pixel format: Fix 0xFF: 8 bit, Red: 8 bit, Green: 8 bit, Blue: 8 bit*/
     0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
     0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
diff --git a/demos/music/assets/img_lv_demo_music_icon_2.c b/demos/music/assets/img_lv_demo_music_icon_2.c
index bb7e29e2d..e6c7edce2 100644
--- a/demos/music/assets/img_lv_demo_music_icon_2.c
+++ b/demos/music/assets/img_lv_demo_music_icon_2.c
@@ -5,7 +5,7 @@
     #define LV_ATTRIBUTE_MEM_ALIGN
 #endif
 
-const LV_ATTRIBUTE_MEM_ALIGN uint8_t img_lv_demo_music_icon_2_map[] = {
+const LV_ATTRIBUTE_MEM_ALIGN LV_ATTRIBUTE_LARGE_CONST uint8_t img_lv_demo_music_icon_2_map[] = {
     /*Pixel format: Fix 0xFF: 8 bit, Red: 8 bit, Green: 8 bit, Blue: 8 bit*/
     0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
     0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
diff --git a/demos/music/assets/img_lv_demo_music_icon_3.c b/demos/music/assets/img_lv_demo_music_icon_3.c
index 2095e51cb..11586fb42 100644
--- a/demos/music/assets/img_lv_demo_music_icon_3.c
+++ b/demos/music/assets/img_lv_demo_music_icon_3.c
@@ -5,7 +5,7 @@
     #define LV_ATTRIBUTE_MEM_ALIGN
 #endif
 
-const LV_ATTRIBUTE_MEM_ALIGN uint8_t img_lv_demo_music_icon_3_map[] = {
+const LV_ATTRIBUTE_MEM_ALIGN LV_ATTRIBUTE_LARGE_CONST uint8_t img_lv_demo_music_icon_3_map[] = {
     /*Pixel format: Fix 0xFF: 8 bit, Red: 8 bit, Green: 8 bit, Blue: 8 bit*/
     0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
     0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
diff --git a/demos/music/assets/img_lv_demo_music_icon_4.c b/demos/music/assets/img_lv_demo_music_icon_4.c
index 07d7477de..d2bdd50e1 100644
--- a/demos/music/assets/img_lv_demo_music_icon_4.c
+++ b/demos/music/assets/img_lv_demo_music_icon_4.c
@@ -5,7 +5,7 @@
     #define LV_ATTRIBUTE_MEM_ALIGN
 #endif
 
-const LV_ATTRIBUTE_MEM_ALIGN uint8_t img_lv_demo_music_icon_4_map[] = {
+const LV_ATTRIBUTE_MEM_ALIGN LV_ATTRIBUTE_LARGE_CONST uint8_t img_lv_demo_music_icon_4_map[] = {
     /*Pixel format: Fix 0xFF: 8 bit, Red: 8 bit, Green: 8 bit, Blue: 8 bit*/
     0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
     0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
diff --git a/demos/music/assets/img_lv_demo_music_list_border.c b/demos/music/assets/img_lv_demo_music_list_border.c
index 7c3329ff8..a20d166b1 100644
--- a/demos/music/assets/img_lv_demo_music_list_border.c
+++ b/demos/music/assets/img_lv_demo_music_list_border.c
@@ -5,7 +5,7 @@
     #define LV_ATTRIBUTE_MEM_ALIGN
 #endif
 
-const LV_ATTRIBUTE_MEM_ALIGN uint8_t img_lv_demo_music_list_border_map[] = {
+const LV_ATTRIBUTE_MEM_ALIGN LV_ATTRIBUTE_LARGE_CONST uint8_t img_lv_demo_music_list_border_map[] = {
     0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08,
     0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x27,
     0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24, 0xc8, 0xc8, 0xc8, 0x24,
diff --git a/demos/music/assets/img_lv_demo_music_logo.c b/demos/music/assets/img_lv_demo_music_logo.c
index b7bdacf6f..1bb4c2115 100644
--- a/demos/music/assets/img_lv_demo_music_logo.c
+++ b/demos/music/assets/img_lv_demo_music_logo.c
@@ -5,7 +5,7 @@
     #define LV_ATTRIBUTE_MEM_ALIGN
 #endif
 
-const LV_ATTRIBUTE_MEM_ALIGN uint8_t img_lv_demo_music_logo_map[] = {
+const LV_ATTRIBUTE_MEM_ALIGN LV_ATTRIBUTE_LARGE_CONST uint8_t img_lv_demo_music_logo_map[] = {
     /*Pixel format: Fix 0xFF: 8 bit, Red: 8 bit, Green: 8 bit, Blue: 8 bit*/
     0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xda,0xda,0xda,0x22,0xb4,0xb4,0xb3,0x3a,0xa5,0xa5,0xa3,0x56,0xa4,0xa4,0xa2,0x57,0xa4,0xa4,0xa2,0x57,0xa4,0xa4,0xa2,0x57,0xa4,0xa4,0xa2,0x57,0xa4,0xa4,0xa2,0x57,0xa4,0xa4,0xa2,0x57,0xa4,0xa4,0xa2,0x57,0xa4,0xa4,0xa2,0x57,0xa4,0xa4,0xa2,0x57,0xa4,0xa4,0xa2,0x57,0xa4,0xa4,0xa2,0x57,0xa4,0xa4,0xa2,0x57,0xa4,0xa4,0xa2,0x57,0xa4,0xa4,0xa2,0x57,0xa4,0xa4,0xa2,0x57,0xa4,0xa4,0xa2,0x57,0xa4,0xa4,0xa2,0x57,0xa4,0xa4,0xa2,0x57,0xa4,0xa4,0xa2,0x57,0xa4,0xa4,0xa2,0x57,0xa4,0xa4,0xa2,0x57,0xa4,0xa4,0xa2,0x57,0xa4,0xa4,0xa2,0x57,0xa4,0xa4,0xa2,0x57,0xa4,0xa4,0xa2,0x57,0xa4,0xa4,0xa2,0x57,0xa4,0xa4,0xa2,0x57,0xa4,0xa4,0xa2,0x57,0xa4,0xa4,0xa2,0x57,0xa4,0xa4,0xa2,0x57,0xa4,0xa4,0xa2,0x57,0xa4,0xa4,0xa2,0x57,0xa4,0xa4,0xa2,0x57,0xa4,0xa4,0xa2,0x57,0xa4,0xa4,0xa2,0x57,0xa4,0xa4,0xa2,0x57,0xa4,0xa4,0xa2,0x57,0xa4,0xa4,0xa2,0x57,0xa4,0xa4,0xa2,0x57,0xa4,0xa4,0xa2,0x57,0xa4,0xa4,0xa2,0x57,0xa4,0xa4,0xa2,0x57,0xa4,0xa4,0xa2,0x57,0xa4,0xa4,0xa2,0x57,0xa4,0xa4,0xa2,0x57,0xa4,0xa4,0xa2,0x57,0xa4,0xa4,0xa2,0x57,0xa4,0xa4,0xa2,0x57,0xa4,0xa4,0xa2,0x57,0xa4,0xa4,0xa2,0x57,0xa4,0xa4,0xa2,0x57,0xa4,0xa4,0xa2,0x57,0xa4,0xa4,0xa2,0x57,0xa4,0xa4,0xa2,0x57,0xa4,0xa4,0xa2,0x57,0xa4,0xa4,0xa2,0x57,0xa4,0xa4,0xa2,0x57,0xa4,0xa4,0xa2,0x57,0xa4,0xa4,0xa2,0x57,0xa4,0xa4,0xa2,0x57,0xa4,0xa4,0xa2,0x57,0xa4,0xa4,0xa2,0x57,0xa4,0xa4,0xa2,0x57,0xa4,0xa4,0xa2,0x57,0xa4,0xa4,0xa2,0x57,0xa4,0xa4,0xa2,0x57,0xa4,0xa4,0xa2,0x57,0xa4,0xa4,0xa2,0x57,0xa4,0xa4,0xa2,0x57,0xa4,0xa4,0xa2,0x57,0xa4,0xa4,0xa2,0x57,0xa4,0xa4,0xa2,0x57,0xa4,0xa4,0xa2,0x57,0xa3,0xa3,0xa1,0x58,0xa9,0xa8,0xa7,0x4d,0xc3,0xc3,0xc2,0x2c,0xe9,0xe9,0xe8,0x13,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,
     0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xf4,0xf4,0xf3,0x04,0xb6,0xb6,0xb4,0x4d,0x7b,0x7a,0x78,0x91,0x4a,0x49,0x45,0xdd,0x3f,0x3e,0x3a,0xeb,0x3f,0x3e,0x3a,0xf5,0x3f,0x3e,0x3a,0xf6,0x3f,0x3e,0x3a,0xf6,0x3f,0x3e,0x3a,0xf6,0x3f,0x3e,0x3a,0xf6,0x3f,0x3e,0x3a,0xf6,0x3f,0x3e,0x3a,0xf6,0x3f,0x3e,0x3a,0xf6,0x3f,0x3e,0x3a,0xf6,0x3f,0x3e,0x3a,0xf6,0x3f,0x3e,0x3a,0xf6,0x3f,0x3e,0x3a,0xf6,0x3f,0x3e,0x3a,0xf6,0x3f,0x3e,0x3a,0xf6,0x3f,0x3e,0x3a,0xf6,0x3f,0x3e,0x3a,0xf6,0x3f,0x3e,0x3a,0xf6,0x3f,0x3e,0x3a,0xf6,0x3f,0x3e,0x3a,0xf6,0x3f,0x3e,0x3a,0xf6,0x3f,0x3e,0x3a,0xf6,0x3f,0x3e,0x3a,0xf6,0x3f,0x3e,0x3a,0xf6,0x3f,0x3e,0x3a,0xf6,0x3f,0x3e,0x3a,0xf6,0x3f,0x3e,0x3a,0xf6,0x3f,0x3e,0x3a,0xf6,0x3f,0x3e,0x3a,0xf6,0x3f,0x3e,0x3a,0xf6,0x3f,0x3e,0x3a,0xf6,0x3f,0x3e,0x3a,0xf6,0x3f,0x3e,0x3a,0xf6,0x3f,0x3e,0x3a,0xf6,0x3f,0x3e,0x3a,0xf6,0x3f,0x3e,0x3a,0xf6,0x3f,0x3e,0x3a,0xf6,0x3f,0x3e,0x3a,0xf6,0x3f,0x3e,0x3a,0xf6,0x3f,0x3e,0x3a,0xf6,0x3f,0x3e,0x3a,0xf6,0x3f,0x3e,0x3a,0xf6,0x3f,0x3e,0x3a,0xf6,0x3f,0x3e,0x3a,0xf6,0x3f,0x3e,0x3a,0xf6,0x3f,0x3e,0x3a,0xf6,0x3f,0x3e,0x3a,0xf6,0x3f,0x3e,0x3a,0xf6,0x3f,0x3e,0x3a,0xf6,0x3f,0x3e,0x3a,0xf6,0x3f,0x3e,0x3a,0xf6,0x3f,0x3e,0x3a,0xf6,0x3f,0x3e,0x3a,0xf6,0x3f,0x3e,0x3a,0xf6,0x3f,0x3e,0x3a,0xf6,0x3f,0x3e,0x3a,0xf6,0x3f,0x3e,0x3a,0xf6,0x3f,0x3e,0x3a,0xf6,0x3f,0x3e,0x3a,0xf6,0x3f,0x3e,0x3a,0xf6,0x3f,0x3e,0x3a,0xf6,0x3f,0x3e,0x3a,0xf6,0x3f,0x3e,0x3a,0xf6,0x3f,0x3e,0x3a,0xf6,0x3f,0x3e,0x3a,0xf6,0x3f,0x3e,0x3a,0xf6,0x3f,0x3e,0x3a,0xf6,0x3f,0x3e,0x3a,0xf6,0x3f,0x3e,0x3a,0xf6,0x3f,0x3e,0x3a,0xf6,0x3f,0x3e,0x3a,0xf6,0x3f,0x3e,0x3a,0xf6,0x3f,0x3e,0x3a,0xf6,0x3f,0x3e,0x3a,0xf6,0x3f,0x3e,0x3a,0xf6,0x3f,0x3e,0x3a,0xf6,0x3f,0x3e,0x3a,0xf2,0x40,0x3f,0x3b,0xe8,0x59,0x58,0x55,0xc6,0x93,0x92,0x90,0x73,0xd1,0xd1,0xd0,0x2a,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,
diff --git a/demos/music/assets/img_lv_demo_music_slider_knob.c b/demos/music/assets/img_lv_demo_music_slider_knob.c
index 3bd70346c..d094a37bb 100644
--- a/demos/music/assets/img_lv_demo_music_slider_knob.c
+++ b/demos/music/assets/img_lv_demo_music_slider_knob.c
@@ -5,7 +5,7 @@
     #define LV_ATTRIBUTE_MEM_ALIGN
 #endif
 
-const LV_ATTRIBUTE_MEM_ALIGN uint8_t img_lv_demo_music_slider_knob_map[] = {
+const LV_ATTRIBUTE_MEM_ALIGN LV_ATTRIBUTE_LARGE_CONST uint8_t img_lv_demo_music_slider_knob_map[] = {
     0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00,
     0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00,
     0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00,
diff --git a/demos/music/assets/img_lv_demo_music_wave_bottom.c b/demos/music/assets/img_lv_demo_music_wave_bottom.c
index ae0282165..9915a82f4 100644
--- a/demos/music/assets/img_lv_demo_music_wave_bottom.c
+++ b/demos/music/assets/img_lv_demo_music_wave_bottom.c
@@ -5,7 +5,7 @@
     #define LV_ATTRIBUTE_MEM_ALIGN
 #endif
 
-const LV_ATTRIBUTE_MEM_ALIGN uint8_t img_lv_demo_music_wave_bottom_map[] = {
+const LV_ATTRIBUTE_MEM_ALIGN LV_ATTRIBUTE_LARGE_CONST uint8_t img_lv_demo_music_wave_bottom_map[] = {
     /*Pixel format: Fix 0xFF: 8 bit, Red: 8 bit, Green: 8 bit, Blue: 8 bit*/
     0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
     0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xfe, 0xff, 0xff, 0xfd, 0xfd, 0xff, 0xff, 0xfc, 0xfc, 0xff, 0xff, 0xfb, 0xfb, 0xff, 0xff, 0xfb, 0xfb, 0xff, 0xff, 0xfa, 0xfa, 0xff, 0xff, 0xfa, 0xfa, 0xff, 0xff, 0xfa, 0xfa, 0xff, 0xff, 0xfa, 0xfa, 0xff, 0xff, 0xfa, 0xfa, 0xff, 0xff, 0xfa, 0xfa, 0xff, 0xff, 0xfa, 0xfa, 0xff, 0xff, 0xfa, 0xfa, 0xff, 0xff, 0xfa, 0xfa, 0xff, 0xff, 0xfa, 0xfa, 0xff, 0xff, 0xfb, 0xfb, 0xff, 0xff, 0xfb, 0xfb, 0xff, 0xff, 0xfc, 0xfc, 0xff, 0xff, 0xfc, 0xfc, 0xff, 0xff, 0xfd, 0xfd, 0xff, 0xff, 0xfd, 0xfd, 0xff, 0xff, 0xfe, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xfe, 0xff, 0xff, 0xfe, 0xfe, 0xff, 0xff, 0xfe, 0xfe, 0xff, 0xff, 0xfe, 0xfe, 0xff, 0xff, 0xfe, 0xfe, 0xff, 0xff, 0xfe, 0xfe, 0xff, 0xff, 0xfe, 0xfe, 0xff, 0xff, 0xfe, 0xfe, 0xff, 0xff, 0xfe, 0xfe, 0xff, 0xff, 0xfe, 0xfe, 0xff, 0xff, 0xfe, 0xfe, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
diff --git a/demos/music/assets/img_lv_demo_music_wave_top.c b/demos/music/assets/img_lv_demo_music_wave_top.c
index 51bfbf571..e5913b125 100644
--- a/demos/music/assets/img_lv_demo_music_wave_top.c
+++ b/demos/music/assets/img_lv_demo_music_wave_top.c
@@ -5,7 +5,7 @@
     #define LV_ATTRIBUTE_MEM_ALIGN
 #endif
 
-const LV_ATTRIBUTE_MEM_ALIGN uint8_t img_lv_demo_music_wave_top_map[] = {
+const LV_ATTRIBUTE_MEM_ALIGN LV_ATTRIBUTE_LARGE_CONST uint8_t img_lv_demo_music_wave_top_map[] = {
     /*Pixel format: Fix 0xFF: 8 bit, Red: 8 bit, Green: 8 bit, Blue: 8 bit*/
     0xff, 0xf5, 0xe5, 0xff, 0xff, 0xf4, 0xe5, 0xff, 0xff, 0xf4, 0xe4, 0xff, 0xff, 0xf4, 0xe5, 0xff, 0xff, 0xf4, 0xe4, 0xff, 0xff, 0xf3, 0xe4, 0xff, 0xff, 0xf3, 0xe3, 0xff, 0xff, 0xf3, 0xe4, 0xff, 0xff, 0xf2, 0xe3, 0xff, 0xff, 0xf1, 0xe2, 0xff, 0xff, 0xf1, 0xe2, 0xff, 0xff, 0xf0, 0xe1, 0xff, 0xff, 0xef, 0xe0, 0xff, 0xff, 0xef, 0xdf, 0xff, 0xff, 0xee, 0xdf, 0xff, 0xff, 0xee, 0xde, 0xff, 0xff, 0xee, 0xdd, 0xff, 0xff, 0xed, 0xdc, 0xff, 0xff, 0xec, 0xdb, 0xff, 0xff, 0xec, 0xdb, 0xff, 0xff, 0xeb, 0xda, 0xff, 0xff, 0xea, 0xda, 0xff, 0xff, 0xe9, 0xd9, 0xff, 0xff, 0xe9, 0xd9, 0xff, 0xff, 0xe8, 0xd8, 0xff, 0xff, 0xe7, 0xd7, 0xff, 0xff, 0xe7, 0xd6, 0xff, 0xff, 0xe6, 0xd6, 0xff, 0xff, 0xe6, 0xd5, 0xff, 0xff, 0xe6, 0xd5, 0xff, 0xff, 0xe5, 0xd4, 0xff, 0xff, 0xe5, 0xd4, 0xff, 0xff, 0xe4, 0xd3, 0xff, 0xff, 0xe4, 0xd3, 0xff, 0xff, 0xe4, 0xd3, 0xff, 0xff, 0xe3, 0xd2, 0xff, 0xff, 0xe3, 0xd2, 0xff, 0xff, 0xe3, 0xd2, 0xff, 0xff, 0xe3, 0xd2, 0xff, 0xff, 0xe3, 0xd2, 0xff, 0xff, 0xe3, 0xd2, 0xff, 0xff, 0xe3, 0xd2, 0xff, 0xff, 0xe3, 0xd2, 0xff, 0xff, 0xe3, 0xd2, 0xff, 0xff, 0xe3, 0xd2, 0xff, 0xff, 0xe3, 0xd2, 0xff, 0xff, 0xe3, 0xd2, 0xff, 0xff, 0xe3, 0xd2, 0xff, 0xff, 0xe9, 0xdc, 0xff, 0xff, 0xf2, 0xe8, 0xff, 0xff, 0xf2, 0xe9, 0xff, 0xff, 0xf2, 0xe9, 0xff, 0xff, 0xf2, 0xe9, 0xff, 0xff, 0xf2, 0xe9, 0xff, 0xff, 0xf2, 0xe9, 0xff, 0xff, 0xf2, 0xe9, 0xff, 0xff, 0xee, 0xea, 0xff, 0xff, 0xea, 0xeb, 0xff, 0xff, 0xe6, 0xeb, 0xff, 0xff, 0xe6, 0xeb, 0xff, 0xff, 0xe6, 0xeb, 0xff, 0xff, 0xe6, 0xeb, 0xff, 0xff, 0xe6, 0xeb, 0xff, 0xff, 0xe6, 0xeb, 0xff, 0xff, 0xe6, 0xeb, 0xff, 0xff, 0xe6, 0xeb, 0xff, 0xff, 0xe6, 0xec, 0xff, 0xff, 0xe6, 0xec, 0xff, 0xff, 0xe6, 0xec, 0xff, 0xff, 0xe6, 0xec, 0xff, 0xff, 0xe6, 0xec, 0xff, 0xff, 0xe6, 0xed, 0xff, 0xff, 0xe6, 0xed, 0xff, 0xff, 0xe6, 0xed, 0xff, 0xff, 0xe6, 0xed, 0xff, 0xff, 0xe6, 0xed, 0xff, 0xfe, 0xe7, 0xee, 0xff, 0xfe, 0xe7, 0xee, 0xff, 0xfe, 0xe7, 0xee, 0xff, 0xfe, 0xe7, 0xef, 0xff, 0xfe, 0xe7, 0xef, 0xff, 0xfe, 0xe7, 0xef, 0xff, 0xfe, 0xe7, 0xef, 0xff, 0xfe, 0xe7, 0xf0, 0xff, 0xfe, 0xe7, 0xf0, 0xff, 0xfe, 0xe7, 0xf0, 0xff, 0xfe, 0xe7, 0xf1, 0xff, 0xfe, 0xe7, 0xf1, 0xff, 0xfe, 0xe7, 0xf1, 0xff, 0xfe, 0xe7, 0xf2, 0xff, 0xfe, 0xe7, 0xf2, 0xff, 0xfe, 0xe7, 0xf3, 0xff, 0xfe, 0xe7, 0xf3, 0xff, 0xfe, 0xe7, 0xf3, 0xff, 0xfe, 0xe7, 0xf3, 0xff, 0xfe, 0xe7, 0xf4, 0xff, 0xfe, 0xe7, 0xf4, 0xff, 0xfe, 0xe7, 0xf4, 0xff, 0xfe, 0xe7, 0xf4, 0xff, 0xfe, 0xe7, 0xf4, 0xff, 0xfe, 0xe7, 0xf4, 0xff, 0xfe, 0xe7, 0xf4, 0xff, 0xfe, 0xe7, 0xf4, 0xff, 0xfe, 0xe7, 0xf4, 0xff, 0xfe, 0xe7, 0xf4, 0xff, 0xfe, 0xe8, 0xf4, 0xff, 0xfe, 0xe8, 0xf4, 0xff, 0xfe, 0xe8, 0xf4, 0xff, 0xfe, 0xe9, 0xf4, 0xff, 0xfe, 0xe9, 0xf4, 0xff, 0xfe, 0xea, 0xf4, 0xff, 0xfe, 0xea, 0xf4, 0xff, 0xfd, 0xea, 0xf5, 0xff, 0xfd, 0xeb, 0xf5, 0xff, 0xfd, 0xec, 0xf5, 0xff, 0xfd, 0xec, 0xf5, 0xff, 0xfd, 0xed, 0xf5, 0xff, 0xfd, 0xed, 0xf5, 0xff, 0xfd, 0xed, 0xf5, 0xff, 0xfd, 0xed, 0xf5, 0xff, 0xfd, 0xed, 0xf5, 0xff, 0xfd, 0xee, 0xf5, 0xff, 0xfd, 0xee, 0xf5, 0xff, 0xfd, 0xef, 0xf5, 0xff, 0xfd, 0xef, 0xf5, 0xff, 0xfd, 0xef, 0xf5, 0xff, 0xfd, 0xf0, 0xf5, 0xff, 0xfd, 0xf0, 0xf5, 0xff, 0xfd, 0xf0, 0xf5, 0xff, 0xfd, 0xf0, 0xf5, 0xff, 0xfd, 0xf2, 0xf6, 0xff, 0xfe, 0xf7, 0xf9, 0xff, 0xfe, 0xf8, 0xfa, 0xff, 0xfe, 0xf8, 0xfa, 0xff, 0xfe, 0xf8, 0xfa, 0xff, 0xfe, 0xf8, 0xfa, 0xff, 0xfe, 0xf8, 0xfa, 0xff, 0xfe, 0xf8, 0xfa, 0xff, 0xfe, 0xf8, 0xf9, 0xff, 0xfe, 0xf8, 0xf9, 0xff, 0xfe, 0xf8, 0xf9, 0xff, 0xfe, 0xf8, 0xf9, 0xff, 0xfe, 0xf8, 0xf9, 0xff, 0xfe, 0xf7, 0xf9, 0xff, 0xfe, 0xf7, 0xf9, 0xff, 0xfe, 0xf7, 0xf9, 0xff, 0xfe, 0xf7, 0xf9, 0xff, 0xfe, 0xf7, 0xf8, 0xff, 0xfe, 0xf7, 0xf8, 0xff, 0xfe, 0xf7, 0xf8, 0xff, 0xfe, 0xf7, 0xf8, 0xff, 0xfe, 0xf7, 0xf8, 0xff, 0xfe, 0xf7, 0xf8, 0xff, 0xfe, 0xf7, 0xf8, 0xff, 0xfe, 0xf7, 0xf7, 0xff, 0xfe, 0xf6, 0xf7, 0xff, 0xfe, 0xf6, 0xf7, 0xff, 0xfe, 0xf6, 0xf7, 0xff, 0xfe, 0xf6, 0xf7, 0xff, 0xfe, 0xf6, 0xf7, 0xff, 0xfe, 0xf6, 0xf7, 0xff, 0xfe, 0xf6, 0xf6, 0xff, 0xfe, 0xf5, 0xf6, 0xff, 0xfe, 0xf5, 0xf6, 0xff, 0xfe, 0xf5, 0xf6, 0xff, 0xfe, 0xf5, 0xf6, 0xff, 0xfe, 0xf5, 0xf5, 0xff, 0xfe, 0xf5, 0xf5, 0xff, 0xfe, 0xf5, 0xf5, 0xff, 0xfe, 0xf4, 0xf5, 0xff, 0xfe, 0xf4, 0xf5, 0xff, 0xfe, 0xf4, 0xf5, 0xff, 0xfe, 0xf4, 0xf4, 0xff, 0xfe, 0xf4, 0xf4, 0xff, 0xfe, 0xf3, 0xf4, 0xff, 0xfe, 0xf3, 0xf4, 0xff, 0xfe, 0xf3, 0xf4, 0xff, 0xfe, 0xf3, 0xf3, 0xff, 0xfe, 0xf3, 0xf3, 0xff, 0xfe, 0xf3, 0xf3, 0xff, 0xfe, 0xf2, 0xf3, 0xff, 0xfe, 0xf2, 0xf3, 0xff, 0xfe, 0xf2, 0xf2, 0xff, 0xfe, 0xf2, 0xf2, 0xff, 0xfe, 0xf2, 0xf2, 0xff, 0xfe, 0xf1, 0xf2, 0xff, 0xfe, 0xf1, 0xf2, 0xff, 0xfe, 0xf1, 0xf1, 0xff, 0xfe, 0xf1, 0xf1, 0xff, 0xfe, 0xf1, 0xf1, 0xff, 0xfe, 0xf1, 0xf1, 0xff, 0xfe, 0xf0, 0xf1, 0xff, 0xfe, 0xf0, 0xf0, 0xff, 0xfe, 0xf0, 0xf0, 0xff, 0xfe, 0xf0, 0xf0, 0xff, 0xfe, 0xf0, 0xf0, 0xff, 0xfe, 0xf0, 0xee, 0xff, 0xff, 0xf3, 0xec, 0xff, 0xff, 0xf4, 0xeb, 0xff, 0xff, 0xf4, 0xeb, 0xff, 0xff, 0xf4, 0xeb, 0xff, 0xff, 0xf4, 0xeb, 0xff, 0xff, 0xf4, 0xec, 0xff, 0xff, 0xf4, 0xec, 0xff, 0xff, 0xf4, 0xec, 0xff, 0xff, 0xf4, 0xec, 0xff, 0xff, 0xf4, 0xec, 0xff, 0xff, 0xf4, 0xec, 0xff, 0xff, 0xf4, 0xeb, 0xff, 0xff, 0xf4, 0xeb, 0xff, 0xff, 0xf4, 0xeb, 0xff, 0xff, 0xf4, 0xeb, 0xff, 0xff, 0xf4, 0xeb, 0xff, 0xff, 0xf4, 0xec, 0xff, 0xff, 0xf4, 0xec, 0xff, 0xff, 0xf4, 0xec, 0xff, 0xff, 0xf4, 0xec, 0xff, 0xff, 0xf4, 0xec, 0xff, 0xff, 0xf4, 0xeb, 0xff, 0xff, 0xf4, 0xeb, 0xff, 0xff, 0xf4, 0xeb, 0xff, 0xff, 0xf4, 0xeb, 0xff, 0xff, 0xf4, 0xeb, 0xff, 0xff, 0xf4, 0xeb, 0xff, 0xff, 0xf4, 0xeb, 0xff, 0xff, 0xf3, 0xeb, 0xff, 0xff, 0xf3, 0xea, 0xff, 0xff, 0xf3, 0xea, 0xff, 0xff, 0xf4, 0xe9, 0xff, 0xff, 0xf5, 0xe9, 0xff, 0xff, 0xf6, 0xe8, 0xff, 0xff, 0xf7, 0xe9, 0xff, 0xff, 0xf6, 0xe9, 0xff, 0xff, 0xf6, 0xea, 0xff, 0xff, 0xf7, 0xea, 0xff, 0xff, 0xf8, 0xea, 0xff, 0xff, 0xf8, 0xea, 0xff, 0xff, 0xf9, 0xeb, 0xff, 0xff, 0xf9, 0xea, 0xff, 0xff, 0xf9, 0xea, 0xff, 0xff, 0xf9, 0xea, 0xff, 0xff, 0xf9, 0xeb, 0xff, 0xff, 0xfa, 0xeb, 0xff, 0xff, 0xfa, 0xeb, 0xff, 0xff, 0xf9, 0xea, 0xff, 0xff, 0xf9, 0xea, 0xff, 0xff, 0xf9, 0xea, 0xff, 0xff, 0xf9, 0xea, 0xff, 0xff, 0xf9, 0xea, 0xff, 0xff, 0xf9, 0xea, 0xff, 0xff, 0xf9, 0xea, 0xff, 0xff, 0xf9, 0xea, 0xff, 0xff, 0xf9, 0xea, 0xff, 0xff, 0xf9, 0xea, 0xff, 0xff, 0xf9, 0xea, 0xff, 0xff, 0xf9, 0xea, 0xff, 0xff, 0xf9, 0xea, 0xff, 0xff, 0xf9, 0xea, 0xff, 0xff, 0xf9, 0xea, 0xff, 0xff, 0xf9, 0xea, 0xff, 0xff, 0xf9, 0xea, 0xff, 0xff, 0xf9, 0xea, 0xff, 0xff, 0xf9, 0xea, 0xff, 0xff, 0xf9, 0xe9, 0xff, 0xfe, 0xf8, 0xe9, 0xff, 0xfe, 0xf8, 0xe9, 0xff, 0xfe, 0xf8, 0xe9, 0xff, 0xfe, 0xf7, 0xe8, 0xff, 0xfe, 0xf7, 0xe8, 0xff, 0xfe, 0xf6, 0xe8, 0xff, 0xfe, 0xf6, 0xe7, 0xff, 0xfe, 0xf5, 0xe8, 0xff,
     0xff, 0xf5, 0xe6, 0xff, 0xff, 0xf4, 0xe5, 0xff, 0xff, 0xf4, 0xe4, 0xff, 0xff, 0xf3, 0xe3, 0xff, 0xff, 0xf4, 0xe4, 0xff, 0xff, 0xf3, 0xe3, 0xff, 0xff, 0xf3, 0xe4, 0xff, 0xff, 0xf2, 0xe3, 0xff, 0xff, 0xf1, 0xe2, 0xff, 0xff, 0xf1, 0xe2, 0xff, 0xff, 0xf0, 0xe1, 0xff, 0xff, 0xef, 0xe0, 0xff, 0xff, 0xef, 0xdf, 0xff, 0xff, 0xee, 0xde, 0xff, 0xff, 0xee, 0xde, 0xff, 0xff, 0xed, 0xdd, 0xff, 0xff, 0xed, 0xdc, 0xff, 0xff, 0xec, 0xdb, 0xff, 0xff, 0xeb, 0xda, 0xff, 0xff, 0xea, 0xda, 0xff, 0xff, 0xea, 0xda, 0xff, 0xff, 0xe9, 0xd9, 0xff, 0xff, 0xe8, 0xd8, 0xff, 0xff, 0xe8, 0xd8, 0xff, 0xff, 0xe7, 0xd7, 0xff, 0xff, 0xe7, 0xd6, 0xff, 0xff, 0xe6, 0xd5, 0xff, 0xff, 0xe6, 0xd5, 0xff, 0xff, 0xe5, 0xd5, 0xff, 0xff, 0xe5, 0xd4, 0xff, 0xff, 0xe5, 0xd4, 0xff, 0xff, 0xe4, 0xd3, 0xff, 0xff, 0xe4, 0xd3, 0xff, 0xff, 0xe4, 0xd3, 0xff, 0xff, 0xe3, 0xd2, 0xff, 0xff, 0xe3, 0xd2, 0xff, 0xff, 0xe3, 0xd2, 0xff, 0xff, 0xe3, 0xd2, 0xff, 0xff, 0xe3, 0xd2, 0xff, 0xff, 0xe3, 0xd2, 0xff, 0xff, 0xe3, 0xd2, 0xff, 0xff, 0xe3, 0xd2, 0xff, 0xff, 0xe3, 0xd2, 0xff, 0xff, 0xe3, 0xd2, 0xff, 0xff, 0xe3, 0xd2, 0xff, 0xff, 0xe3, 0xd2, 0xff, 0xff, 0xe3, 0xd2, 0xff, 0xff, 0xeb, 0xdd, 0xff, 0xff, 0xf2, 0xe9, 0xff, 0xff, 0xf2, 0xe9, 0xff, 0xff, 0xf2, 0xe9, 0xff, 0xff, 0xf2, 0xe9, 0xff, 0xff, 0xf2, 0xe9, 0xff, 0xff, 0xf2, 0xe9, 0xff, 0xff, 0xf2, 0xe9, 0xff, 0xff, 0xf2, 0xe9, 0xff, 0xff, 0xf2, 0xe9, 0xff, 0xff, 0xf2, 0xe9, 0xff, 0xff, 0xef, 0xe9, 0xff, 0xff, 0xeb, 0xea, 0xff, 0xff, 0xe7, 0xeb, 0xff, 0xff, 0xe6, 0xeb, 0xff, 0xff, 0xe6, 0xeb, 0xff, 0xff, 0xe6, 0xeb, 0xff, 0xff, 0xe6, 0xeb, 0xff, 0xff, 0xe6, 0xec, 0xff, 0xff, 0xe6, 0xec, 0xff, 0xff, 0xe6, 0xec, 0xff, 0xff, 0xe6, 0xec, 0xff, 0xff, 0xe6, 0xec, 0xff, 0xff, 0xe6, 0xed, 0xff, 0xff, 0xe6, 0xed, 0xff, 0xff, 0xe6, 0xed, 0xff, 0xff, 0xe6, 0xed, 0xff, 0xff, 0xe6, 0xed, 0xff, 0xff, 0xe7, 0xee, 0xff, 0xfe, 0xe7, 0xee, 0xff, 0xfe, 0xe7, 0xee, 0xff, 0xfe, 0xe7, 0xef, 0xff, 0xfe, 0xe7, 0xef, 0xff, 0xfe, 0xe7, 0xef, 0xff, 0xfe, 0xe7, 0xef, 0xff, 0xfe, 0xe7, 0xf0, 0xff, 0xfe, 0xe7, 0xf0, 0xff, 0xfe, 0xe7, 0xf0, 0xff, 0xfe, 0xe7, 0xf1, 0xff, 0xfe, 0xe7, 0xf1, 0xff, 0xfe, 0xe7, 0xf1, 0xff, 0xfe, 0xe7, 0xf2, 0xff, 0xfe, 0xe7, 0xf2, 0xff, 0xfe, 0xe7, 0xf3, 0xff, 0xfe, 0xe7, 0xf3, 0xff, 0xfe, 0xe7, 0xf3, 0xff, 0xfe, 0xe7, 0xf3, 0xff, 0xfe, 0xe7, 0xf4, 0xff, 0xfe, 0xe7, 0xf4, 0xff, 0xfe, 0xe7, 0xf4, 0xff, 0xfe, 0xe7, 0xf4, 0xff, 0xfe, 0xe7, 0xf4, 0xff, 0xfe, 0xe7, 0xf4, 0xff, 0xfe, 0xe7, 0xf4, 0xff, 0xfe, 0xe7, 0xf4, 0xff, 0xfe, 0xe7, 0xf4, 0xff, 0xfe, 0xe7, 0xf4, 0xff, 0xfe, 0xe8, 0xf4, 0xff, 0xfe, 0xe8, 0xf4, 0xff, 0xfe, 0xe8, 0xf4, 0xff, 0xfe, 0xe9, 0xf4, 0xff, 0xfe, 0xe9, 0xf4, 0xff, 0xfe, 0xea, 0xf4, 0xff, 0xfe, 0xea, 0xf4, 0xff, 0xfd, 0xea, 0xf5, 0xff, 0xfd, 0xeb, 0xf5, 0xff, 0xfd, 0xec, 0xf5, 0xff, 0xfd, 0xec, 0xf5, 0xff, 0xfd, 0xed, 0xf5, 0xff, 0xfd, 0xed, 0xf5, 0xff, 0xfd, 0xed, 0xf5, 0xff, 0xfd, 0xed, 0xf5, 0xff, 0xfd, 0xed, 0xf5, 0xff, 0xfd, 0xee, 0xf5, 0xff, 0xfd, 0xee, 0xf5, 0xff, 0xfd, 0xef, 0xf5, 0xff, 0xfd, 0xef, 0xf5, 0xff, 0xfd, 0xef, 0xf5, 0xff, 0xfd, 0xf0, 0xf5, 0xff, 0xfd, 0xf0, 0xf5, 0xff, 0xfd, 0xf0, 0xf5, 0xff, 0xfd, 0xf0, 0xf6, 0xff, 0xfe, 0xf4, 0xf8, 0xff, 0xfe, 0xf7, 0xfa, 0xff, 0xfe, 0xf8, 0xfa, 0xff, 0xfe, 0xf8, 0xfa, 0xff, 0xfe, 0xf8, 0xfa, 0xff, 0xfe, 0xf8, 0xfa, 0xff, 0xfe, 0xf8, 0xfa, 0xff, 0xfe, 0xf8, 0xfa, 0xff, 0xfe, 0xf8, 0xf9, 0xff, 0xfe, 0xf8, 0xf9, 0xff, 0xfe, 0xf8, 0xf9, 0xff, 0xfe, 0xf8, 0xf9, 0xff, 0xfe, 0xf8, 0xf9, 0xff, 0xfe, 0xf7, 0xf9, 0xff, 0xfe, 0xf7, 0xf9, 0xff, 0xfe, 0xf7, 0xf9, 0xff, 0xfe, 0xf7, 0xf9, 0xff, 0xfe, 0xf7, 0xf8, 0xff, 0xfe, 0xf7, 0xf8, 0xff, 0xfe, 0xf7, 0xf8, 0xff, 0xfe, 0xf7, 0xf8, 0xff, 0xfe, 0xf7, 0xf8, 0xff, 0xfe, 0xf7, 0xf8, 0xff, 0xfe, 0xf7, 0xf8, 0xff, 0xfe, 0xf7, 0xf7, 0xff, 0xfe, 0xf6, 0xf7, 0xff, 0xfe, 0xf6, 0xf7, 0xff, 0xfe, 0xf6, 0xf7, 0xff, 0xfe, 0xf6, 0xf7, 0xff, 0xfe, 0xf6, 0xf7, 0xff, 0xfe, 0xf6, 0xf7, 0xff, 0xfe, 0xf6, 0xf6, 0xff, 0xfe, 0xf5, 0xf6, 0xff, 0xfe, 0xf5, 0xf6, 0xff, 0xfe, 0xf5, 0xf6, 0xff, 0xfe, 0xf5, 0xf6, 0xff, 0xfe, 0xf5, 0xf5, 0xff, 0xfe, 0xf5, 0xf5, 0xff, 0xfe, 0xf5, 0xf5, 0xff, 0xfe, 0xf4, 0xf5, 0xff, 0xfe, 0xf4, 0xf5, 0xff, 0xfe, 0xf4, 0xf5, 0xff, 0xfe, 0xf4, 0xf4, 0xff, 0xfe, 0xf4, 0xf4, 0xff, 0xfe, 0xf4, 0xf4, 0xff, 0xfe, 0xf3, 0xf4, 0xff, 0xfe, 0xf3, 0xf4, 0xff, 0xfe, 0xf3, 0xf3, 0xff, 0xfe, 0xf3, 0xf3, 0xff, 0xfe, 0xf3, 0xf3, 0xff, 0xfe, 0xf2, 0xf3, 0xff, 0xfe, 0xf2, 0xf3, 0xff, 0xfe, 0xf2, 0xf2, 0xff, 0xfe, 0xf2, 0xf2, 0xff, 0xfe, 0xf2, 0xf2, 0xff, 0xfe, 0xf1, 0xf2, 0xff, 0xfe, 0xf1, 0xf2, 0xff, 0xfe, 0xf1, 0xf1, 0xff, 0xfe, 0xf1, 0xf1, 0xff, 0xfe, 0xf1, 0xf1, 0xff, 0xfe, 0xf1, 0xf1, 0xff, 0xfe, 0xf0, 0xf1, 0xff, 0xfe, 0xf0, 0xf0, 0xff, 0xfe, 0xf0, 0xf0, 0xff, 0xfe, 0xf0, 0xf0, 0xff, 0xfe, 0xf0, 0xf0, 0xff, 0xfe, 0xef, 0xf0, 0xff, 0xfe, 0xef, 0xef, 0xff, 0xfe, 0xef, 0xef, 0xff, 0xfe, 0xf0, 0xee, 0xff, 0xff, 0xf3, 0xec, 0xff, 0xff, 0xf4, 0xeb, 0xff, 0xff, 0xf4, 0xec, 0xff, 0xff, 0xf4, 0xec, 0xff, 0xff, 0xf4, 0xec, 0xff, 0xff, 0xf4, 0xec, 0xff, 0xff, 0xf4, 0xeb, 0xff, 0xff, 0xf4, 0xec, 0xff, 0xff, 0xf4, 0xeb, 0xff, 0xff, 0xf4, 0xeb, 0xff, 0xff, 0xf4, 0xeb, 0xff, 0xff, 0xf4, 0xeb, 0xff, 0xff, 0xf4, 0xeb, 0xff, 0xff, 0xf4, 0xec, 0xff, 0xff, 0xf4, 0xec, 0xff, 0xff, 0xf4, 0xec, 0xff, 0xff, 0xf4, 0xec, 0xff, 0xff, 0xf4, 0xec, 0xff, 0xff, 0xf4, 0xeb, 0xff, 0xff, 0xf4, 0xeb, 0xff, 0xff, 0xf4, 0xeb, 0xff, 0xff, 0xf4, 0xeb, 0xff, 0xff, 0xf4, 0xeb, 0xff, 0xff, 0xf4, 0xeb, 0xff, 0xff, 0xf4, 0xeb, 0xff, 0xff, 0xf4, 0xeb, 0xff, 0xff, 0xf3, 0xeb, 0xff, 0xff, 0xf3, 0xea, 0xff, 0xff, 0xf3, 0xe9, 0xff, 0xff, 0xf4, 0xe9, 0xff, 0xff, 0xf5, 0xe8, 0xff, 0xff, 0xf6, 0xe8, 0xff, 0xff, 0xf7, 0xe9, 0xff, 0xff, 0xf6, 0xe9, 0xff, 0xff, 0xf6, 0xea, 0xff, 0xff, 0xf6, 0xea, 0xff, 0xff, 0xf7, 0xea, 0xff, 0xff, 0xf8, 0xea, 0xff, 0xff, 0xf8, 0xea, 0xff, 0xff, 0xf9, 0xea, 0xff, 0xff, 0xf9, 0xeb, 0xff, 0xff, 0xfa, 0xeb, 0xff, 0xff, 0xfa, 0xeb, 0xff, 0xff, 0xfa, 0xea, 0xff, 0xff, 0xf9, 0xea, 0xff, 0xff, 0xf9, 0xea, 0xff, 0xff, 0xf9, 0xea, 0xff, 0xff, 0xf9, 0xea, 0xff, 0xff, 0xf9, 0xea, 0xff, 0xff, 0xf9, 0xea, 0xff, 0xff, 0xf9, 0xea, 0xff, 0xff, 0xf9, 0xea, 0xff, 0xff, 0xf9, 0xea, 0xff, 0xff, 0xf9, 0xea, 0xff, 0xff, 0xf9, 0xea, 0xff, 0xff, 0xf9, 0xea, 0xff, 0xff, 0xf9, 0xea, 0xff, 0xff, 0xf9, 0xea, 0xff, 0xff, 0xf9, 0xea, 0xff, 0xff, 0xf9, 0xea, 0xff, 0xff, 0xf9, 0xea, 0xff, 0xff, 0xf9, 0xea, 0xff, 0xff, 0xf9, 0xea, 0xff, 0xff, 0xf9, 0xea, 0xff, 0xff, 0xf9, 0xe9, 0xff, 0xff, 0xf8, 0xe9, 0xff, 0xff, 0xf8, 0xe8, 0xff, 0xff, 0xf7, 0xe8, 0xff, 0xfe, 0xf7, 0xe8, 0xff, 0xfe, 0xf7, 0xe8, 0xff, 0xfe, 0xf6, 0xe7, 0xff, 0xfe, 0xf5, 0xe7, 0xff, 0xfe, 0xf5, 0xe8, 0xff,
diff --git a/demos/music/assets/spectrum_1.h b/demos/music/assets/spectrum_1.h
index 499db6ff7..aa2889413 100644
--- a/demos/music/assets/spectrum_1.h
+++ b/demos/music/assets/spectrum_1.h
@@ -1,4 +1,4 @@
-const uint16_t spectrum_1[][4] = {
+LV_ATTRIBUTE_LARGE_CONST const uint16_t spectrum_1[][4] = {
 { 0, 0, 0, 0, },
 { 0, 9, 7, 8, },
 { 5, 39, 24, 29, },
diff --git a/demos/music/assets/spectrum_2.h b/demos/music/assets/spectrum_2.h
index ebdbac5c2..8450655a3 100644
--- a/demos/music/assets/spectrum_2.h
+++ b/demos/music/assets/spectrum_2.h
@@ -1,4 +1,4 @@
-const uint16_t spectrum_2[][4] = {
+LV_ATTRIBUTE_LARGE_CONST const uint16_t spectrum_2[][4] = {
 { 0, 0, 0, 0, },
 { 0, 8, 28, 14, },
 { 1, 35, 63, 31, },
diff --git a/demos/music/assets/spectrum_3.h b/demos/music/assets/spectrum_3.h
index 459459de7..cb34bf21c 100644
--- a/demos/music/assets/spectrum_3.h
+++ b/demos/music/assets/spectrum_3.h
@@ -1,4 +1,4 @@
-const uint16_t spectrum_3[][4] = {
+LV_ATTRIBUTE_LARGE_CONST const uint16_t spectrum_3[][4] = {
 { 0, 0, 0, 0, },
 { 0, 0, 0, 0, },
 { 0, 0, 0, 0, },
diff --git a/demos/music/lv_demo_music.c b/demos/music/lv_demo_music.c
index 00e9213dc..85aeef1ca 100644
--- a/demos/music/lv_demo_music.c
+++ b/demos/music/lv_demo_music.c
@@ -113,7 +113,7 @@ static const uint32_t time_list[] = {
 /**********************
  *   GLOBAL FUNCTIONS
  **********************/
-
+__attribute__(( fptrgroup("lv_demo_entry_cb") ))
 void lv_demo_music(void)
 {
     lv_obj_set_style_bg_color(lv_screen_active(), lv_color_hex(0x343247), 0);
@@ -126,24 +126,28 @@ void lv_demo_music(void)
 #endif
 }
 
+LV_FUNC_SECTION
 const char * lv_demo_music_get_title(uint32_t track_id)
 {
     if(track_id >= sizeof(title_list) / sizeof(title_list[0])) return NULL;
     return title_list[track_id];
 }
 
+LV_FUNC_SECTION
 const char * lv_demo_music_get_artist(uint32_t track_id)
 {
     if(track_id >= sizeof(artist_list) / sizeof(artist_list[0])) return NULL;
     return artist_list[track_id];
 }
 
+LV_FUNC_SECTION
 const char * lv_demo_music_get_genre(uint32_t track_id)
 {
     if(track_id >= sizeof(genre_list) / sizeof(genre_list[0])) return NULL;
     return genre_list[track_id];
 }
 
+LV_FUNC_SECTION
 uint32_t lv_demo_music_get_track_length(uint32_t track_id)
 {
     if(track_id >= sizeof(time_list) / sizeof(time_list[0])) return 0;
@@ -155,6 +159,7 @@ uint32_t lv_demo_music_get_track_length(uint32_t track_id)
  **********************/
 
 #if LV_DEMO_MUSIC_AUTO_PLAY
+LV_FUNC_SECTION
 static void auto_step_cb(lv_timer_t * t)
 {
     LV_UNUSED(t);
diff --git a/demos/music/lv_demo_music_list.c b/demos/music/lv_demo_music_list.c
index 4af075a74..85503ff6b 100644
--- a/demos/music/lv_demo_music_list.c
+++ b/demos/music/lv_demo_music_list.c
@@ -51,6 +51,7 @@ LV_IMAGE_DECLARE(img_lv_demo_music_btn_list_pause);
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 lv_obj_t * lv_demo_music_list_create(lv_obj_t * parent)
 {
     font_small = LV_FONT_DEFAULT;
@@ -151,6 +152,7 @@ lv_obj_t * lv_demo_music_list_create(lv_obj_t * parent)
     return list;
 }
 
+LV_FUNC_SECTION
 void lv_demo_music_list_button_check(uint32_t track_id, bool state)
 {
     lv_obj_t * btn = lv_obj_get_child(list, track_id);
@@ -171,6 +173,7 @@ void lv_demo_music_list_button_check(uint32_t track_id, bool state)
  *   STATIC FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 static lv_obj_t * add_list_button(lv_obj_t * parent, uint32_t track_id)
 {
     uint32_t t = lv_demo_music_get_track_length(track_id);
@@ -227,6 +230,7 @@ static lv_obj_t * add_list_button(lv_obj_t * parent, uint32_t track_id)
     return btn;
 }
 
+__attribute__(( fptrgroup("lv_event_cb") ))
 static void btn_click_event_cb(lv_event_t * e)
 {
     lv_obj_t * btn = lv_event_get_target(e);
@@ -236,6 +240,7 @@ static void btn_click_event_cb(lv_event_t * e)
     lv_demo_music_play(idx);
 }
 
+LV_FUNC_SECTION
 static void list_delete_event_cb(lv_event_t * e)
 {
     lv_event_code_t code = lv_event_get_code(e);
diff --git a/demos/music/lv_demo_music_main.c b/demos/music/lv_demo_music_main.c
index f699b4511..976160009 100644
--- a/demos/music/lv_demo_music_main.c
+++ b/demos/music/lv_demo_music_main.c
@@ -110,6 +110,7 @@ static const uint16_t rnd_array[30] = {994, 285, 553, 11, 792, 707, 966, 641, 85
  * Callback adapter function to convert parameter types to avoid compile-time
  * warning.
  */
+LV_FUNC_SECTION
 static void _image_set_scale_anim_cb(void * obj, int32_t scale)
 {
     lv_image_set_scale((lv_obj_t *)obj, (uint16_t)scale);
@@ -119,11 +120,13 @@ static void _image_set_scale_anim_cb(void * obj, int32_t scale)
  * Callback adapter function to convert parameter types to avoid compile-time
  * warning.
  */
+LV_FUNC_SECTION
 static void _obj_set_x_anim_cb(void * obj, int32_t x)
 {
     lv_obj_set_x((lv_obj_t *)obj, (int32_t)x);
 }
 
+LV_FUNC_SECTION
 lv_obj_t * lv_demo_music_main_create(lv_obj_t * parent)
 {
     font_small = LV_FONT_DEFAULT;
@@ -318,6 +321,7 @@ lv_obj_t * lv_demo_music_main_create(lv_obj_t * parent)
     return main_cont;
 }
 
+LV_FUNC_SECTION
 void lv_demo_music_album_next(bool next)
 {
     uint32_t id = track_id;
@@ -342,6 +346,7 @@ void lv_demo_music_album_next(bool next)
     }
 }
 
+LV_FUNC_SECTION
 void lv_demo_music_play(uint32_t id)
 {
     track_load(id);
@@ -349,6 +354,7 @@ void lv_demo_music_play(uint32_t id)
     lv_demo_music_resume();
 }
 
+LV_FUNC_SECTION
 void lv_demo_music_resume(void)
 {
     playing = true;
@@ -370,6 +376,7 @@ void lv_demo_music_resume(void)
 
 }
 
+LV_FUNC_SECTION
 void lv_demo_music_pause(void)
 {
     playing = false;
@@ -386,6 +393,7 @@ void lv_demo_music_pause(void)
  *   STATIC FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 static lv_obj_t * create_cont(lv_obj_t * parent)
 {
     /*A transparent container in which the player section will be scrolled*/
@@ -447,6 +455,7 @@ static lv_obj_t * create_cont(lv_obj_t * parent)
     return player;
 }
 
+LV_FUNC_SECTION
 static void create_wave_images(lv_obj_t * parent)
 {
     LV_IMAGE_DECLARE(img_lv_demo_music_wave_top);
@@ -486,6 +495,7 @@ static void create_wave_images(lv_obj_t * parent)
     lv_obj_add_flag(wave_corner, LV_OBJ_FLAG_IGNORE_LAYOUT);
 }
 
+LV_FUNC_SECTION
 static lv_obj_t * create_title_box(lv_obj_t * parent)
 {
 
@@ -515,6 +525,7 @@ static lv_obj_t * create_title_box(lv_obj_t * parent)
     return cont;
 }
 
+LV_FUNC_SECTION
 static lv_obj_t * create_icon_box(lv_obj_t * parent)
 {
 
@@ -541,6 +552,7 @@ static lv_obj_t * create_icon_box(lv_obj_t * parent)
     return cont;
 }
 
+LV_FUNC_SECTION
 static lv_obj_t * create_spectrum_obj(lv_obj_t * parent)
 {
     /*Create the spectrum visualizer*/
@@ -558,6 +570,7 @@ static lv_obj_t * create_spectrum_obj(lv_obj_t * parent)
     return obj;
 }
 
+LV_FUNC_SECTION
 static lv_obj_t * create_ctrl_box(lv_obj_t * parent)
 {
     /*Create the control box*/
@@ -644,6 +657,7 @@ static lv_obj_t * create_ctrl_box(lv_obj_t * parent)
     return cont;
 }
 
+LV_FUNC_SECTION
 static lv_obj_t * create_handle(lv_obj_t * parent)
 {
     lv_obj_t * cont = lv_obj_create(parent);
@@ -673,6 +687,7 @@ static lv_obj_t * create_handle(lv_obj_t * parent)
     return cont;
 }
 
+LV_FUNC_SECTION
 static void track_load(uint32_t id)
 {
     spectrum_i = 0;
@@ -754,6 +769,7 @@ static void track_load(uint32_t id)
     lv_anim_start(&a);
 }
 
+LV_FUNC_SECTION
 int32_t get_cos(int32_t deg, int32_t a)
 {
     int32_t r = (lv_trigo_cos(deg) * a);
@@ -762,6 +778,7 @@ int32_t get_cos(int32_t deg, int32_t a)
     return r >> LV_TRIGO_SHIFT;
 }
 
+LV_FUNC_SECTION
 int32_t get_sin(int32_t deg, int32_t a)
 {
     int32_t r = lv_trigo_sin(deg) * a;
@@ -770,6 +787,7 @@ int32_t get_sin(int32_t deg, int32_t a)
 
 }
 
+LV_FUNC_SECTION
 static void del_counter_timer_cb(lv_event_t * e)
 {
     lv_event_code_t code = lv_event_get_code(e);
@@ -779,6 +797,7 @@ static void del_counter_timer_cb(lv_event_t * e)
     }
 }
 
+LV_FUNC_SECTION
 static void spectrum_draw_event_cb(lv_event_t * e)
 {
     lv_event_code_t code = lv_event_get_code(e);
@@ -901,6 +920,7 @@ static void spectrum_draw_event_cb(lv_event_t * e)
     }
 }
 
+LV_FUNC_SECTION
 static void spectrum_anim_cb(void * a, int32_t v)
 {
     lv_obj_t * obj = a;
@@ -930,6 +950,7 @@ static void spectrum_anim_cb(void * a, int32_t v)
     lv_image_set_scale(album_image_obj, LV_SCALE_NONE + spectrum[spectrum_i][0]);
 }
 
+LV_FUNC_SECTION
 static void start_anim_cb(void * var, int32_t v)
 {
     int32_t * av = var;
@@ -937,6 +958,7 @@ static void start_anim_cb(void * var, int32_t v)
     lv_obj_invalidate(spectrum_obj);
 }
 
+LV_FUNC_SECTION
 static lv_obj_t * album_image_create(lv_obj_t * parent)
 {
     LV_IMAGE_DECLARE(img_lv_demo_music_cover_1);
@@ -973,6 +995,7 @@ static lv_obj_t * album_image_create(lv_obj_t * parent)
 
 }
 
+LV_FUNC_SECTION
 static void album_gesture_event_cb(lv_event_t * e)
 {
     LV_UNUSED(e);
@@ -981,6 +1004,7 @@ static void album_gesture_event_cb(lv_event_t * e)
     if(dir == LV_DIR_RIGHT) lv_demo_music_album_next(false);
 }
 
+LV_FUNC_SECTION
 static void play_event_click_cb(lv_event_t * e)
 {
     lv_obj_t * obj = lv_event_get_target(e);
@@ -992,12 +1016,14 @@ static void play_event_click_cb(lv_event_t * e)
     }
 }
 
+LV_FUNC_SECTION
 static void prev_click_event_cb(lv_event_t * e)
 {
     LV_UNUSED(e);
     lv_demo_music_album_next(false);
 }
 
+LV_FUNC_SECTION
 static void next_click_event_cb(lv_event_t * e)
 {
     lv_event_code_t code = lv_event_get_code(e);
@@ -1006,6 +1032,7 @@ static void next_click_event_cb(lv_event_t * e)
     }
 }
 
+LV_FUNC_SECTION
 static void timer_cb(lv_timer_t * t)
 {
     LV_UNUSED(t);
@@ -1014,12 +1041,14 @@ static void timer_cb(lv_timer_t * t)
     lv_slider_set_value(slider_obj, time_act, LV_ANIM_ON);
 }
 
+LV_FUNC_SECTION
 static void spectrum_end_cb(lv_anim_t * a)
 {
     LV_UNUSED(a);
     lv_demo_music_album_next(true);
 }
 
+LV_FUNC_SECTION
 static void stop_start_anim(lv_timer_t * t)
 {
     LV_UNUSED(t);
@@ -1027,6 +1056,7 @@ static void stop_start_anim(lv_timer_t * t)
     lv_obj_refresh_ext_draw_size(spectrum_obj);
 }
 
+LV_FUNC_SECTION
 static void album_fade_anim_cb(void * var, int32_t v)
 {
     lv_obj_set_style_image_opa(var, v, 0);
diff --git a/demos/render/lv_demo_render.c b/demos/render/lv_demo_render.c
index bccb1b508..c5f87f2fa 100644
--- a/demos/render/lv_demo_render.c
+++ b/demos/render/lv_demo_render.c
@@ -26,6 +26,7 @@
  **********************/
 typedef struct {
     const char * name;
+    __attribute__(( fptrgroup("lv_scene_create_cb") ))
     void (*create_cb)(lv_obj_t * parent);
 } scene_dsc_t;
 
@@ -35,6 +36,7 @@ typedef struct {
 static lv_opa_t opa_saved;
 static void add_to_cell(lv_obj_t * obj, int32_t col, int32_t row);
 
+LV_FUNC_SECTION
 static lv_obj_t * fill_obj_create(lv_obj_t * parent, int32_t col, int32_t row)
 {
     lv_color_t colors[] = {lv_color_hex3(0x000),
@@ -59,6 +61,7 @@ static lv_obj_t * fill_obj_create(lv_obj_t * parent, int32_t col, int32_t row)
 
 }
 
+__attribute__(( fptrgroup("lv_scene_create_cb") ))
 static void fill_cb(lv_obj_t * parent)
 {
 
@@ -113,6 +116,7 @@ static void fill_cb(lv_obj_t * parent)
     }
 }
 
+LV_FUNC_SECTION
 static lv_obj_t * border_obj_create(lv_obj_t * parent, int32_t col, int32_t row)
 {
     lv_obj_t * obj = lv_obj_create(parent);
@@ -127,6 +131,7 @@ static lv_obj_t * border_obj_create(lv_obj_t * parent, int32_t col, int32_t row)
 
 }
 
+__attribute__(( fptrgroup("lv_scene_create_cb") ))
 static void border_cb(lv_obj_t * parent)
 {
     lv_border_side_t sides[] = {
@@ -208,6 +213,7 @@ static void border_cb(lv_obj_t * parent)
     }
 }
 
+LV_FUNC_SECTION
 static lv_obj_t * box_shadow_obj_create(lv_obj_t * parent, int32_t col, int32_t row)
 {
     lv_obj_t * obj = lv_obj_create(parent);
@@ -222,6 +228,7 @@ static lv_obj_t * box_shadow_obj_create(lv_obj_t * parent, int32_t col, int32_t
     return obj;
 }
 
+__attribute__(( fptrgroup("lv_scene_create_cb") ))
 static void box_shadow_cb(lv_obj_t * parent)
 {
 
@@ -274,6 +281,7 @@ static void box_shadow_cb(lv_obj_t * parent)
     }
 }
 
+LV_FUNC_SECTION
 static lv_obj_t * text_obj_create(lv_obj_t * parent, int32_t col, int32_t row)
 {
 
@@ -287,6 +295,7 @@ static lv_obj_t * text_obj_create(lv_obj_t * parent, int32_t col, int32_t row)
 
 }
 
+__attribute__(( fptrgroup("lv_scene_create_cb") ))
 static void text_cb(lv_obj_t * parent)
 {
     lv_obj_t * obj;
@@ -312,6 +321,7 @@ static void text_cb(lv_obj_t * parent)
 
 }
 
+LV_FUNC_SECTION
 static lv_obj_t * image_obj_create(lv_obj_t * parent, int32_t col, int32_t row, bool recolor)
 {
     lv_obj_t * obj = lv_image_create(parent);
@@ -328,6 +338,7 @@ static lv_obj_t * image_obj_create(lv_obj_t * parent, int32_t col, int32_t row,
 
 }
 
+LV_FUNC_SECTION
 static void image_core_cb(lv_obj_t * parent, bool recolor, uint32_t startAt)
 {
     LV_IMAGE_DECLARE(img_render_lvgl_logo_xrgb8888);
@@ -402,26 +413,31 @@ static void image_core_cb(lv_obj_t * parent, bool recolor, uint32_t startAt)
     }
 }
 
+__attribute__(( fptrgroup("lv_scene_create_cb") ))
 static void image_normal_1_cb(lv_obj_t * parent)
 {
     image_core_cb(parent, false, 0);
 }
 
+__attribute__(( fptrgroup("lv_scene_create_cb") ))
 static void image_recolored_1_cb(lv_obj_t * parent)
 {
     image_core_cb(parent, true, 0);
 }
 
+__attribute__(( fptrgroup("lv_scene_create_cb") ))
 static void image_normal_2_cb(lv_obj_t * parent)
 {
     image_core_cb(parent, false, 4);
 }
 
+__attribute__(( fptrgroup("lv_scene_create_cb") ))
 static void image_recolored_2_cb(lv_obj_t * parent)
 {
     image_core_cb(parent, true, 4);
 }
 
+LV_FUNC_SECTION
 static lv_obj_t * line_obj_create(lv_obj_t * parent, int32_t col, int32_t row, lv_point_precise_t p[])
 {
     lv_obj_t * obj = lv_line_create(parent);
@@ -435,6 +451,7 @@ static lv_obj_t * line_obj_create(lv_obj_t * parent, int32_t col, int32_t row, l
     return obj;
 }
 
+__attribute__(( fptrgroup("lv_scene_create_cb") ))
 static void line_cb(lv_obj_t * parent)
 {
 
@@ -465,6 +482,7 @@ static void line_cb(lv_obj_t * parent)
     }
 }
 
+LV_FUNC_SECTION
 static lv_obj_t * arc_obj_create(lv_obj_t * parent, int32_t col, int32_t row, int32_t w,
                                  lv_value_precise_t start, lv_value_precise_t end)
 {
@@ -481,6 +499,7 @@ static lv_obj_t * arc_obj_create(lv_obj_t * parent, int32_t col, int32_t row, in
     return obj;
 }
 
+LV_FUNC_SECTION
 static void arc_core_cb(lv_obj_t * parent, const void * img_src)
 {
     static lv_value_precise_t angles[][2] = {
@@ -510,17 +529,20 @@ static void arc_core_cb(lv_obj_t * parent, const void * img_src)
     }
 }
 
+__attribute__(( fptrgroup("lv_scene_create_cb") ))
 static void arc_normal_cb(lv_obj_t * parent)
 {
     arc_core_cb(parent, NULL);
 }
 
+__attribute__(( fptrgroup("lv_scene_create_cb") ))
 static void arc_image_cb(lv_obj_t * parent)
 {
     LV_IMAGE_DECLARE(img_render_arc_bg);
     arc_core_cb(parent, &img_render_arc_bg);
 }
 
+LV_FUNC_SECTION
 static void triangle_draw_event_cb(lv_event_t * e)
 {
     lv_draw_triangle_dsc_t dsc;
@@ -555,6 +577,7 @@ static void triangle_draw_event_cb(lv_event_t * e)
     lv_draw_triangle(lv_event_get_layer(e), &dsc);
 }
 
+LV_FUNC_SECTION
 static lv_obj_t * triangle_obj_create(lv_obj_t * parent, int32_t col, int32_t row, lv_point_t p[])
 {
     lv_obj_t * obj = lv_arc_create(parent);
@@ -568,6 +591,7 @@ static lv_obj_t * triangle_obj_create(lv_obj_t * parent, int32_t col, int32_t ro
     return obj;
 }
 
+__attribute__(( fptrgroup("lv_scene_create_cb") ))
 static void triangle_cb(lv_obj_t * parent)
 {
     static lv_point_t points[16][3] = {
@@ -629,6 +653,7 @@ static void triangle_cb(lv_obj_t * parent)
     }
 }
 
+LV_FUNC_SECTION
 static lv_obj_t * layer_obj_create(lv_obj_t * parent, int32_t col, int32_t row, lv_blend_mode_t blend_mode)
 {
     lv_obj_t * obj = lv_obj_create(parent);
@@ -653,6 +678,7 @@ static lv_obj_t * layer_obj_create(lv_obj_t * parent, int32_t col, int32_t row,
     return obj;
 }
 
+LV_FUNC_SECTION
 static void layer_core_cb(lv_obj_t * parent, lv_blend_mode_t blend_mode)
 {
 
@@ -710,11 +736,13 @@ static void layer_core_cb(lv_obj_t * parent, lv_blend_mode_t blend_mode)
     }
 }
 
+__attribute__(( fptrgroup("lv_scene_create_cb") ))
 static void layer_normal_cb(lv_obj_t * parent)
 {
     layer_core_cb(parent, LV_BLEND_MODE_NORMAL);
 }
 
+LV_FUNC_SECTION
 static void create_blend_mode_image_buffer(lv_obj_t * canvas)
 {
     lv_canvas_fill_bg(canvas, lv_color_hex3(0x844), LV_OPA_COVER);
@@ -754,6 +782,7 @@ static void create_blend_mode_image_buffer(lv_obj_t * canvas)
     lv_canvas_finish_layer(canvas, &layer);
 }
 
+LV_FUNC_SECTION
 static lv_obj_t * create_blend_mode_obj(lv_obj_t * parent, int32_t col, int32_t row, const void * src,
                                         lv_blend_mode_t blend_mode)
 {
@@ -768,6 +797,7 @@ static lv_obj_t * create_blend_mode_obj(lv_obj_t * parent, int32_t col, int32_t
     return obj;
 }
 
+__attribute__(( fptrgroup("lv_scene_create_cb") ))
 static void blend_mode_cb(lv_obj_t * parent)
 {
 
@@ -840,6 +870,7 @@ static void blend_mode_cb(lv_obj_t * parent)
 
 #if LV_USE_DRAW_SW_COMPLEX_GRADIENTS
 
+LV_FUNC_SECTION
 static lv_obj_t * create_linear_gradient_obj(lv_obj_t * parent, int32_t col, int32_t row, lv_grad_dsc_t * grad,
                                              int32_t x1, int32_t y1, lv_grad_extend_t extend, bool use_opa_map, int32_t radius)
 {
@@ -879,6 +910,7 @@ static lv_obj_t * create_linear_gradient_obj(lv_obj_t * parent, int32_t col, int
     return obj;
 }
 
+__attribute__(( fptrgroup("lv_scene_create_cb") ))
 static void linear_gradient_cb(lv_obj_t * parent)
 {
     static const int32_t grid_cols[] = { 53, 53, 53, 53, 53, 53, 53, 53, 53, LV_GRID_TEMPLATE_LAST };
@@ -916,6 +948,7 @@ static void linear_gradient_cb(lv_obj_t * parent)
     }
 }
 
+LV_FUNC_SECTION
 static lv_obj_t * create_radial_gradient_obj(lv_obj_t * parent, int32_t col, int32_t row, lv_grad_dsc_t * grad,
                                              int32_t offs, int32_t r0, lv_grad_extend_t extend, bool use_opa_map, int32_t radius)
 {
@@ -959,6 +992,7 @@ static lv_obj_t * create_radial_gradient_obj(lv_obj_t * parent, int32_t col, int
     return obj;
 }
 
+__attribute__(( fptrgroup("lv_scene_create_cb") ))
 static void radial_gradient_cb(lv_obj_t * parent)
 {
     static const int32_t grid_cols[] = { 53, 53, 53, 53, 53, 53, 53, 53, 53, LV_GRID_TEMPLATE_LAST };
@@ -994,6 +1028,7 @@ static void radial_gradient_cb(lv_obj_t * parent)
     }
 }
 
+LV_FUNC_SECTION
 static lv_obj_t * create_conical_gradient_obj(lv_obj_t * parent, int32_t col, int32_t row, lv_grad_dsc_t * grad,
                                               int32_t a0, int32_t a1, lv_grad_extend_t extend, bool use_opa_map, int32_t radius)
 {
@@ -1033,6 +1068,7 @@ static lv_obj_t * create_conical_gradient_obj(lv_obj_t * parent, int32_t col, in
     return obj;
 }
 
+__attribute__(( fptrgroup("lv_scene_create_cb") ))
 static void conical_gradient_cb(lv_obj_t * parent)
 {
     static const int32_t grid_cols[] = { 53, 53, 53, 53, 53, 53, 53, 53, 53, LV_GRID_TEMPLATE_LAST };
@@ -1107,6 +1143,7 @@ static scene_dsc_t scenes[] = {
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 void lv_demo_render(lv_demo_render_scene_t id, lv_opa_t opa)
 {
     lv_obj_t * scr = lv_screen_active();
@@ -1131,6 +1168,7 @@ void lv_demo_render(lv_demo_render_scene_t id, lv_opa_t opa)
     if(scenes[id].create_cb) scenes[id].create_cb(main_parent);
 }
 
+LV_FUNC_SECTION
 const char * lv_demo_render_get_scene_name(lv_demo_render_scene_t id)
 {
     if(id > LV_DEMO_RENDER_SCENE_NUM) return NULL;
@@ -1141,6 +1179,7 @@ const char * lv_demo_render_get_scene_name(lv_demo_render_scene_t id)
  *   STATIC FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 static void add_to_cell(lv_obj_t * obj, int32_t col, int32_t row)
 {
     lv_obj_set_grid_cell(obj, LV_GRID_ALIGN_CENTER, col, 1, LV_GRID_ALIGN_CENTER, row, 1);
diff --git a/demos/scroll/lv_demo_scroll.c b/demos/scroll/lv_demo_scroll.c
index 170b0c1e0..2a3cab290 100644
--- a/demos/scroll/lv_demo_scroll.c
+++ b/demos/scroll/lv_demo_scroll.c
@@ -35,6 +35,7 @@ static lv_obj_t * list;
 /**********************
  *   GLOBAL FUNCTIONS
  **********************/
+__attribute__(( fptrgroup("lv_demo_entry_cb") ))
 void lv_demo_scroll(void)
 {
     lv_obj_t * panel = lv_obj_create(lv_screen_active());
@@ -74,6 +75,7 @@ void lv_demo_scroll(void)
  *   STATIC FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 static lv_obj_t * switch_create(lv_obj_t * parent, const char * title, lv_obj_flag_t flag, bool en)
 {
     lv_obj_t * cont = lv_obj_create(parent);
@@ -100,6 +102,7 @@ static lv_obj_t * switch_create(lv_obj_t * parent, const char * title, lv_obj_fl
     return cont;
 }
 
+LV_FUNC_SECTION
 static void generic_switch_event_cb(lv_event_t * e)
 {
     lv_obj_t * sw = lv_event_get_target(e);
diff --git a/demos/stress/lv_demo_stress.c b/demos/stress/lv_demo_stress.c
index 0b01fec79..25876e469 100644
--- a/demos/stress/lv_demo_stress.c
+++ b/demos/stress/lv_demo_stress.c
@@ -42,7 +42,7 @@ static int16_t g_state = -1;
 /**********************
  *   GLOBAL FUNCTIONS
  **********************/
-
+__attribute__(( fptrgroup("lv_demo_entry_cb") ))
 void lv_demo_stress(void)
 {
     LV_LOG_USER("Starting stress test. (< 100 bytes permanent memory leak is normal due to fragmentation)");
@@ -50,6 +50,7 @@ void lv_demo_stress(void)
     lv_timer_ready(t); /*Prepare the test right now in first state change.*/
 }
 
+LV_FUNC_SECTION
 bool lv_demo_stress_finished(void)
 {
     return g_state == -1;
@@ -59,6 +60,7 @@ bool lv_demo_stress_finished(void)
  *   STATIC FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 static void obj_test_task_cb(lv_timer_t * tmr)
 {
     (void) tmr;    /*Unused*/
@@ -425,6 +427,7 @@ static void obj_test_task_cb(lv_timer_t * tmr)
     g_state++;
 }
 
+LV_FUNC_SECTION
 static void auto_delete(lv_obj_t * obj, uint32_t delay)
 {
     lv_anim_t a;
@@ -436,21 +439,25 @@ static void auto_delete(lv_obj_t * obj, uint32_t delay)
     lv_anim_start(&a);
 }
 
+LV_FUNC_SECTION
 static void msgbox_delete(lv_timer_t * tmr)
 {
     lv_msgbox_close(lv_timer_get_user_data(tmr));
 }
 
+LV_FUNC_SECTION
 static void set_y_anim(void * obj, int32_t v)
 {
     lv_obj_set_y(obj, v);
 }
 
+LV_FUNC_SECTION
 static void set_width_anim(void * obj, int32_t v)
 {
     lv_obj_set_width(obj, v);
 }
 
+LV_FUNC_SECTION
 static void arc_set_end_angle_anim(void * obj, int32_t v)
 {
     lv_arc_set_end_angle(obj, v);
diff --git a/demos/transform/lv_demo_transform.c b/demos/transform/lv_demo_transform.c
index 4ecce6d65..5761807d2 100644
--- a/demos/transform/lv_demo_transform.c
+++ b/demos/transform/lv_demo_transform.c
@@ -46,6 +46,7 @@ LV_IMAGE_DECLARE(img_transform_avatar_15);
 /**********************
  *   GLOBAL FUNCTIONS
  **********************/
+__attribute__(( fptrgroup("lv_demo_entry_cb") ))
 void lv_demo_transform(void)
 {
     static const int32_t grid_cols[] = {LV_GRID_CONTENT, 4, LV_GRID_FR(1), LV_GRID_TEMPLATE_LAST};
@@ -108,6 +109,7 @@ void lv_demo_transform(void)
  *   STATIC FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 static lv_obj_t * card_create(void)
 {
     lv_obj_t * card = lv_obj_create(lv_screen_active());
@@ -143,6 +145,7 @@ static lv_obj_t * card_create(void)
     return card;
 }
 
+LV_FUNC_SECTION
 static void arc_event_cb(lv_event_t * e)
 {
     lv_obj_t * arc = lv_event_get_target(e);
@@ -151,6 +154,7 @@ static void arc_event_cb(lv_event_t * e)
     lv_obj_set_style_transform_rotation(card_to_transform, v * 10, 0);
 }
 
+LV_FUNC_SECTION
 static void slider_event_cb(lv_event_t * e)
 {
     lv_obj_t * slider = lv_event_get_target(e);
diff --git a/demos/vector_graphic/lv_demo_vector_graphic.c b/demos/vector_graphic/lv_demo_vector_graphic.c
index 38729da05..855330edd 100644
--- a/demos/vector_graphic/lv_demo_vector_graphic.c
+++ b/demos/vector_graphic/lv_demo_vector_graphic.c
@@ -23,6 +23,7 @@
 /**********************
  *  STATIC PROTOTYPES
  **********************/
+LV_FUNC_SECTION
 static void draw_pattern(lv_vector_dsc_t * ctx, lv_vector_path_t * path)
 {
     lv_vector_path_clear(path);
@@ -48,6 +49,7 @@ static void draw_pattern(lv_vector_dsc_t * ctx, lv_vector_path_t * path)
     lv_vector_dsc_add_path(ctx, path); // draw a path
 }
 
+LV_FUNC_SECTION
 static void draw_gradient(lv_vector_dsc_t * ctx, lv_vector_path_t * path)
 {
     lv_vector_path_clear(path);
@@ -78,6 +80,7 @@ static void draw_gradient(lv_vector_dsc_t * ctx, lv_vector_path_t * path)
     lv_vector_dsc_add_path(ctx, path); // draw a path
 }
 
+LV_FUNC_SECTION
 static void draw_radial_gradient(lv_vector_dsc_t * ctx, lv_vector_path_t * path)
 {
     lv_vector_path_clear(path);
@@ -105,6 +108,7 @@ static void draw_radial_gradient(lv_vector_dsc_t * ctx, lv_vector_path_t * path)
     lv_vector_dsc_add_path(ctx, path); // draw a path
 }
 
+LV_FUNC_SECTION
 static void draw_shapes(lv_vector_dsc_t * ctx, lv_vector_path_t * path)
 {
     lv_vector_path_clear(path);
@@ -145,6 +149,7 @@ static void draw_shapes(lv_vector_dsc_t * ctx, lv_vector_path_t * path)
     lv_vector_path_delete(path2);
 }
 
+LV_FUNC_SECTION
 static void draw_lines(lv_vector_dsc_t * ctx, lv_vector_path_t * path)
 {
     lv_vector_path_clear(path);
@@ -169,6 +174,7 @@ static void draw_lines(lv_vector_dsc_t * ctx, lv_vector_path_t * path)
     lv_vector_dsc_set_fill_opa(ctx, LV_OPA_COVER);
 }
 
+LV_FUNC_SECTION
 static void draw_blend(lv_vector_dsc_t * ctx, lv_vector_path_t * path)
 {
     lv_vector_path_clear(path);
@@ -185,6 +191,7 @@ static void draw_blend(lv_vector_dsc_t * ctx, lv_vector_path_t * path)
     lv_vector_dsc_add_path(ctx, path); // draw a path
 }
 
+LV_FUNC_SECTION
 static void draw_arc(lv_vector_dsc_t * ctx, lv_vector_path_t * path)
 {
     lv_vector_path_clear(path);
@@ -216,6 +223,7 @@ static void draw_arc(lv_vector_dsc_t * ctx, lv_vector_path_t * path)
     lv_vector_dsc_add_path(ctx, path); // draw a path
 }
 
+LV_FUNC_SECTION
 static void draw_vector(lv_layer_t * layer)
 {
     lv_vector_dsc_t * ctx = lv_vector_dsc_create(layer);
@@ -238,6 +246,7 @@ static void draw_vector(lv_layer_t * layer)
     lv_vector_dsc_delete(ctx);
 }
 
+LV_FUNC_SECTION
 static void delete_event_cb(lv_event_t * e)
 {
     lv_obj_t * obj = lv_event_get_target(e);
@@ -245,6 +254,7 @@ static void delete_event_cb(lv_event_t * e)
     lv_draw_buf_destroy(draw_buf);
 }
 
+LV_FUNC_SECTION
 static void event_cb(lv_event_t * e)
 {
     lv_layer_t * layer = lv_event_get_layer(e);
@@ -263,12 +273,13 @@ static void event_cb(lv_event_t * e)
 /**********************
  *   GLOBAL FUNCTIONS
  **********************/
-
+__attribute__(( fptrgroup("lv_demo_entry_cb") ))
 void lv_demo_vector_graphic_not_buffered(void)
 {
     lv_obj_add_event_cb(lv_screen_active(), event_cb, LV_EVENT_DRAW_MAIN, NULL);
 }
 
+__attribute__(( fptrgroup("lv_demo_entry_cb") ))
 void lv_demo_vector_graphic_buffered(void)
 {
     lv_draw_buf_t * draw_buf = lv_draw_buf_create(WIDTH, HEIGHT, LV_COLOR_FORMAT_ARGB8888, LV_STRIDE_AUTO);
@@ -290,6 +301,7 @@ void lv_demo_vector_graphic_buffered(void)
  **********************/
 #else
 
+__attribute__(( fptrgroup("lv_demo_entry_cb") ))
 void lv_demo_vector_graphic_not_buffered(void)
 {
     /*fallback for online examples*/
@@ -298,6 +310,7 @@ void lv_demo_vector_graphic_not_buffered(void)
     lv_obj_center(label);
 }
 
+__attribute__(( fptrgroup("lv_demo_entry_cb") ))
 void lv_demo_vector_graphic_buffered(void)
 {
     /*fallback for online examples*/
diff --git a/demos/widgets/lv_demo_widgets.c b/demos/widgets/lv_demo_widgets.c
index 21a366d83..cf2716c08 100644
--- a/demos/widgets/lv_demo_widgets.c
+++ b/demos/widgets/lv_demo_widgets.c
@@ -111,7 +111,7 @@ static lv_obj_t * scale3_mbps_label;
 /**********************
  *   GLOBAL FUNCTIONS
  **********************/
-
+__attribute__(( fptrgroup("lv_demo_entry_cb") ))
 void lv_demo_widgets(void)
 {
     if(LV_HOR_RES <= 320) disp_size = DISP_SMALL;
@@ -220,6 +220,7 @@ void lv_demo_widgets(void)
     color_changer_create(tv);
 }
 
+LV_FUNC_SECTION
 void lv_demo_widgets_start_slideshow(void)
 {
     lv_obj_update_layout(tv);
@@ -245,6 +246,7 @@ void lv_demo_widgets_start_slideshow(void)
  *   STATIC FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 static void profile_create(lv_obj_t * parent)
 {
     lv_obj_t * panel1 = lv_obj_create(parent);
@@ -566,6 +568,7 @@ static void profile_create(lv_obj_t * parent)
     }
 }
 
+LV_FUNC_SECTION
 static lv_obj_t * create_chart_with_scales(lv_obj_t * parent, const char * title,  const char * hor_text[])
 {
     static const int32_t col_dsc[] = {40, LV_GRID_FR(1), LV_GRID_TEMPLATE_LAST};
@@ -617,6 +620,7 @@ static lv_obj_t * create_chart_with_scales(lv_obj_t * parent, const char * title
     return chart;
 }
 
+LV_FUNC_SECTION
 static void analytics_create(lv_obj_t * parent)
 {
     lv_obj_set_flex_flow(parent, LV_FLEX_FLOW_ROW);
@@ -872,6 +876,7 @@ static void analytics_create(lv_obj_t * parent)
     lv_obj_add_event_cb(scale3, scale3_size_changed_event_cb, LV_EVENT_SIZE_CHANGED, NULL);
 }
 
+LV_FUNC_SECTION
 void shop_create(lv_obj_t * parent)
 {
     lv_obj_set_flex_flow(parent, LV_FLEX_FLOW_ROW_WRAP);
@@ -1044,6 +1049,7 @@ void shop_create(lv_obj_t * parent)
 
 }
 
+LV_FUNC_SECTION
 static void color_changer_create(lv_obj_t * parent)
 {
     static lv_palette_t palette[] = {
@@ -1097,6 +1103,7 @@ static void color_changer_create(lv_obj_t * parent)
     }
 }
 
+LV_FUNC_SECTION
 static void color_changer_anim_cb(void * var, int32_t v)
 {
     lv_obj_t * obj = var;
@@ -1123,6 +1130,7 @@ static void color_changer_anim_cb(void * var, int32_t v)
 
 }
 
+LV_FUNC_SECTION
 static void color_changer_event_cb(lv_event_t * e)
 {
     if(lv_event_get_code(e) == LV_EVENT_CLICKED) {
@@ -1147,6 +1155,7 @@ static void color_changer_event_cb(lv_event_t * e)
         }
     }
 }
+LV_FUNC_SECTION
 static void color_event_cb(lv_event_t * e)
 {
     lv_event_code_t code = lv_event_get_code(e);
@@ -1179,6 +1188,7 @@ static void color_event_cb(lv_event_t * e)
     }
 }
 
+LV_FUNC_SECTION
 static lv_obj_t * create_scale_box(lv_obj_t * parent, const char * title, const char * text1, const char * text2,
                                    const char * text3)
 {
@@ -1249,6 +1259,7 @@ static lv_obj_t * create_scale_box(lv_obj_t * parent, const char * title, const
     return scale;
 }
 
+LV_FUNC_SECTION
 static lv_obj_t * create_shop_item(lv_obj_t * parent, const void * img_src, const char * name, const char * category,
                                    const char * price)
 {
@@ -1281,6 +1292,7 @@ static lv_obj_t * create_shop_item(lv_obj_t * parent, const void * img_src, cons
     return cont;
 }
 
+__attribute__(( fptrgroup("lv_event_cb") ))
 static void ta_event_cb(lv_event_t * e)
 {
     lv_event_code_t code = lv_event_get_code(e);
@@ -1311,6 +1323,7 @@ static void ta_event_cb(lv_event_t * e)
     }
 }
 
+LV_FUNC_SECTION
 static void birthday_event_cb(lv_event_t * e)
 {
     lv_event_code_t code = lv_event_get_code(e);
@@ -1336,6 +1349,7 @@ static void birthday_event_cb(lv_event_t * e)
     }
 }
 
+LV_FUNC_SECTION
 static void calendar_event_cb(lv_event_t * e)
 {
     lv_event_code_t code = lv_event_get_code(e);
@@ -1355,6 +1369,7 @@ static void calendar_event_cb(lv_event_t * e)
     }
 }
 
+LV_FUNC_SECTION
 static void slider_event_cb(lv_event_t * e)
 {
     lv_event_code_t code = lv_event_get_code(e);
@@ -1407,6 +1422,7 @@ static void slider_event_cb(lv_event_t * e)
     }
 }
 
+LV_FUNC_SECTION
 static void chart_event_cb(lv_event_t * e)
 {
     lv_event_code_t code = lv_event_get_code(e);
@@ -1544,11 +1560,13 @@ static void chart_event_cb(lv_event_t * e)
     }
 }
 
+LV_FUNC_SECTION
 static void shop_chart_event_cb(lv_event_t * e)
 {
     LV_UNUSED(e);
 }
 
+LV_FUNC_SECTION
 static void scale1_indic1_anim_cb(void * var, int32_t v)
 {
     lv_arc_set_value(var, v);
@@ -1558,6 +1576,7 @@ static void scale1_indic1_anim_cb(void * var, int32_t v)
     lv_label_set_text_fmt(label, "Revenue: %"LV_PRId32" %%", v);
 }
 
+LV_FUNC_SECTION
 static void scale2_timer_cb(lv_timer_t * timer)
 {
     LV_UNUSED(timer);
@@ -1614,6 +1633,7 @@ static void scale2_timer_cb(lv_timer_t * timer)
     lv_label_set_text_fmt(label, "Mobile: %"LV_PRIu32, session_mobile);
 }
 
+LV_FUNC_SECTION
 static void scale3_anim_cb(void * var, int32_t v)
 {
     lv_obj_t * needle = lv_obj_get_child(var, 0);
@@ -1623,6 +1643,7 @@ static void scale3_anim_cb(void * var, int32_t v)
     lv_label_set_text_fmt(label, "%"LV_PRId32, v);
 }
 
+LV_FUNC_SECTION
 static void scale3_size_changed_event_cb(lv_event_t * e)
 {
     LV_UNUSED(e);
@@ -1640,11 +1661,13 @@ static void scale3_size_changed_event_cb(lv_event_t * e)
     lv_obj_align(scale3_mbps_label, LV_ALIGN_TOP_LEFT, minor_dim_half, minor_dim * 55 / 100);
 }
 
+LV_FUNC_SECTION
 static void scroll_anim_y_cb(void * var, int32_t v)
 {
     lv_obj_scroll_to_y(var, v, LV_ANIM_OFF);
 }
 
+LV_FUNC_SECTION
 static void delete_timer_event_cb(lv_event_t * e)
 {
     lv_event_code_t code = lv_event_get_code(e);
@@ -1654,6 +1677,7 @@ static void delete_timer_event_cb(lv_event_t * e)
     }
 }
 
+LV_FUNC_SECTION
 static void slideshow_anim_completed_cb(lv_anim_t * a_old)
 {
     LV_UNUSED(a_old);
@@ -1682,6 +1706,7 @@ static void slideshow_anim_completed_cb(lv_anim_t * a_old)
     lv_anim_start(&a);
 }
 
+LV_FUNC_SECTION
 static void scale3_delete_event_cb(lv_event_t * e)
 {
     lv_event_code_t code = lv_event_get_code(e);
@@ -1699,6 +1724,7 @@ static void scale3_delete_event_cb(lv_event_t * e)
     }
 }
 
+LV_FUNC_SECTION
 static void tabview_delete_event_cb(lv_event_t * e)
 {
     lv_event_code_t code = lv_event_get_code(e);
diff --git a/env_support/pikascript/pika_lv_point_t.c b/env_support/pikascript/pika_lv_point_t.c
index 7fe31cbe2..3f16c3cc9 100644
--- a/env_support/pikascript/pika_lv_point_t.c
+++ b/env_support/pikascript/pika_lv_point_t.c
@@ -8,6 +8,7 @@
 
 #include "pika_lvgl_point_t.h"
 
+LV_FUNC_SECTION
 void pika_lvgl_point_t___init__(PikaObj* self) {
     lv_point_t lv_point = {0};
     args_setStruct(self->list, "lv_point_struct", lv_point);
diff --git a/env_support/pikascript/pika_lv_timer_t.c b/env_support/pikascript/pika_lv_timer_t.c
index cea970c37..115c9c475 100644
--- a/env_support/pikascript/pika_lv_timer_t.c
+++ b/env_support/pikascript/pika_lv_timer_t.c
@@ -10,6 +10,7 @@
 
 PikaEventListener* g_pika_lv_timer_event_listener;
 
+LV_FUNC_SECTION
 void __pika_timer_cb(lv_timer_t* timer) {
     PikaObj* eventHandleObj = pks_eventListener_getEventHandleObj(
         g_pika_lv_timer_event_listener, (uint32_t)timer);
@@ -18,11 +19,13 @@ void __pika_timer_cb(lv_timer_t* timer) {
     obj_run(eventHandleObj, "eventCallBack(timer)");
 }
 
+LV_FUNC_SECTION
 void pika_lvgl_lv_timer_t_set_period(PikaObj* self, int period) {
     lv_timer_t* lv_timer = obj_getPtr(self, "lv_timer");
     lv_timer_set_period(lv_timer, period);
 }
 
+LV_FUNC_SECTION
 void pika_lvgl_lv_timer_t_set_cb(PikaObj* self, Arg* cb) {
     lv_timer_t* lv_timer = obj_getPtr(self, "lv_timer");
     lv_timer_set_cb(lv_timer, __pika_timer_cb);
@@ -37,6 +40,7 @@ void pika_lvgl_lv_timer_t_set_cb(PikaObj* self, Arg* cb) {
 
 }
 
+LV_FUNC_SECTION
 void pika_lvgl_lv_timer_t__delete(PikaObj* self) {
     lv_timer_t* lv_timer = obj_getPtr(self, "lv_timer");
     lv_timer_delete(lv_timer);
diff --git a/env_support/pikascript/pika_lv_wegit.c b/env_support/pikascript/pika_lv_wegit.c
index 122347cf5..56f215839 100644
--- a/env_support/pikascript/pika_lv_wegit.c
+++ b/env_support/pikascript/pika_lv_wegit.c
@@ -20,6 +20,7 @@
 #include "pika_lvgl_table.h"
 #include "pika_lvgl_textarea.h"
 
+LV_FUNC_SECTION
 void pika_lvgl_arc___init__(PikaObj* self, PikaObj* parent) {
     lv_obj_t* lv_parent = obj_getPtr(parent, "lv_obj");
     lv_obj_t* lv_obj = lv_arc_create(lv_parent);
@@ -29,45 +30,55 @@ void pika_lvgl_arc___init__(PikaObj* self, PikaObj* parent) {
     obj_setInt(self, "MODE_REVERSE", LV_ARC_MODE_REVERSE);
 }
 
+LV_FUNC_SECTION
 void pika_lvgl_arc_set_end_angle(PikaObj* self, int angle) {
     lv_obj_t* lv_obj = obj_getPtr(self, "lv_obj");
     lv_arc_set_end_angle(lv_obj, angle);
 }
 
+LV_FUNC_SECTION
 void pika_lvgl_arc_set_bg_angles(PikaObj* self, int start, int end) {
     lv_obj_t* lv_obj = obj_getPtr(self, "lv_obj");
     lv_arc_set_bg_angles(lv_obj, start, end);
 }
 
+LV_FUNC_SECTION
 void pika_lvgl_arc_set_angles(PikaObj* self, int start, int end) {
     lv_obj_t* lv_obj = obj_getPtr(self, "lv_obj");
     lv_arc_set_angles(lv_obj, start, end);
 }
 
+LV_FUNC_SECTION
 int pika_lvgl_arc_get_angle_end(PikaObj *self){
     lv_obj_t* lv_obj = obj_getPtr(self, "lv_obj");
     return lv_arc_get_angle_end(lv_obj);
 }
+LV_FUNC_SECTION
 int pika_lvgl_arc_get_angle_start(PikaObj *self){
     lv_obj_t* lv_obj = obj_getPtr(self, "lv_obj");
     return lv_arc_get_angle_start(lv_obj);
 }
+LV_FUNC_SECTION
 int pika_lvgl_arc_get_bg_angle_end(PikaObj *self){
     lv_obj_t* lv_obj = obj_getPtr(self, "lv_obj");
     return lv_arc_get_bg_angle_end(lv_obj);
 }
+LV_FUNC_SECTION
 int pika_lvgl_arc_get_bg_angle_start(PikaObj *self){
     lv_obj_t* lv_obj = obj_getPtr(self, "lv_obj");
     return lv_arc_get_bg_angle_start(lv_obj);
 }
+LV_FUNC_SECTION
 int pika_lvgl_arc_get_max_value(PikaObj *self){
     lv_obj_t* lv_obj = obj_getPtr(self, "lv_obj");
     return lv_arc_get_max_value(lv_obj);
 }
+LV_FUNC_SECTION
 int pika_lvgl_arc_get_min_value(PikaObj *self){
     lv_obj_t* lv_obj = obj_getPtr(self, "lv_obj");
     return lv_arc_get_min_value(lv_obj);
 }
+LV_FUNC_SECTION
 int pika_lvgl_arc_get_mode(PikaObj *self){
     lv_obj_t* lv_obj = obj_getPtr(self, "lv_obj");
     return lv_arc_get_mode(lv_obj);
@@ -76,138 +87,168 @@ int pika_lvgl_arc_get_mode(PikaObj *self){
 //     lv_obj_t* lv_obj = obj_getPtr(self, "lv_obj");
 //     return lv_arc_get_rotation(lv_obj);
 // }
+LV_FUNC_SECTION
 int pika_lvgl_arc_get_value(PikaObj *self){
     lv_obj_t* lv_obj = obj_getPtr(self, "lv_obj");
     return lv_arc_get_value(lv_obj);
 }
+LV_FUNC_SECTION
 void pika_lvgl_arc_set_mode(PikaObj *self, int mode){
     lv_obj_t* lv_obj = obj_getPtr(self, "lv_obj");
     lv_arc_set_mode(lv_obj, mode);
 }
+LV_FUNC_SECTION
 void pika_lvgl_arc_set_range(PikaObj *self, int min, int max){
     lv_obj_t* lv_obj = obj_getPtr(self, "lv_obj");
     lv_arc_set_range(lv_obj, min, max);
 }
+LV_FUNC_SECTION
 void pika_lvgl_arc_set_rotation(PikaObj *self, int rotation){
     lv_obj_t* lv_obj = obj_getPtr(self, "lv_obj");
     lv_arc_set_rotation(lv_obj, rotation);
 }
+LV_FUNC_SECTION
 void pika_lvgl_arc_set_start_angle(PikaObj *self, int start){
     lv_obj_t* lv_obj = obj_getPtr(self, "lv_obj");
     lv_arc_set_start_angle(lv_obj, start);
 }
+LV_FUNC_SECTION
 void pika_lvgl_arc_set_value(PikaObj *self, int value){
     lv_obj_t* lv_obj = obj_getPtr(self, "lv_obj");
     lv_arc_set_value(lv_obj, value);
 }
+LV_FUNC_SECTION
 void pika_lvgl_arc_set_bg_end_angle(PikaObj *self, int angle){
     lv_obj_t* lv_obj = obj_getPtr(self, "lv_obj");
     lv_arc_set_bg_end_angle(lv_obj, angle);
 }
+LV_FUNC_SECTION
 void pika_lvgl_arc_set_bg_start_angle(PikaObj *self, int start){
     lv_obj_t* lv_obj = obj_getPtr(self, "lv_obj");
     lv_arc_set_bg_start_angle(lv_obj, start);
 }
 
+LV_FUNC_SECTION
 void pika_lvgl_arc_set_change_rate(PikaObj *self, int rate){
     lv_obj_t* lv_obj = obj_getPtr(self, "lv_obj");
     lv_arc_set_change_rate(lv_obj, rate);
 }
 
+LV_FUNC_SECTION
 void pika_lvgl_bar___init__(PikaObj* self, PikaObj* parent) {
     lv_obj_t* lv_parent = obj_getPtr(parent, "lv_obj");
     lv_obj_t* lv_obj = lv_bar_create(lv_parent);
     obj_setPtr(self, "lv_obj", lv_obj);
 }
 
+LV_FUNC_SECTION
 void pika_lvgl_bar_set_value(PikaObj* self, int value, int anim) {
     lv_obj_t* lv_obj = obj_getPtr(self, "lv_obj");
     lv_bar_set_value(lv_obj, value, value);
 }
 
+LV_FUNC_SECTION
 int pika_lvgl_bar_get_max_value(PikaObj *self){
     lv_obj_t* lv_obj = obj_getPtr(self, "lv_obj");
     return lv_bar_get_max_value(lv_obj);
 }
+LV_FUNC_SECTION
 int pika_lvgl_bar_get_min_value(PikaObj *self){
     lv_obj_t* lv_obj = obj_getPtr(self, "lv_obj");
     return lv_bar_get_min_value(lv_obj);
 }
+LV_FUNC_SECTION
 int pika_lvgl_bar_get_mode(PikaObj *self){
     lv_obj_t* lv_obj = obj_getPtr(self, "lv_obj");
     return lv_bar_get_mode(lv_obj);
 }
+LV_FUNC_SECTION
 int pika_lvgl_bar_get_start_value(PikaObj *self){
     lv_obj_t* lv_obj = obj_getPtr(self, "lv_obj");
     return lv_bar_get_start_value(lv_obj);
 }
+LV_FUNC_SECTION
 int pika_lvgl_bar_get_value(PikaObj *self){
     lv_obj_t* lv_obj = obj_getPtr(self, "lv_obj");
     return lv_bar_get_value(lv_obj);
 }
+LV_FUNC_SECTION
 void pika_lvgl_bar_set_mode(PikaObj *self, int mode){
     lv_obj_t* lv_obj = obj_getPtr(self, "lv_obj");
     lv_bar_set_mode(lv_obj, mode);
 }
+LV_FUNC_SECTION
 void pika_lvgl_bar_set_range(PikaObj *self, int min, int max){
     lv_obj_t* lv_obj = obj_getPtr(self, "lv_obj");
     lv_bar_set_range(lv_obj, min, max);
 }
+LV_FUNC_SECTION
 void pika_lvgl_bar_set_start_value(PikaObj *self, int start_value, int anim){
     lv_obj_t* lv_obj = obj_getPtr(self, "lv_obj");
     lv_bar_set_start_value(lv_obj, start_value, anim);
 }
 
+LV_FUNC_SECTION
 void pika_lvgl_btn___init__(PikaObj* self, PikaObj* parent) {
     lv_obj_t* lv_parent = obj_getPtr(parent, "lv_obj");
     lv_obj_t* lv_obj = lv_button_create(lv_parent);
     obj_setPtr(self, "lv_obj", lv_obj);
 }
 
+LV_FUNC_SECTION
 void pika_lvgl_checkbox___init__(PikaObj* self, PikaObj* parent) {
     lv_obj_t* lv_parent = obj_getPtr(parent, "lv_obj");
     lv_obj_t* lv_obj = lv_checkbox_create(lv_parent);
     obj_setPtr(self, "lv_obj", lv_obj);
 }
 
+LV_FUNC_SECTION
 void pika_lvgl_checkbox_set_text(PikaObj* self, char* txt) {
     lv_obj_t* lv_obj = obj_getPtr(self, "lv_obj");
     lv_checkbox_set_text(lv_obj, txt);
 }
 
+LV_FUNC_SECTION
 void pika_lvgl_checkbox_set_text_static(PikaObj *self, char* txt){
     lv_obj_t* lv_obj = obj_getPtr(self, "lv_obj");
     lv_checkbox_set_text_static(lv_obj, txt);
 }
 
+LV_FUNC_SECTION
 char* pika_lvgl_checkbox_get_text(PikaObj *self){
     lv_obj_t* lv_obj = obj_getPtr(self, "lv_obj");
     return (char*) lv_checkbox_get_text(lv_obj);
 }
 
+LV_FUNC_SECTION
 void pika_lvgl_dropdown___init__(PikaObj* self, PikaObj* parent) {
     lv_obj_t* lv_parent = obj_getPtr(parent, "lv_obj");
     lv_obj_t* lv_obj = lv_dropdown_create(lv_parent);
     obj_setPtr(self, "lv_obj", lv_obj);
 }
 
+LV_FUNC_SECTION
 void pika_lvgl_dropdown_set_options(PikaObj* self, char* options) {
     lv_obj_t* lv_obj = obj_getPtr(self, "lv_obj");
     lv_dropdown_set_options(lv_obj, options);
 }
 
+LV_FUNC_SECTION
 void pika_lvgl_dropdown_add_option(PikaObj *self, char* options, int pos){
     lv_obj_t* lv_obj = obj_getPtr(self, "lv_obj");
     lv_dropdown_add_option(lv_obj, options, pos);
 }
+LV_FUNC_SECTION
 void pika_lvgl_dropdown_clear_options(PikaObj *self){
     lv_obj_t* lv_obj = obj_getPtr(self, "lv_obj");
     lv_dropdown_clear_options(lv_obj);
 }
+LV_FUNC_SECTION
 void pika_lvgl_dropdown_close(PikaObj *self){
     lv_obj_t* lv_obj = obj_getPtr(self, "lv_obj");
     lv_dropdown_close(lv_obj);
 }
+LV_FUNC_SECTION
 int pika_lvgl_dropdown_get_dir(PikaObj *self){
     lv_obj_t* lv_obj = obj_getPtr(self, "lv_obj");
     return lv_dropdown_get_dir(lv_obj);
@@ -216,27 +257,33 @@ int pika_lvgl_dropdown_get_dir(PikaObj *self){
 //     lv_obj_t* lv_obj = obj_getPtr(self, "lv_obj");
 //     return obj_getObj(lv_dropdown_get_list(lv_obj));
 // }
+LV_FUNC_SECTION
 int pika_lvgl_dropdown_get_option_count(PikaObj *self){
     lv_obj_t* lv_obj = obj_getPtr(self, "lv_obj");
     return lv_dropdown_get_option_count(lv_obj);
 }
+LV_FUNC_SECTION
 int pika_lvgl_dropdown_get_option_index(PikaObj *self, char* txt){
     lv_obj_t* lv_obj = obj_getPtr(self, "lv_obj");
     return lv_dropdown_get_option_index(lv_obj, txt);
 }
+LV_FUNC_SECTION
 char* pika_lvgl_dropdown_get_options(PikaObj *self){
     lv_obj_t* lv_obj = obj_getPtr(self, "lv_obj");
     return (char*) lv_dropdown_get_options(lv_obj);
 }
+LV_FUNC_SECTION
 int pika_lvgl_dropdown_get_selected(PikaObj *self){
     lv_obj_t* lv_obj = obj_getPtr(self, "lv_obj");
     return lv_dropdown_get_selected(lv_obj);
 }
+LV_FUNC_SECTION
 int pika_lvgl_dropdown_get_selected_highlight(PikaObj *self){
     lv_obj_t* lv_obj = obj_getPtr(self, "lv_obj");
     return lv_dropdown_get_selected_highlight(lv_obj);
 }
 
+LV_FUNC_SECTION
 char* pika_lvgl_dropdown_get_selected_str(PikaObj *self){
     lv_obj_t* lv_obj = obj_getPtr(self, "lv_obj");
     obj_setBytes(self, "_buff",NULL, 128);
@@ -244,64 +291,78 @@ char* pika_lvgl_dropdown_get_selected_str(PikaObj *self){
     lv_dropdown_get_selected_str(lv_obj, _buff, 128);
     return _buff;
 }
+LV_FUNC_SECTION
 char* pika_lvgl_dropdown_get_symbol(PikaObj *self){
     lv_obj_t* lv_obj = obj_getPtr(self, "lv_obj");
     return (char*)lv_dropdown_get_symbol(lv_obj);
 }
+LV_FUNC_SECTION
 char* pika_lvgl_dropdown_get_text(PikaObj *self){
     lv_obj_t* lv_obj = obj_getPtr(self, "lv_obj");
     return (char*)lv_dropdown_get_text(lv_obj);
 }
+LV_FUNC_SECTION
 int pika_lvgl_dropdown_is_open(PikaObj *self){
     lv_obj_t* lv_obj = obj_getPtr(self, "lv_obj");
     return lv_dropdown_is_open(lv_obj);
 }
+LV_FUNC_SECTION
 void pika_lvgl_dropdown_open(PikaObj *self){
     lv_obj_t* lv_obj = obj_getPtr(self, "lv_obj");
     lv_dropdown_open(lv_obj);
 }
+LV_FUNC_SECTION
 void pika_lvgl_dropdown_set_dir(PikaObj *self, int dir){
     lv_obj_t* lv_obj = obj_getPtr(self, "lv_obj");
     lv_dropdown_set_dir(lv_obj, dir);
 }
+LV_FUNC_SECTION
 void pika_lvgl_dropdown_set_selected(PikaObj *self, int sel_opt){
     lv_obj_t* lv_obj = obj_getPtr(self, "lv_obj");
     lv_dropdown_set_selected(lv_obj, sel_opt);
 }
+LV_FUNC_SECTION
 void pika_lvgl_dropdown_set_selected_highlight(PikaObj *self, int en){
     lv_obj_t* lv_obj = obj_getPtr(self, "lv_obj");
     lv_dropdown_set_selected_highlight(lv_obj, en);
 }
+LV_FUNC_SECTION
 void pika_lvgl_dropdown_set_symbol(PikaObj *self, char* symbol){
     lv_obj_t* lv_obj = obj_getPtr(self, "lv_obj");
     lv_dropdown_set_symbol(lv_obj, symbol);
 }
+LV_FUNC_SECTION
 void pika_lvgl_dropdown_set_text(PikaObj *self, char* txt){
     lv_obj_t* lv_obj = obj_getPtr(self, "lv_obj");
     lv_dropdown_set_text(lv_obj, txt);
 }
 
+LV_FUNC_SECTION
 void pika_lvgl_label___init__(PikaObj* self, PikaObj* parent) {
     lv_obj_t* lv_parent = obj_getPtr(parent, "lv_obj");
     lv_obj_t* lv_obj = lv_label_create(lv_parent);
     obj_setPtr(self, "lv_obj", lv_obj);
 }
 
+LV_FUNC_SECTION
 void pika_lvgl_label_set_long_mode(PikaObj* self, int mode) {
     lv_obj_t* lv_obj = obj_getPtr(self, "lv_obj");
     lv_label_set_long_mode(lv_obj, mode);
 }
 
+LV_FUNC_SECTION
 void pika_lvgl_label_set_recolor(PikaObj* self, int en) {
     lv_obj_t* lv_obj = obj_getPtr(self, "lv_obj");
     lv_label_set_recolor(lv_obj, en);
 }
 
+LV_FUNC_SECTION
 void pika_lvgl_label_set_text(PikaObj* self, char* txt) {
     lv_obj_t* lv_obj = obj_getPtr(self, "lv_obj");
     lv_label_set_text(lv_obj, txt);
 }
 
+LV_FUNC_SECTION
 void pika_lvgl_label_set_style_text_align(PikaObj* self,
                                           int value,
                                           int selector) {
@@ -309,40 +370,47 @@ void pika_lvgl_label_set_style_text_align(PikaObj* self,
     lv_obj_set_style_text_align(lv_obj, value, selector);
 }
 
+LV_FUNC_SECTION
 void pika_lvgl_roller___init__(PikaObj* self, PikaObj* parent) {
     lv_obj_t* lv_parent = obj_getPtr(parent, "lv_obj");
     lv_obj_t* lv_obj = lv_roller_create(lv_parent);
     obj_setPtr(self, "lv_obj", lv_obj);
 }
 
+LV_FUNC_SECTION
 void pika_lvgl_roller_set_options(PikaObj* self, char* options, int mode) {
     lv_obj_t* lv_obj = obj_getPtr(self, "lv_obj");
     lv_roller_set_options(lv_obj, options, mode);
 }
 
+LV_FUNC_SECTION
 void pika_lvgl_roller_set_visible_row_count(PikaObj* self, int row_cnt) {
     lv_obj_t* lv_obj = obj_getPtr(self, "lv_obj");
     lv_roller_set_visible_row_count(lv_obj, row_cnt);
 }
 
+LV_FUNC_SECTION
 void pika_lvgl_slider___init__(PikaObj* self, PikaObj* parent) {
     lv_obj_t* lv_parent = obj_getPtr(parent, "lv_obj");
     lv_obj_t* lv_obj = lv_slider_create(lv_parent);
     obj_setPtr(self, "lv_obj", lv_obj);
 }
 
+LV_FUNC_SECTION
 void pika_lvgl_switch___init__(PikaObj* self, PikaObj* parent) {
     lv_obj_t* lv_parent = obj_getPtr(parent, "lv_obj");
     lv_obj_t* lv_obj = lv_switch_create(lv_parent);
     obj_setPtr(self, "lv_obj", lv_obj);
 }
 
+LV_FUNC_SECTION
 void pika_lvgl_table___init__(PikaObj* self, PikaObj* parent) {
     lv_obj_t* lv_parent = obj_getPtr(parent, "lv_obj");
     lv_obj_t* lv_obj = lv_table_create(lv_parent);
     obj_setPtr(self, "lv_obj", lv_obj);
 }
 
+LV_FUNC_SECTION
 void pika_lvgl_table_set_cell_value(PikaObj* self,
                                     int row,
                                     int col,
@@ -351,12 +419,14 @@ void pika_lvgl_table_set_cell_value(PikaObj* self,
     lv_table_set_cell_value(lv_obj, row, col, txt);
 }
 
+LV_FUNC_SECTION
 void pika_lvgl_textarea___init__(PikaObj* self, PikaObj* parent) {
     lv_obj_t* lv_parent = obj_getPtr(parent, "lv_obj");
     lv_obj_t* lv_obj = lv_textarea_create(lv_parent);
     obj_setPtr(self, "lv_obj", lv_obj);
 }
 
+LV_FUNC_SECTION
 void pika_lvgl_textarea_set_one_line(PikaObj* self, int en) {
     lv_obj_t* lv_obj = obj_getPtr(self, "lv_obj");
     lv_textarea_set_one_line(lv_obj, en);
diff --git a/env_support/pikascript/pika_lvgl.c b/env_support/pikascript/pika_lvgl.c
index 70021f7b6..9b4df4f06 100644
--- a/env_support/pikascript/pika_lvgl.c
+++ b/env_support/pikascript/pika_lvgl.c
@@ -21,6 +21,7 @@
 
 PikaObj* pika_lv_event_listener_g;
 
+LV_FUNC_SECTION
 void pika_lvgl_STATE___init__(PikaObj* self) {
     obj_setInt(self, "DEFAULT", LV_STATE_DEFAULT);
     obj_setInt(self, "CHECKED", LV_STATE_CHECKED);
@@ -38,11 +39,13 @@ void pika_lvgl_STATE___init__(PikaObj* self) {
     obj_setInt(self, "ANY", LV_STATE_ANY);
 }
 
+LV_FUNC_SECTION
 void pika_lvgl_ANIM___init__(PikaObj* self) {
     obj_setInt(self, "ON", LV_ANIM_OFF);
     obj_setInt(self, "OFF", LV_ANIM_ON);
 }
 
+LV_FUNC_SECTION
 void pika_lvgl_ALIGN___init__(PikaObj* self) {
     obj_setInt(self, "CENTER", LV_ALIGN_CENTER);
     obj_setInt(self, "DEFAULT", LV_ALIGN_DEFAULT);
@@ -68,6 +71,7 @@ void pika_lvgl_ALIGN___init__(PikaObj* self) {
     obj_setInt(self, "OUT_RIGHT_BOTTOM", LV_ALIGN_OUT_RIGHT_BOTTOM);
 }
 
+LV_FUNC_SECTION
 void pika_lvgl_EVENT___init__(PikaObj* self) {
     obj_setInt(self, "ALL", LV_EVENT_ALL);
     obj_setInt(self, "PRESSED", LV_EVENT_PRESSED);
@@ -117,11 +121,13 @@ void pika_lvgl_EVENT___init__(PikaObj* self) {
     obj_setInt(self, "PREPROCESS", LV_EVENT_PREPROCESS);
 }
 
+LV_FUNC_SECTION
 void pika_lvgl_OPA___init__(PikaObj* self) {
     obj_setInt(self, "TRANSP", LV_OPA_TRANSP);
     obj_setInt(self, "COVER", LV_OPA_COVER);
 }
 
+LV_FUNC_SECTION
 void pika_lvgl_PALETTE___init__(PikaObj* self) {
     obj_setInt(self, "RED", LV_PALETTE_RED);
     obj_setInt(self, "PINK", LV_PALETTE_PINK);
@@ -145,6 +151,7 @@ void pika_lvgl_PALETTE___init__(PikaObj* self) {
     obj_setInt(self, "NONE", LV_PALETTE_NONE);
 }
 
+LV_FUNC_SECTION
 PikaObj* pika_lvgl_screen_active(PikaObj* self) {
     PikaObj* new_obj = newNormalObj(New_TinyObj);
     lv_obj_t* lv_obj = lv_screen_active();
@@ -152,11 +159,13 @@ PikaObj* pika_lvgl_screen_active(PikaObj* self) {
     return new_obj;
 }
 
+LV_FUNC_SECTION
 void pika_lvgl___init__(PikaObj* self) {
     obj_newDirectObj(self, "lv_event_listener", New_TinyObj);
     pika_lv_event_listener_g = obj_getObj(self, "lv_event_listener");
 }
 
+LV_FUNC_SECTION
 PikaObj* pika_lvgl_obj(PikaObj* self, PikaObj* parent) {
     lv_obj_t* lv_parent = obj_getPtr(parent, "lv_obj");
     lv_obj_t* lv_obj = lv_obj_create(lv_parent);
@@ -165,6 +174,7 @@ PikaObj* pika_lvgl_obj(PikaObj* self, PikaObj* parent) {
     return new_obj;
 }
 
+LV_FUNC_SECTION
 PikaObj* pika_lvgl_palette_lighten(PikaObj *self, int p, int lvl){
     PikaObj* new_obj = newNormalObj(New_pika_lvgl_lv_color_t);
     lv_color_t lv_color = lv_palette_lighten(p, lvl);
@@ -174,6 +184,7 @@ PikaObj* pika_lvgl_palette_lighten(PikaObj *self, int p, int lvl){
     return new_obj;
 }
 
+LV_FUNC_SECTION
 PikaObj* pika_lvgl_palette_main(PikaObj* self, int p) {
     PikaObj* new_obj = newNormalObj(New_pika_lvgl_lv_color_t);
     lv_color_t lv_color = lv_palette_main(p);
@@ -183,6 +194,7 @@ PikaObj* pika_lvgl_palette_main(PikaObj* self, int p) {
     return new_obj;
 }
 
+LV_FUNC_SECTION
 PikaObj* pika_lvgl_indev_get_active(PikaObj *self){
     PikaObj* new_obj = newNormalObj(New_pika_lvgl_indev_t);
     lv_indev_t *lv_indev = lv_indev_active();
@@ -190,6 +202,7 @@ PikaObj* pika_lvgl_indev_get_active(PikaObj *self){
     return new_obj;
 }
 
+LV_FUNC_SECTION
 PikaObj* pika_lvgl_timer_create_basic(PikaObj *self){
     PikaObj* new_obj = newNormalObj(New_pika_lvgl_lv_timer_t);
     lv_timer_t *lv_timer = lv_timer_create_basic();
diff --git a/env_support/pikascript/pika_lvgl_indev_t.c b/env_support/pikascript/pika_lvgl_indev_t.c
index 591ee8a62..67367e58a 100644
--- a/env_support/pikascript/pika_lvgl_indev_t.c
+++ b/env_support/pikascript/pika_lvgl_indev_t.c
@@ -8,6 +8,7 @@
 
 #include "pika_lvgl_indev_t.h"
 
+LV_FUNC_SECTION
 void pika_lvgl_indev_t_get_vect(PikaObj* self, PikaObj* point) {
     lv_indev_t* lv_indev = obj_getPtr(self, "lv_indev");
     lv_point_t* lv_point = obj_getPtr(point, "lv_point");
diff --git a/env_support/pikascript/pika_lvgl_lv_event.c b/env_support/pikascript/pika_lvgl_lv_event.c
index 575cf1648..04f4451ce 100644
--- a/env_support/pikascript/pika_lvgl_lv_event.c
+++ b/env_support/pikascript/pika_lvgl_lv_event.c
@@ -8,12 +8,14 @@
 
 #include "pika_lvgl_lv_event.h"
 
+LV_FUNC_SECTION
 int pika_lvgl_lv_event_get_code(PikaObj *self){
     lv_event_t *lv_event = obj_getPtr(self, "lv_event");
     return lv_event_get_code(lv_event);
 }
 
 PikaObj *New_pika_lvgl_lv_obj(Args *args);
+LV_FUNC_SECTION
 PikaObj* pika_lvgl_lv_event_get_target(PikaObj *self){
     lv_event_t *lv_event = obj_getPtr(self, "lv_event");
     lv_obj_t* lv_obj = lv_event_get_target(lv_event);
diff --git a/env_support/pikascript/pika_lvgl_lv_obj.c b/env_support/pikascript/pika_lvgl_lv_obj.c
index efda44136..a0be70826 100644
--- a/env_support/pikascript/pika_lvgl_lv_obj.c
+++ b/env_support/pikascript/pika_lvgl_lv_obj.c
@@ -15,41 +15,49 @@
 
 extern PikaObj* pika_lv_event_listener_g;
 
+LV_FUNC_SECTION
 void pika_lvgl_lv_obj_center(PikaObj* self) {
     lv_obj_t* lv_obj = obj_getPtr(self, "lv_obj");
     lv_obj_center(lv_obj);
 }
 
+LV_FUNC_SECTION
 void pika_lvgl_lv_obj_set_size(PikaObj* self, int size_x, int size_y) {
     lv_obj_t* lv_obj = obj_getPtr(self, "lv_obj");
     lv_obj_set_size(lv_obj, size_x, size_y);
 }
 
+LV_FUNC_SECTION
 void pika_lvgl_lv_obj_align(PikaObj* self, int align, int x_ofs, int y_ofs) {
     lv_obj_t* lv_obj = obj_getPtr(self, "lv_obj");
     lv_obj_align(lv_obj, align, x_ofs, y_ofs);
 }
 
+LV_FUNC_SECTION
 void pika_lvgl_lv_obj_set_height(PikaObj* self, int h) {
     lv_obj_t* lv_obj = obj_getPtr(self, "lv_obj");
     lv_obj_set_height(lv_obj, h);
 }
 
+LV_FUNC_SECTION
 void pika_lvgl_lv_obj_update_layout(PikaObj* self) {
     lv_obj_t* lv_obj = obj_getPtr(self, "lv_obj");
     lv_obj_update_layout(lv_obj);
 }
 
+LV_FUNC_SECTION
 void pika_lvgl_lv_obj_set_width(PikaObj* self, int w) {
     lv_obj_t* lv_obj = obj_getPtr(self, "lv_obj");
     lv_obj_set_width(lv_obj, w);
 }
 
+LV_FUNC_SECTION
 void pika_lvgl_lv_obj_add_state(PikaObj* self, int state) {
     lv_obj_t* lv_obj = obj_getPtr(self, "lv_obj");
     lv_obj_add_state(lv_obj, state);
 }
 
+LV_FUNC_SECTION
 PikaObj* eventListener_getHandler(PikaObj* self, uintptr_t event_id) {
     Args buffs = {0};
     char* event_name =
@@ -60,6 +68,7 @@ PikaObj* eventListener_getHandler(PikaObj* self, uintptr_t event_id) {
     return event_handler;
 }
 
+LV_FUNC_SECTION
 static void __pika_event_cb(lv_event_t* e) {
     lv_obj_t* target = lv_event_get_target(e);
     PikaObj* event_handler =
@@ -69,6 +78,7 @@ static void __pika_event_cb(lv_event_t* e) {
     obj_run(event_handler, "_event_cb(_event_evt)");
 }
 
+LV_FUNC_SECTION
 void eventListener_registerEvent(PikaObj* self,
                               uintptr_t event_id,
                               PikaObj* event_handler) {
@@ -81,6 +91,7 @@ void eventListener_registerEvent(PikaObj* self,
     strsDeinit(&buffs);
 }
 
+LV_FUNC_SECTION
 void pika_lvgl_lv_obj_add_event_cb(PikaObj* self,
                                    Arg* event_cb,
                                    int filter,
@@ -93,22 +104,26 @@ void pika_lvgl_lv_obj_add_event_cb(PikaObj* self,
     eventListener_registerEvent(pika_lv_event_listener_g, (uintptr_t)lv_obj, self);
 }
 
+LV_FUNC_SECTION
 void pika_lvgl_lv_obj_add_style(PikaObj *self, PikaObj* style, int selector){
     lv_obj_t* lv_obj = obj_getPtr(self, "lv_obj");
     lv_style_t* lv_style = obj_getPtr(style, "lv_style");
     lv_obj_add_style(lv_obj, lv_style, selector);
 }
 
+LV_FUNC_SECTION
 int pika_lvgl_lv_obj_get_x(PikaObj *self){
     lv_obj_t* lv_obj = obj_getPtr(self, "lv_obj");
     return lv_obj_get_x(lv_obj);
 }
 
+LV_FUNC_SECTION
 int pika_lvgl_lv_obj_get_y(PikaObj *self){
     lv_obj_t* lv_obj = obj_getPtr(self, "lv_obj");
     return lv_obj_get_y(lv_obj);
 }
 
+LV_FUNC_SECTION
 void pika_lvgl_lv_obj_set_pos(PikaObj *self, int x, int y){
     lv_obj_t* lv_obj = obj_getPtr(self, "lv_obj");
     lv_obj_set_pos(lv_obj, x, y);
diff --git a/env_support/pikascript/pika_lvgl_lv_style_t.c b/env_support/pikascript/pika_lvgl_lv_style_t.c
index 478300898..163135051 100644
--- a/env_support/pikascript/pika_lvgl_lv_style_t.c
+++ b/env_support/pikascript/pika_lvgl_lv_style_t.c
@@ -8,43 +8,51 @@
 
 #include "pika_lvgl_style_t.h"
 
+LV_FUNC_SECTION
 void pika_lvgl_style_t_init(PikaObj* self) {
     lv_style_t* lv_style = obj_getPtr(self, "lv_style");
     lv_style_init(lv_style);
 }
 
+LV_FUNC_SECTION
 void pika_lvgl_style_t_set_bg_color(PikaObj* self, PikaObj* color) {
     lv_style_t* lv_style = obj_getPtr(self, "lv_style");
     lv_color_t* lv_color = obj_getPtr(color, "lv_color");
     lv_style_set_bg_color(lv_style, *lv_color);
 }
 
+LV_FUNC_SECTION
 void pika_lvgl_style_t_set_bg_opa(PikaObj* self, int opa) {
     lv_style_t* lv_style = obj_getPtr(self, "lv_style");
     lv_style_set_bg_opa(lv_style, opa);
 }
 
+LV_FUNC_SECTION
 void pika_lvgl_style_t_set_outline_color(PikaObj* self, PikaObj* color) {
     lv_style_t* lv_style = obj_getPtr(self, "lv_style");
     lv_color_t* lv_color = obj_getPtr(color, "lv_color");
     lv_style_set_outline_color(lv_style, *lv_color);
 }
 
+LV_FUNC_SECTION
 void pika_lvgl_style_t_set_outline_pad(PikaObj* self, int pad) {
     lv_style_t* lv_style = obj_getPtr(self, "lv_style");
     lv_style_set_outline_pad(lv_style, pad);
 }
 
+LV_FUNC_SECTION
 void pika_lvgl_style_t_set_outline_width(PikaObj* self, int w) {
     lv_style_t* lv_style = obj_getPtr(self, "lv_style");
     lv_style_set_outline_width(lv_style, w);
 }
 
+LV_FUNC_SECTION
 void pika_lvgl_style_t_set_radius(PikaObj* self, int radius) {
     lv_style_t* lv_style = obj_getPtr(self, "lv_style");
     lv_style_set_radius(lv_style, radius);
 }
 
+LV_FUNC_SECTION
 void pika_lvgl_style_t___init__(PikaObj* self) {
     lv_style_t lv_style_stack = {0};
     args_setStruct(self->list, "lv_style_struct", lv_style_stack);
@@ -52,17 +60,20 @@ void pika_lvgl_style_t___init__(PikaObj* self) {
     obj_setPtr(self, "lv_style", lv_style);
 }
 
+LV_FUNC_SECTION
 void pika_lvgl_style_t_set_shadow_color(PikaObj *self, PikaObj* color){
     lv_style_t* lv_style = obj_getPtr(self, "lv_style");
     lv_color_t* lv_color = obj_getPtr(color, "lv_color");
     lv_style_set_shadow_color(lv_style, *lv_color);
 }
 
+LV_FUNC_SECTION
 void pika_lvgl_style_t_set_shadow_spread(PikaObj *self, int s){
     lv_style_t* lv_style = obj_getPtr(self, "lv_style");
     lv_style_set_shadow_spread(lv_style, s);
 }
 
+LV_FUNC_SECTION
 void pika_lvgl_style_t_set_shadow_width(PikaObj *self, int w){
     lv_style_t* lv_style = obj_getPtr(self, "lv_style");
     lv_style_set_shadow_width(lv_style, w);
diff --git a/env_support/rt-thread/lv_rt_thread_port.c b/env_support/rt-thread/lv_rt_thread_port.c
index dcb08b5cf..4658e40dc 100644
--- a/env_support/rt-thread/lv_rt_thread_port.c
+++ b/env_support/rt-thread/lv_rt_thread_port.c
@@ -40,6 +40,7 @@ extern void lv_user_gui_init(void);
 static struct rt_thread lvgl_thread;
 
 #ifdef rt_align
+LV_FUNC_SECTION
     rt_align(RT_ALIGN_SIZE)
 #else
     ALIGN(RT_ALIGN_SIZE)
@@ -55,12 +56,14 @@ static void lv_rt_log(lv_log_level_t level, const char * buf)
 #endif /* LV_USE_LOG */
 
 #ifdef PKG_USING_CPU_USAGE
+LV_FUNC_SECTION
 uint32_t lv_timer_os_get_idle(void)
 {
     return (100 - (uint32_t)cpu_load_average());
 }
 #endif /* PKG_USING_CPU_USAGE */
 
+LV_FUNC_SECTION
 static void lvgl_thread_entry(void *parameter)
 {
 #if LV_USE_LOG
@@ -85,6 +88,7 @@ static void lvgl_thread_entry(void *parameter)
     }
 }
 
+LV_FUNC_SECTION
 static int lvgl_thread_init(void)
 {
     rt_err_t err;
diff --git a/env_support/rt-thread/squareline/lv_ui_entry.c b/env_support/rt-thread/squareline/lv_ui_entry.c
index f08e1f58d..23af06d94 100644
--- a/env_support/rt-thread/squareline/lv_ui_entry.c
+++ b/env_support/rt-thread/squareline/lv_ui_entry.c
@@ -10,6 +10,7 @@
 
 #ifdef __RTTHREAD__
 
+LV_FUNC_SECTION
 void lv_user_gui_init(void)
 {
     extern void ui_init(void);
diff --git a/examples/anim/lv_example_anim_1.c b/examples/anim/lv_example_anim_1.c
index 168f5ad57..0b1c62a4d 100644
--- a/examples/anim/lv_example_anim_1.c
+++ b/examples/anim/lv_example_anim_1.c
@@ -1,11 +1,13 @@
 #include "../lv_examples.h"
 #if LV_BUILD_EXAMPLES && LV_USE_SWITCH
 
+__attribute__(( fptrgroup("lv_anim_exec_cb") ))
 static void anim_x_cb(void * var, int32_t v)
 {
     lv_obj_set_x(var, v);
 }
 
+__attribute__(( fptrgroup("lv_event_cb") ))
 static void sw_event_cb(lv_event_t * e)
 {
     lv_obj_t * sw = lv_event_get_target(e);
@@ -37,6 +39,7 @@ static void sw_event_cb(lv_event_t * e)
 /**
  * Start animation on an event
  */
+LV_FUNC_SECTION
 void lv_example_anim_1(void)
 {
     lv_obj_t * label = lv_label_create(lv_screen_active());
diff --git a/examples/anim/lv_example_anim_2.c b/examples/anim/lv_example_anim_2.c
index 434e0d1f6..a9aa160a4 100644
--- a/examples/anim/lv_example_anim_2.c
+++ b/examples/anim/lv_example_anim_2.c
@@ -1,11 +1,13 @@
 #include "../lv_examples.h"
 #if LV_BUILD_EXAMPLES && LV_USE_SWITCH
 
+__attribute__(( fptrgroup("lv_anim_exec_cb") ))
 static void anim_x_cb(void * var, int32_t v)
 {
     lv_obj_set_x(var, v);
 }
 
+__attribute__(( fptrgroup("lv_anim_exec_cb") ))
 static void anim_size_cb(void * var, int32_t v)
 {
     lv_obj_set_size(var, v, v);
@@ -14,6 +16,7 @@ static void anim_size_cb(void * var, int32_t v)
 /**
  * Create a playback animation
  */
+LV_FUNC_SECTION
 void lv_example_anim_2(void)
 {
 
diff --git a/examples/anim/lv_example_anim_3.c b/examples/anim/lv_example_anim_3.c
index e13ff6122..ef975c031 100644
--- a/examples/anim/lv_example_anim_3.c
+++ b/examples/anim/lv_example_anim_3.c
@@ -34,6 +34,7 @@ static void anim_x_cb(void * var, int32_t v);
 /**
  * create an animation
  */
+LV_FUNC_SECTION
 void lv_example_anim_3(void)
 {
     static int32_t col_dsc[] = {LV_GRID_FR(1), 200, LV_GRID_FR(1), LV_GRID_TEMPLATE_LAST};
@@ -62,6 +63,7 @@ void lv_example_anim_3(void)
     refer_chart_cubic_bezier();
 }
 
+__attribute__(( fptrgroup("lv_anim_path_cb") ))
 static int32_t anim_path_bezier3_cb(const lv_anim_t * a)
 {
     uint32_t t = lv_map(a->act_time, 0, a->duration, 0, 1024);
@@ -73,6 +75,7 @@ static int32_t anim_path_bezier3_cb(const lv_anim_t * a)
     return new_value;
 }
 
+LV_FUNC_SECTION
 static void refer_chart_cubic_bezier(void)
 {
     for(uint16_t i = 0; i <= CHART_POINTS_NUM; i ++) {
@@ -83,11 +86,13 @@ static void refer_chart_cubic_bezier(void)
     lv_chart_refresh(ginfo.chart);
 }
 
+__attribute__(( fptrgroup("lv_anim_exec_cb") ))
 static void anim_x_cb(void * var, int32_t v)
 {
     lv_obj_set_style_translate_x(var, v, LV_PART_MAIN);
 }
 
+LV_FUNC_SECTION
 static void run_button_event_handler(lv_event_t * e)
 {
     lv_event_code_t code = lv_event_get_code(e);
@@ -96,6 +101,7 @@ static void run_button_event_handler(lv_event_t * e)
     }
 }
 
+__attribute__(( fptrgroup("lv_event_cb") ))
 static void slider_event_cb(lv_event_t * e)
 {
     char buf[16];
@@ -117,6 +123,7 @@ static void slider_event_cb(lv_event_t * e)
     refer_chart_cubic_bezier();
 }
 
+LV_FUNC_SECTION
 static void page_obj_init(lv_obj_t * par)
 {
     ginfo.anim_obj = lv_obj_create(par);
diff --git a/examples/anim/lv_example_anim_timeline_1.c b/examples/anim/lv_example_anim_timeline_1.c
index dcb4ef227..1659e029b 100644
--- a/examples/anim/lv_example_anim_timeline_1.c
+++ b/examples/anim/lv_example_anim_timeline_1.c
@@ -4,21 +4,25 @@
 static const int32_t obj_width = 90;
 static const int32_t obj_height = 70;
 
+__attribute__(( fptrgroup("lv_anim_custom_exec_cb") ))
 static void set_width(lv_anim_t * var, int32_t v)
 {
     lv_obj_set_width(var->var, v);
 }
 
+__attribute__(( fptrgroup("lv_anim_custom_exec_cb") ))
 static void set_height(lv_anim_t * var, int32_t v)
 {
     lv_obj_set_height(var->var, v);
 }
 
+__attribute__(( fptrgroup("lv_anim_custom_exec_cb") ))
 static void set_slider_value(lv_anim_t * var, int32_t v)
 {
     lv_slider_set_value(var->var, v, LV_ANIM_OFF);
 }
 
+__attribute__(( fptrgroup("lv_event_cb") ))
 static void btn_start_event_handler(lv_event_t * e)
 {
     lv_obj_t * btn = lv_event_get_current_target_obj(e);
@@ -29,12 +33,14 @@ static void btn_start_event_handler(lv_event_t * e)
     lv_anim_timeline_start(anim_timeline);
 }
 
+__attribute__(( fptrgroup("lv_event_cb") ))
 static void btn_pause_event_handler(lv_event_t * e)
 {
     lv_anim_timeline_t * anim_timeline = lv_event_get_user_data(e);
     lv_anim_timeline_pause(anim_timeline);
 }
 
+__attribute__(( fptrgroup("lv_event_cb") ))
 static void slider_prg_event_handler(lv_event_t * e)
 {
     lv_obj_t * slider = lv_event_get_current_target_obj(e);
@@ -46,6 +52,7 @@ static void slider_prg_event_handler(lv_event_t * e)
 /**
  * Create an animation timeline
  */
+LV_FUNC_SECTION
 void lv_example_anim_timeline_1(void)
 {
     /* Create anim timeline */
diff --git a/examples/event/lv_example_event_1.c b/examples/event/lv_example_event_1.c
index a6162859f..5eda98ff1 100644
--- a/examples/event/lv_example_event_1.c
+++ b/examples/event/lv_example_event_1.c
@@ -1,6 +1,7 @@
 #include "../lv_examples.h"
 #if LV_BUILD_EXAMPLES && LV_USE_SWITCH
 
+__attribute__(( fptrgroup("lv_event_cb") ))
 static void event_cb(lv_event_t * e)
 {
     LV_LOG_USER("Clicked");
@@ -15,6 +16,7 @@ static void event_cb(lv_event_t * e)
 /**
  * Add click event to a button
  */
+LV_FUNC_SECTION
 void lv_example_event_1(void)
 {
     lv_obj_t * btn = lv_button_create(lv_screen_active());
diff --git a/examples/event/lv_example_event_2.c b/examples/event/lv_example_event_2.c
index 35d2f757c..e04871b3b 100644
--- a/examples/event/lv_example_event_2.c
+++ b/examples/event/lv_example_event_2.c
@@ -1,6 +1,7 @@
 #include "../lv_examples.h"
 #if LV_BUILD_EXAMPLES && LV_USE_SWITCH
 
+__attribute__(( fptrgroup("lv_event_cb") ))
 static void event_cb(lv_event_t * e)
 {
     lv_event_code_t code = lv_event_get_code(e);
@@ -27,6 +28,7 @@ static void event_cb(lv_event_t * e)
 /**
  * Handle multiple events
  */
+LV_FUNC_SECTION
 void lv_example_event_2(void)
 {
     lv_obj_t * btn = lv_button_create(lv_screen_active());
diff --git a/examples/event/lv_example_event_3.c b/examples/event/lv_example_event_3.c
index 6a8f3cb21..9156786a5 100644
--- a/examples/event/lv_example_event_3.c
+++ b/examples/event/lv_example_event_3.c
@@ -1,6 +1,7 @@
 #include "../lv_examples.h"
 #if LV_BUILD_EXAMPLES && LV_USE_FLEX
 
+__attribute__(( fptrgroup("lv_event_cb") ))
 static void event_cb(lv_event_t * e)
 {
     /*The original target of the event. Can be the buttons or the container*/
@@ -19,6 +20,7 @@ static void event_cb(lv_event_t * e)
 /**
  * Demonstrate event bubbling
  */
+LV_FUNC_SECTION
 void lv_example_event_3(void)
 {
 
diff --git a/examples/event/lv_example_event_4.c b/examples/event/lv_example_event_4.c
index 1d38587d7..0f8e0abdc 100644
--- a/examples/event/lv_example_event_4.c
+++ b/examples/event/lv_example_event_4.c
@@ -5,6 +5,7 @@
 static uint32_t size = 0;
 static bool size_dec = false;
 
+__attribute__(( fptrgroup("lv_timer_cb") ))
 static void timer_cb(lv_timer_t * timer)
 {
     lv_obj_invalidate(lv_timer_get_user_data(timer));
@@ -15,6 +16,7 @@ static void timer_cb(lv_timer_t * timer)
     else if(size == 0) size_dec = false;
 }
 
+__attribute__(( fptrgroup("lv_event_cb") ))
 static void event_cb(lv_event_t * e)
 {
     lv_obj_t * obj = lv_event_get_target(e);
@@ -47,6 +49,7 @@ static void event_cb(lv_event_t * e)
 /**
  * Demonstrate the usage of draw event
  */
+LV_FUNC_SECTION
 void lv_example_event_4(void)
 {
     lv_obj_t * cont = lv_obj_create(lv_screen_active());
diff --git a/examples/get_started/lv_example_get_started_1.c b/examples/get_started/lv_example_get_started_1.c
index 541f797b4..52e017a2a 100644
--- a/examples/get_started/lv_example_get_started_1.c
+++ b/examples/get_started/lv_example_get_started_1.c
@@ -4,6 +4,7 @@
 /**
  * Basic example to create a "Hello world" label
  */
+LV_FUNC_SECTION
 void lv_example_get_started_1(void)
 {
     /*Change the active screen's background color*/
diff --git a/examples/get_started/lv_example_get_started_2.c b/examples/get_started/lv_example_get_started_2.c
index 9edac9f03..4afb9c272 100644
--- a/examples/get_started/lv_example_get_started_2.c
+++ b/examples/get_started/lv_example_get_started_2.c
@@ -1,6 +1,7 @@
 #include "../lv_examples.h"
 #if LV_BUILD_EXAMPLES && LV_USE_BUTTON
 
+__attribute__(( fptrgroup("lv_event_cb") ))
 static void btn_event_cb(lv_event_t * e)
 {
     lv_event_code_t code = lv_event_get_code(e);
@@ -18,6 +19,7 @@ static void btn_event_cb(lv_event_t * e)
 /**
  * Create a button with a label and react on click event.
  */
+LV_FUNC_SECTION
 void lv_example_get_started_2(void)
 {
     lv_obj_t * btn = lv_button_create(lv_screen_active());     /*Add a button the current screen*/
diff --git a/examples/get_started/lv_example_get_started_3.c b/examples/get_started/lv_example_get_started_3.c
index b869cc633..331382dc0 100644
--- a/examples/get_started/lv_example_get_started_3.c
+++ b/examples/get_started/lv_example_get_started_3.c
@@ -5,12 +5,14 @@ static lv_style_t style_btn;
 static lv_style_t style_button_pressed;
 static lv_style_t style_button_red;
 
+LV_FUNC_SECTION
 static lv_color_t darken(const lv_color_filter_dsc_t * dsc, lv_color_t color, lv_opa_t opa)
 {
     LV_UNUSED(dsc);
     return lv_color_darken(color, opa);
 }
 
+LV_FUNC_SECTION
 static void style_init(void)
 {
     /*Create a simple button style*/
@@ -44,6 +46,7 @@ static void style_init(void)
 /**
  * Create styles from scratch for buttons.
  */
+LV_FUNC_SECTION
 void lv_example_get_started_3(void)
 {
     /*Initialize the style*/
diff --git a/examples/get_started/lv_example_get_started_4.c b/examples/get_started/lv_example_get_started_4.c
index e6f3b97e2..29da13e88 100644
--- a/examples/get_started/lv_example_get_started_4.c
+++ b/examples/get_started/lv_example_get_started_4.c
@@ -3,6 +3,7 @@
 
 static lv_obj_t * label;
 
+__attribute__(( fptrgroup("lv_event_cb") ))
 static void slider_event_cb(lv_event_t * e)
 {
     lv_obj_t * slider = lv_event_get_target(e);
@@ -15,6 +16,7 @@ static void slider_event_cb(lv_event_t * e)
 /**
  * Create a slider and write its value on a label.
  */
+LV_FUNC_SECTION
 void lv_example_get_started_4(void)
 {
     /*Create a slider in the center of the display*/
diff --git a/examples/layouts/flex/lv_example_flex_1.c b/examples/layouts/flex/lv_example_flex_1.c
index b92a9bd2b..0d04c2daf 100644
--- a/examples/layouts/flex/lv_example_flex_1.c
+++ b/examples/layouts/flex/lv_example_flex_1.c
@@ -4,6 +4,7 @@
 /**
  * A simple row and a column layout with flexbox
  */
+LV_FUNC_SECTION
 void lv_example_flex_1(void)
 {
     /*Create a container with ROW flex direction*/
diff --git a/examples/layouts/flex/lv_example_flex_2.c b/examples/layouts/flex/lv_example_flex_2.c
index 7c5c3d040..5f07778a7 100644
--- a/examples/layouts/flex/lv_example_flex_2.c
+++ b/examples/layouts/flex/lv_example_flex_2.c
@@ -4,6 +4,7 @@
 /**
  * Arrange items in rows with wrap and place the items to get even space around them.
  */
+LV_FUNC_SECTION
 void lv_example_flex_2(void)
 {
     static lv_style_t style;
diff --git a/examples/layouts/flex/lv_example_flex_3.c b/examples/layouts/flex/lv_example_flex_3.c
index 207e6b9de..6ea72cde1 100644
--- a/examples/layouts/flex/lv_example_flex_3.c
+++ b/examples/layouts/flex/lv_example_flex_3.c
@@ -4,6 +4,7 @@
 /**
  * Demonstrate flex grow.
  */
+LV_FUNC_SECTION
 void lv_example_flex_3(void)
 {
     lv_obj_t * cont = lv_obj_create(lv_screen_active());
diff --git a/examples/layouts/flex/lv_example_flex_4.c b/examples/layouts/flex/lv_example_flex_4.c
index bf9a4ba2c..185c86e22 100644
--- a/examples/layouts/flex/lv_example_flex_4.c
+++ b/examples/layouts/flex/lv_example_flex_4.c
@@ -4,6 +4,7 @@
 /**
  * Reverse the order of flex items
  */
+LV_FUNC_SECTION
 void lv_example_flex_4(void)
 {
 
diff --git a/examples/layouts/flex/lv_example_flex_5.c b/examples/layouts/flex/lv_example_flex_5.c
index 11d494cb5..743d86665 100644
--- a/examples/layouts/flex/lv_example_flex_5.c
+++ b/examples/layouts/flex/lv_example_flex_5.c
@@ -1,11 +1,13 @@
 #include "../../lv_examples.h"
 #if LV_USE_FLEX && LV_BUILD_EXAMPLES
 
+__attribute__(( fptrgroup("lv_anim_exec_cb") ))
 static void row_gap_anim(void * obj, int32_t v)
 {
     lv_obj_set_style_pad_row(obj, v, 0);
 }
 
+__attribute__(( fptrgroup("lv_anim_exec_cb") ))
 static void column_gap_anim(void * obj, int32_t v)
 {
     lv_obj_set_style_pad_column(obj, v, 0);
@@ -14,6 +16,7 @@ static void column_gap_anim(void * obj, int32_t v)
 /**
  * Demonstrate the effect of column and row gap style properties
  */
+LV_FUNC_SECTION
 void lv_example_flex_5(void)
 {
     lv_obj_t * cont = lv_obj_create(lv_screen_active());
diff --git a/examples/layouts/flex/lv_example_flex_6.c b/examples/layouts/flex/lv_example_flex_6.c
index 0f9b27ccf..bc8ab4e10 100644
--- a/examples/layouts/flex/lv_example_flex_6.c
+++ b/examples/layouts/flex/lv_example_flex_6.c
@@ -5,6 +5,7 @@
  * RTL base direction changes order of the items.
  * Also demonstrate how horizontal scrolling works with RTL.
  */
+LV_FUNC_SECTION
 void lv_example_flex_6(void)
 {
     lv_obj_t * cont = lv_obj_create(lv_screen_active());
diff --git a/examples/layouts/grid/lv_example_grid_1.c b/examples/layouts/grid/lv_example_grid_1.c
index c4b076777..0fb91c18c 100644
--- a/examples/layouts/grid/lv_example_grid_1.c
+++ b/examples/layouts/grid/lv_example_grid_1.c
@@ -4,6 +4,7 @@
 /**
  * A simple grid
  */
+LV_FUNC_SECTION
 void lv_example_grid_1(void)
 {
     static int32_t col_dsc[] = {70, 70, 70, LV_GRID_TEMPLATE_LAST};
diff --git a/examples/layouts/grid/lv_example_grid_2.c b/examples/layouts/grid/lv_example_grid_2.c
index 92e33b008..6e3161e43 100644
--- a/examples/layouts/grid/lv_example_grid_2.c
+++ b/examples/layouts/grid/lv_example_grid_2.c
@@ -4,6 +4,7 @@
 /**
  * Demonstrate cell placement and span
  */
+LV_FUNC_SECTION
 void lv_example_grid_2(void)
 {
     static int32_t col_dsc[] = {70, 70, 70, LV_GRID_TEMPLATE_LAST};
diff --git a/examples/layouts/grid/lv_example_grid_3.c b/examples/layouts/grid/lv_example_grid_3.c
index a1ac496e9..e6e0c3686 100644
--- a/examples/layouts/grid/lv_example_grid_3.c
+++ b/examples/layouts/grid/lv_example_grid_3.c
@@ -4,6 +4,7 @@
 /**
  * Demonstrate grid's "free unit"
  */
+LV_FUNC_SECTION
 void lv_example_grid_3(void)
 {
     /*Column 1: fix width 60 px
diff --git a/examples/layouts/grid/lv_example_grid_4.c b/examples/layouts/grid/lv_example_grid_4.c
index eba363087..299530df0 100644
--- a/examples/layouts/grid/lv_example_grid_4.c
+++ b/examples/layouts/grid/lv_example_grid_4.c
@@ -4,6 +4,7 @@
 /**
  * Demonstrate track placement
  */
+LV_FUNC_SECTION
 void lv_example_grid_4(void)
 {
     static int32_t col_dsc[] = {60, 60, 60, LV_GRID_TEMPLATE_LAST};
diff --git a/examples/layouts/grid/lv_example_grid_5.c b/examples/layouts/grid/lv_example_grid_5.c
index f5b1a5842..85966f882 100644
--- a/examples/layouts/grid/lv_example_grid_5.c
+++ b/examples/layouts/grid/lv_example_grid_5.c
@@ -1,11 +1,13 @@
 #include "../../lv_examples.h"
 #if LV_USE_GRID && LV_BUILD_EXAMPLES
 
+__attribute__(( fptrgroup("lv_anim_exec_cb") ))
 static void row_gap_anim(void * obj, int32_t v)
 {
     lv_obj_set_style_pad_row(obj, v, 0);
 }
 
+__attribute__(( fptrgroup("lv_anim_exec_cb") ))
 static void column_gap_anim(void * obj, int32_t v)
 {
     lv_obj_set_style_pad_column(obj, v, 0);
@@ -14,6 +16,7 @@ static void column_gap_anim(void * obj, int32_t v)
 /**
  * Demonstrate column and row gap
  */
+LV_FUNC_SECTION
 void lv_example_grid_5(void)
 {
 
diff --git a/examples/layouts/grid/lv_example_grid_6.c b/examples/layouts/grid/lv_example_grid_6.c
index 475f8d04f..54049ee4b 100644
--- a/examples/layouts/grid/lv_example_grid_6.c
+++ b/examples/layouts/grid/lv_example_grid_6.c
@@ -4,6 +4,7 @@
 /**
  * Demonstrate RTL direction on grid
  */
+LV_FUNC_SECTION
 void lv_example_grid_6(void)
 {
 
diff --git a/examples/libs/barcode/lv_example_barcode_1.c b/examples/libs/barcode/lv_example_barcode_1.c
index eea012ce6..81f6255d1 100644
--- a/examples/libs/barcode/lv_example_barcode_1.c
+++ b/examples/libs/barcode/lv_example_barcode_1.c
@@ -4,6 +4,7 @@
 /**
  * Create a Barcode
  */
+LV_FUNC_SECTION
 void lv_example_barcode_1(void)
 {
     lv_color_t bg_color = lv_palette_lighten(LV_PALETTE_LIGHT_BLUE, 5);
diff --git a/examples/libs/bmp/lv_example_bmp_1.c b/examples/libs/bmp/lv_example_bmp_1.c
index 2dc8713ac..3ec0adb0b 100644
--- a/examples/libs/bmp/lv_example_bmp_1.c
+++ b/examples/libs/bmp/lv_example_bmp_1.c
@@ -4,6 +4,7 @@
 /**
  * Open a BMP file from a file
  */
+LV_FUNC_SECTION
 void lv_example_bmp_1(void)
 {
     lv_obj_t * img = lv_image_create(lv_screen_active());
diff --git a/examples/libs/ffmpeg/lv_example_ffmpeg_1.c b/examples/libs/ffmpeg/lv_example_ffmpeg_1.c
index f8637d208..2c1ddd86b 100644
--- a/examples/libs/ffmpeg/lv_example_ffmpeg_1.c
+++ b/examples/libs/ffmpeg/lv_example_ffmpeg_1.c
@@ -5,6 +5,7 @@
 /**
  * Open an image from a file
  */
+LV_FUNC_SECTION
 void lv_example_ffmpeg_1(void)
 {
     /*It always uses the LVGL filesystem abstraction (not the OS filesystem)
@@ -17,6 +18,7 @@ void lv_example_ffmpeg_1(void)
 
 #else
 
+LV_FUNC_SECTION
 void lv_example_ffmpeg_1(void)
 {
     /*TODO
diff --git a/examples/libs/ffmpeg/lv_example_ffmpeg_2.c b/examples/libs/ffmpeg/lv_example_ffmpeg_2.c
index f396aeb8b..8900d4d1d 100644
--- a/examples/libs/ffmpeg/lv_example_ffmpeg_2.c
+++ b/examples/libs/ffmpeg/lv_example_ffmpeg_2.c
@@ -5,6 +5,7 @@
 /**
  * Open a video from a file
  */
+LV_FUNC_SECTION
 void lv_example_ffmpeg_2(void)
 {
     /*birds.mp4 is downloaded from http://www.videezy.com (Free Stock Footage by Videezy!)
@@ -20,6 +21,7 @@ void lv_example_ffmpeg_2(void)
 
 #else
 
+LV_FUNC_SECTION
 void lv_example_ffmpeg_2(void)
 {
     /*TODO
diff --git a/examples/libs/freetype/lv_example_freetype_1.c b/examples/libs/freetype/lv_example_freetype_1.c
index 5aba4c4fe..2f01bfb10 100644
--- a/examples/libs/freetype/lv_example_freetype_1.c
+++ b/examples/libs/freetype/lv_example_freetype_1.c
@@ -11,6 +11,7 @@
 /**
  * Load a font with FreeType
  */
+LV_FUNC_SECTION
 void lv_example_freetype_1(void)
 {
     /*Create a font*/
@@ -38,6 +39,7 @@ void lv_example_freetype_1(void)
 }
 #else
 
+LV_FUNC_SECTION
 void lv_example_freetype_1(void)
 {
     /*TODO
diff --git a/examples/libs/gif/lv_example_gif_1.c b/examples/libs/gif/lv_example_gif_1.c
index e972e39ae..39cca864d 100644
--- a/examples/libs/gif/lv_example_gif_1.c
+++ b/examples/libs/gif/lv_example_gif_1.c
@@ -4,6 +4,7 @@
 /**
  * Open a GIF image from a file and a variable
  */
+LV_FUNC_SECTION
 void lv_example_gif_1(void)
 {
     LV_IMAGE_DECLARE(img_bulb_gif);
diff --git a/examples/libs/libjpeg_turbo/lv_example_libjpeg_turbo_1.c b/examples/libs/libjpeg_turbo/lv_example_libjpeg_turbo_1.c
index 5cf8837e6..86acd2f6d 100644
--- a/examples/libs/libjpeg_turbo/lv_example_libjpeg_turbo_1.c
+++ b/examples/libs/libjpeg_turbo/lv_example_libjpeg_turbo_1.c
@@ -6,6 +6,7 @@
 /**
  * Load a JPG image
  */
+LV_FUNC_SECTION
 void lv_example_libjpeg_turbo_1(void)
 {
     lv_obj_t * wp;
@@ -19,6 +20,7 @@ void lv_example_libjpeg_turbo_1(void)
 
 #else
 
+LV_FUNC_SECTION
 void lv_example_libjpeg_turbo_1(void)
 {
     lv_obj_t * label = lv_label_create(lv_screen_active());
diff --git a/examples/libs/libpng/lv_example_libpng_1.c b/examples/libs/libpng/lv_example_libpng_1.c
index 621c74c38..9a1057144 100644
--- a/examples/libs/libpng/lv_example_libpng_1.c
+++ b/examples/libs/libpng/lv_example_libpng_1.c
@@ -6,6 +6,7 @@
 /**
  * Open a PNG image from a file
  */
+LV_FUNC_SECTION
 void lv_example_libpng_1(void)
 {
     LV_IMAGE_DECLARE(img_png_demo);
@@ -24,6 +25,7 @@ void lv_example_libpng_1(void)
 
 #else
 
+LV_FUNC_SECTION
 void lv_example_libpng_1(void)
 {
     lv_obj_t * label = lv_label_create(lv_screen_active());
diff --git a/examples/libs/lodepng/lv_example_lodepng_1.c b/examples/libs/lodepng/lv_example_lodepng_1.c
index 9aba1c2a1..b4a76d115 100644
--- a/examples/libs/lodepng/lv_example_lodepng_1.c
+++ b/examples/libs/lodepng/lv_example_lodepng_1.c
@@ -4,6 +4,7 @@
 /**
  * Open a PNG image from a file and a variable
  */
+LV_FUNC_SECTION
 void lv_example_lodepng_1(void)
 {
     LV_IMAGE_DECLARE(img_wink_png);
diff --git a/examples/libs/qrcode/lv_example_qrcode_1.c b/examples/libs/qrcode/lv_example_qrcode_1.c
index 3a9f87ce6..f0d404a89 100644
--- a/examples/libs/qrcode/lv_example_qrcode_1.c
+++ b/examples/libs/qrcode/lv_example_qrcode_1.c
@@ -5,6 +5,7 @@
 /**
  * Create a QR Code
  */
+LV_FUNC_SECTION
 void lv_example_qrcode_1(void)
 {
     lv_color_t bg_color = lv_palette_lighten(LV_PALETTE_LIGHT_BLUE, 5);
diff --git a/examples/libs/rlottie/lv_example_rlottie_1.c b/examples/libs/rlottie/lv_example_rlottie_1.c
index 71f01398e..24849a143 100644
--- a/examples/libs/rlottie/lv_example_rlottie_1.c
+++ b/examples/libs/rlottie/lv_example_rlottie_1.c
@@ -5,6 +5,7 @@
 /**
  * Load an lottie animation from flash
  */
+LV_FUNC_SECTION
 void lv_example_rlottie_1(void)
 {
     extern const uint8_t lv_example_rlottie_approve[];
@@ -13,6 +14,7 @@ void lv_example_rlottie_1(void)
 }
 
 #else
+LV_FUNC_SECTION
 void lv_example_rlottie_1(void)
 {
     /*TODO
diff --git a/examples/libs/rlottie/lv_example_rlottie_2.c b/examples/libs/rlottie/lv_example_rlottie_2.c
index 5c610ab5e..1415d1ff6 100644
--- a/examples/libs/rlottie/lv_example_rlottie_2.c
+++ b/examples/libs/rlottie/lv_example_rlottie_2.c
@@ -5,6 +5,7 @@
 /**
  * Load an lottie animation from file
  */
+LV_FUNC_SECTION
 void lv_example_rlottie_2(void)
 {
     /*The rlottie library uses STDIO file API, so there is no driver letter for LVGL*/
@@ -14,6 +15,7 @@ void lv_example_rlottie_2(void)
 }
 
 #else
+LV_FUNC_SECTION
 void lv_example_rlottie_2(void)
 {
     /*TODO
diff --git a/examples/libs/tiny_ttf/lv_example_tiny_ttf_1.c b/examples/libs/tiny_ttf/lv_example_tiny_ttf_1.c
index adbeca2d6..b05d53cc0 100644
--- a/examples/libs/tiny_ttf/lv_example_tiny_ttf_1.c
+++ b/examples/libs/tiny_ttf/lv_example_tiny_ttf_1.c
@@ -4,6 +4,7 @@
 /**
  * Load a font with Tiny_TTF
  */
+LV_FUNC_SECTION
 void lv_example_tiny_ttf_1(void)
 {
     extern const uint8_t ubuntu_font[];
diff --git a/examples/libs/tiny_ttf/lv_example_tiny_ttf_2.c b/examples/libs/tiny_ttf/lv_example_tiny_ttf_2.c
index 3133b955e..7d7c0bc68 100644
--- a/examples/libs/tiny_ttf/lv_example_tiny_ttf_2.c
+++ b/examples/libs/tiny_ttf/lv_example_tiny_ttf_2.c
@@ -4,6 +4,7 @@
 /**
  * Load a font with Tiny_TTF from file
  */
+LV_FUNC_SECTION
 void lv_example_tiny_ttf_2(void)
 {
     /*Create style with the new font*/
diff --git a/examples/libs/tiny_ttf/lv_example_tiny_ttf_3.c b/examples/libs/tiny_ttf/lv_example_tiny_ttf_3.c
index af52a09e9..a1b64945e 100644
--- a/examples/libs/tiny_ttf/lv_example_tiny_ttf_3.c
+++ b/examples/libs/tiny_ttf/lv_example_tiny_ttf_3.c
@@ -8,6 +8,7 @@ static lv_subject_t subject_font;
 /**
  * Change font size with Tiny_TTF
  */
+LV_FUNC_SECTION
 void lv_example_tiny_ttf_3(void)
 {
     extern const uint8_t ubuntu_font[];
@@ -42,6 +43,7 @@ void lv_example_tiny_ttf_3(void)
     lv_subject_add_observer(&subject_font, font_size_observer_cb, &style);
 }
 
+__attribute__(( fptrgroup("lv_observer_cb") ))
 static void font_size_observer_cb(lv_observer_t * observer, lv_subject_t * subject)
 {
     lv_style_t * style = lv_observer_get_user_data(observer);
diff --git a/examples/libs/tjpgd/lv_example_tjpgd_1.c b/examples/libs/tjpgd/lv_example_tjpgd_1.c
index be6256761..697c5e8eb 100644
--- a/examples/libs/tjpgd/lv_example_tjpgd_1.c
+++ b/examples/libs/tjpgd/lv_example_tjpgd_1.c
@@ -4,6 +4,7 @@
 /**
  * Load a JPG image
  */
+LV_FUNC_SECTION
 void lv_example_tjpgd_1(void)
 {
     lv_obj_t * wp;
diff --git a/examples/others/file_explorer/lv_example_file_explorer_1.c b/examples/others/file_explorer/lv_example_file_explorer_1.c
index 9145cd361..58766464b 100644
--- a/examples/others/file_explorer/lv_example_file_explorer_1.c
+++ b/examples/others/file_explorer/lv_example_file_explorer_1.c
@@ -6,6 +6,7 @@
 #include <stdlib.h>
 #include <string.h>
 
+__attribute__(( fptrgroup("lv_event_cb") ))
 static void file_explorer_event_handler(lv_event_t * e)
 {
     lv_event_code_t code = lv_event_get_code(e);
@@ -18,6 +19,7 @@ static void file_explorer_event_handler(lv_event_t * e)
     }
 }
 
+LV_FUNC_SECTION
 void lv_example_file_explorer_1(void)
 {
     lv_obj_t * file_explorer = lv_file_explorer_create(lv_screen_active());
diff --git a/examples/others/file_explorer/lv_example_file_explorer_2.c b/examples/others/file_explorer/lv_example_file_explorer_2.c
index 082635a6d..cd455fcb2 100644
--- a/examples/others/file_explorer/lv_example_file_explorer_2.c
+++ b/examples/others/file_explorer/lv_example_file_explorer_2.c
@@ -6,6 +6,7 @@
 #include <stdlib.h>
 #include <string.h>
 
+__attribute__(( fptrgroup("lv_event_cb") ))
 static void file_explorer_event_handler(lv_event_t * e)
 {
     lv_event_code_t code = lv_event_get_code(e);
@@ -19,6 +20,7 @@ static void file_explorer_event_handler(lv_event_t * e)
     }
 }
 
+__attribute__(( fptrgroup("lv_event_cb") ))
 static void btn_event_handler(lv_event_t * e)
 {
     lv_event_code_t code = lv_event_get_code(e);
@@ -33,6 +35,7 @@ static void btn_event_handler(lv_event_t * e)
     }
 }
 
+__attribute__(( fptrgroup("lv_event_cb") ))
 static void dd_event_handler(lv_event_t * e)
 {
     lv_event_code_t code = lv_event_get_code(e);
@@ -51,6 +54,7 @@ static void dd_event_handler(lv_event_t * e)
     }
 }
 
+LV_FUNC_SECTION
 void lv_example_file_explorer_2(void)
 {
     lv_obj_t * file_explorer = lv_file_explorer_create(lv_screen_active());
diff --git a/examples/others/file_explorer/lv_example_file_explorer_3.c b/examples/others/file_explorer/lv_example_file_explorer_3.c
index 7dea32c04..acde6f4bf 100644
--- a/examples/others/file_explorer/lv_example_file_explorer_3.c
+++ b/examples/others/file_explorer/lv_example_file_explorer_3.c
@@ -6,6 +6,7 @@
 #include <stdlib.h>
 #include <string.h>
 
+LV_FUNC_SECTION
 static void exch_table_item(lv_obj_t * tb, int16_t i, int16_t j)
 {
     const char * tmp;
@@ -21,6 +22,7 @@ static void exch_table_item(lv_obj_t * tb, int16_t i, int16_t j)
 }
 
 /*Quick sort 3 way*/
+LV_FUNC_SECTION
 static void sort_by_file_kind(lv_obj_t * tb, int16_t lo, int16_t hi)
 {
     if(lo >= hi) return;
@@ -42,6 +44,7 @@ static void sort_by_file_kind(lv_obj_t * tb, int16_t lo, int16_t hi)
     sort_by_file_kind(tb, gt + 1, hi);
 }
 
+__attribute__(( fptrgroup("lv_event_cb") ))
 static void file_explorer_event_handler(lv_event_t * e)
 {
     lv_event_code_t code = lv_event_get_code(e);
@@ -61,6 +64,7 @@ static void file_explorer_event_handler(lv_event_t * e)
     }
 }
 
+LV_FUNC_SECTION
 void lv_example_file_explorer_3(void)
 {
     lv_obj_t * file_explorer = lv_file_explorer_create(lv_screen_active());
diff --git a/examples/others/fragment/lv_example_fragment_1.c b/examples/others/fragment/lv_example_fragment_1.c
index cb3470a01..90f2d4b77 100644
--- a/examples/others/fragment/lv_example_fragment_1.c
+++ b/examples/others/fragment/lv_example_fragment_1.c
@@ -25,6 +25,7 @@ static const lv_fragment_class_t sample_cls = {
     .instance_size = sizeof(struct sample_fragment_t),
     };
 
+LV_FUNC_SECTION
 void lv_example_fragment_1(void)
 {
     root = lv_obj_create(lv_screen_active());
@@ -37,11 +38,13 @@ void lv_example_fragment_1(void)
     lv_fragment_manager_replace(manager, fragment, &root);
 }
 
+__attribute__(( fptrgroup("lv_fragment_constructor_cb") ))
 static void sample_fragment_ctor(lv_fragment_t * self, void * args)
 {
     ((struct sample_fragment_t *) self)->name = args;
 }
 
+__attribute__(( fptrgroup("lv_fragment_create_obj_cb") ))
 static lv_obj_t * sample_fragment_create_obj(lv_fragment_t * self, lv_obj_t * parent)
 {
     lv_obj_t * label = lv_label_create(parent);
@@ -50,6 +53,7 @@ static lv_obj_t * sample_fragment_create_obj(lv_fragment_t * self, lv_obj_t * pa
     return label;
 }
 
+__attribute__(( fptrgroup("lv_event_cb") ))
 static void sample_container_delete(lv_event_t * e)
 {
     lv_fragment_manager_t * manager = (lv_fragment_manager_t *) lv_event_get_user_data(e);
diff --git a/examples/others/fragment/lv_example_fragment_2.c b/examples/others/fragment/lv_example_fragment_2.c
index d93c31cb0..15d544cc8 100644
--- a/examples/others/fragment/lv_example_fragment_2.c
+++ b/examples/others/fragment/lv_example_fragment_2.c
@@ -33,6 +33,7 @@ static const lv_fragment_class_t sample_cls = {
 
 static lv_obj_t * container = NULL;
 
+LV_FUNC_SECTION
 void lv_example_fragment_2(void)
 {
     lv_obj_t * root = lv_obj_create(lv_screen_active());
@@ -66,6 +67,7 @@ void lv_example_fragment_2(void)
     lv_obj_add_event_cb(pop_btn, sample_pop_click, LV_EVENT_CLICKED, manager);
 }
 
+__attribute__(( fptrgroup("lv_fragment_constructor_cb") ))
 static void sample_fragment_ctor(lv_fragment_t * self, void * args)
 {
     LV_UNUSED(args);
@@ -73,6 +75,7 @@ static void sample_fragment_ctor(lv_fragment_t * self, void * args)
     ((sample_fragment_t *) self)->counter = 0;
 }
 
+__attribute__(( fptrgroup("lv_fragment_create_obj_cb") ))
 static lv_obj_t * sample_fragment_create_obj(lv_fragment_t * self, lv_obj_t * parent)
 {
     sample_fragment_t * fragment = (sample_fragment_t *) self;
@@ -96,6 +99,7 @@ static lv_obj_t * sample_fragment_create_obj(lv_fragment_t * self, lv_obj_t * pa
     return content;
 }
 
+__attribute__(( fptrgroup("lv_event_cb") ))
 static void sample_push_click(lv_event_t * e)
 {
     lv_fragment_manager_t * manager = (lv_fragment_manager_t *) lv_event_get_user_data(e);
@@ -104,18 +108,21 @@ static void sample_push_click(lv_event_t * e)
     lv_fragment_manager_push(manager, fragment, &container);
 }
 
+__attribute__(( fptrgroup("lv_event_cb") ))
 static void sample_pop_click(lv_event_t * e)
 {
     lv_fragment_manager_t * manager = (lv_fragment_manager_t *) lv_event_get_user_data(e);
     lv_fragment_manager_pop(manager);
 }
 
+LV_FUNC_SECTION
 static void sample_container_delete(lv_event_t * e)
 {
     lv_fragment_manager_t * manager = (lv_fragment_manager_t *) lv_event_get_user_data(e);
     lv_fragment_manager_delete(manager);
 }
 
+__attribute__(( fptrgroup("lv_event_cb") ))
 static void sample_fragment_inc_click(lv_event_t * e)
 {
     sample_fragment_t * fragment = (sample_fragment_t *) lv_event_get_user_data(e);
diff --git a/examples/others/gridnav/lv_example_gridnav_1.c b/examples/others/gridnav/lv_example_gridnav_1.c
index 17dafccb6..82bdc1636 100644
--- a/examples/others/gridnav/lv_example_gridnav_1.c
+++ b/examples/others/gridnav/lv_example_gridnav_1.c
@@ -4,6 +4,7 @@
 /**
  * Demonstrate a a basic grid navigation
  */
+LV_FUNC_SECTION
 void lv_example_gridnav_1(void)
 {
     /*It's assumed that the default group is set and
diff --git a/examples/others/gridnav/lv_example_gridnav_2.c b/examples/others/gridnav/lv_example_gridnav_2.c
index 8ce001334..aa52a563b 100644
--- a/examples/others/gridnav/lv_example_gridnav_2.c
+++ b/examples/others/gridnav/lv_example_gridnav_2.c
@@ -4,6 +4,7 @@
 /**
  * Grid navigation on a list
  */
+LV_FUNC_SECTION
 void lv_example_gridnav_2(void)
 {
     /*It's assumed that the default group is set and
diff --git a/examples/others/gridnav/lv_example_gridnav_3.c b/examples/others/gridnav/lv_example_gridnav_3.c
index e8c3dbf07..f3a878dbd 100644
--- a/examples/others/gridnav/lv_example_gridnav_3.c
+++ b/examples/others/gridnav/lv_example_gridnav_3.c
@@ -1,6 +1,7 @@
 #include "../../lv_examples.h"
 #if LV_USE_GRIDNAV && LV_USE_FLEX && LV_BUILD_EXAMPLES
 
+__attribute__(( fptrgroup("lv_event_cb") ))
 static void cont_sub_event_cb(lv_event_t * e)
 {
     uint32_t k = lv_event_get_key(e);
@@ -17,6 +18,7 @@ static void cont_sub_event_cb(lv_event_t * e)
 /**
  * Nested grid navigations
  */
+LV_FUNC_SECTION
 void lv_example_gridnav_3(void)
 {
     /*It's assumed that the default group is set and
diff --git a/examples/others/gridnav/lv_example_gridnav_4.c b/examples/others/gridnav/lv_example_gridnav_4.c
index 069ba66b7..8a8c0f10e 100644
--- a/examples/others/gridnav/lv_example_gridnav_4.c
+++ b/examples/others/gridnav/lv_example_gridnav_4.c
@@ -1,6 +1,7 @@
 #include "../../lv_examples.h"
 #if LV_USE_GRIDNAV && LV_USE_FLEX && LV_BUILD_EXAMPLES
 
+__attribute__(( fptrgroup("lv_event_cb") ))
 static void event_handler(lv_event_t * e)
 {
     lv_obj_t * obj = lv_event_get_target(e);
@@ -12,6 +13,7 @@ static void event_handler(lv_event_t * e)
 /**
  * Simple navigation on a list widget
  */
+LV_FUNC_SECTION
 void lv_example_gridnav_4(void)
 {
     /*It's assumed that the default group is set and
diff --git a/examples/others/gridnav/lv_example_gridnav_5.c b/examples/others/gridnav/lv_example_gridnav_5.c
index 217daad41..2697d50b3 100644
--- a/examples/others/gridnav/lv_example_gridnav_5.c
+++ b/examples/others/gridnav/lv_example_gridnav_5.c
@@ -7,11 +7,13 @@ static const int32_t opts_counts[] = {6, 10, 3};
 static lv_obj_t * sliders[3];
 static lv_obj_t * rollers[3];
 
+__attribute__(( fptrgroup("lv_event_cb") ))
 static void slider_key_cb(lv_event_t * e)
 {
     uint8_t i = (uint32_t)(uintptr_t)lv_event_get_user_data(e);
     lv_roller_set_selected(rollers[i], lv_slider_get_value(sliders[i]), LV_ANIM_ON);
 }
+__attribute__(( fptrgroup("lv_event_cb") ))
 static void roller_key_cb(lv_event_t * e)
 {
     uint8_t i = (uint32_t)(uintptr_t)lv_event_get_user_data(e);
@@ -21,6 +23,7 @@ static void roller_key_cb(lv_event_t * e)
 /**
  * Grid navigation for only one axis
  */
+LV_FUNC_SECTION
 void lv_example_gridnav_5(void)
 {
     /*It's assumed that the default group is set and
diff --git a/examples/others/ime/lv_example_ime_pinyin_1.c b/examples/others/ime/lv_example_ime_pinyin_1.c
index c706ab599..243e87dd6 100644
--- a/examples/others/ime/lv_example_ime_pinyin_1.c
+++ b/examples/others/ime/lv_example_ime_pinyin_1.c
@@ -1,6 +1,7 @@
 #include "../../lv_examples.h"
 #if LV_USE_LABEL && LV_USE_TEXTAREA && LV_FONT_SIMSUN_16_CJK && LV_USE_IME_PINYIN && LV_BUILD_EXAMPLES
 
+__attribute__(( fptrgroup("lv_event_cb") ))
 static void ta_event_cb(lv_event_t * e)
 {
     lv_event_code_t code = lv_event_get_code(e);
@@ -20,6 +21,7 @@ static void ta_event_cb(lv_event_t * e)
     }
 }
 
+LV_FUNC_SECTION
 void lv_example_ime_pinyin_1(void)
 {
     lv_obj_t * pinyin_ime = lv_ime_pinyin_create(lv_screen_active());
diff --git a/examples/others/ime/lv_example_ime_pinyin_2.c b/examples/others/ime/lv_example_ime_pinyin_2.c
index 1227bfe55..5e616f239 100644
--- a/examples/others/ime/lv_example_ime_pinyin_2.c
+++ b/examples/others/ime/lv_example_ime_pinyin_2.c
@@ -1,6 +1,7 @@
 #include "../../lv_examples.h"
 #if LV_USE_LABEL && LV_USE_TEXTAREA && LV_FONT_SIMSUN_16_CJK && LV_USE_IME_PINYIN && LV_IME_PINYIN_USE_K9_MODE && LV_BUILD_EXAMPLES
 
+__attribute__(( fptrgroup("lv_event_cb") ))
 static void ta_event_cb(lv_event_t * e)
 {
     lv_event_code_t code = lv_event_get_code(e);
@@ -20,6 +21,7 @@ static void ta_event_cb(lv_event_t * e)
     }
 }
 
+LV_FUNC_SECTION
 void lv_example_ime_pinyin_2(void)
 {
     lv_obj_t * pinyin_ime = lv_ime_pinyin_create(lv_screen_active());
diff --git a/examples/others/imgfont/lv_example_imgfont_1.c b/examples/others/imgfont/lv_example_imgfont_1.c
index dd103c905..727b01ea9 100644
--- a/examples/others/imgfont/lv_example_imgfont_1.c
+++ b/examples/others/imgfont/lv_example_imgfont_1.c
@@ -3,6 +3,7 @@
 #if LV_BUILD_EXAMPLES
 #if LV_USE_IMGFONT
 
+LV_FUNC_SECTION
 static const void * get_imgfont_path(const lv_font_t * font, uint32_t unicode, uint32_t unicode_next,
                                      int32_t * offset_y, void * user_data)
 {
@@ -32,6 +33,7 @@ static const void * get_imgfont_path(const lv_font_t * font, uint32_t unicode, u
 /**
  * draw img in label or span obj
  */
+LV_FUNC_SECTION
 void lv_example_imgfont_1(void)
 {
     lv_font_t * imgfont = lv_imgfont_create(80, get_imgfont_path, NULL);
@@ -49,6 +51,7 @@ void lv_example_imgfont_1(void)
 }
 #else
 
+LV_FUNC_SECTION
 void lv_example_imgfont_1(void)
 {
     lv_obj_t * label = lv_label_create(lv_screen_active());
diff --git a/examples/others/monkey/lv_example_monkey_1.c b/examples/others/monkey/lv_example_monkey_1.c
index a38c6b4fa..0a14e3d08 100644
--- a/examples/others/monkey/lv_example_monkey_1.c
+++ b/examples/others/monkey/lv_example_monkey_1.c
@@ -1,6 +1,7 @@
 #include "../../lv_examples.h"
 #if LV_USE_MONKEY && LV_BUILD_EXAMPLES
 
+LV_FUNC_SECTION
 void lv_example_monkey_1(void)
 {
     /*Create pointer monkey test*/
diff --git a/examples/others/monkey/lv_example_monkey_2.c b/examples/others/monkey/lv_example_monkey_2.c
index c86411413..d9f7c3938 100644
--- a/examples/others/monkey/lv_example_monkey_2.c
+++ b/examples/others/monkey/lv_example_monkey_2.c
@@ -1,6 +1,7 @@
 #include "../../lv_examples.h"
 #if LV_USE_MONKEY && LV_BUILD_EXAMPLES
 
+LV_FUNC_SECTION
 void lv_example_monkey_2(void)
 {
     /*Create encoder monkey test*/
diff --git a/examples/others/monkey/lv_example_monkey_3.c b/examples/others/monkey/lv_example_monkey_3.c
index c4329834f..40605c05f 100644
--- a/examples/others/monkey/lv_example_monkey_3.c
+++ b/examples/others/monkey/lv_example_monkey_3.c
@@ -1,6 +1,7 @@
 #include "../../lv_examples.h"
 #if LV_USE_MONKEY && LV_BUILD_EXAMPLES
 
+LV_FUNC_SECTION
 void lv_example_monkey_3(void)
 {
     static lv_point_t btn_points[3];
diff --git a/examples/others/observer/lv_example_observer_1.c b/examples/others/observer/lv_example_observer_1.c
index 332e8a5dc..52164c45f 100644
--- a/examples/others/observer/lv_example_observer_1.c
+++ b/examples/others/observer/lv_example_observer_1.c
@@ -6,6 +6,7 @@ static lv_subject_t temperature_subject;
 /**
  * A slider sends a message on value change and a label display's that value
  */
+LV_FUNC_SECTION
 void lv_example_observer_1(void)
 {
     lv_subject_init_int(&temperature_subject, 28);
diff --git a/examples/others/observer/lv_example_observer_2.c b/examples/others/observer/lv_example_observer_2.c
index fdd23f0f8..19a91281c 100644
--- a/examples/others/observer/lv_example_observer_2.c
+++ b/examples/others/observer/lv_example_observer_2.c
@@ -11,6 +11,7 @@ static void ui_init(void);
  * Simple PIN login screen to start an engine.
  * The only interface between the UI and the application is a single "subject".
  */
+LV_FUNC_SECTION
 void lv_example_observer_2(void)
 {
     lv_subject_init_int(&engine_subject, 0);
@@ -25,6 +26,7 @@ void lv_example_observer_2(void)
  * It doesn't know anything about the internals of the UI
  * and uses any the `engine_subject` as an interface.
  * -------------------------------------------------*/
+__attribute__(( fptrgroup("lv_observer_cb") ))
 static void engine_state_observer_cb(lv_observer_t * observer, lv_subject_t * subject)
 {
     LV_UNUSED(observer);
@@ -35,6 +37,7 @@ static void engine_state_observer_cb(lv_observer_t * observer, lv_subject_t * su
     LV_LOG_USER("Engine state: %" LV_PRId32, v);
 }
 
+LV_FUNC_SECTION
 static void app_init(void)
 {
     lv_subject_add_observer(&engine_subject, engine_state_observer_cb, NULL);
@@ -56,6 +59,7 @@ typedef enum {
 
 static lv_subject_t auth_state_subject;
 
+__attribute__(( fptrgroup("lv_event_cb") ))
 static void textarea_event_cb(lv_event_t * e)
 {
     lv_obj_t * ta = lv_event_get_target(e);
@@ -67,6 +71,7 @@ static void textarea_event_cb(lv_event_t * e)
     }
 }
 
+__attribute__(( fptrgroup("lv_observer_cb") ))
 static void info_label_observer_cb(lv_observer_t * observer, lv_subject_t * subject)
 {
     lv_obj_t * label = lv_observer_get_target(observer);
@@ -83,12 +88,14 @@ static void info_label_observer_cb(lv_observer_t * observer, lv_subject_t * subj
     }
 }
 
+__attribute__(( fptrgroup("lv_event_cb") ))
 static void log_out_click_event_cb(lv_event_t * e)
 {
     LV_UNUSED(e);
     lv_subject_set_int(&auth_state_subject, LOGGED_OUT);
 }
 
+LV_FUNC_SECTION
 static void ui_init(void)
 {
     lv_subject_init_int(&auth_state_subject, LOGGED_OUT);
diff --git a/examples/others/observer/lv_example_observer_3.c b/examples/others/observer/lv_example_observer_3.c
index 029bbf3e3..a1d18cff0 100644
--- a/examples/others/observer/lv_example_observer_3.c
+++ b/examples/others/observer/lv_example_observer_3.c
@@ -35,6 +35,7 @@ typedef enum {
  * In this example the widgets to set the time are create/deleted dynamically,
  * yet they always know what the current values are by using subjects.
  */
+LV_FUNC_SECTION
 void lv_example_observer_3(void)
 {
     /*Initialize the subjects.
@@ -66,6 +67,7 @@ void lv_example_observer_3(void)
     lv_subject_set_int(&am_pm_subject, TIME_PM);
 }
 
+__attribute__(( fptrgroup("lv_event_cb") ))
 static void set_btn_clicked_event_cb(lv_event_t * e)
 {
     lv_obj_t * set_btn = lv_event_get_target(e);
@@ -108,6 +110,7 @@ static void set_btn_clicked_event_cb(lv_event_t * e)
     lv_label_set_text(close_label, LV_SYMBOL_CLOSE);
 }
 
+__attribute__(( fptrgroup("lv_event_cb") ))
 static void close_clicked_event_cb(lv_event_t * e)
 {
     lv_obj_t * set_btn = lv_event_get_user_data(e);
@@ -118,6 +121,7 @@ static void close_clicked_event_cb(lv_event_t * e)
 }
 
 /*Watch all related subject to display the current time correctly*/
+__attribute__(( fptrgroup("lv_observer_cb") ))
 static void time_observer_cb(lv_observer_t * observer, lv_subject_t * subject)
 {
     int32_t hour = lv_subject_get_int(lv_subject_get_group_element(subject, 0));
@@ -136,6 +140,7 @@ static void time_observer_cb(lv_observer_t * observer, lv_subject_t * subject)
 }
 
 /*Change the hour options on format change*/
+LV_FUNC_SECTION
 static void hour_roller_options_update(lv_observer_t * observer, lv_subject_t * subject)
 {
     lv_obj_t * roller = lv_observer_get_target(observer);
diff --git a/examples/others/observer/lv_example_observer_4.c b/examples/others/observer/lv_example_observer_4.c
index 934a3f5b0..02905d71c 100644
--- a/examples/others/observer/lv_example_observer_4.c
+++ b/examples/others/observer/lv_example_observer_4.c
@@ -12,6 +12,7 @@ static lv_subject_t slider_subject[4];
 static lv_subject_t dropdown_subject[3];
 static lv_subject_t roller_subject[2];
 
+LV_FUNC_SECTION
 void lv_example_observer_4(void)
 {
     lv_subject_init_int(&current_tab_subject, 0);
@@ -64,16 +65,19 @@ void lv_example_observer_4(void)
     lv_subject_notify(&current_tab_subject);
 }
 
+__attribute__(( fptrgroup("lv_anim_exec_cb") ))
 static int32_t anim_get_x_cb(lv_anim_t * a)
 {
     return lv_obj_get_x_aligned(a->var);
 }
 
+__attribute__(( fptrgroup("lv_anim_exec_cb") ))
 static void anim_set_x_cb(void * obj, int32_t v)
 {
     lv_obj_set_x(obj, v);
 }
 
+__attribute__(( fptrgroup("lv_observer_cb") ))
 static void cont_observer_cb(lv_observer_t * observer, lv_subject_t * subject)
 {
     int32_t prev_v = lv_subject_get_previous_int(subject);
@@ -149,6 +153,7 @@ static void cont_observer_cb(lv_observer_t * observer, lv_subject_t * subject)
 
 }
 
+LV_FUNC_SECTION
 static void btn_create(lv_obj_t * parent, const char * text)
 {
     lv_obj_t * btn = lv_button_create(parent);
@@ -163,6 +168,7 @@ static void btn_create(lv_obj_t * parent, const char * text)
     lv_obj_center(label);
 }
 
+__attribute__(( fptrgroup("lv_event_cb") ))
 static void btn_click_event_cb(lv_event_t * e)
 {
     lv_obj_t * btn = lv_event_get_target(e);
@@ -170,6 +176,7 @@ static void btn_click_event_cb(lv_event_t * e)
     lv_subject_set_int(&current_tab_subject, idx);
 }
 
+__attribute__(( fptrgroup("lv_observer_cb") ))
 static void btn_observer_cb(lv_observer_t * observer, lv_subject_t * subject)
 {
     int32_t prev_v = lv_subject_get_previous_int(subject);
@@ -182,6 +189,7 @@ static void btn_observer_cb(lv_observer_t * observer, lv_subject_t * subject)
     if(idx == cur_v) lv_obj_add_state(btn, LV_STATE_CHECKED);
 }
 
+__attribute__(( fptrgroup("lv_observer_cb") ))
 static void indicator_observer_cb(lv_observer_t * observer, lv_subject_t * subject)
 {
     int32_t cur_v = lv_subject_get_int(subject);
diff --git a/examples/others/observer/lv_example_observer_5.c b/examples/others/observer/lv_example_observer_5.c
index 47ea4eefa..3bdca0fd6 100644
--- a/examples/others/observer/lv_example_observer_5.c
+++ b/examples/others/observer/lv_example_observer_5.c
@@ -25,6 +25,7 @@ static lv_subject_t fw_update_status_subject;
  *   - the UI needs to wait for the App (connecting or downloading)
  * With observers these complex mechanisms can be implemented a simple and clean way.
  */
+LV_FUNC_SECTION
 void lv_example_observer_5(void)
 {
     lv_subject_init_int(&fw_download_percent_subject, 0);
@@ -40,6 +41,7 @@ void lv_example_observer_5(void)
     lv_label_set_text(label, "Firmware update");
 }
 
+LV_FUNC_SECTION
 static void fw_update_btn_clicked_event_cb(lv_event_t * e)
 {
     LV_UNUSED(e);
@@ -60,12 +62,14 @@ static void fw_update_btn_clicked_event_cb(lv_event_t * e)
     lv_subject_add_observer_obj(&fw_update_status_subject, fw_update_win_observer_cb, win, NULL);
 }
 
+LV_FUNC_SECTION
 static void fw_update_close_event_cb(lv_event_t * e)
 {
     LV_UNUSED(e);
     lv_subject_set_int(&fw_update_status_subject, FW_UPDATE_STATE_CANCEL);
 }
 
+LV_FUNC_SECTION
 static void restart_btn_click_event_cb(lv_event_t * e)
 {
     lv_obj_t * win = lv_event_get_user_data(e);
@@ -73,6 +77,7 @@ static void restart_btn_click_event_cb(lv_event_t * e)
     lv_subject_set_int(&fw_update_status_subject, FW_UPDATE_STATE_IDLE);
 }
 
+LV_FUNC_SECTION
 static void fw_update_win_observer_cb(lv_observer_t * observer, lv_subject_t * subject)
 {
     lv_obj_t * win = lv_observer_get_target(observer);
@@ -120,6 +125,7 @@ static void fw_update_win_observer_cb(lv_observer_t * observer, lv_subject_t * s
     }
 }
 
+LV_FUNC_SECTION
 static void connect_timer_cb(lv_timer_t * t)
 {
     if(lv_subject_get_int(&fw_update_status_subject) != FW_UPDATE_STATE_CANCEL) {
@@ -128,6 +134,7 @@ static void connect_timer_cb(lv_timer_t * t)
     lv_timer_delete(t);
 }
 
+LV_FUNC_SECTION
 static void download_timer_cb(lv_timer_t * t)
 {
     if(lv_subject_get_int(&fw_update_status_subject) == FW_UPDATE_STATE_CANCEL) {
@@ -148,6 +155,7 @@ static void download_timer_cb(lv_timer_t * t)
 /**
  * Emulate connection and FW downloading by timers
  */
+LV_FUNC_SECTION
 static void fw_upload_manager_observer_cb(lv_observer_t * observer, lv_subject_t * subject)
 {
     LV_UNUSED(subject);
diff --git a/examples/others/observer/lv_example_observer_6.c b/examples/others/observer/lv_example_observer_6.c
index f6926aad4..f2ab90549 100644
--- a/examples/others/observer/lv_example_observer_6.c
+++ b/examples/others/observer/lv_example_observer_6.c
@@ -15,6 +15,7 @@ static lv_subject_t theme_subject;
 /**
  * Change between light and dark mode
  */
+LV_FUNC_SECTION
 void lv_example_observer_6(void)
 {
     lv_subject_init_int(&theme_subject, THEME_MODE_DARK);
@@ -37,6 +38,7 @@ void lv_example_observer_6(void)
     my_button_create(panel1, "Button 10", switch_theme_event_cb);
 }
 
+LV_FUNC_SECTION
 static void switch_theme_event_cb(lv_event_t * e)
 {
     LV_UNUSED(e);
@@ -56,6 +58,7 @@ typedef struct {
     lv_style_t style_scrollbar;
 } my_panel_styles_t;
 
+LV_FUNC_SECTION
 static void my_panel_style_observer_cb(lv_observer_t * observer, lv_subject_t * subject)
 {
     LV_UNUSED(subject);
@@ -80,6 +83,7 @@ static void my_panel_style_observer_cb(lv_observer_t * observer, lv_subject_t *
     lv_obj_report_style_change(&styles->style_scrollbar);
 }
 
+LV_FUNC_SECTION
 static lv_obj_t * my_panel_create(lv_obj_t * parent)
 {
     static bool inited = false;
@@ -126,6 +130,7 @@ typedef struct {
     lv_style_t style_pressed;
 } my_button_styles_t;
 
+LV_FUNC_SECTION
 static void my_button_style_observer_cb(lv_observer_t * observer, lv_subject_t * subject)
 {
     LV_UNUSED(subject);
@@ -154,6 +159,7 @@ static void my_button_style_observer_cb(lv_observer_t * observer, lv_subject_t *
     lv_obj_report_style_change(&styles->style_pressed);
 }
 
+LV_FUNC_SECTION
 static lv_obj_t * my_button_create(lv_obj_t * parent, const char * text, lv_event_cb_t event_cb)
 {
     static bool inited = false;
diff --git a/examples/others/snapshot/lv_example_snapshot_1.c b/examples/others/snapshot/lv_example_snapshot_1.c
index f659cae4f..e1970cb81 100644
--- a/examples/others/snapshot/lv_example_snapshot_1.c
+++ b/examples/others/snapshot/lv_example_snapshot_1.c
@@ -1,6 +1,7 @@
 #include "../../lv_examples.h"
 #if LV_USE_SNAPSHOT && LV_BUILD_EXAMPLES
 
+LV_FUNC_SECTION
 static void event_cb(lv_event_t * e)
 {
     lv_obj_t * snapshot_obj = lv_event_get_user_data(e);
@@ -20,6 +21,7 @@ static void event_cb(lv_event_t * e)
     }
 }
 
+LV_FUNC_SECTION
 void lv_example_snapshot_1(void)
 {
     LV_IMAGE_DECLARE(img_star);
diff --git a/examples/porting/osal/lv_example_osal.c b/examples/porting/osal/lv_example_osal.c
index 6e8e07e83..b3e4a1c94 100644
--- a/examples/porting/osal/lv_example_osal.c
+++ b/examples/porting/osal/lv_example_osal.c
@@ -38,6 +38,7 @@ static lv_thread_t increment_thread;
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 void lv_example_osal(void)
 {
     lv_obj_t * counter_button;
@@ -59,6 +60,7 @@ void lv_example_osal(void)
  *   STATIC FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 static void counter_button_event_cb(lv_event_t * e)
 {
     LV_UNUSED(e);
@@ -67,6 +69,7 @@ static void counter_button_event_cb(lv_event_t * e)
     }
 }
 
+LV_FUNC_SECTION
 static void increment_thread_entry(void * user_data)
 {
     LV_UNUSED(user_data);
diff --git a/examples/scroll/lv_example_scroll_1.c b/examples/scroll/lv_example_scroll_1.c
index 18941305a..6cfe20f30 100644
--- a/examples/scroll/lv_example_scroll_1.c
+++ b/examples/scroll/lv_example_scroll_1.c
@@ -4,6 +4,7 @@
 /**
  * Demonstrate how scrolling appears automatically
  */
+LV_FUNC_SECTION
 void lv_example_scroll_1(void)
 {
     /*Create an object with the new style*/
diff --git a/examples/scroll/lv_example_scroll_2.c b/examples/scroll/lv_example_scroll_2.c
index 13385c235..3323928be 100644
--- a/examples/scroll/lv_example_scroll_2.c
+++ b/examples/scroll/lv_example_scroll_2.c
@@ -1,6 +1,7 @@
 #include "../lv_examples.h"
 #if LV_BUILD_EXAMPLES && LV_USE_FLEX
 
+LV_FUNC_SECTION
 static void sw_event_cb(lv_event_t * e)
 {
     lv_event_code_t code = lv_event_get_code(e);
@@ -17,6 +18,7 @@ static void sw_event_cb(lv_event_t * e)
 /**
  * Show an example to scroll snap
  */
+LV_FUNC_SECTION
 void lv_example_scroll_2(void)
 {
     lv_obj_t * panel = lv_obj_create(lv_screen_active());
diff --git a/examples/scroll/lv_example_scroll_3.c b/examples/scroll/lv_example_scroll_3.c
index 8181c4349..23027efab 100644
--- a/examples/scroll/lv_example_scroll_3.c
+++ b/examples/scroll/lv_example_scroll_3.c
@@ -3,6 +3,7 @@
 
 static uint32_t btn_cnt = 1;
 
+LV_FUNC_SECTION
 static void float_button_event_cb(lv_event_t * e)
 {
     lv_event_code_t code = lv_event_get_code(e);
@@ -24,6 +25,7 @@ static void float_button_event_cb(lv_event_t * e)
 /**
  * Create a list with a floating button
  */
+LV_FUNC_SECTION
 void lv_example_scroll_3(void)
 {
     lv_obj_t * list = lv_list_create(lv_screen_active());
diff --git a/examples/scroll/lv_example_scroll_4.c b/examples/scroll/lv_example_scroll_4.c
index f0c741ba3..55cf17af7 100644
--- a/examples/scroll/lv_example_scroll_4.c
+++ b/examples/scroll/lv_example_scroll_4.c
@@ -4,6 +4,7 @@
 /**
  * Styling the scrollbars
  */
+LV_FUNC_SECTION
 void lv_example_scroll_4(void)
 {
     lv_obj_t * obj = lv_obj_create(lv_screen_active());
diff --git a/examples/scroll/lv_example_scroll_5.c b/examples/scroll/lv_example_scroll_5.c
index 5f0b0af71..34bbb2adf 100644
--- a/examples/scroll/lv_example_scroll_5.c
+++ b/examples/scroll/lv_example_scroll_5.c
@@ -4,6 +4,7 @@
 /**
  * Scrolling with Right To Left base direction
  */
+LV_FUNC_SECTION
 void lv_example_scroll_5(void)
 {
     lv_obj_t * obj = lv_obj_create(lv_screen_active());
diff --git a/examples/scroll/lv_example_scroll_6.c b/examples/scroll/lv_example_scroll_6.c
index 66dc60da7..952e581df 100644
--- a/examples/scroll/lv_example_scroll_6.c
+++ b/examples/scroll/lv_example_scroll_6.c
@@ -1,6 +1,7 @@
 #include "../lv_examples.h"
 #if LV_BUILD_EXAMPLES && LV_USE_FLEX
 
+LV_FUNC_SECTION
 static void scroll_event_cb(lv_event_t * e)
 {
     lv_obj_t * cont = lv_event_get_target(e);
@@ -48,6 +49,7 @@ static void scroll_event_cb(lv_event_t * e)
 /**
  * Translate the object as they scroll
  */
+LV_FUNC_SECTION
 void lv_example_scroll_6(void)
 {
     lv_obj_t * cont = lv_obj_create(lv_screen_active());
diff --git a/examples/styles/lv_example_style_1.c b/examples/styles/lv_example_style_1.c
index 073439a6b..03004245e 100644
--- a/examples/styles/lv_example_style_1.c
+++ b/examples/styles/lv_example_style_1.c
@@ -4,6 +4,7 @@
 /**
  * Using the Size, Position and Padding style properties
  */
+LV_FUNC_SECTION
 void lv_example_style_1(void)
 {
     static lv_style_t style;
diff --git a/examples/styles/lv_example_style_10.c b/examples/styles/lv_example_style_10.c
index 8951a759a..8d87184b6 100644
--- a/examples/styles/lv_example_style_10.c
+++ b/examples/styles/lv_example_style_10.c
@@ -4,6 +4,7 @@
 /**
  * Creating a transition
  */
+LV_FUNC_SECTION
 void lv_example_style_10(void)
 {
     static const lv_style_prop_t props[] = {LV_STYLE_BG_COLOR, LV_STYLE_BORDER_COLOR, LV_STYLE_BORDER_WIDTH, 0};
diff --git a/examples/styles/lv_example_style_11.c b/examples/styles/lv_example_style_11.c
index f9f0a5b61..aa19e7e3b 100644
--- a/examples/styles/lv_example_style_11.c
+++ b/examples/styles/lv_example_style_11.c
@@ -4,6 +4,7 @@
 /**
  * Using multiple styles
  */
+LV_FUNC_SECTION
 void lv_example_style_11(void)
 {
     /*A base style*/
diff --git a/examples/styles/lv_example_style_12.c b/examples/styles/lv_example_style_12.c
index e210ef214..aa26c42e6 100644
--- a/examples/styles/lv_example_style_12.c
+++ b/examples/styles/lv_example_style_12.c
@@ -4,6 +4,7 @@
 /**
  * Local styles
  */
+LV_FUNC_SECTION
 void lv_example_style_12(void)
 {
     static lv_style_t style;
diff --git a/examples/styles/lv_example_style_13.c b/examples/styles/lv_example_style_13.c
index 6f506e4d6..274a6508a 100644
--- a/examples/styles/lv_example_style_13.c
+++ b/examples/styles/lv_example_style_13.c
@@ -4,6 +4,7 @@
 /**
  * Add styles to parts and states
  */
+LV_FUNC_SECTION
 void lv_example_style_13(void)
 {
     static lv_style_t style_indic;
diff --git a/examples/styles/lv_example_style_14.c b/examples/styles/lv_example_style_14.c
index 1b14c01c4..18b540df1 100644
--- a/examples/styles/lv_example_style_14.c
+++ b/examples/styles/lv_example_style_14.c
@@ -6,6 +6,7 @@ static lv_style_t style_btn;
 
 /*Will be called when the styles of the base theme are already added
   to add new styles*/
+LV_FUNC_SECTION
 static void new_theme_apply_cb(lv_theme_t * th, lv_obj_t * obj)
 {
     LV_UNUSED(th);
@@ -15,6 +16,7 @@ static void new_theme_apply_cb(lv_theme_t * th, lv_obj_t * obj)
     }
 }
 
+LV_FUNC_SECTION
 static void new_theme_init_and_set(void)
 {
     /*Initialize the styles*/
@@ -39,6 +41,7 @@ static void new_theme_init_and_set(void)
 /**
  * Extending the current theme
  */
+LV_FUNC_SECTION
 void lv_example_style_14(void)
 {
     lv_obj_t * btn;
diff --git a/examples/styles/lv_example_style_15.c b/examples/styles/lv_example_style_15.c
index 09158e6a8..5f1de5ae1 100644
--- a/examples/styles/lv_example_style_15.c
+++ b/examples/styles/lv_example_style_15.c
@@ -4,6 +4,7 @@
 /**
  * Opacity and Transformations
  */
+LV_FUNC_SECTION
 void lv_example_style_15(void)
 {
     lv_obj_t * btn;
diff --git a/examples/styles/lv_example_style_16.c b/examples/styles/lv_example_style_16.c
index 0d4bef68b..807f9e8c5 100644
--- a/examples/styles/lv_example_style_16.c
+++ b/examples/styles/lv_example_style_16.c
@@ -7,6 +7,7 @@
  * Simulate metallic knob using conical gradient
  * For best effect set LV_GRADIENT_MAX_STOPS to 8 or at least 3
  */
+LV_FUNC_SECTION
 void lv_example_style_16(void)
 {
 #if LV_GRADIENT_MAX_STOPS >= 8
@@ -70,6 +71,7 @@ void lv_example_style_16(void)
 
 #else
 
+LV_FUNC_SECTION
 void lv_example_style_16(void)
 {
     lv_obj_t * label = lv_label_create(lv_screen_active());
diff --git a/examples/styles/lv_example_style_17.c b/examples/styles/lv_example_style_17.c
index f4a6f4198..32fa44c2a 100644
--- a/examples/styles/lv_example_style_17.c
+++ b/examples/styles/lv_example_style_17.c
@@ -6,6 +6,7 @@
 /**
  * Using radial gradient as background
  */
+LV_FUNC_SECTION
 void lv_example_style_17(void)
 {
     static const lv_color_t grad_colors[2] = {
@@ -39,6 +40,7 @@ void lv_example_style_17(void)
 
 #else
 
+LV_FUNC_SECTION
 void lv_example_style_17(void)
 {
     lv_obj_t * label = lv_label_create(lv_screen_active());
diff --git a/examples/styles/lv_example_style_18.c b/examples/styles/lv_example_style_18.c
index 21e5c9ea2..fd6272720 100644
--- a/examples/styles/lv_example_style_18.c
+++ b/examples/styles/lv_example_style_18.c
@@ -6,6 +6,7 @@
 /**
  * Using various gradients for button background
  */
+LV_FUNC_SECTION
 void lv_example_style_18(void)
 {
     static const lv_color_t grad_colors[2] = {
@@ -85,6 +86,7 @@ void lv_example_style_18(void)
 
 #else
 
+LV_FUNC_SECTION
 void lv_example_style_18(void)
 {
     lv_obj_t * label = lv_label_create(lv_screen_active());
diff --git a/examples/styles/lv_example_style_2.c b/examples/styles/lv_example_style_2.c
index 8376e5f17..b5f100d65 100644
--- a/examples/styles/lv_example_style_2.c
+++ b/examples/styles/lv_example_style_2.c
@@ -4,6 +4,7 @@
 /**
  * Using the background style properties
  */
+LV_FUNC_SECTION
 void lv_example_style_2(void)
 {
     static lv_style_t style;
diff --git a/examples/styles/lv_example_style_3.c b/examples/styles/lv_example_style_3.c
index 0a1dea82d..72b740a28 100644
--- a/examples/styles/lv_example_style_3.c
+++ b/examples/styles/lv_example_style_3.c
@@ -4,6 +4,7 @@
 /**
  * Using the border style properties
  */
+LV_FUNC_SECTION
 void lv_example_style_3(void)
 {
     static lv_style_t style;
diff --git a/examples/styles/lv_example_style_4.c b/examples/styles/lv_example_style_4.c
index a69be3927..82059c073 100644
--- a/examples/styles/lv_example_style_4.c
+++ b/examples/styles/lv_example_style_4.c
@@ -4,6 +4,7 @@
 /**
  * Using the outline style properties
  */
+LV_FUNC_SECTION
 void lv_example_style_4(void)
 {
     static lv_style_t style;
diff --git a/examples/styles/lv_example_style_5.c b/examples/styles/lv_example_style_5.c
index c25a94154..a094cf3cc 100644
--- a/examples/styles/lv_example_style_5.c
+++ b/examples/styles/lv_example_style_5.c
@@ -4,6 +4,7 @@
 /**
  * Using the Shadow style properties
  */
+LV_FUNC_SECTION
 void lv_example_style_5(void)
 {
     static lv_style_t style;
diff --git a/examples/styles/lv_example_style_6.c b/examples/styles/lv_example_style_6.c
index 59d569269..d348acd00 100644
--- a/examples/styles/lv_example_style_6.c
+++ b/examples/styles/lv_example_style_6.c
@@ -4,6 +4,7 @@
 /**
  * Using the Image style properties
  */
+LV_FUNC_SECTION
 void lv_example_style_6(void)
 {
     static lv_style_t style;
diff --git a/examples/styles/lv_example_style_7.c b/examples/styles/lv_example_style_7.c
index 146fd9844..7f9711cc4 100644
--- a/examples/styles/lv_example_style_7.c
+++ b/examples/styles/lv_example_style_7.c
@@ -4,6 +4,7 @@
 /**
  * Using the Arc style properties
  */
+LV_FUNC_SECTION
 void lv_example_style_7(void)
 {
     static lv_style_t style;
diff --git a/examples/styles/lv_example_style_8.c b/examples/styles/lv_example_style_8.c
index 853daf406..47d657061 100644
--- a/examples/styles/lv_example_style_8.c
+++ b/examples/styles/lv_example_style_8.c
@@ -4,6 +4,7 @@
 /**
  * Using the text style properties
  */
+LV_FUNC_SECTION
 void lv_example_style_8(void)
 {
     static lv_style_t style;
diff --git a/examples/styles/lv_example_style_9.c b/examples/styles/lv_example_style_9.c
index 684f631a1..3f1b03da1 100644
--- a/examples/styles/lv_example_style_9.c
+++ b/examples/styles/lv_example_style_9.c
@@ -4,6 +4,7 @@
 /**
  * Using the line style properties
  */
+LV_FUNC_SECTION
 void lv_example_style_9(void)
 {
     static lv_style_t style;
diff --git a/examples/widgets/animimg/lv_example_animimg_1.c b/examples/widgets/animimg/lv_example_animimg_1.c
index 8b8d68b47..e98183480 100644
--- a/examples/widgets/animimg/lv_example_animimg_1.c
+++ b/examples/widgets/animimg/lv_example_animimg_1.c
@@ -10,6 +10,7 @@ static const lv_image_dsc_t * anim_imgs[3] = {
     & animimg003,
 };
 
+LV_FUNC_SECTION
 void lv_example_animimg_1(void)
 {
     lv_obj_t * animimg0 = lv_animimg_create(lv_screen_active());
diff --git a/examples/widgets/arc/lv_example_arc_1.c b/examples/widgets/arc/lv_example_arc_1.c
index ca4093783..c81585783 100644
--- a/examples/widgets/arc/lv_example_arc_1.c
+++ b/examples/widgets/arc/lv_example_arc_1.c
@@ -4,6 +4,7 @@
 
 static void value_changed_event_cb(lv_event_t * e);
 
+LV_FUNC_SECTION
 void lv_example_arc_1(void)
 {
     lv_obj_t * label = lv_label_create(lv_screen_active());
@@ -21,6 +22,7 @@ void lv_example_arc_1(void)
     lv_obj_send_event(arc, LV_EVENT_VALUE_CHANGED, NULL);
 }
 
+LV_FUNC_SECTION
 static void value_changed_event_cb(lv_event_t * e)
 {
     lv_obj_t * arc = lv_event_get_target(e);
diff --git a/examples/widgets/arc/lv_example_arc_2.c b/examples/widgets/arc/lv_example_arc_2.c
index 198545a53..5fb517d03 100644
--- a/examples/widgets/arc/lv_example_arc_2.c
+++ b/examples/widgets/arc/lv_example_arc_2.c
@@ -2,6 +2,7 @@
 
 #if LV_USE_ARC && LV_BUILD_EXAMPLES
 
+LV_FUNC_SECTION
 static void set_angle(void * obj, int32_t v)
 {
     lv_arc_set_value(obj, v);
@@ -10,6 +11,7 @@ static void set_angle(void * obj, int32_t v)
 /**
  * Create an arc which acts as a loader.
  */
+LV_FUNC_SECTION
 void lv_example_arc_2(void)
 {
     /*Create an Arc*/
diff --git a/examples/widgets/bar/lv_example_bar_1.c b/examples/widgets/bar/lv_example_bar_1.c
index 59a49bd6a..1ee98a374 100644
--- a/examples/widgets/bar/lv_example_bar_1.c
+++ b/examples/widgets/bar/lv_example_bar_1.c
@@ -1,6 +1,7 @@
 #include "../../lv_examples.h"
 #if LV_USE_BAR && LV_BUILD_EXAMPLES
 
+LV_FUNC_SECTION
 void lv_example_bar_1(void)
 {
     lv_obj_t * bar1 = lv_bar_create(lv_screen_active());
diff --git a/examples/widgets/bar/lv_example_bar_2.c b/examples/widgets/bar/lv_example_bar_2.c
index 108022931..1d90cb500 100644
--- a/examples/widgets/bar/lv_example_bar_2.c
+++ b/examples/widgets/bar/lv_example_bar_2.c
@@ -4,6 +4,7 @@
 /**
  * Example of styling the bar
  */
+LV_FUNC_SECTION
 void lv_example_bar_2(void)
 {
     static lv_style_t style_bg;
diff --git a/examples/widgets/bar/lv_example_bar_3.c b/examples/widgets/bar/lv_example_bar_3.c
index af1fa4302..bb473b361 100644
--- a/examples/widgets/bar/lv_example_bar_3.c
+++ b/examples/widgets/bar/lv_example_bar_3.c
@@ -1,6 +1,7 @@
 #include "../../lv_examples.h"
 #if LV_USE_BAR && LV_BUILD_EXAMPLES
 
+LV_FUNC_SECTION
 static void set_temp(void * bar, int32_t temp)
 {
     lv_bar_set_value(bar, temp, LV_ANIM_ON);
@@ -9,6 +10,7 @@ static void set_temp(void * bar, int32_t temp)
 /**
  * A temperature meter example
  */
+LV_FUNC_SECTION
 void lv_example_bar_3(void)
 {
     static lv_style_t style_indic;
diff --git a/examples/widgets/bar/lv_example_bar_4.c b/examples/widgets/bar/lv_example_bar_4.c
index 2a6f4db67..bbfc465a8 100644
--- a/examples/widgets/bar/lv_example_bar_4.c
+++ b/examples/widgets/bar/lv_example_bar_4.c
@@ -4,6 +4,7 @@
 /**
  * Bar with stripe pattern and ranged value
  */
+LV_FUNC_SECTION
 void lv_example_bar_4(void)
 {
     LV_IMAGE_DECLARE(img_skew_strip);
diff --git a/examples/widgets/bar/lv_example_bar_5.c b/examples/widgets/bar/lv_example_bar_5.c
index 75b923505..bcb22d849 100644
--- a/examples/widgets/bar/lv_example_bar_5.c
+++ b/examples/widgets/bar/lv_example_bar_5.c
@@ -4,6 +4,7 @@
 /**
  * Bar with LTR and RTL base direction
  */
+LV_FUNC_SECTION
 void lv_example_bar_5(void)
 {
     lv_obj_t * label;
diff --git a/examples/widgets/bar/lv_example_bar_6.c b/examples/widgets/bar/lv_example_bar_6.c
index ad2e37105..33a9112bb 100644
--- a/examples/widgets/bar/lv_example_bar_6.c
+++ b/examples/widgets/bar/lv_example_bar_6.c
@@ -4,11 +4,13 @@
 #define MAX_VALUE 100
 #define MIN_VALUE 0
 
+LV_FUNC_SECTION
 static void set_value(void * bar, int32_t v)
 {
     lv_bar_set_value(bar, v, LV_ANIM_OFF);
 }
 
+LV_FUNC_SECTION
 static void event_cb(lv_event_t * e)
 {
     lv_obj_t * obj = lv_event_get_target(e);
@@ -53,6 +55,7 @@ static void event_cb(lv_event_t * e)
 /**
  * Custom drawer on the bar to display the current value
  */
+LV_FUNC_SECTION
 void lv_example_bar_6(void)
 {
     lv_obj_t * bar = lv_bar_create(lv_screen_active());
diff --git a/examples/widgets/bar/lv_example_bar_7.c b/examples/widgets/bar/lv_example_bar_7.c
index 86d1e037a..0db993534 100644
--- a/examples/widgets/bar/lv_example_bar_7.c
+++ b/examples/widgets/bar/lv_example_bar_7.c
@@ -4,6 +4,7 @@
 /**
  * Bar with opposite direction
  */
+LV_FUNC_SECTION
 void lv_example_bar_7(void)
 {
     lv_obj_t * label;
diff --git a/examples/widgets/button/lv_example_button_1.c b/examples/widgets/button/lv_example_button_1.c
index eae9c9dab..cfde88ce1 100644
--- a/examples/widgets/button/lv_example_button_1.c
+++ b/examples/widgets/button/lv_example_button_1.c
@@ -1,6 +1,7 @@
 #include "../../lv_examples.h"
 #if LV_USE_BUTTON && LV_BUILD_EXAMPLES
 
+__attribute__(( fptrgroup("lv_event_cb") ))
 static void event_handler(lv_event_t * e)
 {
     lv_event_code_t code = lv_event_get_code(e);
@@ -13,6 +14,7 @@ static void event_handler(lv_event_t * e)
     }
 }
 
+LV_FUNC_SECTION
 void lv_example_button_1(void)
 {
     lv_obj_t * label;
diff --git a/examples/widgets/button/lv_example_button_2.c b/examples/widgets/button/lv_example_button_2.c
index 441901e58..1fb349bfd 100644
--- a/examples/widgets/button/lv_example_button_2.c
+++ b/examples/widgets/button/lv_example_button_2.c
@@ -4,6 +4,7 @@
 /**
  * Style a button from scratch
  */
+LV_FUNC_SECTION
 void lv_example_button_2(void)
 {
     /*Init the style for the default state*/
diff --git a/examples/widgets/button/lv_example_button_3.c b/examples/widgets/button/lv_example_button_3.c
index d68038563..5adea1ddc 100644
--- a/examples/widgets/button/lv_example_button_3.c
+++ b/examples/widgets/button/lv_example_button_3.c
@@ -4,6 +4,7 @@
 /**
  * Create a style transition on a button to act like a gum when clicked
  */
+LV_FUNC_SECTION
 void lv_example_button_3(void)
 {
     /*Properties to transition*/
diff --git a/examples/widgets/buttonmatrix/lv_example_buttonmatrix_1.c b/examples/widgets/buttonmatrix/lv_example_buttonmatrix_1.c
index baa2057cd..54a7179be 100644
--- a/examples/widgets/buttonmatrix/lv_example_buttonmatrix_1.c
+++ b/examples/widgets/buttonmatrix/lv_example_buttonmatrix_1.c
@@ -1,6 +1,7 @@
 #include "../../lv_examples.h"
 #if LV_USE_BUTTONMATRIX && LV_BUILD_EXAMPLES
 
+__attribute__(( fptrgroup("lv_event_cb") ))
 static void event_handler(lv_event_t * e)
 {
     lv_event_code_t code = lv_event_get_code(e);
@@ -18,6 +19,7 @@ static const char * btnm_map[] = {"1", "2", "3", "4", "5", "\n",
                                   "Action1", "Action2", ""
                                  };
 
+LV_FUNC_SECTION
 void lv_example_buttonmatrix_1(void)
 {
     lv_obj_t * btnm1 = lv_buttonmatrix_create(lv_screen_active());
diff --git a/examples/widgets/buttonmatrix/lv_example_buttonmatrix_2.c b/examples/widgets/buttonmatrix/lv_example_buttonmatrix_2.c
index f3c3aacb2..0db27d950 100644
--- a/examples/widgets/buttonmatrix/lv_example_buttonmatrix_2.c
+++ b/examples/widgets/buttonmatrix/lv_example_buttonmatrix_2.c
@@ -1,6 +1,7 @@
 #include "../../lv_examples.h"
 #if LV_USE_BUTTONMATRIX && LV_BUILD_EXAMPLES
 
+LV_FUNC_SECTION
 static void event_cb(lv_event_t * e)
 {
     lv_obj_t * obj = lv_event_get_target(e);
@@ -78,6 +79,7 @@ static void event_cb(lv_event_t * e)
 /**
  * Add custom drawer to the button matrix to customize buttons one by one
  */
+LV_FUNC_SECTION
 void lv_example_buttonmatrix_2(void)
 {
     lv_obj_t * btnm = lv_buttonmatrix_create(lv_screen_active());
diff --git a/examples/widgets/buttonmatrix/lv_example_buttonmatrix_3.c b/examples/widgets/buttonmatrix/lv_example_buttonmatrix_3.c
index d8e84d298..e257dfb04 100644
--- a/examples/widgets/buttonmatrix/lv_example_buttonmatrix_3.c
+++ b/examples/widgets/buttonmatrix/lv_example_buttonmatrix_3.c
@@ -1,6 +1,7 @@
 #include "../../lv_examples.h"
 #if LV_USE_BUTTONMATRIX  && LV_BUILD_EXAMPLES
 
+LV_FUNC_SECTION
 static void event_cb(lv_event_t * e)
 {
     lv_obj_t * obj = lv_event_get_target(e);
@@ -24,6 +25,7 @@ static void event_cb(lv_event_t * e)
 /**
  * Make a button group (pagination)
  */
+LV_FUNC_SECTION
 void lv_example_buttonmatrix_3(void)
 {
     static lv_style_t style_bg;
diff --git a/examples/widgets/calendar/lv_example_calendar_1.c b/examples/widgets/calendar/lv_example_calendar_1.c
index 9fe71447e..4f21c3641 100644
--- a/examples/widgets/calendar/lv_example_calendar_1.c
+++ b/examples/widgets/calendar/lv_example_calendar_1.c
@@ -1,6 +1,7 @@
 #include "../../lv_examples.h"
 #if LV_USE_CALENDAR && LV_BUILD_EXAMPLES
 
+__attribute__(( fptrgroup("lv_event_cb") ))
 static void event_handler(lv_event_t * e)
 {
     lv_event_code_t code = lv_event_get_code(e);
@@ -14,6 +15,7 @@ static void event_handler(lv_event_t * e)
     }
 }
 
+LV_FUNC_SECTION
 void lv_example_calendar_1(void)
 {
     lv_obj_t  * calendar = lv_calendar_create(lv_screen_active());
diff --git a/examples/widgets/calendar/lv_example_calendar_2.c b/examples/widgets/calendar/lv_example_calendar_2.c
index 548b7134a..dd5cff59d 100644
--- a/examples/widgets/calendar/lv_example_calendar_2.c
+++ b/examples/widgets/calendar/lv_example_calendar_2.c
@@ -1,6 +1,7 @@
 #include "../../lv_examples.h"
 #if LV_USE_CALENDAR && LV_USE_CALENDAR_CHINESE && LV_BUILD_EXAMPLES
 
+LV_FUNC_SECTION
 void lv_example_calendar_2(void)
 {
     lv_obj_t  * calendar = lv_calendar_create(lv_screen_active());
@@ -22,6 +23,7 @@ void lv_example_calendar_2(void)
 
 #else
 
+LV_FUNC_SECTION
 void lv_example_calendar_2(void)
 {
     lv_obj_t * label = lv_label_create(lv_screen_active());
diff --git a/examples/widgets/canvas/lv_example_canvas_1.c b/examples/widgets/canvas/lv_example_canvas_1.c
index 5d146f935..9cc5b6f4a 100644
--- a/examples/widgets/canvas/lv_example_canvas_1.c
+++ b/examples/widgets/canvas/lv_example_canvas_1.c
@@ -4,6 +4,7 @@
 #define CANVAS_WIDTH  200
 #define CANVAS_HEIGHT  150
 
+LV_FUNC_SECTION
 void lv_example_canvas_1(void)
 {
     lv_draw_rect_dsc_t rect_dsc;
diff --git a/examples/widgets/canvas/lv_example_canvas_2.c b/examples/widgets/canvas/lv_example_canvas_2.c
index 2ee1fb563..30aa2ea64 100644
--- a/examples/widgets/canvas/lv_example_canvas_2.c
+++ b/examples/widgets/canvas/lv_example_canvas_2.c
@@ -7,6 +7,7 @@
 /**
  * Create a transparent canvas with transparency
  */
+LV_FUNC_SECTION
 void lv_example_canvas_2(void)
 {
     lv_obj_set_style_bg_color(lv_screen_active(), lv_palette_lighten(LV_PALETTE_RED, 5), 0);
diff --git a/examples/widgets/canvas/lv_example_canvas_3.c b/examples/widgets/canvas/lv_example_canvas_3.c
index d22b13173..c76813044 100644
--- a/examples/widgets/canvas/lv_example_canvas_3.c
+++ b/examples/widgets/canvas/lv_example_canvas_3.c
@@ -7,6 +7,7 @@
 /**
  * Draw a rectangle to the canvas
  */
+LV_FUNC_SECTION
 void lv_example_canvas_3(void)
 {
     /*Create a buffer for the canvas*/
diff --git a/examples/widgets/canvas/lv_example_canvas_4.c b/examples/widgets/canvas/lv_example_canvas_4.c
index 91311afc5..93064205a 100644
--- a/examples/widgets/canvas/lv_example_canvas_4.c
+++ b/examples/widgets/canvas/lv_example_canvas_4.c
@@ -7,6 +7,7 @@
 /**
  * Draw a text to the canvas
  */
+LV_FUNC_SECTION
 void lv_example_canvas_4(void)
 {
     /*Create a buffer for the canvas*/
diff --git a/examples/widgets/canvas/lv_example_canvas_5.c b/examples/widgets/canvas/lv_example_canvas_5.c
index 02fa431ac..ccb5d3969 100644
--- a/examples/widgets/canvas/lv_example_canvas_5.c
+++ b/examples/widgets/canvas/lv_example_canvas_5.c
@@ -7,6 +7,7 @@
 /**
  * Draw an arc to the canvas
  */
+LV_FUNC_SECTION
 void lv_example_canvas_5(void)
 {
     /*Create a buffer for the canvas*/
diff --git a/examples/widgets/canvas/lv_example_canvas_6.c b/examples/widgets/canvas/lv_example_canvas_6.c
index d0136f1e1..95d168fa2 100644
--- a/examples/widgets/canvas/lv_example_canvas_6.c
+++ b/examples/widgets/canvas/lv_example_canvas_6.c
@@ -7,6 +7,7 @@
 /**
  * Draw an image to the canvas
  */
+LV_FUNC_SECTION
 void lv_example_canvas_6(void)
 {
     /*Create a buffer for the canvas*/
diff --git a/examples/widgets/canvas/lv_example_canvas_7.c b/examples/widgets/canvas/lv_example_canvas_7.c
index 05dfc375b..bc98b669f 100644
--- a/examples/widgets/canvas/lv_example_canvas_7.c
+++ b/examples/widgets/canvas/lv_example_canvas_7.c
@@ -7,6 +7,7 @@
 /**
  * Draw a line to the canvas
  */
+LV_FUNC_SECTION
 void lv_example_canvas_7(void)
 {
     /*Create a buffer for the canvas*/
diff --git a/examples/widgets/canvas/lv_example_canvas_8.c b/examples/widgets/canvas/lv_example_canvas_8.c
index ef8675f78..f32dbd32a 100644
--- a/examples/widgets/canvas/lv_example_canvas_8.c
+++ b/examples/widgets/canvas/lv_example_canvas_8.c
@@ -9,6 +9,7 @@
 /**
  * Draw a path to the canvas
  */
+LV_FUNC_SECTION
 void lv_example_canvas_8(void)
 {
     /*Create a buffer for the canvas*/
@@ -44,6 +45,7 @@ void lv_example_canvas_8(void)
 }
 #else
 
+LV_FUNC_SECTION
 void lv_example_canvas_8(void)
 {
     /*fallback for online examples*/
diff --git a/examples/widgets/chart/lv_example_chart_1.c b/examples/widgets/chart/lv_example_chart_1.c
index 145b7aea5..5aeb9f426 100644
--- a/examples/widgets/chart/lv_example_chart_1.c
+++ b/examples/widgets/chart/lv_example_chart_1.c
@@ -4,6 +4,7 @@
 /**
  * A very basic line chart
  */
+LV_FUNC_SECTION
 void lv_example_chart_1(void)
 {
     /*Create a chart*/
diff --git a/examples/widgets/chart/lv_example_chart_2.c b/examples/widgets/chart/lv_example_chart_2.c
index d638f46ed..63ada9561 100644
--- a/examples/widgets/chart/lv_example_chart_2.c
+++ b/examples/widgets/chart/lv_example_chart_2.c
@@ -4,6 +4,7 @@
 /**
  * Use lv_scale to add ticks to a scrollable chart
  */
+LV_FUNC_SECTION
 void lv_example_chart_2(void)
 {
     /*Create a container*/
diff --git a/examples/widgets/chart/lv_example_chart_3.c b/examples/widgets/chart/lv_example_chart_3.c
index dd882e07b..79d4cae12 100644
--- a/examples/widgets/chart/lv_example_chart_3.c
+++ b/examples/widgets/chart/lv_example_chart_3.c
@@ -1,6 +1,7 @@
 #include "../../lv_examples.h"
 #if LV_USE_CHART && LV_BUILD_EXAMPLES
 
+LV_FUNC_SECTION
 static void event_cb(lv_event_t * e)
 {
     lv_event_code_t code = lv_event_get_code(e);
@@ -60,6 +61,7 @@ static void event_cb(lv_event_t * e)
 /**
  * Show the value of the pressed points
  */
+LV_FUNC_SECTION
 void lv_example_chart_3(void)
 {
     /*Create a chart*/
diff --git a/examples/widgets/chart/lv_example_chart_4.c b/examples/widgets/chart/lv_example_chart_4.c
index b6591b14f..cfc549822 100644
--- a/examples/widgets/chart/lv_example_chart_4.c
+++ b/examples/widgets/chart/lv_example_chart_4.c
@@ -2,6 +2,7 @@
 
 #if LV_USE_CHART && LV_DRAW_SW_COMPLEX && LV_BUILD_EXAMPLES
 
+LV_FUNC_SECTION
 static void draw_event_cb(lv_event_t * e)
 {
     lv_draw_task_t * draw_task = lv_event_get_draw_task(e);
@@ -25,6 +26,7 @@ static void draw_event_cb(lv_event_t * e)
 /**
  * Recolor the bars of a chart based on their value
  */
+LV_FUNC_SECTION
 void lv_example_chart_4(void)
 {
     /*Create a chart1*/
diff --git a/examples/widgets/chart/lv_example_chart_5.c b/examples/widgets/chart/lv_example_chart_5.c
index 723b3f110..0bf92c18f 100644
--- a/examples/widgets/chart/lv_example_chart_5.c
+++ b/examples/widgets/chart/lv_example_chart_5.c
@@ -9,6 +9,7 @@ static void draw_event_cb(lv_event_t * e);
 /**
  * Add a faded area effect to the line chart and make some division lines ticker
  */
+LV_FUNC_SECTION
 void lv_example_chart_5(void)
 {
     /*Create a chart*/
@@ -32,6 +33,7 @@ void lv_example_chart_5(void)
     }
 }
 
+LV_FUNC_SECTION
 static void draw_event_cb(lv_event_t * e)
 {
     lv_draw_task_t * draw_task = lv_event_get_draw_task(e);
@@ -47,6 +49,7 @@ static void draw_event_cb(lv_event_t * e)
     }
 }
 
+LV_FUNC_SECTION
 static void add_faded_area(lv_event_t * e)
 {
     lv_obj_t * obj = lv_event_get_target(e);
@@ -103,6 +106,7 @@ static void add_faded_area(lv_event_t * e)
     lv_draw_rect(base_dsc->layer, &rect_dsc, &rect_area);
 }
 
+LV_FUNC_SECTION
 static void hook_division_lines(lv_event_t * e)
 {
     lv_draw_task_t * draw_task = lv_event_get_draw_task(e);
diff --git a/examples/widgets/chart/lv_example_chart_6.c b/examples/widgets/chart/lv_example_chart_6.c
index 58d58cd1d..4e6dd4ac1 100644
--- a/examples/widgets/chart/lv_example_chart_6.c
+++ b/examples/widgets/chart/lv_example_chart_6.c
@@ -5,6 +5,7 @@ static lv_obj_t * chart;
 static lv_chart_series_t * ser;
 static lv_chart_cursor_t * cursor;
 
+LV_FUNC_SECTION
 static void value_changed_event_cb(lv_event_t * e)
 {
     static int32_t last_id = -1;
@@ -19,6 +20,7 @@ static void value_changed_event_cb(lv_event_t * e)
 /**
  * Show cursor on the clicked point
  */
+LV_FUNC_SECTION
 void lv_example_chart_6(void)
 {
     chart = lv_chart_create(lv_screen_active());
diff --git a/examples/widgets/chart/lv_example_chart_7.c b/examples/widgets/chart/lv_example_chart_7.c
index da5a3dad1..042e21b77 100644
--- a/examples/widgets/chart/lv_example_chart_7.c
+++ b/examples/widgets/chart/lv_example_chart_7.c
@@ -1,6 +1,7 @@
 #include "../../lv_examples.h"
 #if LV_USE_CHART && LV_BUILD_EXAMPLES
 
+LV_FUNC_SECTION
 static void draw_event_cb(lv_event_t * e)
 {
     lv_draw_task_t * draw_task = lv_event_get_draw_task(e);
@@ -29,6 +30,7 @@ static void draw_event_cb(lv_event_t * e)
     }
 }
 
+LV_FUNC_SECTION
 static void add_data(lv_timer_t * timer)
 {
     lv_obj_t * chart = lv_timer_get_user_data(timer);
@@ -38,6 +40,7 @@ static void add_data(lv_timer_t * timer)
 /**
  * A scatter chart
  */
+LV_FUNC_SECTION
 void lv_example_chart_7(void)
 {
     lv_obj_t * chart = lv_chart_create(lv_screen_active());
diff --git a/examples/widgets/chart/lv_example_chart_8.c b/examples/widgets/chart/lv_example_chart_8.c
index 21da47697..c50f84184 100644
--- a/examples/widgets/chart/lv_example_chart_8.c
+++ b/examples/widgets/chart/lv_example_chart_8.c
@@ -1,6 +1,7 @@
 #include "../../lv_examples.h"
 #if LV_USE_CHART && LV_DRAW_SW_COMPLEX && LV_BUILD_EXAMPLES
 
+LV_FUNC_SECTION
 static void add_data(lv_timer_t * t)
 {
     lv_obj_t * chart = lv_timer_get_user_data(t);
@@ -22,6 +23,7 @@ static void add_data(lv_timer_t * t)
 /**
  * Circular line chart with gap
  */
+LV_FUNC_SECTION
 void lv_example_chart_8(void)
 {
     /*Create a stacked_area_chart.obj*/
diff --git a/examples/widgets/checkbox/lv_example_checkbox_1.c b/examples/widgets/checkbox/lv_example_checkbox_1.c
index 9fe71f94b..c5a581162 100644
--- a/examples/widgets/checkbox/lv_example_checkbox_1.c
+++ b/examples/widgets/checkbox/lv_example_checkbox_1.c
@@ -1,6 +1,7 @@
 #include "../../lv_examples.h"
 #if LV_USE_CHECKBOX && LV_BUILD_EXAMPLES
 
+__attribute__(( fptrgroup("lv_event_cb") ))
 static void event_handler(lv_event_t * e)
 {
     lv_event_code_t code = lv_event_get_code(e);
@@ -15,6 +16,7 @@ static void event_handler(lv_event_t * e)
     }
 }
 
+LV_FUNC_SECTION
 void lv_example_checkbox_1(void)
 {
     lv_obj_set_flex_flow(lv_screen_active(), LV_FLEX_FLOW_COLUMN);
diff --git a/examples/widgets/checkbox/lv_example_checkbox_2.c b/examples/widgets/checkbox/lv_example_checkbox_2.c
index b10d9d2c5..4a5fef110 100644
--- a/examples/widgets/checkbox/lv_example_checkbox_2.c
+++ b/examples/widgets/checkbox/lv_example_checkbox_2.c
@@ -6,6 +6,7 @@ static lv_style_t style_radio_chk;
 static uint32_t active_index_1 = 0;
 static uint32_t active_index_2 = 0;
 
+LV_FUNC_SECTION
 static void radio_event_handler(lv_event_t * e)
 {
     uint32_t * active_id = lv_event_get_user_data(e);
@@ -24,6 +25,7 @@ static void radio_event_handler(lv_event_t * e)
     LV_LOG_USER("Selected radio buttons: %d, %d", (int)active_index_1, (int)active_index_2);
 }
 
+LV_FUNC_SECTION
 static void radiobutton_create(lv_obj_t * parent, const char * txt)
 {
     lv_obj_t * obj = lv_checkbox_create(parent);
@@ -36,6 +38,7 @@ static void radiobutton_create(lv_obj_t * parent, const char * txt)
 /**
  * Checkboxes as radio buttons
  */
+LV_FUNC_SECTION
 void lv_example_checkbox_2(void)
 {
     /* The idea is to enable `LV_OBJ_FLAG_EVENT_BUBBLE` on checkboxes and process the
diff --git a/examples/widgets/dropdown/lv_example_dropdown_1.c b/examples/widgets/dropdown/lv_example_dropdown_1.c
index 856c97dbd..8f2a5fea0 100644
--- a/examples/widgets/dropdown/lv_example_dropdown_1.c
+++ b/examples/widgets/dropdown/lv_example_dropdown_1.c
@@ -1,6 +1,7 @@
 #include "../../lv_examples.h"
 #if LV_USE_DROPDOWN && LV_BUILD_EXAMPLES
 
+__attribute__(( fptrgroup("lv_event_cb") ))
 static void event_handler(lv_event_t * e)
 {
     lv_event_code_t code = lv_event_get_code(e);
@@ -12,6 +13,7 @@ static void event_handler(lv_event_t * e)
     }
 }
 
+LV_FUNC_SECTION
 void lv_example_dropdown_1(void)
 {
 
diff --git a/examples/widgets/dropdown/lv_example_dropdown_2.c b/examples/widgets/dropdown/lv_example_dropdown_2.c
index 10c485a04..9874eb608 100644
--- a/examples/widgets/dropdown/lv_example_dropdown_2.c
+++ b/examples/widgets/dropdown/lv_example_dropdown_2.c
@@ -4,6 +4,7 @@
 /**
  * Create a drop down, up, left and right menus
  */
+LV_FUNC_SECTION
 void lv_example_dropdown_2(void)
 {
     static const char * opts = "Apple\n"
diff --git a/examples/widgets/dropdown/lv_example_dropdown_3.c b/examples/widgets/dropdown/lv_example_dropdown_3.c
index f92ccb8fc..e3b4cfc64 100644
--- a/examples/widgets/dropdown/lv_example_dropdown_3.c
+++ b/examples/widgets/dropdown/lv_example_dropdown_3.c
@@ -1,6 +1,7 @@
 #include "../../lv_examples.h"
 #if LV_USE_DROPDOWN && LV_BUILD_EXAMPLES
 
+LV_FUNC_SECTION
 static void event_cb(lv_event_t * e)
 {
     lv_obj_t * dropdown = lv_event_get_target(e);
@@ -12,6 +13,7 @@ static void event_cb(lv_event_t * e)
 /**
  * Create a menu from a drop-down list and show some drop-down list features and styling
  */
+LV_FUNC_SECTION
 void lv_example_dropdown_3(void)
 {
     /*Create a drop down list*/
diff --git a/examples/widgets/image/lv_example_image_1.c b/examples/widgets/image/lv_example_image_1.c
index 0e2bd55e1..2f85fb28d 100644
--- a/examples/widgets/image/lv_example_image_1.c
+++ b/examples/widgets/image/lv_example_image_1.c
@@ -1,6 +1,7 @@
 #include "../../lv_examples.h"
 #if LV_USE_IMAGE && LV_BUILD_EXAMPLES
 
+LV_FUNC_SECTION
 void lv_example_image_1(void)
 {
     LV_IMAGE_DECLARE(img_cogwheel_argb);
diff --git a/examples/widgets/image/lv_example_image_2.c b/examples/widgets/image/lv_example_image_2.c
index 01629916e..16d0d8138 100644
--- a/examples/widgets/image/lv_example_image_2.c
+++ b/examples/widgets/image/lv_example_image_2.c
@@ -10,6 +10,7 @@ static lv_obj_t * img1;
 /**
  * Demonstrate runtime image re-coloring
  */
+LV_FUNC_SECTION
 void lv_example_image_2(void)
 {
     /*Create 4 sliders to adjust RGB color and re-color intensity*/
@@ -37,6 +38,7 @@ void lv_example_image_2(void)
     lv_obj_send_event(intense_slider, LV_EVENT_VALUE_CHANGED, NULL);
 }
 
+LV_FUNC_SECTION
 static void slider_event_cb(lv_event_t * e)
 {
     LV_UNUSED(e);
@@ -49,6 +51,7 @@ static void slider_event_cb(lv_event_t * e)
     lv_obj_set_style_image_recolor(img1, color, 0);
 }
 
+LV_FUNC_SECTION
 static lv_obj_t * create_slider(lv_color_t color)
 {
     lv_obj_t * slider = lv_slider_create(lv_screen_active());
diff --git a/examples/widgets/image/lv_example_image_3.c b/examples/widgets/image/lv_example_image_3.c
index 11467930f..077ef1d90 100644
--- a/examples/widgets/image/lv_example_image_3.c
+++ b/examples/widgets/image/lv_example_image_3.c
@@ -1,11 +1,13 @@
 #include "../../lv_examples.h"
 #if LV_USE_IMAGE && LV_BUILD_EXAMPLES
 
+LV_FUNC_SECTION
 static void set_angle(void * img, int32_t v)
 {
     lv_image_set_rotation(img, v);
 }
 
+LV_FUNC_SECTION
 static void set_scale(void * img, int32_t v)
 {
     lv_image_set_scale(img, v);
@@ -14,6 +16,7 @@ static void set_scale(void * img, int32_t v)
 /**
  * Show transformations (zoom and rotation) using a pivot point.
  */
+LV_FUNC_SECTION
 void lv_example_image_3(void)
 {
     LV_IMAGE_DECLARE(img_cogwheel_argb);
diff --git a/examples/widgets/image/lv_example_image_4.c b/examples/widgets/image/lv_example_image_4.c
index 40ce31345..c5fb2fdea 100644
--- a/examples/widgets/image/lv_example_image_4.c
+++ b/examples/widgets/image/lv_example_image_4.c
@@ -1,6 +1,7 @@
 #include "../../lv_examples.h"
 #if LV_USE_IMAGE && LV_BUILD_EXAMPLES
 
+LV_FUNC_SECTION
 static void ofs_y_anim(void * img, int32_t v)
 {
     lv_image_set_offset_y(img, v);
@@ -9,6 +10,7 @@ static void ofs_y_anim(void * img, int32_t v)
 /**
  * Image styling and offset
  */
+LV_FUNC_SECTION
 void lv_example_image_4(void)
 {
     LV_IMAGE_DECLARE(img_skew_strip);
diff --git a/examples/widgets/imagebutton/lv_example_imagebutton_1.c b/examples/widgets/imagebutton/lv_example_imagebutton_1.c
index 22fd694fc..ec2ea54d6 100644
--- a/examples/widgets/imagebutton/lv_example_imagebutton_1.c
+++ b/examples/widgets/imagebutton/lv_example_imagebutton_1.c
@@ -1,6 +1,7 @@
 #include "../../lv_examples.h"
 #if LV_USE_IMAGEBUTTON && LV_BUILD_EXAMPLES
 
+LV_FUNC_SECTION
 void lv_example_imagebutton_1(void)
 {
     LV_IMAGE_DECLARE(imagebutton_left);
diff --git a/examples/widgets/keyboard/lv_example_keyboard_1.c b/examples/widgets/keyboard/lv_example_keyboard_1.c
index ba4bc0727..cdf92dbfe 100644
--- a/examples/widgets/keyboard/lv_example_keyboard_1.c
+++ b/examples/widgets/keyboard/lv_example_keyboard_1.c
@@ -1,6 +1,7 @@
 #include "../../lv_examples.h"
 #if LV_USE_KEYBOARD && LV_BUILD_EXAMPLES
 
+__attribute__(( fptrgroup("lv_event_cb") ))
 static void ta_event_cb(lv_event_t * e)
 {
     lv_event_code_t code = lv_event_get_code(e);
@@ -17,6 +18,7 @@ static void ta_event_cb(lv_event_t * e)
     }
 }
 
+LV_FUNC_SECTION
 void lv_example_keyboard_1(void)
 {
     /*Create a keyboard to use it with an of the text areas*/
diff --git a/examples/widgets/keyboard/lv_example_keyboard_2.c b/examples/widgets/keyboard/lv_example_keyboard_2.c
index ff2686413..78869eb44 100644
--- a/examples/widgets/keyboard/lv_example_keyboard_2.c
+++ b/examples/widgets/keyboard/lv_example_keyboard_2.c
@@ -1,6 +1,7 @@
 #include "../../lv_examples.h"
 #if LV_USE_KEYBOARD && LV_BUILD_EXAMPLES
 
+LV_FUNC_SECTION
 void lv_example_keyboard_2(void)
 {
     /*Create an AZERTY keyboard map*/
diff --git a/examples/widgets/label/lv_example_label_1.c b/examples/widgets/label/lv_example_label_1.c
index 1e06f35a5..5f8721d31 100644
--- a/examples/widgets/label/lv_example_label_1.c
+++ b/examples/widgets/label/lv_example_label_1.c
@@ -4,6 +4,7 @@
 /**
  * Show line wrap, re-color, line align and text scrolling.
  */
+LV_FUNC_SECTION
 void lv_example_label_1(void)
 {
     lv_obj_t * label1 = lv_label_create(lv_screen_active());
diff --git a/examples/widgets/label/lv_example_label_2.c b/examples/widgets/label/lv_example_label_2.c
index c85a7b864..4c2343e8b 100644
--- a/examples/widgets/label/lv_example_label_2.c
+++ b/examples/widgets/label/lv_example_label_2.c
@@ -4,6 +4,7 @@
 /**
  * Create a fake text shadow
  */
+LV_FUNC_SECTION
 void lv_example_label_2(void)
 {
     /*Create a style for the shadow*/
diff --git a/examples/widgets/label/lv_example_label_3.c b/examples/widgets/label/lv_example_label_3.c
index 730b41ed3..29c338b81 100644
--- a/examples/widgets/label/lv_example_label_3.c
+++ b/examples/widgets/label/lv_example_label_3.c
@@ -4,6 +4,7 @@
 /**
  * Show mixed LTR, RTL and Chinese label
  */
+LV_FUNC_SECTION
 void lv_example_label_3(void)
 {
     lv_obj_t * ltr_label = lv_label_create(lv_screen_active());
diff --git a/examples/widgets/label/lv_example_label_4.c b/examples/widgets/label/lv_example_label_4.c
index 89d93255e..520532b19 100644
--- a/examples/widgets/label/lv_example_label_4.c
+++ b/examples/widgets/label/lv_example_label_4.c
@@ -5,6 +5,7 @@
 #define MASK_WIDTH 150
 #define MASK_HEIGHT 60
 
+LV_FUNC_SECTION
 static void generate_mask(lv_draw_buf_t * mask, int32_t w, int32_t h, const char * txt)
 {
     /*Create a "8 bit alpha" canvas and clear it*/
@@ -33,6 +34,7 @@ static void generate_mask(lv_draw_buf_t * mask, int32_t w, int32_t h, const char
 /**
  * Draw label with gradient color
  */
+LV_FUNC_SECTION
 void lv_example_label_4(void)
 {
     /* Create the mask of a text by drawing it to a canvas*/
diff --git a/examples/widgets/label/lv_example_label_5.c b/examples/widgets/label/lv_example_label_5.c
index 1cf988943..7dda1eef5 100644
--- a/examples/widgets/label/lv_example_label_5.c
+++ b/examples/widgets/label/lv_example_label_5.c
@@ -5,6 +5,7 @@
  * Show customizing the circular scrolling animation of a label with `LV_LABEL_LONG_SCROLL_CIRCULAR`
  * long mode.
  */
+LV_FUNC_SECTION
 void lv_example_label_5(void)
 {
     static lv_anim_t animation_template;
diff --git a/examples/widgets/led/lv_example_led_1.c b/examples/widgets/led/lv_example_led_1.c
index 2e7ad93ea..b62d789da 100644
--- a/examples/widgets/led/lv_example_led_1.c
+++ b/examples/widgets/led/lv_example_led_1.c
@@ -4,6 +4,7 @@
 /**
  * Create LED's with different brightness and color
  */
+LV_FUNC_SECTION
 void lv_example_led_1(void)
 {
     /*Create a LED and switch it OFF*/
diff --git a/examples/widgets/line/lv_example_line_1.c b/examples/widgets/line/lv_example_line_1.c
index d2dc6bb8e..6cfd7d642 100644
--- a/examples/widgets/line/lv_example_line_1.c
+++ b/examples/widgets/line/lv_example_line_1.c
@@ -1,6 +1,7 @@
 #include "../../lv_examples.h"
 #if LV_USE_LINE && LV_BUILD_EXAMPLES
 
+LV_FUNC_SECTION
 void lv_example_line_1(void)
 {
     /*Create an array for the points of the line*/
diff --git a/examples/widgets/list/lv_example_list_1.c b/examples/widgets/list/lv_example_list_1.c
index 7ee7eb5f6..c60a8b982 100644
--- a/examples/widgets/list/lv_example_list_1.c
+++ b/examples/widgets/list/lv_example_list_1.c
@@ -2,6 +2,7 @@
 #if LV_USE_LIST && LV_BUILD_EXAMPLES
 static lv_obj_t * list1;
 
+__attribute__(( fptrgroup("lv_event_cb") ))
 static void event_handler(lv_event_t * e)
 {
     lv_event_code_t code = lv_event_get_code(e);
@@ -11,6 +12,7 @@ static void event_handler(lv_event_t * e)
         LV_LOG_USER("Clicked: %s", lv_list_get_button_text(list1, obj));
     }
 }
+LV_FUNC_SECTION
 void lv_example_list_1(void)
 {
     /*Create a list*/
diff --git a/examples/widgets/list/lv_example_list_2.c b/examples/widgets/list/lv_example_list_2.c
index c50201312..06c2de418 100644
--- a/examples/widgets/list/lv_example_list_2.c
+++ b/examples/widgets/list/lv_example_list_2.c
@@ -6,6 +6,7 @@ static lv_obj_t * list2;
 
 static lv_obj_t * currentButton = NULL;
 
+__attribute__(( fptrgroup("lv_event_cb") ))
 static void event_handler(lv_event_t * e)
 {
     lv_event_code_t code = lv_event_get_code(e);
@@ -33,6 +34,7 @@ static void event_handler(lv_event_t * e)
     }
 }
 
+LV_FUNC_SECTION
 static void event_handler_top(lv_event_t * e)
 {
     lv_event_code_t code = lv_event_get_code(e);
@@ -43,6 +45,7 @@ static void event_handler_top(lv_event_t * e)
     }
 }
 
+LV_FUNC_SECTION
 static void event_handler_up(lv_event_t * e)
 {
     lv_event_code_t code = lv_event_get_code(e);
@@ -55,6 +58,7 @@ static void event_handler_up(lv_event_t * e)
     }
 }
 
+LV_FUNC_SECTION
 static void event_handler_center(lv_event_t * e)
 {
     const lv_event_code_t code = lv_event_get_code(e);
@@ -70,6 +74,7 @@ static void event_handler_center(lv_event_t * e)
     }
 }
 
+LV_FUNC_SECTION
 static void event_handler_dn(lv_event_t * e)
 {
     const lv_event_code_t code = lv_event_get_code(e);
@@ -82,6 +87,7 @@ static void event_handler_dn(lv_event_t * e)
     }
 }
 
+LV_FUNC_SECTION
 static void event_handler_bottom(lv_event_t * e)
 {
     const lv_event_code_t code = lv_event_get_code(e);
@@ -92,6 +98,7 @@ static void event_handler_bottom(lv_event_t * e)
     }
 }
 
+LV_FUNC_SECTION
 static void event_handler_swap(lv_event_t * e)
 {
     const lv_event_code_t code = lv_event_get_code(e);
@@ -109,6 +116,7 @@ static void event_handler_swap(lv_event_t * e)
     }
 }
 
+LV_FUNC_SECTION
 void lv_example_list_2(void)
 {
     /*Create a list*/
diff --git a/examples/widgets/lottie/lv_example_lottie_1.c b/examples/widgets/lottie/lv_example_lottie_1.c
index 7fb781cd7..882aa60ff 100644
--- a/examples/widgets/lottie/lv_example_lottie_1.c
+++ b/examples/widgets/lottie/lv_example_lottie_1.c
@@ -5,6 +5,7 @@
 /**
  * Load an lottie animation from data
  */
+LV_FUNC_SECTION
 void lv_example_lottie_1(void)
 {
     extern const uint8_t lv_example_lottie_approve[];
@@ -29,6 +30,7 @@ void lv_example_lottie_1(void)
 
 #else
 
+LV_FUNC_SECTION
 void lv_example_lottie_1(void)
 {
     /*fallback for online examples*/
diff --git a/examples/widgets/lottie/lv_example_lottie_2.c b/examples/widgets/lottie/lv_example_lottie_2.c
index fafa43712..60b48f0e6 100644
--- a/examples/widgets/lottie/lv_example_lottie_2.c
+++ b/examples/widgets/lottie/lv_example_lottie_2.c
@@ -5,6 +5,7 @@
 /**
  * Load an lottie animation from file
  */
+LV_FUNC_SECTION
 void lv_example_lottie_2(void)
 {
 
@@ -27,6 +28,7 @@ void lv_example_lottie_2(void)
 
 #else
 
+LV_FUNC_SECTION
 void lv_example_lottie_2(void)
 {
     /*fallback for online examples*/
diff --git a/examples/widgets/menu/lv_example_menu_1.c b/examples/widgets/menu/lv_example_menu_1.c
index 7edbcae78..f94eef982 100644
--- a/examples/widgets/menu/lv_example_menu_1.c
+++ b/examples/widgets/menu/lv_example_menu_1.c
@@ -1,6 +1,7 @@
 #include "../../lv_examples.h"
 #if LV_USE_MENU && LV_BUILD_EXAMPLES
 
+LV_FUNC_SECTION
 void lv_example_menu_1(void)
 {
     /*Create a menu object*/
diff --git a/examples/widgets/menu/lv_example_menu_2.c b/examples/widgets/menu/lv_example_menu_2.c
index 71f9162ee..a6b0ad4ee 100644
--- a/examples/widgets/menu/lv_example_menu_2.c
+++ b/examples/widgets/menu/lv_example_menu_2.c
@@ -1,6 +1,7 @@
 #include "../../lv_examples.h"
 #if LV_USE_MENU && LV_USE_MSGBOX && LV_BUILD_EXAMPLES
 
+LV_FUNC_SECTION
 static void back_event_handler(lv_event_t * e)
 {
     lv_obj_t * obj = lv_event_get_target(e);
@@ -14,6 +15,7 @@ static void back_event_handler(lv_event_t * e)
     }
 }
 
+LV_FUNC_SECTION
 void lv_example_menu_2(void)
 {
     lv_obj_t * menu = lv_menu_create(lv_screen_active());
diff --git a/examples/widgets/menu/lv_example_menu_3.c b/examples/widgets/menu/lv_example_menu_3.c
index f4210a89e..9ffd86329 100644
--- a/examples/widgets/menu/lv_example_menu_3.c
+++ b/examples/widgets/menu/lv_example_menu_3.c
@@ -1,6 +1,7 @@
 #include "../../lv_examples.h"
 #if LV_USE_MENU && LV_BUILD_EXAMPLES
 
+LV_FUNC_SECTION
 void lv_example_menu_3(void)
 {
     /*Create a menu object*/
diff --git a/examples/widgets/menu/lv_example_menu_4.c b/examples/widgets/menu/lv_example_menu_4.c
index 3cd7165de..a81e209a3 100644
--- a/examples/widgets/menu/lv_example_menu_4.c
+++ b/examples/widgets/menu/lv_example_menu_4.c
@@ -5,6 +5,7 @@ static uint32_t btn_cnt = 1;
 static lv_obj_t * main_page;
 static lv_obj_t * menu;
 
+LV_FUNC_SECTION
 static void float_button_event_cb(lv_event_t * e)
 {
     LV_UNUSED(e);
@@ -28,6 +29,7 @@ static void float_button_event_cb(lv_event_t * e)
     lv_obj_scroll_to_view_recursive(cont, LV_ANIM_ON);
 }
 
+LV_FUNC_SECTION
 void lv_example_menu_4(void)
 {
     /*Create a menu object*/
diff --git a/examples/widgets/menu/lv_example_menu_5.c b/examples/widgets/menu/lv_example_menu_5.c
index 781e630e5..9041597f9 100644
--- a/examples/widgets/menu/lv_example_menu_5.c
+++ b/examples/widgets/menu/lv_example_menu_5.c
@@ -16,6 +16,7 @@ static lv_obj_t * create_slider(lv_obj_t * parent,
 static lv_obj_t * create_switch(lv_obj_t * parent,
                                 const char * icon, const char * txt, bool chk);
 
+LV_FUNC_SECTION
 void lv_example_menu_5(void)
 {
     lv_obj_t * menu = lv_menu_create(lv_screen_active());
@@ -110,6 +111,7 @@ void lv_example_menu_5(void)
                       NULL);
 }
 
+LV_FUNC_SECTION
 static void back_event_handler(lv_event_t * e)
 {
     lv_obj_t * obj = lv_event_get_target(e);
@@ -123,6 +125,7 @@ static void back_event_handler(lv_event_t * e)
     }
 }
 
+LV_FUNC_SECTION
 static void switch_handler(lv_event_t * e)
 {
     lv_event_code_t code = lv_event_get_code(e);
@@ -143,6 +146,7 @@ static void switch_handler(lv_event_t * e)
     }
 }
 
+LV_FUNC_SECTION
 static lv_obj_t * create_text(lv_obj_t * parent, const char * icon, const char * txt,
                               lv_menu_builder_variant_t builder_variant)
 {
@@ -171,6 +175,7 @@ static lv_obj_t * create_text(lv_obj_t * parent, const char * icon, const char *
     return obj;
 }
 
+LV_FUNC_SECTION
 static lv_obj_t * create_slider(lv_obj_t * parent, const char * icon, const char * txt, int32_t min, int32_t max,
                                 int32_t val)
 {
@@ -188,6 +193,7 @@ static lv_obj_t * create_slider(lv_obj_t * parent, const char * icon, const char
     return obj;
 }
 
+LV_FUNC_SECTION
 static lv_obj_t * create_switch(lv_obj_t * parent, const char * icon, const char * txt, bool chk)
 {
     lv_obj_t * obj = create_text(parent, icon, txt, LV_MENU_ITEM_BUILDER_VARIANT_1);
diff --git a/examples/widgets/msgbox/lv_example_msgbox_1.c b/examples/widgets/msgbox/lv_example_msgbox_1.c
index 9591ce32d..4f12e95eb 100644
--- a/examples/widgets/msgbox/lv_example_msgbox_1.c
+++ b/examples/widgets/msgbox/lv_example_msgbox_1.c
@@ -1,6 +1,7 @@
 #include "../../lv_examples.h"
 #if LV_USE_MSGBOX && LV_BUILD_EXAMPLES
 
+LV_FUNC_SECTION
 static void event_cb(lv_event_t * e)
 {
     lv_obj_t * btn = lv_event_get_target(e);
@@ -9,6 +10,7 @@ static void event_cb(lv_event_t * e)
     LV_LOG_USER("Button %s clicked", lv_label_get_text(label));
 }
 
+LV_FUNC_SECTION
 void lv_example_msgbox_1(void)
 {
     lv_obj_t * mbox1 = lv_msgbox_create(NULL);
diff --git a/examples/widgets/msgbox/lv_example_msgbox_2.c b/examples/widgets/msgbox/lv_example_msgbox_2.c
index 793a9c4df..75ba9cd14 100644
--- a/examples/widgets/msgbox/lv_example_msgbox_2.c
+++ b/examples/widgets/msgbox/lv_example_msgbox_2.c
@@ -1,19 +1,21 @@
 #include "../../lv_examples.h"
 #if LV_USE_MSGBOX && LV_BUILD_EXAMPLES
 
+LV_FUNC_SECTION
 static void minimize_button_event_cb(lv_event_t * e)
 {
     lv_obj_t * mbox = (lv_obj_t *) lv_event_get_user_data(e);
     lv_obj_add_flag(mbox, LV_OBJ_FLAG_HIDDEN);
 }
 
+LV_FUNC_SECTION
 void lv_example_msgbox_2(void)
 {
     lv_obj_t * setting = lv_msgbox_create(lv_screen_active());
     lv_obj_set_style_clip_corner(setting, true, 0);
 
     /* setting fixed size */
-    lv_obj_set_size(setting, 300, 200);
+    lv_obj_set_size(setting, 200, 200);
 
     /* setting's titlebar/header */
     lv_msgbox_add_title(setting, "Setting");
diff --git a/examples/widgets/obj/lv_example_obj_1.c b/examples/widgets/obj/lv_example_obj_1.c
index 322306e4a..97f02bad0 100644
--- a/examples/widgets/obj/lv_example_obj_1.c
+++ b/examples/widgets/obj/lv_example_obj_1.c
@@ -1,6 +1,7 @@
 #include "../../lv_examples.h"
 #if LV_BUILD_EXAMPLES
 
+LV_FUNC_SECTION
 void lv_example_obj_1(void)
 {
     lv_obj_t * obj1;
diff --git a/examples/widgets/obj/lv_example_obj_2.c b/examples/widgets/obj/lv_example_obj_2.c
index b9abfe901..7d4b61741 100644
--- a/examples/widgets/obj/lv_example_obj_2.c
+++ b/examples/widgets/obj/lv_example_obj_2.c
@@ -1,6 +1,7 @@
 #include "../../lv_examples.h"
 #if LV_BUILD_EXAMPLES
 
+LV_FUNC_SECTION
 static void drag_event_handler(lv_event_t * e)
 {
     lv_obj_t * obj = lv_event_get_target(e);
@@ -19,6 +20,7 @@ static void drag_event_handler(lv_event_t * e)
 /**
  * Make an object draggable.
  */
+LV_FUNC_SECTION
 void lv_example_obj_2(void)
 {
     lv_obj_t * obj;
diff --git a/examples/widgets/roller/lv_example_roller_1.c b/examples/widgets/roller/lv_example_roller_1.c
index 7a9d8407d..d86b5dc97 100644
--- a/examples/widgets/roller/lv_example_roller_1.c
+++ b/examples/widgets/roller/lv_example_roller_1.c
@@ -1,6 +1,7 @@
 #include "../../lv_examples.h"
 #if LV_USE_ROLLER && LV_BUILD_EXAMPLES
 
+__attribute__(( fptrgroup("lv_event_cb") ))
 static void event_handler(lv_event_t * e)
 {
     lv_event_code_t code = lv_event_get_code(e);
@@ -15,6 +16,7 @@ static void event_handler(lv_event_t * e)
 /**
  * An infinite roller with the name of the months
  */
+LV_FUNC_SECTION
 void lv_example_roller_1(void)
 {
     lv_obj_t * roller1 = lv_roller_create(lv_screen_active());
diff --git a/examples/widgets/roller/lv_example_roller_2.c b/examples/widgets/roller/lv_example_roller_2.c
index a4b02378b..ad7eef589 100644
--- a/examples/widgets/roller/lv_example_roller_2.c
+++ b/examples/widgets/roller/lv_example_roller_2.c
@@ -1,6 +1,7 @@
 #include "../../lv_examples.h"
 #if LV_USE_ROLLER && LV_FONT_MONTSERRAT_22 && LV_BUILD_EXAMPLES
 
+__attribute__(( fptrgroup("lv_event_cb") ))
 static void event_handler(lv_event_t * e)
 {
     lv_event_code_t code = lv_event_get_code(e);
@@ -15,6 +16,7 @@ static void event_handler(lv_event_t * e)
 /**
  * Roller with various alignments and larger text in the selected area
  */
+LV_FUNC_SECTION
 void lv_example_roller_2(void)
 {
     /*A style to make the selected option larger*/
diff --git a/examples/widgets/roller/lv_example_roller_3.c b/examples/widgets/roller/lv_example_roller_3.c
index e4c50bc27..0c8e46907 100644
--- a/examples/widgets/roller/lv_example_roller_3.c
+++ b/examples/widgets/roller/lv_example_roller_3.c
@@ -2,6 +2,7 @@
 
 #if LV_USE_ROLLER && LV_DRAW_SW_COMPLEX && LV_BUILD_EXAMPLES && 1
 
+LV_FUNC_SECTION
 static void generate_mask(lv_draw_buf_t * mask)
 {
     /*Create a "8 bit alpha" canvas and clear it*/
@@ -38,6 +39,7 @@ static void generate_mask(lv_draw_buf_t * mask)
 /**
  * Add a fade mask to roller.
  */
+LV_FUNC_SECTION
 void lv_example_roller_3(void)
 {
     lv_obj_set_style_bg_color(lv_screen_active(), lv_palette_main(LV_PALETTE_BLUE_GREY), 0);
diff --git a/examples/widgets/scale/lv_example_scale_1.c b/examples/widgets/scale/lv_example_scale_1.c
index 2a5377484..14cecd815 100644
--- a/examples/widgets/scale/lv_example_scale_1.c
+++ b/examples/widgets/scale/lv_example_scale_1.c
@@ -4,6 +4,7 @@
 /**
  * A simple horizontal scale
  */
+LV_FUNC_SECTION
 void lv_example_scale_1(void)
 {
     lv_obj_t * scale = lv_scale_create(lv_screen_active());
diff --git a/examples/widgets/scale/lv_example_scale_2.c b/examples/widgets/scale/lv_example_scale_2.c
index 011892008..0df9793be 100644
--- a/examples/widgets/scale/lv_example_scale_2.c
+++ b/examples/widgets/scale/lv_example_scale_2.c
@@ -4,6 +4,7 @@
 /**
  * An vertical scale with section and custom styling
  */
+LV_FUNC_SECTION
 void lv_example_scale_2(void)
 {
     lv_obj_t * scale = lv_scale_create(lv_screen_active());
diff --git a/examples/widgets/scale/lv_example_scale_3.c b/examples/widgets/scale/lv_example_scale_3.c
index 25d038daa..14a2f9da4 100644
--- a/examples/widgets/scale/lv_example_scale_3.c
+++ b/examples/widgets/scale/lv_example_scale_3.c
@@ -6,11 +6,13 @@ LV_IMAGE_DECLARE(img_hand);
 lv_obj_t * needle_line;
 lv_obj_t * needle_img;
 
+LV_FUNC_SECTION
 static void set_needle_line_value(void * obj, int32_t v)
 {
     lv_scale_set_line_needle_value(obj, needle_line, 60, v);
 }
 
+LV_FUNC_SECTION
 static void set_needle_img_value(void * obj, int32_t v)
 {
     lv_scale_set_image_needle_value(obj, needle_img, v);
@@ -19,6 +21,7 @@ static void set_needle_img_value(void * obj, int32_t v)
 /**
  * A simple round scale
  */
+LV_FUNC_SECTION
 void lv_example_scale_3(void)
 {
     lv_obj_t * scale_line = lv_scale_create(lv_screen_active());
diff --git a/examples/widgets/scale/lv_example_scale_4.c b/examples/widgets/scale/lv_example_scale_4.c
index 033a01015..9004b8387 100644
--- a/examples/widgets/scale/lv_example_scale_4.c
+++ b/examples/widgets/scale/lv_example_scale_4.c
@@ -4,6 +4,7 @@
 /**
  * A round scale with section and custom styling
  */
+LV_FUNC_SECTION
 void lv_example_scale_4(void)
 {
     lv_obj_t * scale = lv_scale_create(lv_screen_active());
diff --git a/examples/widgets/scale/lv_example_scale_5.c b/examples/widgets/scale/lv_example_scale_5.c
index e84789d5d..bc2b01367 100644
--- a/examples/widgets/scale/lv_example_scale_5.c
+++ b/examples/widgets/scale/lv_example_scale_5.c
@@ -4,6 +4,7 @@
 /**
  * An scale with section and custom styling
  */
+LV_FUNC_SECTION
 void lv_example_scale_5(void)
 {
     lv_obj_t * scale = lv_scale_create(lv_screen_active());
diff --git a/examples/widgets/scale/lv_example_scale_6.c b/examples/widgets/scale/lv_example_scale_6.c
index 0a5503577..b76d23be9 100644
--- a/examples/widgets/scale/lv_example_scale_6.c
+++ b/examples/widgets/scale/lv_example_scale_6.c
@@ -14,6 +14,7 @@ static lv_point_precise_t minute_hand_points[2];
 static int32_t hour;
 static int32_t minute;
 
+LV_FUNC_SECTION
 static void timer_cb(lv_timer_t * timer)
 {
     LV_UNUSED(timer);
@@ -51,6 +52,7 @@ static void timer_cb(lv_timer_t * timer)
 /**
  * A round scale with multiple needles, resembling a clock
  */
+LV_FUNC_SECTION
 void lv_example_scale_6(void)
 {
     scale = lv_scale_create(lv_screen_active());
diff --git a/examples/widgets/scale/lv_example_scale_7.c b/examples/widgets/scale/lv_example_scale_7.c
index 7891164aa..7e07e8a81 100644
--- a/examples/widgets/scale/lv_example_scale_7.c
+++ b/examples/widgets/scale/lv_example_scale_7.c
@@ -3,6 +3,7 @@
 
 #include "../../../src/lvgl_private.h" //To expose the fields of lv_draw_task_t
 
+LV_FUNC_SECTION
 static void draw_event_cb(lv_event_t * e)
 {
     lv_obj_t * obj = lv_event_get_target(e);
@@ -49,6 +50,7 @@ static void draw_event_cb(lv_event_t * e)
 /**
  * Customizing scale major tick label color with `LV_EVENT_DRAW_TASK_ADDED` event
  */
+LV_FUNC_SECTION
 void lv_example_scale_7(void)
 {
     lv_obj_t * scale = lv_scale_create(lv_screen_active());
diff --git a/examples/widgets/slider/lv_example_slider_1.c b/examples/widgets/slider/lv_example_slider_1.c
index bcb20fb8c..9b73c14ef 100644
--- a/examples/widgets/slider/lv_example_slider_1.c
+++ b/examples/widgets/slider/lv_example_slider_1.c
@@ -7,6 +7,7 @@ static lv_obj_t * slider_label;
 /**
  * A default slider with a label displaying the current value
  */
+LV_FUNC_SECTION
 void lv_example_slider_1(void)
 {
     /*Create a slider in the center of the display*/
@@ -22,6 +23,7 @@ void lv_example_slider_1(void)
     lv_obj_align_to(slider_label, slider, LV_ALIGN_OUT_BOTTOM_MID, 0, 10);
 }
 
+LV_FUNC_SECTION
 static void slider_event_cb(lv_event_t * e)
 {
     lv_obj_t * slider = lv_event_get_target(e);
diff --git a/examples/widgets/slider/lv_example_slider_2.c b/examples/widgets/slider/lv_example_slider_2.c
index 7cfeff745..32ad16272 100644
--- a/examples/widgets/slider/lv_example_slider_2.c
+++ b/examples/widgets/slider/lv_example_slider_2.c
@@ -4,6 +4,7 @@
 /**
  * Show how to style a slider.
  */
+LV_FUNC_SECTION
 void lv_example_slider_2(void)
 {
     /*Create a transition*/
diff --git a/examples/widgets/slider/lv_example_slider_3.c b/examples/widgets/slider/lv_example_slider_3.c
index 9a190c555..0956ea3bc 100644
--- a/examples/widgets/slider/lv_example_slider_3.c
+++ b/examples/widgets/slider/lv_example_slider_3.c
@@ -10,6 +10,7 @@ static void slider_event_cb(lv_event_t * e);
  * Show the current value when the slider is pressed by extending the drawer
  *
  */
+LV_FUNC_SECTION
 void lv_example_slider_3(void)
 {
     /*Create a slider in the center of the display*/
@@ -26,6 +27,7 @@ void lv_example_slider_3(void)
     lv_obj_refresh_ext_draw_size(slider);
 }
 
+LV_FUNC_SECTION
 static void slider_event_cb(lv_event_t * e)
 {
     lv_event_code_t code = lv_event_get_code(e);
diff --git a/examples/widgets/slider/lv_example_slider_4.c b/examples/widgets/slider/lv_example_slider_4.c
index 12792a887..7bffbd1eb 100644
--- a/examples/widgets/slider/lv_example_slider_4.c
+++ b/examples/widgets/slider/lv_example_slider_4.c
@@ -7,6 +7,7 @@ static lv_obj_t * slider_label;
 /**
  * Slider with opposite direction
  */
+LV_FUNC_SECTION
 void lv_example_slider_4(void)
 {
     /*Create a slider in the center of the display*/
@@ -22,6 +23,7 @@ void lv_example_slider_4(void)
     lv_obj_align_to(slider_label, slider, LV_ALIGN_OUT_BOTTOM_MID, 0, 10);
 }
 
+LV_FUNC_SECTION
 static void slider_event_cb(lv_event_t * e)
 {
     lv_obj_t * slider = lv_event_get_target(e);
diff --git a/examples/widgets/span/lv_example_span_1.c b/examples/widgets/span/lv_example_span_1.c
index f74e0a3f8..e7ef317ca 100644
--- a/examples/widgets/span/lv_example_span_1.c
+++ b/examples/widgets/span/lv_example_span_1.c
@@ -4,6 +4,7 @@
 /**
  * Create span.
  */
+LV_FUNC_SECTION
 void lv_example_span_1(void)
 {
     static lv_style_t style;
diff --git a/examples/widgets/spinbox/lv_example_spinbox_1.c b/examples/widgets/spinbox/lv_example_spinbox_1.c
index 774c8f276..ab3700252 100644
--- a/examples/widgets/spinbox/lv_example_spinbox_1.c
+++ b/examples/widgets/spinbox/lv_example_spinbox_1.c
@@ -3,6 +3,7 @@
 
 static lv_obj_t * spinbox;
 
+LV_FUNC_SECTION
 static void lv_spinbox_increment_event_cb(lv_event_t * e)
 {
     lv_event_code_t code = lv_event_get_code(e);
@@ -11,6 +12,7 @@ static void lv_spinbox_increment_event_cb(lv_event_t * e)
     }
 }
 
+LV_FUNC_SECTION
 static void lv_spinbox_decrement_event_cb(lv_event_t * e)
 {
     lv_event_code_t code = lv_event_get_code(e);
@@ -19,6 +21,7 @@ static void lv_spinbox_decrement_event_cb(lv_event_t * e)
     }
 }
 
+LV_FUNC_SECTION
 void lv_example_spinbox_1(void)
 {
     spinbox = lv_spinbox_create(lv_screen_active());
diff --git a/examples/widgets/spinner/lv_example_spinner_1.c b/examples/widgets/spinner/lv_example_spinner_1.c
index ce978b940..29541fbb0 100644
--- a/examples/widgets/spinner/lv_example_spinner_1.c
+++ b/examples/widgets/spinner/lv_example_spinner_1.c
@@ -1,6 +1,7 @@
 #include "../../lv_examples.h"
 #if LV_USE_SPINNER && LV_BUILD_EXAMPLES
 
+LV_FUNC_SECTION
 void lv_example_spinner_1(void)
 {
     /*Create a spinner*/
diff --git a/examples/widgets/switch/lv_example_switch_1.c b/examples/widgets/switch/lv_example_switch_1.c
index 7b6a53138..ed90a2b32 100644
--- a/examples/widgets/switch/lv_example_switch_1.c
+++ b/examples/widgets/switch/lv_example_switch_1.c
@@ -1,6 +1,7 @@
 #include "../../lv_examples.h"
 #if LV_USE_SWITCH && LV_BUILD_EXAMPLES
 
+__attribute__(( fptrgroup("lv_event_cb") ))
 static void event_handler(lv_event_t * e)
 {
     lv_event_code_t code = lv_event_get_code(e);
@@ -11,6 +12,7 @@ static void event_handler(lv_event_t * e)
     }
 }
 
+LV_FUNC_SECTION
 void lv_example_switch_1(void)
 {
     lv_obj_set_flex_flow(lv_screen_active(), LV_FLEX_FLOW_COLUMN);
diff --git a/examples/widgets/table/lv_example_table_1.c b/examples/widgets/table/lv_example_table_1.c
index 9dcd3dfa5..424410d0d 100644
--- a/examples/widgets/table/lv_example_table_1.c
+++ b/examples/widgets/table/lv_example_table_1.c
@@ -1,6 +1,7 @@
 #include "../../lv_examples.h"
 #if LV_USE_TABLE && LV_BUILD_EXAMPLES
 
+LV_FUNC_SECTION
 static void draw_event_cb(lv_event_t * e)
 {
     lv_draw_task_t * draw_task = lv_event_get_draw_task(e);
@@ -41,6 +42,7 @@ static void draw_event_cb(lv_event_t * e)
     }
 }
 
+LV_FUNC_SECTION
 void lv_example_table_1(void)
 {
     lv_obj_t * table = lv_table_create(lv_screen_active());
diff --git a/examples/widgets/table/lv_example_table_2.c b/examples/widgets/table/lv_example_table_2.c
index d0d5ae192..29e99ecf8 100644
--- a/examples/widgets/table/lv_example_table_2.c
+++ b/examples/widgets/table/lv_example_table_2.c
@@ -3,6 +3,7 @@
 
 #define ITEM_CNT 200
 
+LV_FUNC_SECTION
 static void draw_event_cb(lv_event_t * e)
 {
     lv_obj_t * obj = lv_event_get_target(e);
@@ -45,6 +46,7 @@ static void draw_event_cb(lv_event_t * e)
     }
 }
 
+LV_FUNC_SECTION
 static void change_event_cb(lv_event_t * e)
 {
     lv_obj_t * obj = lv_event_get_target(e);
@@ -59,6 +61,7 @@ static void change_event_cb(lv_event_t * e)
 /**
  * A very light-weighted list created from table
  */
+LV_FUNC_SECTION
 void lv_example_table_2(void)
 {
     /*Measure memory usage*/
diff --git a/examples/widgets/tabview/lv_example_tabview_1.c b/examples/widgets/tabview/lv_example_tabview_1.c
index fe84d71ea..b120c58d6 100644
--- a/examples/widgets/tabview/lv_example_tabview_1.c
+++ b/examples/widgets/tabview/lv_example_tabview_1.c
@@ -1,6 +1,7 @@
 #include "../../lv_examples.h"
 #if LV_USE_TABVIEW && LV_BUILD_EXAMPLES
 
+LV_FUNC_SECTION
 void lv_example_tabview_1(void)
 {
     /*Create a Tab view object*/
diff --git a/examples/widgets/tabview/lv_example_tabview_2.c b/examples/widgets/tabview/lv_example_tabview_2.c
index 5e9dfe095..66e61efd8 100644
--- a/examples/widgets/tabview/lv_example_tabview_2.c
+++ b/examples/widgets/tabview/lv_example_tabview_2.c
@@ -2,6 +2,7 @@
 #if LV_USE_TABVIEW && LV_BUILD_EXAMPLES
 
 /*A vertical tab view with disabled scrolling and some styling*/
+LV_FUNC_SECTION
 void lv_example_tabview_2(void)
 {
     /*Create a Tab view object*/
diff --git a/examples/widgets/textarea/lv_example_textarea_1.c b/examples/widgets/textarea/lv_example_textarea_1.c
index 1eab27ec8..1703d90e2 100644
--- a/examples/widgets/textarea/lv_example_textarea_1.c
+++ b/examples/widgets/textarea/lv_example_textarea_1.c
@@ -1,6 +1,7 @@
 #include "../../lv_examples.h"
 #if LV_USE_TEXTAREA && LV_BUILD_EXAMPLES
 
+LV_FUNC_SECTION
 static void textarea_event_handler(lv_event_t * e)
 {
     lv_obj_t * ta = lv_event_get_target(e);
@@ -8,6 +9,7 @@ static void textarea_event_handler(lv_event_t * e)
     LV_LOG_USER("Enter was pressed. The current text is: %s", lv_textarea_get_text(ta));
 }
 
+LV_FUNC_SECTION
 static void btnm_event_handler(lv_event_t * e)
 {
     lv_obj_t * obj = lv_event_get_target(e);
@@ -20,6 +22,7 @@ static void btnm_event_handler(lv_event_t * e)
 
 }
 
+LV_FUNC_SECTION
 void lv_example_textarea_1(void)
 {
     lv_obj_t * ta = lv_textarea_create(lv_screen_active());
diff --git a/examples/widgets/textarea/lv_example_textarea_2.c b/examples/widgets/textarea/lv_example_textarea_2.c
index b1d7cbc8c..ecedf6f09 100644
--- a/examples/widgets/textarea/lv_example_textarea_2.c
+++ b/examples/widgets/textarea/lv_example_textarea_2.c
@@ -5,6 +5,7 @@ static void ta_event_cb(lv_event_t * e);
 
 static lv_obj_t * kb;
 
+LV_FUNC_SECTION
 void lv_example_textarea_2(void)
 {
     /*Create the password box*/
@@ -49,6 +50,7 @@ void lv_example_textarea_2(void)
 
 }
 
+__attribute__(( fptrgroup("lv_event_cb") ))
 static void ta_event_cb(lv_event_t * e)
 {
     lv_event_code_t code = lv_event_get_code(e);
diff --git a/examples/widgets/textarea/lv_example_textarea_3.c b/examples/widgets/textarea/lv_example_textarea_3.c
index 6fccb3f92..96d4c17c2 100644
--- a/examples/widgets/textarea/lv_example_textarea_3.c
+++ b/examples/widgets/textarea/lv_example_textarea_3.c
@@ -9,6 +9,7 @@ static lv_obj_t * kb;
  * Automatically format text like a clock. E.g. "12:34"
  * Add the ':' automatically.
  */
+LV_FUNC_SECTION
 void lv_example_textarea_3(void)
 {
     /*Create the text area*/
@@ -26,6 +27,7 @@ void lv_example_textarea_3(void)
     lv_keyboard_set_textarea(kb, ta);
 }
 
+__attribute__(( fptrgroup("lv_event_cb") ))
 static void ta_event_cb(lv_event_t * e)
 {
     lv_obj_t * ta = lv_event_get_target(e);
diff --git a/examples/widgets/tileview/lv_example_tileview_1.c b/examples/widgets/tileview/lv_example_tileview_1.c
index 8a1458063..5b4997875 100644
--- a/examples/widgets/tileview/lv_example_tileview_1.c
+++ b/examples/widgets/tileview/lv_example_tileview_1.c
@@ -6,6 +6,7 @@
  * Demonstrate scroll chaining with a long list that
  * scrolls the tile view when it can't be scrolled further.
  */
+LV_FUNC_SECTION
 void lv_example_tileview_1(void)
 {
     lv_obj_t * tv = lv_tileview_create(lv_screen_active());
diff --git a/examples/widgets/win/lv_example_win_1.c b/examples/widgets/win/lv_example_win_1.c
index 67411a958..25eaf1ab9 100644
--- a/examples/widgets/win/lv_example_win_1.c
+++ b/examples/widgets/win/lv_example_win_1.c
@@ -1,6 +1,7 @@
 #include "../../lv_examples.h"
 #if LV_USE_WIN && LV_BUILD_EXAMPLES
 
+__attribute__(( fptrgroup("lv_event_cb") ))
 static void event_handler(lv_event_t * e)
 {
     lv_obj_t * obj = lv_event_get_target(e);
@@ -8,6 +9,7 @@ static void event_handler(lv_event_t * e)
     LV_LOG_USER("Button %d clicked", (int)lv_obj_get_index(obj));
 }
 
+LV_FUNC_SECTION
 void lv_example_win_1(void)
 {
     lv_obj_t * win = lv_win_create(lv_screen_active());
diff --git a/src/core/lv_group.c b/src/core/lv_group.c
index d1cdb3176..5bab120e5 100644
--- a/src/core/lv_group.c
+++ b/src/core/lv_group.c
@@ -42,16 +42,19 @@ static lv_indev_t * get_indev(const lv_group_t * g);
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 void lv_group_init(void)
 {
     lv_ll_init(group_ll_p, sizeof(lv_group_t));
 }
 
+LV_FUNC_SECTION
 void lv_group_deinit(void)
 {
     lv_ll_clear(group_ll_p);
 }
 
+LV_FUNC_SECTION
 lv_group_t * lv_group_create(void)
 {
     lv_group_t * group = lv_ll_ins_head(group_ll_p);
@@ -71,6 +74,7 @@ lv_group_t * lv_group_create(void)
     return group;
 }
 
+LV_FUNC_SECTION
 void lv_group_delete(lv_group_t * group)
 {
     /*Defocus the currently focused object*/
@@ -103,16 +107,19 @@ void lv_group_delete(lv_group_t * group)
     lv_free(group);
 }
 
+LV_FUNC_SECTION
 void lv_group_set_default(lv_group_t * group)
 {
     default_group = group;
 }
 
+LV_FUNC_SECTION
 lv_group_t * lv_group_get_default(void)
 {
     return default_group;
 }
 
+LV_FUNC_SECTION
 void lv_group_add_obj(lv_group_t * group, lv_obj_t * obj)
 {
     if(group == NULL) return;
@@ -139,6 +146,7 @@ void lv_group_add_obj(lv_group_t * group, lv_obj_t * obj)
     LV_LOG_TRACE("finished");
 }
 
+LV_FUNC_SECTION
 void lv_group_swap_obj(lv_obj_t * obj1, lv_obj_t * obj2)
 {
     lv_group_t * g1 = lv_obj_get_group(obj1);
@@ -159,6 +167,7 @@ void lv_group_swap_obj(lv_obj_t * obj1, lv_obj_t * obj2)
 
 }
 
+LV_FUNC_SECTION
 void lv_group_remove_obj(lv_obj_t * obj)
 {
     lv_group_t * g = lv_obj_get_group(obj);
@@ -200,6 +209,7 @@ void lv_group_remove_obj(lv_obj_t * obj)
     LV_LOG_TRACE("finished");
 }
 
+LV_FUNC_SECTION
 void lv_group_remove_all_objs(lv_group_t * group)
 {
     LV_ASSERT_NULL(group);
@@ -220,6 +230,7 @@ void lv_group_remove_all_objs(lv_group_t * group)
     lv_ll_clear(&(group->obj_ll));
 }
 
+LV_FUNC_SECTION
 void lv_group_focus_obj(lv_obj_t * obj)
 {
     if(obj == NULL) return;
@@ -253,6 +264,7 @@ void lv_group_focus_obj(lv_obj_t * obj)
     }
 }
 
+LV_FUNC_SECTION
 void lv_group_focus_next(lv_group_t * group)
 {
     LV_ASSERT_NULL(group);
@@ -264,6 +276,7 @@ void lv_group_focus_next(lv_group_t * group)
     }
 }
 
+LV_FUNC_SECTION
 void lv_group_focus_prev(lv_group_t * group)
 {
     LV_ASSERT_NULL(group);
@@ -275,6 +288,7 @@ void lv_group_focus_prev(lv_group_t * group)
     }
 }
 
+LV_FUNC_SECTION
 void lv_group_focus_freeze(lv_group_t * group, bool en)
 {
     LV_ASSERT_NULL(group);
@@ -283,6 +297,7 @@ void lv_group_focus_freeze(lv_group_t * group, bool en)
     else group->frozen = 1;
 }
 
+LV_FUNC_SECTION
 lv_result_t lv_group_send_data(lv_group_t * group, uint32_t c)
 {
     LV_ASSERT_NULL(group);
@@ -295,6 +310,7 @@ lv_result_t lv_group_send_data(lv_group_t * group, uint32_t c)
     return lv_obj_send_event(act, LV_EVENT_KEY, &c);
 }
 
+LV_FUNC_SECTION
 void lv_group_set_focus_cb(lv_group_t * group, lv_group_focus_cb_t focus_cb)
 {
     if(group == NULL) return;
@@ -302,6 +318,7 @@ void lv_group_set_focus_cb(lv_group_t * group, lv_group_focus_cb_t focus_cb)
     group->focus_cb = focus_cb;
 }
 
+LV_FUNC_SECTION
 void lv_group_set_edge_cb(lv_group_t * group, lv_group_edge_cb_t edge_cb)
 {
     LV_ASSERT_NULL(group);
@@ -309,6 +326,7 @@ void lv_group_set_edge_cb(lv_group_t * group, lv_group_edge_cb_t edge_cb)
     group->edge_cb = edge_cb;
 }
 
+LV_FUNC_SECTION
 void lv_group_set_editing(lv_group_t * group, bool edit)
 {
     LV_ASSERT_NULL(group);
@@ -327,18 +345,21 @@ void lv_group_set_editing(lv_group_t * group, bool edit)
     }
 }
 
+LV_FUNC_SECTION
 void lv_group_set_refocus_policy(lv_group_t * group, lv_group_refocus_policy_t policy)
 {
     LV_ASSERT_NULL(group);
     group->refocus_policy = policy & 0x01;
 }
 
+LV_FUNC_SECTION
 void lv_group_set_wrap(lv_group_t * group, bool en)
 {
     LV_ASSERT_NULL(group);
     group->wrap = en ? 1 : 0;
 }
 
+LV_FUNC_SECTION
 lv_obj_t * lv_group_get_focused(const lv_group_t * group)
 {
     if(!group) return NULL;
@@ -347,36 +368,42 @@ lv_obj_t * lv_group_get_focused(const lv_group_t * group)
     return *group->obj_focus;
 }
 
+LV_FUNC_SECTION
 lv_group_focus_cb_t lv_group_get_focus_cb(const lv_group_t * group)
 {
     if(!group) return NULL;
     return group->focus_cb;
 }
 
+LV_FUNC_SECTION
 lv_group_edge_cb_t lv_group_get_edge_cb(const lv_group_t * group)
 {
     if(!group) return NULL;
     return group->edge_cb;
 }
 
+LV_FUNC_SECTION
 bool lv_group_get_editing(const lv_group_t * group)
 {
     if(!group) return false;
     return group->editing;
 }
 
+LV_FUNC_SECTION
 bool lv_group_get_wrap(lv_group_t * group)
 {
     if(!group) return false;
     return group->wrap;
 }
 
+LV_FUNC_SECTION
 uint32_t lv_group_get_obj_count(lv_group_t * group)
 {
     LV_ASSERT_NULL(group);
     return lv_ll_get_len(&group->obj_ll);
 }
 
+LV_FUNC_SECTION
 lv_obj_t * lv_group_get_obj_by_index(lv_group_t * group, uint32_t index)
 {
     uint32_t len = 0;
@@ -391,11 +418,13 @@ lv_obj_t * lv_group_get_obj_by_index(lv_group_t * group, uint32_t index)
     return NULL;
 }
 
+LV_FUNC_SECTION
 uint32_t lv_group_get_count(void)
 {
     return lv_ll_get_len(group_ll_p);
 }
 
+LV_FUNC_SECTION
 lv_group_t  * lv_group_by_index(uint32_t index)
 {
     uint32_t len = 0;
@@ -414,6 +443,7 @@ lv_group_t  * lv_group_by_index(uint32_t index)
  *   STATIC FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 static void lv_group_refocus(lv_group_t * g)
 {
     /*Refocus must temporarily allow wrapping to work correctly*/
@@ -428,8 +458,10 @@ static void lv_group_refocus(lv_group_t * g)
     g->wrap = temp_wrap;
 }
 
-static bool focus_next_core(lv_group_t * group, void * (*begin)(const lv_ll_t *),
-                            void * (*move)(const lv_ll_t *, const void *))
+LV_FUNC_SECTION
+static bool focus_next_core(lv_group_t * group,
+    __attribute__(( fptrgroup("lv_ll_get") )) void * (*begin)(const lv_ll_t *),
+    __attribute__(( fptrgroup("lv_ll_get") )) void * (*move)(const lv_ll_t *, const void *))
 {
     bool focus_changed = false;
     if(group->frozen) return focus_changed;
@@ -511,6 +543,7 @@ static bool focus_next_core(lv_group_t * group, void * (*begin)(const lv_ll_t *)
  * @param g     a group the find in the indevs
  * @return      the suggested indev
  */
+LV_FUNC_SECTION
 static lv_indev_t * get_indev(const lv_group_t * g)
 {
     lv_indev_t * indev_guess = NULL;
diff --git a/src/core/lv_group_private.h b/src/core/lv_group_private.h
index 33b7640c7..fbbbcb806 100644
--- a/src/core/lv_group_private.h
+++ b/src/core/lv_group_private.h
@@ -32,7 +32,9 @@ struct lv_group_t {
     lv_ll_t obj_ll;        /**< Linked list to store the objects in the group*/
     lv_obj_t ** obj_focus; /**< The object in focus*/
 
+    __attribute__(( fptrgroup("lv_focus_cb") ))
     lv_group_focus_cb_t focus_cb;              /**< A function to call when a new object is focused (optional)*/
+    __attribute__(( fptrgroup("lv_edge_cb") ))
     lv_group_edge_cb_t  edge_cb;               /**< A function to call when an edge is reached, no more focus
                                                     targets are available in this direction (to allow edge feedback
                                                     like a sound or a scroll bounce) */
diff --git a/src/core/lv_obj.c b/src/core/lv_obj.c
index c58e95502..d407d9528 100644
--- a/src/core/lv_obj.c
+++ b/src/core/lv_obj.c
@@ -210,6 +210,7 @@ const lv_obj_class_t lv_obj_class = {
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 lv_obj_t * lv_obj_create(lv_obj_t * parent)
 {
     LV_LOG_INFO("begin");
@@ -228,6 +229,7 @@ lv_obj_t * lv_obj_create(lv_obj_t * parent)
  * Attribute set
  *----------------*/
 
+LV_FUNC_SECTION
 void lv_obj_add_flag(lv_obj_t * obj, lv_obj_flag_t f)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -265,6 +267,7 @@ void lv_obj_add_flag(lv_obj_t * obj, lv_obj_flag_t f)
     }
 }
 
+LV_FUNC_SECTION
 void lv_obj_remove_flag(lv_obj_t * obj, lv_obj_flag_t f)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -293,12 +296,14 @@ void lv_obj_remove_flag(lv_obj_t * obj, lv_obj_flag_t f)
 
 }
 
+LV_FUNC_SECTION
 void lv_obj_update_flag(lv_obj_t * obj, lv_obj_flag_t f, bool v)
 {
     if(v) lv_obj_add_flag(obj, f);
     else lv_obj_remove_flag(obj, f);
 }
 
+LV_FUNC_SECTION
 void lv_obj_add_state(lv_obj_t * obj, lv_state_t state)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -314,6 +319,7 @@ void lv_obj_add_state(lv_obj_t * obj, lv_state_t state)
     }
 }
 
+LV_FUNC_SECTION
 void lv_obj_remove_state(lv_obj_t * obj, lv_state_t state)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -324,6 +330,7 @@ void lv_obj_remove_state(lv_obj_t * obj, lv_state_t state)
     }
 }
 
+LV_FUNC_SECTION
 void lv_obj_set_state(lv_obj_t * obj, lv_state_t state, bool v)
 {
     if(v) lv_obj_add_state(obj, state);
@@ -334,6 +341,7 @@ void lv_obj_set_state(lv_obj_t * obj, lv_state_t state, bool v)
  * Getter functions
  *======================*/
 
+LV_FUNC_SECTION
 bool lv_obj_has_flag(const lv_obj_t * obj, lv_obj_flag_t f)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -341,6 +349,7 @@ bool lv_obj_has_flag(const lv_obj_t * obj, lv_obj_flag_t f)
     return (obj->flags & f)  == f;
 }
 
+LV_FUNC_SECTION
 bool lv_obj_has_flag_any(const lv_obj_t * obj, lv_obj_flag_t f)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -348,6 +357,7 @@ bool lv_obj_has_flag_any(const lv_obj_t * obj, lv_obj_flag_t f)
     return !!(obj->flags & f);
 }
 
+LV_FUNC_SECTION
 lv_state_t lv_obj_get_state(const lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -355,6 +365,7 @@ lv_state_t lv_obj_get_state(const lv_obj_t * obj)
     return obj->state;
 }
 
+LV_FUNC_SECTION
 bool lv_obj_has_state(const lv_obj_t * obj, lv_state_t state)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -362,6 +373,7 @@ bool lv_obj_has_state(const lv_obj_t * obj, lv_state_t state)
     return !!(obj->state & state);
 }
 
+LV_FUNC_SECTION
 lv_group_t * lv_obj_get_group(const lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -374,6 +386,7 @@ lv_group_t * lv_obj_get_group(const lv_obj_t * obj)
  * OTHER FUNCTIONS
  *------------------*/
 
+LV_FUNC_SECTION
 void lv_obj_allocate_spec_attr(lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -388,12 +401,14 @@ void lv_obj_allocate_spec_attr(lv_obj_t * obj)
     }
 }
 
+LV_FUNC_SECTION
 bool lv_obj_check_type(const lv_obj_t * obj, const lv_obj_class_t * class_p)
 {
     if(obj == NULL) return false;
     return obj->class_p == class_p;
 }
 
+LV_FUNC_SECTION
 bool lv_obj_has_class(const lv_obj_t * obj, const lv_obj_class_t * class_p)
 {
     const lv_obj_class_t * obj_class = obj->class_p;
@@ -405,11 +420,13 @@ bool lv_obj_has_class(const lv_obj_t * obj, const lv_obj_class_t * class_p)
     return false;
 }
 
+LV_FUNC_SECTION
 const lv_obj_class_t * lv_obj_get_class(const lv_obj_t * obj)
 {
     return obj->class_p;
 }
 
+LV_FUNC_SECTION
 bool lv_obj_is_valid(const lv_obj_t * obj)
 {
     lv_display_t * disp = lv_display_get_next(NULL);
@@ -427,18 +444,21 @@ bool lv_obj_is_valid(const lv_obj_t * obj)
     return false;
 }
 
+LV_FUNC_SECTION
 void lv_obj_null_on_delete(lv_obj_t ** obj_ptr)
 {
     lv_obj_add_event_cb(*obj_ptr, null_on_delete_cb, LV_EVENT_DELETE, obj_ptr);
 }
 
 #if LV_USE_OBJ_ID
+LV_FUNC_SECTION
 void * lv_obj_get_id(const lv_obj_t * obj)
 {
     LV_ASSERT_NULL(obj);
     return obj->id;
 }
 
+LV_FUNC_SECTION
 lv_obj_t * lv_obj_get_child_by_id(const lv_obj_t * obj, const void * id)
 {
     if(obj == NULL) obj = lv_display_get_screen_active(NULL);
@@ -462,11 +482,13 @@ lv_obj_t * lv_obj_get_child_by_id(const lv_obj_t * obj, const void * id)
 }
 #endif
 
+LV_FUNC_SECTION
 void lv_obj_set_user_data(lv_obj_t * obj, void * user_data)
 {
     obj->user_data = user_data;
 }
 
+LV_FUNC_SECTION
 void * lv_obj_get_user_data(lv_obj_t * obj)
 {
     return obj->user_data;
@@ -476,6 +498,7 @@ void * lv_obj_get_user_data(lv_obj_t * obj)
  *   STATIC FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 static void lv_obj_constructor(const lv_obj_class_t * class_p, lv_obj_t * obj)
 {
     LV_UNUSED(class_p);
@@ -511,6 +534,7 @@ static void lv_obj_constructor(const lv_obj_class_t * class_p, lv_obj_t * obj)
     LV_TRACE_OBJ_CREATE("finished");
 }
 
+LV_FUNC_SECTION
 static void lv_obj_destructor(const lv_obj_class_t * class_p, lv_obj_t * obj)
 {
     LV_UNUSED(class_p);
@@ -546,6 +570,7 @@ static void lv_obj_destructor(const lv_obj_class_t * class_p, lv_obj_t * obj)
 #endif
 }
 
+LV_FUNC_SECTION
 static void lv_obj_draw(lv_event_t * e)
 {
     lv_event_code_t code = lv_event_get_code(e);
@@ -643,6 +668,7 @@ static void lv_obj_draw(lv_event_t * e)
     }
 }
 
+LV_FUNC_SECTION
 static void draw_scrollbar(lv_obj_t * obj, lv_layer_t * layer)
 {
 
@@ -672,6 +698,7 @@ static void draw_scrollbar(lv_obj_t * obj, lv_layer_t * layer)
  * @param dsc the draw descriptor to initialize
  * @return LV_RESULT_OK: the scrollbar is visible; LV_RESULT_INVALID: the scrollbar is not visible
  */
+LV_FUNC_SECTION
 static lv_result_t scrollbar_init_draw_dsc(lv_obj_t * obj, lv_draw_rect_dsc_t * dsc)
 {
     lv_draw_rect_dsc_init(dsc);
@@ -720,6 +747,7 @@ static lv_result_t scrollbar_init_draw_dsc(lv_obj_t * obj, lv_draw_rect_dsc_t *
     }
 }
 
+LV_FUNC_SECTION
 static void lv_obj_event(const lv_obj_class_t * class_p, lv_event_t * e)
 {
     LV_UNUSED(class_p);
@@ -889,6 +917,7 @@ static void lv_obj_event(const lv_obj_class_t * class_p, lv_event_t * e)
  * @param obj       pointer to an object
  * @param state     the new state
  */
+LV_FUNC_SECTION
 static void update_obj_state(lv_obj_t * obj, lv_state_t new_state)
 {
     if(obj->state == new_state) return;
@@ -967,6 +996,7 @@ static void update_obj_state(lv_obj_t * obj, lv_state_t new_state)
     }
 }
 
+LV_FUNC_SECTION
 static bool obj_valid_child(const lv_obj_t * parent, const lv_obj_t * obj_to_find)
 {
     /*Check all children of `parent`*/
@@ -988,6 +1018,7 @@ static bool obj_valid_child(const lv_obj_t * parent, const lv_obj_t * obj_to_fin
     return false;
 }
 
+__attribute__(( fptrgroup("lv_event_cb") ))
 static void null_on_delete_cb(lv_event_t * e)
 {
     lv_obj_t ** obj_ptr = lv_event_get_user_data(e);
@@ -995,6 +1026,7 @@ static void null_on_delete_cb(lv_event_t * e)
 }
 
 #if LV_USE_OBJ_PROPERTY
+LV_FUNC_SECTION
 static lv_result_t lv_obj_set_any(lv_obj_t * obj, lv_prop_id_t id, const lv_property_t * prop)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -1020,6 +1052,7 @@ static lv_result_t lv_obj_set_any(lv_obj_t * obj, lv_prop_id_t id, const lv_prop
     }
 }
 
+LV_FUNC_SECTION
 static lv_result_t lv_obj_get_any(const lv_obj_t * obj, lv_prop_id_t id, lv_property_t * prop)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
diff --git a/src/core/lv_obj_class.c b/src/core/lv_obj_class.c
index cb5a396b0..500be5ec9 100644
--- a/src/core/lv_obj_class.c
+++ b/src/core/lv_obj_class.c
@@ -44,6 +44,7 @@ static uint32_t get_instance_size(const lv_obj_class_t * class_p);
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 lv_obj_t * lv_obj_class_create_obj(const lv_obj_class_t * class_p, lv_obj_t * parent)
 {
     LV_TRACE_OBJ_CREATE("Creating object with %p class on %p parent", (void *)class_p, (void *)parent);
@@ -101,6 +102,7 @@ lv_obj_t * lv_obj_class_create_obj(const lv_obj_class_t * class_p, lv_obj_t * pa
     return obj;
 }
 
+LV_FUNC_SECTION
 void lv_obj_class_init_obj(lv_obj_t * obj)
 {
     if(obj == NULL) return;
@@ -133,6 +135,8 @@ void lv_obj_class_init_obj(lv_obj_t * obj)
     }
 }
 
+#pragma stackfunction 1024
+LV_FUNC_SECTION
 void lv_obj_destruct(lv_obj_t * obj)
 {
     if(obj->class_p->destructor_cb) obj->class_p->destructor_cb(obj->class_p, obj);
@@ -146,6 +150,7 @@ void lv_obj_destruct(lv_obj_t * obj)
     }
 }
 
+LV_FUNC_SECTION
 bool lv_obj_is_editable(lv_obj_t * obj)
 {
     const lv_obj_class_t * class_p = obj->class_p;
@@ -158,6 +163,7 @@ bool lv_obj_is_editable(lv_obj_t * obj)
     return class_p->editable == LV_OBJ_CLASS_EDITABLE_TRUE;
 }
 
+LV_FUNC_SECTION
 bool lv_obj_is_group_def(lv_obj_t * obj)
 {
     const lv_obj_class_t * class_p = obj->class_p;
@@ -173,7 +179,8 @@ bool lv_obj_is_group_def(lv_obj_t * obj)
 /**********************
  *   STATIC FUNCTIONS
  **********************/
-
+#pragma stackfunction 1024
+LV_FUNC_SECTION
 static void lv_obj_construct(const lv_obj_class_t * class_p, lv_obj_t * obj)
 {
     if(obj->class_p->base_class) {
@@ -192,6 +199,7 @@ static void lv_obj_construct(const lv_obj_class_t * class_p, lv_obj_t * obj)
     if(obj->class_p->constructor_cb) obj->class_p->constructor_cb(class_p, obj);
 }
 
+LV_FUNC_SECTION
 static uint32_t get_instance_size(const lv_obj_class_t * class_p)
 {
     /*Find a base in which instance size is set*/
diff --git a/src/core/lv_obj_class_private.h b/src/core/lv_obj_class_private.h
index 1279b9caf..53bf0f519 100644
--- a/src/core/lv_obj_class_private.h
+++ b/src/core/lv_obj_class_private.h
@@ -31,10 +31,13 @@ extern "C" {
 struct lv_obj_class_t {
     const lv_obj_class_t * base_class;
     /** class_p is the final class while obj->class_p is the class currently being [de]constructed. */
+    __attribute__(( fptrgroup("lv_obj_constructor_cb") ))
     void (*constructor_cb)(const lv_obj_class_t * class_p, lv_obj_t * obj);
+    __attribute__(( fptrgroup("lv_obj_destructor_cb") ))
     void (*destructor_cb)(const lv_obj_class_t * class_p, lv_obj_t * obj);
 
     /** class_p is the class in which event is being processed. */
+    __attribute__(( fptrgroup("lv_event_cb") ))
     void (*event_cb)(const lv_obj_class_t * class_p, lv_event_t * e);  /**< Widget type specific event function*/
 
 #if LV_USE_OBJ_PROPERTY
diff --git a/src/core/lv_obj_draw.c b/src/core/lv_obj_draw.c
index b3694b9e5..78901334d 100644
--- a/src/core/lv_obj_draw.c
+++ b/src/core/lv_obj_draw.c
@@ -39,6 +39,7 @@
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 void lv_obj_init_draw_rect_dsc(lv_obj_t * obj, lv_part_t part, lv_draw_rect_dsc_t * draw_dsc)
 {
     draw_dsc->base.obj = obj;
@@ -144,6 +145,7 @@ void lv_obj_init_draw_rect_dsc(lv_obj_t * obj, lv_part_t part, lv_draw_rect_dsc_
     }
 }
 
+LV_FUNC_SECTION
 void lv_obj_init_draw_label_dsc(lv_obj_t * obj, lv_part_t part, lv_draw_label_dsc_t * draw_dsc)
 {
     draw_dsc->base.obj = obj;
@@ -173,6 +175,7 @@ void lv_obj_init_draw_label_dsc(lv_obj_t * obj, lv_part_t part, lv_draw_label_ds
     draw_dsc->align = lv_obj_get_style_text_align(obj, part);
 }
 
+LV_FUNC_SECTION
 void lv_obj_init_draw_image_dsc(lv_obj_t * obj, lv_part_t part, lv_draw_image_dsc_t * draw_dsc)
 {
     draw_dsc->base.obj = obj;
@@ -199,6 +202,7 @@ void lv_obj_init_draw_image_dsc(lv_obj_t * obj, lv_part_t part, lv_draw_image_ds
     if(part != LV_PART_MAIN) draw_dsc->blend_mode = lv_obj_get_style_blend_mode(obj, part);
 }
 
+LV_FUNC_SECTION
 void lv_obj_init_draw_line_dsc(lv_obj_t * obj, lv_part_t part, lv_draw_line_dsc_t * draw_dsc)
 {
     draw_dsc->base.obj = obj;
@@ -229,6 +233,7 @@ void lv_obj_init_draw_line_dsc(lv_obj_t * obj, lv_part_t part, lv_draw_line_dsc_
     if(part != LV_PART_MAIN) draw_dsc->blend_mode = lv_obj_get_style_blend_mode(obj, part);
 }
 
+LV_FUNC_SECTION
 void lv_obj_init_draw_arc_dsc(lv_obj_t * obj, lv_part_t part, lv_draw_arc_dsc_t * draw_dsc)
 {
     draw_dsc->base.obj = obj;
@@ -252,6 +257,7 @@ void lv_obj_init_draw_arc_dsc(lv_obj_t * obj, lv_part_t part, lv_draw_arc_dsc_t
     draw_dsc->rounded = lv_obj_get_style_arc_rounded(obj, part);
 }
 
+LV_FUNC_SECTION
 int32_t lv_obj_calculate_ext_draw_size(lv_obj_t * obj, lv_part_t part)
 {
     int32_t s = 0;
@@ -286,6 +292,7 @@ int32_t lv_obj_calculate_ext_draw_size(lv_obj_t * obj, lv_part_t part)
     return s;
 }
 
+LV_FUNC_SECTION
 void lv_obj_refresh_ext_draw_size(lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -308,12 +315,14 @@ void lv_obj_refresh_ext_draw_size(lv_obj_t * obj)
     if(s_new != s_old) lv_obj_invalidate(obj);
 }
 
+LV_FUNC_SECTION
 int32_t lv_obj_get_ext_draw_size(const lv_obj_t * obj)
 {
     if(obj->spec_attr) return obj->spec_attr->ext_draw_size;
     else return 0;
 }
 
+LV_FUNC_SECTION
 lv_layer_type_t lv_obj_get_layer_type(const lv_obj_t * obj)
 {
 
diff --git a/src/core/lv_obj_event.c b/src/core/lv_obj_event.c
index 3831feeb5..b51b73bd8 100644
--- a/src/core/lv_obj_event.c
+++ b/src/core/lv_obj_event.c
@@ -44,7 +44,7 @@ static bool event_is_bubbled(lv_event_t * e);
 /**********************
  *   GLOBAL FUNCTIONS
  **********************/
-
+LV_FUNC_SECTION
 lv_result_t lv_obj_send_event(lv_obj_t * obj, lv_event_code_t event_code, void * param)
 {
     if(obj == NULL) return LV_RESULT_OK;
@@ -72,6 +72,7 @@ lv_result_t lv_obj_send_event(lv_obj_t * obj, lv_event_code_t event_code, void *
     return res;
 }
 
+LV_FUNC_SECTION
 lv_result_t lv_obj_event_base(const lv_obj_class_t * class_p, lv_event_t * e)
 {
     const lv_obj_class_t * base;
@@ -95,6 +96,7 @@ lv_result_t lv_obj_event_base(const lv_obj_class_t * class_p, lv_event_t * e)
     return res;
 }
 
+LV_FUNC_SECTION
 lv_event_dsc_t * lv_obj_add_event_cb(lv_obj_t * obj, lv_event_cb_t event_cb, lv_event_code_t filter, void * user_data)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -103,6 +105,7 @@ lv_event_dsc_t * lv_obj_add_event_cb(lv_obj_t * obj, lv_event_cb_t event_cb, lv_
     return lv_event_add(&obj->spec_attr->event_list, event_cb, filter, user_data);
 }
 
+LV_FUNC_SECTION
 uint32_t lv_obj_get_event_count(lv_obj_t * obj)
 {
     LV_ASSERT_NULL(obj);
@@ -110,6 +113,7 @@ uint32_t lv_obj_get_event_count(lv_obj_t * obj)
     return lv_event_get_count(&obj->spec_attr->event_list);
 }
 
+LV_FUNC_SECTION
 lv_event_dsc_t * lv_obj_get_event_dsc(lv_obj_t * obj, uint32_t index)
 {
     LV_ASSERT_NULL(obj);
@@ -117,6 +121,7 @@ lv_event_dsc_t * lv_obj_get_event_dsc(lv_obj_t * obj, uint32_t index)
     return lv_event_get_dsc(&obj->spec_attr->event_list, index);
 }
 
+LV_FUNC_SECTION
 bool lv_obj_remove_event(lv_obj_t * obj, uint32_t index)
 {
     LV_ASSERT_NULL(obj);
@@ -124,6 +129,7 @@ bool lv_obj_remove_event(lv_obj_t * obj, uint32_t index)
     return lv_event_remove(&obj->spec_attr->event_list, index);
 }
 
+LV_FUNC_SECTION
 bool lv_obj_remove_event_cb(lv_obj_t * obj, lv_event_cb_t event_cb)
 {
     LV_ASSERT_NULL(obj);
@@ -141,6 +147,7 @@ bool lv_obj_remove_event_cb(lv_obj_t * obj, lv_event_cb_t event_cb)
     return false;
 }
 
+LV_FUNC_SECTION
 bool lv_obj_remove_event_dsc(lv_obj_t * obj, lv_event_dsc_t * dsc)
 {
     LV_ASSERT_NULL(obj);
@@ -149,6 +156,7 @@ bool lv_obj_remove_event_dsc(lv_obj_t * obj, lv_event_dsc_t * dsc)
     return lv_event_remove_dsc(&obj->spec_attr->event_list, dsc);
 }
 
+LV_FUNC_SECTION
 uint32_t lv_obj_remove_event_cb_with_user_data(lv_obj_t * obj, lv_event_cb_t event_cb, void * user_data)
 {
     LV_ASSERT_NULL(obj);
@@ -168,16 +176,19 @@ uint32_t lv_obj_remove_event_cb_with_user_data(lv_obj_t * obj, lv_event_cb_t eve
     return removed_count;
 }
 
+LV_FUNC_SECTION
 lv_obj_t * lv_event_get_current_target_obj(lv_event_t * e)
 {
     return lv_event_get_current_target(e);
 }
 
+LV_FUNC_SECTION
 lv_obj_t * lv_event_get_target_obj(lv_event_t * e)
 {
     return lv_event_get_target(e);
 }
 
+LV_FUNC_SECTION
 lv_indev_t * lv_event_get_indev(lv_event_t * e)
 {
 
@@ -207,6 +218,7 @@ lv_indev_t * lv_event_get_indev(lv_event_t * e)
     }
 }
 
+LV_FUNC_SECTION
 lv_layer_t * lv_event_get_layer(lv_event_t * e)
 {
     if(e->code == LV_EVENT_DRAW_MAIN ||
@@ -223,6 +235,7 @@ lv_layer_t * lv_event_get_layer(lv_event_t * e)
     }
 }
 
+LV_FUNC_SECTION
 const lv_area_t * lv_event_get_old_size(lv_event_t * e)
 {
     if(e->code == LV_EVENT_SIZE_CHANGED) {
@@ -234,6 +247,7 @@ const lv_area_t * lv_event_get_old_size(lv_event_t * e)
     }
 }
 
+LV_FUNC_SECTION
 uint32_t lv_event_get_key(lv_event_t * e)
 {
     if(e->code == LV_EVENT_KEY) {
@@ -247,6 +261,7 @@ uint32_t lv_event_get_key(lv_event_t * e)
     }
 }
 
+LV_FUNC_SECTION
 int32_t lv_event_get_rotary_diff(lv_event_t * e)
 {
     if(e->code == LV_EVENT_ROTARY) {
@@ -260,6 +275,7 @@ int32_t lv_event_get_rotary_diff(lv_event_t * e)
     }
 }
 
+LV_FUNC_SECTION
 lv_anim_t * lv_event_get_scroll_anim(lv_event_t * e)
 {
     if(e->code == LV_EVENT_SCROLL_BEGIN) {
@@ -271,6 +287,7 @@ lv_anim_t * lv_event_get_scroll_anim(lv_event_t * e)
     }
 }
 
+LV_FUNC_SECTION
 void lv_event_set_ext_draw_size(lv_event_t * e, int32_t size)
 {
     if(e->code == LV_EVENT_REFR_EXT_DRAW_SIZE) {
@@ -282,6 +299,7 @@ void lv_event_set_ext_draw_size(lv_event_t * e, int32_t size)
     }
 }
 
+LV_FUNC_SECTION
 lv_point_t * lv_event_get_self_size_info(lv_event_t * e)
 {
     if(e->code == LV_EVENT_GET_SELF_SIZE) {
@@ -293,6 +311,7 @@ lv_point_t * lv_event_get_self_size_info(lv_event_t * e)
     }
 }
 
+LV_FUNC_SECTION
 lv_hit_test_info_t * lv_event_get_hit_test_info(lv_event_t * e)
 {
     if(e->code == LV_EVENT_HIT_TEST) {
@@ -304,6 +323,7 @@ lv_hit_test_info_t * lv_event_get_hit_test_info(lv_event_t * e)
     }
 }
 
+LV_FUNC_SECTION
 const lv_area_t * lv_event_get_cover_area(lv_event_t * e)
 {
     if(e->code == LV_EVENT_COVER_CHECK) {
@@ -316,6 +336,7 @@ const lv_area_t * lv_event_get_cover_area(lv_event_t * e)
     }
 }
 
+LV_FUNC_SECTION
 void lv_event_set_cover_res(lv_event_t * e, lv_cover_res_t res)
 {
     if(e->code == LV_EVENT_COVER_CHECK) {
@@ -327,6 +348,7 @@ void lv_event_set_cover_res(lv_event_t * e, lv_cover_res_t res)
     }
 }
 
+LV_FUNC_SECTION
 lv_draw_task_t * lv_event_get_draw_task(lv_event_t * e)
 {
     if(e->code == LV_EVENT_DRAW_TASK_ADDED) {
@@ -342,7 +364,8 @@ lv_draw_task_t * lv_event_get_draw_task(lv_event_t * e)
 /**********************
  *   STATIC FUNCTIONS
  **********************/
-
+ #pragma stackfunction 1024
+LV_FUNC_SECTION
 static lv_result_t event_send_core(lv_event_t * e)
 {
     LV_TRACE_EVENT("Sending event %d to %p with %p param", e->code, (void *)e->original_target, e->param);
@@ -377,6 +400,7 @@ static lv_result_t event_send_core(lv_event_t * e)
     return res;
 }
 
+LV_FUNC_SECTION
 static bool event_is_bubbled(lv_event_t * e)
 {
     if(e->stop_bubbling) return false;
diff --git a/src/core/lv_obj_id_builtin.c b/src/core/lv_obj_id_builtin.c
index ed8f745ff..f8e93e1d1 100644
--- a/src/core/lv_obj_id_builtin.c
+++ b/src/core/lv_obj_id_builtin.c
@@ -43,6 +43,7 @@ typedef struct _class_info_t {
 
 #if LV_USE_OBJ_ID && LV_USE_OBJ_ID_BUILTIN
 
+LV_FUNC_SECTION
 void lv_obj_assign_id(const lv_obj_class_t * class_p, lv_obj_t * obj)
 {
     LV_ASSERT(obj && class_p);
@@ -79,6 +80,7 @@ void lv_obj_assign_id(const lv_obj_class_t * class_p, lv_obj_t * obj)
     obj->id = (void *)(lv_uintptr_t)id;
 }
 
+LV_FUNC_SECTION
 void lv_obj_set_id(lv_obj_t * obj, void * id)
 {
     LV_ASSERT_NULL(obj);
@@ -86,12 +88,14 @@ void lv_obj_set_id(lv_obj_t * obj, void * id)
     obj->id = id;
 }
 
+LV_FUNC_SECTION
 void lv_obj_free_id(lv_obj_t * obj)
 {
     LV_UNUSED(obj);
     obj->id = NULL;
 }
 
+LV_FUNC_SECTION
 const char * lv_obj_stringify_id(lv_obj_t * obj, char * buf, uint32_t len)
 {
     const char * name;
@@ -105,6 +109,7 @@ const char * lv_obj_stringify_id(lv_obj_t * obj, char * buf, uint32_t len)
     return buf;
 }
 
+LV_FUNC_SECTION
 void lv_objid_builtin_destroy(void)
 {
     lv_global_t * global = LV_GLOBAL_DEFAULT();
@@ -114,6 +119,7 @@ void lv_objid_builtin_destroy(void)
     global->objid_count = 0;
 }
 
+LV_FUNC_SECTION
 int lv_obj_id_compare(const void * id1, const void * id2)
 {
     return id1 == id2 ? 0 : 1;
diff --git a/src/core/lv_obj_pos.c b/src/core/lv_obj_pos.c
index 0f10d7dcc..58ed79265 100644
--- a/src/core/lv_obj_pos.c
+++ b/src/core/lv_obj_pos.c
@@ -46,6 +46,7 @@ static void transform_point_array(const lv_obj_t * obj, lv_point_t * p, size_t p
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 void lv_obj_set_pos(lv_obj_t * obj, int32_t x, int32_t y)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -54,6 +55,7 @@ void lv_obj_set_pos(lv_obj_t * obj, int32_t x, int32_t y)
     lv_obj_set_y(obj, y);
 }
 
+__attribute__(( fptrgroup("lv_anim_exec_cb") ))
 void lv_obj_set_x(lv_obj_t * obj, int32_t x)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -68,6 +70,7 @@ void lv_obj_set_x(lv_obj_t * obj, int32_t x)
     }
 }
 
+__attribute__(( fptrgroup("lv_anim_exec_cb") ))
 void lv_obj_set_y(lv_obj_t * obj, int32_t y)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -82,6 +85,7 @@ void lv_obj_set_y(lv_obj_t * obj, int32_t y)
     }
 }
 
+LV_FUNC_SECTION
 bool lv_obj_refr_size(lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -208,6 +212,7 @@ bool lv_obj_refr_size(lv_obj_t * obj)
     return true;
 }
 
+LV_FUNC_SECTION
 void lv_obj_set_size(lv_obj_t * obj, int32_t w, int32_t h)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -216,6 +221,7 @@ void lv_obj_set_size(lv_obj_t * obj, int32_t w, int32_t h)
     lv_obj_set_height(obj, h);
 }
 
+LV_FUNC_SECTION
 void lv_obj_set_width(lv_obj_t * obj, int32_t w)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -229,6 +235,7 @@ void lv_obj_set_width(lv_obj_t * obj, int32_t w)
     }
 }
 
+LV_FUNC_SECTION
 void lv_obj_set_height(lv_obj_t * obj, int32_t h)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -242,6 +249,7 @@ void lv_obj_set_height(lv_obj_t * obj, int32_t h)
     }
 }
 
+LV_FUNC_SECTION
 void lv_obj_set_content_width(lv_obj_t * obj, int32_t w)
 {
     int32_t left = lv_obj_get_style_space_left(obj, LV_PART_MAIN);
@@ -249,6 +257,7 @@ void lv_obj_set_content_width(lv_obj_t * obj, int32_t w)
     lv_obj_set_width(obj, w + left + right);
 }
 
+LV_FUNC_SECTION
 void lv_obj_set_content_height(lv_obj_t * obj, int32_t h)
 {
     int32_t top = lv_obj_get_style_space_top(obj, LV_PART_MAIN);
@@ -256,6 +265,7 @@ void lv_obj_set_content_height(lv_obj_t * obj, int32_t h)
     lv_obj_set_height(obj, h + top + bottom);
 }
 
+LV_FUNC_SECTION
 void lv_obj_set_layout(lv_obj_t * obj, uint32_t layout)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -265,6 +275,7 @@ void lv_obj_set_layout(lv_obj_t * obj, uint32_t layout)
     lv_obj_mark_layout_as_dirty(obj);
 }
 
+LV_FUNC_SECTION
 bool lv_obj_is_layout_positioned(const lv_obj_t * obj)
 {
     if(lv_obj_has_flag_any(obj, LV_OBJ_FLAG_HIDDEN | LV_OBJ_FLAG_IGNORE_LAYOUT | LV_OBJ_FLAG_FLOATING)) return false;
@@ -277,6 +288,7 @@ bool lv_obj_is_layout_positioned(const lv_obj_t * obj)
     else return false;
 }
 
+LV_FUNC_SECTION
 void lv_obj_mark_layout_as_dirty(lv_obj_t * obj)
 {
     obj->layout_inv = 1;
@@ -290,6 +302,7 @@ void lv_obj_mark_layout_as_dirty(lv_obj_t * obj)
     lv_display_send_event(disp, LV_EVENT_REFR_REQUEST, NULL);
 }
 
+LV_FUNC_SECTION
 void lv_obj_update_layout(const lv_obj_t * obj)
 {
     if(update_layout_mutex) {
@@ -312,17 +325,20 @@ void lv_obj_update_layout(const lv_obj_t * obj)
     LV_PROFILER_END;
 }
 
+LV_FUNC_SECTION
 void lv_obj_set_align(lv_obj_t * obj, lv_align_t align)
 {
     lv_obj_set_style_align(obj, align, 0);
 }
 
+LV_FUNC_SECTION
 void lv_obj_align(lv_obj_t * obj, lv_align_t align, int32_t x_ofs, int32_t y_ofs)
 {
     lv_obj_set_style_align(obj, align, 0);
     lv_obj_set_pos(obj, x_ofs, y_ofs);
 }
 
+LV_FUNC_SECTION
 void lv_obj_align_to(lv_obj_t * obj, const lv_obj_t * base, lv_align_t align, int32_t x_ofs, int32_t y_ofs)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -473,6 +489,7 @@ void lv_obj_align_to(lv_obj_t * obj, const lv_obj_t * base, lv_align_t align, in
 
 }
 
+LV_FUNC_SECTION
 void lv_obj_get_coords(const lv_obj_t * obj, lv_area_t * coords)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -480,6 +497,7 @@ void lv_obj_get_coords(const lv_obj_t * obj, lv_area_t * coords)
     lv_area_copy(coords, &obj->coords);
 }
 
+LV_FUNC_SECTION
 int32_t lv_obj_get_x(const lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -497,6 +515,7 @@ int32_t lv_obj_get_x(const lv_obj_t * obj)
     return rel_x;
 }
 
+LV_FUNC_SECTION
 int32_t lv_obj_get_x2(const lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -504,6 +523,7 @@ int32_t lv_obj_get_x2(const lv_obj_t * obj)
     return lv_obj_get_x(obj) + lv_obj_get_width(obj);
 }
 
+LV_FUNC_SECTION
 int32_t lv_obj_get_y(const lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -521,6 +541,7 @@ int32_t lv_obj_get_y(const lv_obj_t * obj)
     return rel_y;
 }
 
+LV_FUNC_SECTION
 int32_t lv_obj_get_y2(const lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -528,16 +549,19 @@ int32_t lv_obj_get_y2(const lv_obj_t * obj)
     return lv_obj_get_y(obj) + lv_obj_get_height(obj);
 }
 
+LV_FUNC_SECTION
 int32_t lv_obj_get_x_aligned(const lv_obj_t * obj)
 {
     return lv_obj_get_style_x(obj, LV_PART_MAIN);
 }
 
+LV_FUNC_SECTION
 int32_t lv_obj_get_y_aligned(const lv_obj_t * obj)
 {
     return lv_obj_get_style_y(obj, LV_PART_MAIN);
 }
 
+LV_FUNC_SECTION
 int32_t lv_obj_get_width(const lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -545,6 +569,7 @@ int32_t lv_obj_get_width(const lv_obj_t * obj)
     return lv_area_get_width(&obj->coords);
 }
 
+LV_FUNC_SECTION
 int32_t lv_obj_get_height(const lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -552,6 +577,7 @@ int32_t lv_obj_get_height(const lv_obj_t * obj)
     return lv_area_get_height(&obj->coords);
 }
 
+LV_FUNC_SECTION
 int32_t lv_obj_get_content_width(const lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -562,6 +588,7 @@ int32_t lv_obj_get_content_width(const lv_obj_t * obj)
     return lv_obj_get_width(obj) - left - right;
 }
 
+LV_FUNC_SECTION
 int32_t lv_obj_get_content_height(const lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -572,6 +599,7 @@ int32_t lv_obj_get_content_height(const lv_obj_t * obj)
     return lv_obj_get_height(obj) - top - bottom;
 }
 
+LV_FUNC_SECTION
 void lv_obj_get_content_coords(const lv_obj_t * obj, lv_area_t * area)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -584,6 +612,7 @@ void lv_obj_get_content_coords(const lv_obj_t * obj, lv_area_t * area)
 
 }
 
+LV_FUNC_SECTION
 int32_t lv_obj_get_self_width(const lv_obj_t * obj)
 {
     lv_point_t p = {0, LV_COORD_MIN};
@@ -591,6 +620,7 @@ int32_t lv_obj_get_self_width(const lv_obj_t * obj)
     return p.x;
 }
 
+LV_FUNC_SECTION
 int32_t lv_obj_get_self_height(const lv_obj_t * obj)
 {
     lv_point_t p = {LV_COORD_MIN, 0};
@@ -598,6 +628,7 @@ int32_t lv_obj_get_self_height(const lv_obj_t * obj)
     return p.y;
 }
 
+LV_FUNC_SECTION
 bool lv_obj_refresh_self_size(lv_obj_t * obj)
 {
     int32_t w_set = lv_obj_get_style_width(obj, LV_PART_MAIN);
@@ -608,6 +639,7 @@ bool lv_obj_refresh_self_size(lv_obj_t * obj)
     return true;
 }
 
+LV_FUNC_SECTION
 void lv_obj_refr_pos(lv_obj_t * obj)
 {
     if(lv_obj_is_layout_positioned(obj)) return;
@@ -684,6 +716,7 @@ void lv_obj_refr_pos(lv_obj_t * obj)
     lv_obj_move_to(obj, x, y);
 }
 
+LV_FUNC_SECTION
 void lv_obj_move_to(lv_obj_t * obj, int32_t x, int32_t y)
 {
     /*Convert x and y to absolute coordinates*/
@@ -753,6 +786,8 @@ void lv_obj_move_to(lv_obj_t * obj, int32_t x, int32_t y)
     }
 }
 
+#pragma stackfunction 2048
+LV_FUNC_SECTION
 void lv_obj_move_children_by(lv_obj_t * obj, int32_t x_diff, int32_t y_diff, bool ignore_floating)
 {
     uint32_t i;
@@ -769,11 +804,14 @@ void lv_obj_move_children_by(lv_obj_t * obj, int32_t x_diff, int32_t y_diff, boo
     }
 }
 
+LV_FUNC_SECTION
 void lv_obj_transform_point(const lv_obj_t * obj, lv_point_t * p, lv_obj_point_transform_flag_t flags)
 {
     lv_obj_transform_point_array(obj, p, 1, flags);
 }
 
+#pragma stackfunction 1024
+LV_FUNC_SECTION
 void lv_obj_transform_point_array(const lv_obj_t * obj, lv_point_t points[], size_t count,
                                   lv_obj_point_transform_flag_t flags)
 {
@@ -793,6 +831,7 @@ void lv_obj_transform_point_array(const lv_obj_t * obj, lv_point_t points[], siz
     }
 }
 
+LV_FUNC_SECTION
 void lv_obj_get_transformed_area(const lv_obj_t * obj, lv_area_t * area, lv_obj_point_transform_flag_t flags)
 {
     lv_point_t p[4] = {
@@ -810,6 +849,7 @@ void lv_obj_get_transformed_area(const lv_obj_t * obj, lv_area_t * area, lv_obj_
     area->y2 = LV_MAX4(p[0].y, p[1].y, p[2].y, p[3].y);
 }
 
+LV_FUNC_SECTION
 void lv_obj_invalidate_area(const lv_obj_t * obj, const lv_area_t * area)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -838,6 +878,7 @@ void lv_obj_invalidate_area(const lv_obj_t * obj, const lv_area_t * area)
     lv_inv_area(lv_obj_get_display(obj),  &area_tmp);
 }
 
+LV_FUNC_SECTION
 void lv_obj_invalidate(const lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -854,6 +895,7 @@ void lv_obj_invalidate(const lv_obj_t * obj)
     lv_obj_invalidate_area(obj, &obj_coords);
 }
 
+LV_FUNC_SECTION
 bool lv_obj_area_is_visible(const lv_obj_t * obj, lv_area_t * area)
 {
     if(lv_obj_has_flag(obj, LV_OBJ_FLAG_HIDDEN)) return false;
@@ -902,6 +944,7 @@ bool lv_obj_area_is_visible(const lv_obj_t * obj, lv_area_t * area)
     return true;
 }
 
+LV_FUNC_SECTION
 bool lv_obj_is_visible(const lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -917,6 +960,7 @@ bool lv_obj_is_visible(const lv_obj_t * obj)
     return lv_obj_area_is_visible(obj, &obj_coords);
 }
 
+LV_FUNC_SECTION
 void lv_obj_set_ext_click_area(lv_obj_t * obj, int32_t size)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -925,6 +969,7 @@ void lv_obj_set_ext_click_area(lv_obj_t * obj, int32_t size)
     obj->spec_attr->ext_click_pad = size;
 }
 
+LV_FUNC_SECTION
 void lv_obj_get_click_area(const lv_obj_t * obj, lv_area_t * area)
 {
     lv_area_copy(area, &obj->coords);
@@ -933,6 +978,7 @@ void lv_obj_get_click_area(const lv_obj_t * obj, lv_area_t * area)
     }
 }
 
+LV_FUNC_SECTION
 bool lv_obj_hit_test(lv_obj_t * obj, const lv_point_t * point)
 {
     if(!lv_obj_has_flag(obj, LV_OBJ_FLAG_CLICKABLE)) return false;
@@ -953,6 +999,7 @@ bool lv_obj_hit_test(lv_obj_t * obj, const lv_point_t * point)
     return res;
 }
 
+LV_FUNC_SECTION
 int32_t lv_clamp_width(int32_t width, int32_t min_width, int32_t max_width, int32_t ref_width)
 {
     if(LV_COORD_IS_PCT(min_width)) min_width = (ref_width * LV_COORD_GET_PCT(min_width)) / 100;
@@ -960,6 +1007,7 @@ int32_t lv_clamp_width(int32_t width, int32_t min_width, int32_t max_width, int3
     return LV_CLAMP(min_width, width, max_width);
 }
 
+LV_FUNC_SECTION
 int32_t lv_clamp_height(int32_t height, int32_t min_height, int32_t max_height, int32_t ref_height)
 {
     if(LV_COORD_IS_PCT(min_height)) min_height = (ref_height * LV_COORD_GET_PCT(min_height)) / 100;
@@ -967,6 +1015,7 @@ int32_t lv_clamp_height(int32_t height, int32_t min_height, int32_t max_height,
     return LV_CLAMP(min_height, height, max_height);
 }
 
+LV_FUNC_SECTION
 void lv_obj_center(lv_obj_t * obj)
 {
     lv_obj_align(obj, LV_ALIGN_CENTER, 0, 0);
@@ -976,6 +1025,7 @@ void lv_obj_center(lv_obj_t * obj)
  *   STATIC FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 static int32_t calc_content_width(lv_obj_t * obj)
 {
     int32_t scroll_x_tmp = lv_obj_get_scroll_x(obj);
@@ -1071,6 +1121,7 @@ static int32_t calc_content_width(lv_obj_t * obj)
     return LV_MAX(child_res, self_w);
 }
 
+LV_FUNC_SECTION
 static int32_t calc_content_height(lv_obj_t * obj)
 {
     int32_t scroll_y_tmp = lv_obj_get_scroll_y(obj);
@@ -1123,6 +1174,8 @@ static int32_t calc_content_height(lv_obj_t * obj)
     return LV_MAX(self_h, child_res + space_bottom);
 }
 
+#pragma stackfunction 2048
+LV_FUNC_SECTION
 static void layout_update_core(lv_obj_t * obj)
 {
     uint32_t i;
@@ -1148,6 +1201,7 @@ static void layout_update_core(lv_obj_t * obj)
     }
 }
 
+LV_FUNC_SECTION
 static void transform_point_array(const lv_obj_t * obj, lv_point_t * p, size_t p_count, bool inv)
 {
     int32_t angle = lv_obj_get_style_transform_rotation(obj, 0);
diff --git a/src/core/lv_obj_property.c b/src/core/lv_obj_property.c
index 405b00674..f5d2251c9 100644
--- a/src/core/lv_obj_property.c
+++ b/src/core/lv_obj_property.c
@@ -58,6 +58,7 @@ static int property_name_compare(const void * ref, const void * element);
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 lv_result_t lv_obj_set_property(lv_obj_t * obj, const lv_property_t * value)
 {
     LV_ASSERT(obj && value);
@@ -76,6 +77,7 @@ lv_result_t lv_obj_set_property(lv_obj_t * obj, const lv_property_t * value)
     return obj_property(obj, value->id, (lv_property_t *)value, true);
 }
 
+LV_FUNC_SECTION
 lv_result_t lv_obj_set_properties(lv_obj_t * obj, const lv_property_t * value, uint32_t count)
 {
     for(uint32_t i = 0; i < count; i++) {
@@ -88,6 +90,7 @@ lv_result_t lv_obj_set_properties(lv_obj_t * obj, const lv_property_t * value, u
     return LV_RESULT_OK;
 }
 
+LV_FUNC_SECTION
 lv_property_t lv_obj_get_property(lv_obj_t * obj, lv_prop_id_t id)
 {
     lv_result_t result;
@@ -115,6 +118,7 @@ lv_property_t lv_obj_get_property(lv_obj_t * obj, lv_prop_id_t id)
     return value;
 }
 
+LV_FUNC_SECTION
 lv_property_t lv_obj_get_style_property(lv_obj_t * obj, lv_prop_id_t id, uint32_t selector)
 {
     lv_property_t value;
@@ -133,6 +137,7 @@ lv_property_t lv_obj_get_style_property(lv_obj_t * obj, lv_prop_id_t id, uint32_
     return value;
 }
 
+LV_FUNC_SECTION
 lv_prop_id_t lv_style_property_get_id(const char * name)
 {
 #if LV_USE_OBJ_PROPERTY_NAME
@@ -147,6 +152,7 @@ lv_prop_id_t lv_style_property_get_id(const char * name)
     return LV_PROPERTY_ID_INVALID;
 }
 
+LV_FUNC_SECTION
 lv_prop_id_t lv_obj_class_property_get_id(const lv_obj_class_t * clz, const char * name)
 {
 #if LV_USE_OBJ_PROPERTY_NAME
@@ -169,6 +175,7 @@ lv_prop_id_t lv_obj_class_property_get_id(const lv_obj_class_t * clz, const char
     return LV_PROPERTY_ID_INVALID;
 }
 
+LV_FUNC_SECTION
 lv_prop_id_t lv_obj_property_get_id(const lv_obj_t * obj, const char * name)
 {
 #if LV_USE_OBJ_PROPERTY_NAME
@@ -195,6 +202,7 @@ lv_prop_id_t lv_obj_property_get_id(const lv_obj_t * obj, const char * name)
  *  STATIC FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 static lv_result_t obj_property(lv_obj_t * obj, lv_prop_id_t id, lv_property_t * value, bool set)
 {
     const lv_property_ops_t * properties;
@@ -293,6 +301,7 @@ static lv_result_t obj_property(lv_obj_t * obj, lv_prop_id_t id, lv_property_t *
     return LV_RESULT_INVALID;
 }
 
+__attribute__(( fptrgroup("lv_utils_cmp") ))
 static int property_name_compare(const void * ref, const void * element)
 {
     const lv_property_name_t * prop = element;
diff --git a/src/core/lv_obj_scroll.c b/src/core/lv_obj_scroll.c
index fa5e16fc9..3a9ecf053 100644
--- a/src/core/lv_obj_scroll.c
+++ b/src/core/lv_obj_scroll.c
@@ -55,6 +55,7 @@ static void scroll_area_into_view(const lv_area_t * area, lv_obj_t * child, lv_p
  * Setter functions
  *====================*/
 
+LV_FUNC_SECTION
 void lv_obj_set_scrollbar_mode(lv_obj_t * obj, lv_scrollbar_mode_t mode)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -66,6 +67,7 @@ void lv_obj_set_scrollbar_mode(lv_obj_t * obj, lv_scrollbar_mode_t mode)
     lv_obj_invalidate(obj);
 }
 
+LV_FUNC_SECTION
 void lv_obj_set_scroll_dir(lv_obj_t * obj, lv_dir_t dir)
 {
     lv_obj_allocate_spec_attr(obj);
@@ -75,12 +77,14 @@ void lv_obj_set_scroll_dir(lv_obj_t * obj, lv_dir_t dir)
     }
 }
 
+LV_FUNC_SECTION
 void lv_obj_set_scroll_snap_x(lv_obj_t * obj, lv_scroll_snap_t align)
 {
     lv_obj_allocate_spec_attr(obj);
     obj->spec_attr->scroll_snap_x = align;
 }
 
+LV_FUNC_SECTION
 void lv_obj_set_scroll_snap_y(lv_obj_t * obj, lv_scroll_snap_t align)
 {
     lv_obj_allocate_spec_attr(obj);
@@ -91,48 +95,56 @@ void lv_obj_set_scroll_snap_y(lv_obj_t * obj, lv_scroll_snap_t align)
  * Getter functions
  *====================*/
 
+LV_FUNC_SECTION
 lv_scrollbar_mode_t lv_obj_get_scrollbar_mode(const lv_obj_t * obj)
 {
     if(obj->spec_attr) return (lv_scrollbar_mode_t) obj->spec_attr->scrollbar_mode;
     else return LV_SCROLLBAR_MODE_AUTO;
 }
 
+LV_FUNC_SECTION
 lv_dir_t lv_obj_get_scroll_dir(const lv_obj_t * obj)
 {
     if(obj->spec_attr) return (lv_dir_t) obj->spec_attr->scroll_dir;
     else return LV_DIR_ALL;
 }
 
+LV_FUNC_SECTION
 lv_scroll_snap_t lv_obj_get_scroll_snap_x(const lv_obj_t * obj)
 {
     if(obj->spec_attr) return (lv_scroll_snap_t) obj->spec_attr->scroll_snap_x;
     else return LV_SCROLL_SNAP_NONE;
 }
 
+LV_FUNC_SECTION
 lv_scroll_snap_t lv_obj_get_scroll_snap_y(const lv_obj_t * obj)
 {
     if(obj->spec_attr) return (lv_scroll_snap_t) obj->spec_attr->scroll_snap_y;
     else return LV_SCROLL_SNAP_NONE;
 }
 
+LV_FUNC_SECTION
 int32_t lv_obj_get_scroll_x(const lv_obj_t * obj)
 {
     if(obj->spec_attr == NULL) return 0;
     return -obj->spec_attr->scroll.x;
 }
 
+LV_FUNC_SECTION
 int32_t lv_obj_get_scroll_y(const lv_obj_t * obj)
 {
     if(obj->spec_attr == NULL) return 0;
     return -obj->spec_attr->scroll.y;
 }
 
+LV_FUNC_SECTION
 int32_t lv_obj_get_scroll_top(lv_obj_t * obj)
 {
     if(obj->spec_attr == NULL) return 0;
     return -obj->spec_attr->scroll.y;
 }
 
+LV_FUNC_SECTION
 int32_t lv_obj_get_scroll_bottom(lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -161,6 +173,7 @@ int32_t lv_obj_get_scroll_bottom(lv_obj_t * obj)
     return LV_MAX(child_res, self_h);
 }
 
+LV_FUNC_SECTION
 int32_t lv_obj_get_scroll_left(lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -204,6 +217,7 @@ int32_t lv_obj_get_scroll_left(lv_obj_t * obj)
     return LV_MAX(child_res, self_w);
 }
 
+LV_FUNC_SECTION
 int32_t lv_obj_get_scroll_right(lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -241,6 +255,7 @@ int32_t lv_obj_get_scroll_right(lv_obj_t * obj)
     return LV_MAX(child_res, self_w);
 }
 
+LV_FUNC_SECTION
 void lv_obj_get_scroll_end(lv_obj_t * obj, lv_point_t * end)
 {
     lv_anim_t * a;
@@ -255,6 +270,7 @@ void lv_obj_get_scroll_end(lv_obj_t * obj, lv_point_t * end)
  * Other functions
  *====================*/
 
+LV_FUNC_SECTION
 void lv_obj_scroll_by_bounded(lv_obj_t * obj, int32_t dx, int32_t dy, lv_anim_enable_t anim_en)
 {
     if(dx == 0 && dy == 0) return;
@@ -303,6 +319,7 @@ void lv_obj_scroll_by_bounded(lv_obj_t * obj, int32_t dx, int32_t dy, lv_anim_en
     }
 }
 
+LV_FUNC_SECTION
 void lv_obj_scroll_by(lv_obj_t * obj, int32_t dx, int32_t dy, lv_anim_enable_t anim_en)
 {
     if(dx == 0 && dy == 0) return;
@@ -360,12 +377,14 @@ void lv_obj_scroll_by(lv_obj_t * obj, int32_t dx, int32_t dy, lv_anim_enable_t a
     }
 }
 
+LV_FUNC_SECTION
 void lv_obj_scroll_to(lv_obj_t * obj, int32_t x, int32_t y, lv_anim_enable_t anim_en)
 {
     lv_obj_scroll_to_x(obj, x, anim_en);
     lv_obj_scroll_to_y(obj, y, anim_en);
 }
 
+LV_FUNC_SECTION
 void lv_obj_scroll_to_x(lv_obj_t * obj, int32_t x, lv_anim_enable_t anim_en)
 {
     lv_anim_delete(obj, scroll_x_anim);
@@ -376,6 +395,7 @@ void lv_obj_scroll_to_x(lv_obj_t * obj, int32_t x, lv_anim_enable_t anim_en)
     lv_obj_scroll_by_bounded(obj, diff, 0, anim_en);
 }
 
+LV_FUNC_SECTION
 void lv_obj_scroll_to_y(lv_obj_t * obj, int32_t y, lv_anim_enable_t anim_en)
 {
     lv_anim_delete(obj, scroll_y_anim);
@@ -386,6 +406,7 @@ void lv_obj_scroll_to_y(lv_obj_t * obj, int32_t y, lv_anim_enable_t anim_en)
     lv_obj_scroll_by_bounded(obj, 0, diff, anim_en);
 }
 
+LV_FUNC_SECTION
 void lv_obj_scroll_to_view(lv_obj_t * obj, lv_anim_enable_t anim_en)
 {
     /*Be sure the screens layout is correct*/
@@ -395,6 +416,7 @@ void lv_obj_scroll_to_view(lv_obj_t * obj, lv_anim_enable_t anim_en)
     scroll_area_into_view(&obj->coords, obj, &p, anim_en);
 }
 
+LV_FUNC_SECTION
 void lv_obj_scroll_to_view_recursive(lv_obj_t * obj, lv_anim_enable_t anim_en)
 {
     /*Be sure the screens layout is correct*/
@@ -410,6 +432,7 @@ void lv_obj_scroll_to_view_recursive(lv_obj_t * obj, lv_anim_enable_t anim_en)
     }
 }
 
+LV_FUNC_SECTION
 lv_result_t lv_obj_scroll_by_raw(lv_obj_t * obj, int32_t x, int32_t y)
 {
     if(x == 0 && y == 0) return LV_RESULT_OK;
@@ -426,6 +449,7 @@ lv_result_t lv_obj_scroll_by_raw(lv_obj_t * obj, int32_t x, int32_t y)
     return LV_RESULT_OK;
 }
 
+LV_FUNC_SECTION
 bool lv_obj_is_scrolling(const lv_obj_t * obj)
 {
     lv_indev_t * indev = lv_indev_get_next(NULL);
@@ -437,6 +461,7 @@ bool lv_obj_is_scrolling(const lv_obj_t * obj)
     return false;
 }
 
+LV_FUNC_SECTION
 void lv_obj_update_snap(lv_obj_t * obj, lv_anim_enable_t anim_en)
 {
     lv_obj_update_layout(obj);
@@ -447,6 +472,7 @@ void lv_obj_update_snap(lv_obj_t * obj, lv_anim_enable_t anim_en)
     lv_obj_scroll_by(obj, p.x, p.y, anim_en);
 }
 
+LV_FUNC_SECTION
 void lv_obj_get_scrollbar_area(lv_obj_t * obj, lv_area_t * hor_area, lv_area_t * ver_area)
 {
     lv_area_set(hor_area, 0, 0, -1, -1);
@@ -620,6 +646,7 @@ void lv_obj_get_scrollbar_area(lv_obj_t * obj, lv_area_t * hor_area, lv_area_t *
     }
 }
 
+LV_FUNC_SECTION
 void lv_obj_scrollbar_invalidate(lv_obj_t * obj)
 {
     lv_area_t hor_area;
@@ -632,6 +659,7 @@ void lv_obj_scrollbar_invalidate(lv_obj_t * obj)
     if(lv_area_get_size(&ver_area) > 0) lv_obj_invalidate_area(obj, &ver_area);
 }
 
+LV_FUNC_SECTION
 void lv_obj_readjust_scroll(lv_obj_t * obj, lv_anim_enable_t anim_en)
 {
     /*Be sure the bottom side is not remains scrolled in*/
@@ -668,23 +696,26 @@ void lv_obj_readjust_scroll(lv_obj_t * obj, lv_anim_enable_t anim_en)
 /**********************
  *   STATIC FUNCTIONS
  **********************/
-
+__attribute__(( fptrgroup("lv_anim_exec_cb") ))
 static void scroll_x_anim(void * obj, int32_t v)
 {
     lv_obj_scroll_by_raw(obj, v + lv_obj_get_scroll_x(obj), 0);
 }
 
+__attribute__(( fptrgroup("lv_anim_exec_cb") ))
 static void scroll_y_anim(void * obj, int32_t v)
 {
     lv_obj_scroll_by_raw(obj, 0, v + lv_obj_get_scroll_y(obj));
 }
 
+__attribute__(( fptrgroup("lv_anim_deleted_cb") ))
 static void scroll_end_cb(lv_anim_t * a)
 {
     /*Do not sent END event if there wasn't a BEGIN*/
     if(a->start_cb_called) lv_obj_send_event(a->var, LV_EVENT_SCROLL_END, NULL);
 }
 
+LV_FUNC_SECTION
 static void scroll_area_into_view(const lv_area_t * area, lv_obj_t * child, lv_point_t * scroll_value,
                                   lv_anim_enable_t anim_en)
 {
diff --git a/src/core/lv_obj_style.c b/src/core/lv_obj_style.c
index 06e3ffec3..21f3c905d 100644
--- a/src/core/lv_obj_style.c
+++ b/src/core/lv_obj_style.c
@@ -81,11 +81,13 @@ static lv_style_res_t get_selector_style_prop(const lv_obj_t * obj, lv_style_sel
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 void lv_obj_style_init(void)
 {
     lv_ll_init(style_trans_ll_p, sizeof(trans_t));
 }
 
+LV_FUNC_SECTION
 void lv_obj_style_deinit(void)
 {
     lv_ll_clear(style_trans_ll_p);
@@ -95,6 +97,7 @@ void lv_obj_style_deinit(void)
     }
 }
 
+LV_FUNC_SECTION
 void lv_obj_add_style(lv_obj_t * obj, const lv_style_t * style, lv_style_selector_t selector)
 {
     LV_ASSERT(obj->style_cnt < 63);
@@ -154,6 +157,7 @@ void lv_obj_add_style(lv_obj_t * obj, const lv_style_t * style, lv_style_selecto
     lv_obj_refresh_style(obj, selector, LV_STYLE_PROP_ANY);
 }
 
+LV_FUNC_SECTION
 bool lv_obj_replace_style(lv_obj_t * obj, const lv_style_t * old_style, const lv_style_t * new_style,
                           lv_style_selector_t selector)
 {
@@ -200,6 +204,7 @@ bool lv_obj_replace_style(lv_obj_t * obj, const lv_style_t * old_style, const lv
     return replaced;
 }
 
+LV_FUNC_SECTION
 void lv_obj_remove_style(lv_obj_t * obj, const lv_style_t * style, lv_style_selector_t selector)
 {
     lv_state_t state = lv_obj_style_get_selector_state(selector);
@@ -253,11 +258,13 @@ void lv_obj_remove_style(lv_obj_t * obj, const lv_style_t * style, lv_style_sele
     }
 }
 
+LV_FUNC_SECTION
 void lv_obj_remove_style_all(lv_obj_t * obj)
 {
     lv_obj_remove_style(obj, NULL, LV_PART_ANY | LV_STATE_ANY);
 }
 
+LV_FUNC_SECTION
 void lv_obj_report_style_change(lv_style_t * style)
 {
     if(!style_refr) return;
@@ -272,6 +279,7 @@ void lv_obj_report_style_change(lv_style_t * style)
     }
 }
 
+LV_FUNC_SECTION
 void lv_obj_refresh_style(lv_obj_t * obj, lv_style_selector_t selector, lv_style_prop_t prop)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -318,11 +326,13 @@ void lv_obj_refresh_style(lv_obj_t * obj, lv_style_selector_t selector, lv_style
     }
 }
 
+LV_FUNC_SECTION
 void lv_obj_enable_style_refresh(bool en)
 {
     style_refr = en;
 }
 
+LV_FUNC_SECTION
 lv_style_value_t lv_obj_get_style_prop(const lv_obj_t * obj, lv_part_t part, lv_style_prop_t prop)
 {
     LV_ASSERT_NULL(obj)
@@ -337,6 +347,7 @@ lv_style_value_t lv_obj_get_style_prop(const lv_obj_t * obj, lv_part_t part, lv_
     return lv_style_prop_get_default(prop);
 }
 
+LV_FUNC_SECTION
 bool lv_obj_has_style_prop(const lv_obj_t * obj, lv_style_selector_t selector, lv_style_prop_t prop)
 {
     LV_ASSERT_NULL(obj)
@@ -350,6 +361,7 @@ bool lv_obj_has_style_prop(const lv_obj_t * obj, lv_style_selector_t selector, l
     return false;
 }
 
+LV_FUNC_SECTION
 void lv_obj_set_local_style_prop(lv_obj_t * obj, lv_style_prop_t prop, lv_style_value_t value,
                                  lv_style_selector_t selector)
 {
@@ -376,6 +388,7 @@ void lv_obj_set_local_style_prop(lv_obj_t * obj, lv_style_prop_t prop, lv_style_
     lv_obj_refresh_style(obj, selector, prop);
 }
 
+LV_FUNC_SECTION
 lv_style_res_t lv_obj_get_local_style_prop(lv_obj_t * obj, lv_style_prop_t prop, lv_style_value_t * value,
                                            lv_style_selector_t selector)
 {
@@ -390,6 +403,7 @@ lv_style_res_t lv_obj_get_local_style_prop(lv_obj_t * obj, lv_style_prop_t prop,
     return LV_STYLE_RES_NOT_FOUND;
 }
 
+LV_FUNC_SECTION
 bool lv_obj_remove_local_style_prop(lv_obj_t * obj, lv_style_prop_t prop, lv_style_selector_t selector)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -415,6 +429,7 @@ bool lv_obj_remove_local_style_prop(lv_obj_t * obj, lv_style_prop_t prop, lv_sty
     return res;
 }
 
+LV_FUNC_SECTION
 void lv_obj_style_create_transition(lv_obj_t * obj, lv_part_t part, lv_state_t prev_state, lv_state_t new_state,
                                     const lv_obj_style_transition_dsc_t * tr_dsc)
 {
@@ -470,6 +485,7 @@ void lv_obj_style_create_transition(lv_obj_t * obj, lv_part_t part, lv_state_t p
     lv_anim_start(&a);
 }
 
+LV_FUNC_SECTION
 lv_style_value_t lv_obj_style_apply_color_filter(const lv_obj_t * obj, lv_part_t part, lv_style_value_t v)
 {
     if(obj == NULL) return v;
@@ -481,6 +497,7 @@ lv_style_value_t lv_obj_style_apply_color_filter(const lv_obj_t * obj, lv_part_t
     return v;
 }
 
+LV_FUNC_SECTION
 lv_style_state_cmp_t lv_obj_style_state_compare(lv_obj_t * obj, lv_state_t state1, lv_state_t state2)
 {
     lv_style_state_cmp_t res = LV_STYLE_STATE_CMP_SAME;
@@ -542,6 +559,7 @@ lv_style_state_cmp_t lv_obj_style_state_compare(lv_obj_t * obj, lv_state_t state
     return res;
 }
 
+LV_FUNC_SECTION
 void lv_obj_fade_in(lv_obj_t * obj, uint32_t time, uint32_t delay)
 {
     lv_anim_t a;
@@ -555,6 +573,7 @@ void lv_obj_fade_in(lv_obj_t * obj, uint32_t time, uint32_t delay)
     lv_anim_start(&a);
 }
 
+LV_FUNC_SECTION
 void lv_obj_fade_out(lv_obj_t * obj, uint32_t time, uint32_t delay)
 {
     lv_anim_t a;
@@ -567,6 +586,7 @@ void lv_obj_fade_out(lv_obj_t * obj, uint32_t time, uint32_t delay)
     lv_anim_start(&a);
 }
 
+LV_FUNC_SECTION
 lv_text_align_t lv_obj_calculate_style_text_align(const lv_obj_t * obj, lv_part_t part, const char * txt)
 {
     lv_text_align_t align = lv_obj_get_style_text_align(obj, part);
@@ -575,6 +595,7 @@ lv_text_align_t lv_obj_calculate_style_text_align(const lv_obj_t * obj, lv_part_
     return align;
 }
 
+LV_FUNC_SECTION
 lv_opa_t lv_obj_get_style_opa_recursive(const lv_obj_t * obj, lv_part_t part)
 {
 
@@ -608,6 +629,7 @@ lv_opa_t lv_obj_get_style_opa_recursive(const lv_obj_t * obj, lv_part_t part)
     return opa_final;
 }
 
+LV_FUNC_SECTION
 void lv_obj_update_layer_type(lv_obj_t * obj)
 {
     lv_layer_type_t layer_type = calculate_layer_type(obj);
@@ -629,6 +651,7 @@ void lv_obj_update_layer_type(lv_obj_t * obj)
  * @param selector OR-ed value of parts and state for which the style should be get
  * @return pointer to the local style
  */
+LV_FUNC_SECTION
 static lv_style_t * get_local_style(lv_obj_t * obj, lv_style_selector_t selector)
 {
     uint32_t i;
@@ -667,6 +690,7 @@ static lv_style_t * get_local_style(lv_obj_t * obj, lv_style_selector_t selector
  * @param selector OR-ed value of parts and state for which the style should be get
  * @return pointer to the transition style
  */
+LV_FUNC_SECTION
 static lv_obj_style_t * get_trans_style(lv_obj_t * obj,  lv_style_selector_t selector)
 {
     uint32_t i;
@@ -694,6 +718,7 @@ static lv_obj_style_t * get_trans_style(lv_obj_t * obj,  lv_style_selector_t sel
     return &obj->styles[0];
 }
 
+LV_FUNC_SECTION
 static lv_style_res_t get_prop_core(const lv_obj_t * obj, lv_style_selector_t selector, lv_style_prop_t prop,
                                     lv_style_value_t * v)
 {
@@ -753,6 +778,8 @@ static lv_style_res_t get_prop_core(const lv_obj_t * obj, lv_style_selector_t se
  * @param style refresh objects only with this
  * @param obj pointer to an object
  */
+#pragma stackfunction 1024
+LV_FUNC_SECTION
 static void report_style_change_core(void * style, lv_obj_t * obj)
 {
     uint32_t i;
@@ -775,6 +802,8 @@ static void report_style_change_core(void * style, lv_obj_t * obj)
  * because the NULL styles are inherited from the parent
  * @param obj pointer to an object
  */
+#pragma stackfunction 1024
+LV_FUNC_SECTION
 static void refresh_children_style(lv_obj_t * obj)
 {
     uint32_t i;
@@ -798,6 +827,7 @@ static void refresh_children_style(lv_obj_t * obj)
  * @param prop a property or 0xFF to remove all properties
  * @param tr_limit delete transitions only "older" than this. `NULL` if not used
  */
+LV_FUNC_SECTION
 static bool trans_delete(lv_obj_t * obj, lv_part_t part, lv_style_prop_t prop, trans_t * tr_limit)
 {
     trans_t * tr;
@@ -832,6 +862,7 @@ static bool trans_delete(lv_obj_t * obj, lv_part_t part, lv_style_prop_t prop, t
     return removed;
 }
 
+__attribute__(( fptrgroup("lv_anim_exec_cb") ))
 static void trans_anim_cb(void * _tr, int32_t v)
 {
     trans_t * tr = _tr;
@@ -896,6 +927,7 @@ static void trans_anim_cb(void * _tr, int32_t v)
 
 }
 
+__attribute__(( fptrgroup("lv_anim_start_cb") ))
 static void trans_anim_start_cb(lv_anim_t * a)
 {
     trans_t * tr = a->var;
@@ -919,6 +951,7 @@ static void trans_anim_start_cb(lv_anim_t * a)
 
 }
 
+__attribute__(( fptrgroup("lv_anim_completed_cb") ))
 static void trans_anim_completed_cb(lv_anim_t * a)
 {
     trans_t * tr = a->var;
@@ -957,6 +990,7 @@ static void trans_anim_completed_cb(lv_anim_t * a)
     }
 }
 
+LV_FUNC_SECTION
 static lv_layer_type_t calculate_layer_type(lv_obj_t * obj)
 {
     if(lv_obj_get_style_transform_rotation(obj, 0) != 0) return LV_LAYER_TYPE_TRANSFORM;
@@ -970,6 +1004,7 @@ static lv_layer_type_t calculate_layer_type(lv_obj_t * obj)
     return LV_LAYER_TYPE_NONE;
 }
 
+LV_FUNC_SECTION
 static void full_cache_refresh(lv_obj_t * obj, lv_part_t part)
 {
 #if LV_OBJ_STYLE_CACHE
@@ -1020,16 +1055,19 @@ static void full_cache_refresh(lv_obj_t * obj, lv_part_t part)
 #endif
 }
 
+__attribute__(( fptrgroup("lv_anim_exec_cb") ))
 static void fade_anim_cb(void * obj, int32_t v)
 {
     lv_obj_set_style_opa(obj, v, 0);
 }
 
+__attribute__(( fptrgroup("lv_anim_completed_cb") ))
 static void fade_in_anim_completed(lv_anim_t * a)
 {
     lv_obj_remove_local_style_prop(a->var, LV_STYLE_OPA, 0);
 }
 
+LV_FUNC_SECTION
 static bool style_has_flag(const lv_style_t * style, uint32_t flag)
 {
     if(lv_style_is_const(style)) {
@@ -1053,6 +1091,7 @@ static bool style_has_flag(const lv_style_t * style, uint32_t flag)
     return false;
 }
 
+LV_FUNC_SECTION
 static lv_style_res_t get_selector_style_prop(const lv_obj_t * obj, lv_style_selector_t selector, lv_style_prop_t prop,
                                               lv_style_value_t * value_act)
 {
diff --git a/src/core/lv_obj_style_gen.c b/src/core/lv_obj_style_gen.c
index ad97db594..8635b36e8 100644
--- a/src/core/lv_obj_style_gen.c
+++ b/src/core/lv_obj_style_gen.c
@@ -10,6 +10,7 @@
 #include "lv_obj.h"
 
 
+LV_FUNC_SECTION
 void lv_obj_set_style_width(lv_obj_t * obj, int32_t value, lv_style_selector_t selector)
 {
     lv_style_value_t v = {
@@ -18,6 +19,7 @@ void lv_obj_set_style_width(lv_obj_t * obj, int32_t value, lv_style_selector_t s
     lv_obj_set_local_style_prop(obj, LV_STYLE_WIDTH, v, selector);
 }
 
+LV_FUNC_SECTION
 void lv_obj_set_style_min_width(lv_obj_t * obj, int32_t value, lv_style_selector_t selector)
 {
     lv_style_value_t v = {
@@ -26,6 +28,7 @@ void lv_obj_set_style_min_width(lv_obj_t * obj, int32_t value, lv_style_selector
     lv_obj_set_local_style_prop(obj, LV_STYLE_MIN_WIDTH, v, selector);
 }
 
+LV_FUNC_SECTION
 void lv_obj_set_style_max_width(lv_obj_t * obj, int32_t value, lv_style_selector_t selector)
 {
     lv_style_value_t v = {
@@ -34,6 +37,7 @@ void lv_obj_set_style_max_width(lv_obj_t * obj, int32_t value, lv_style_selector
     lv_obj_set_local_style_prop(obj, LV_STYLE_MAX_WIDTH, v, selector);
 }
 
+LV_FUNC_SECTION
 void lv_obj_set_style_height(lv_obj_t * obj, int32_t value, lv_style_selector_t selector)
 {
     lv_style_value_t v = {
@@ -42,6 +46,7 @@ void lv_obj_set_style_height(lv_obj_t * obj, int32_t value, lv_style_selector_t
     lv_obj_set_local_style_prop(obj, LV_STYLE_HEIGHT, v, selector);
 }
 
+LV_FUNC_SECTION
 void lv_obj_set_style_min_height(lv_obj_t * obj, int32_t value, lv_style_selector_t selector)
 {
     lv_style_value_t v = {
@@ -50,6 +55,7 @@ void lv_obj_set_style_min_height(lv_obj_t * obj, int32_t value, lv_style_selecto
     lv_obj_set_local_style_prop(obj, LV_STYLE_MIN_HEIGHT, v, selector);
 }
 
+LV_FUNC_SECTION
 void lv_obj_set_style_max_height(lv_obj_t * obj, int32_t value, lv_style_selector_t selector)
 {
     lv_style_value_t v = {
@@ -58,6 +64,7 @@ void lv_obj_set_style_max_height(lv_obj_t * obj, int32_t value, lv_style_selecto
     lv_obj_set_local_style_prop(obj, LV_STYLE_MAX_HEIGHT, v, selector);
 }
 
+LV_FUNC_SECTION
 void lv_obj_set_style_length(lv_obj_t * obj, int32_t value, lv_style_selector_t selector)
 {
     lv_style_value_t v = {
@@ -66,6 +73,7 @@ void lv_obj_set_style_length(lv_obj_t * obj, int32_t value, lv_style_selector_t
     lv_obj_set_local_style_prop(obj, LV_STYLE_LENGTH, v, selector);
 }
 
+LV_FUNC_SECTION
 void lv_obj_set_style_x(lv_obj_t * obj, int32_t value, lv_style_selector_t selector)
 {
     lv_style_value_t v = {
@@ -74,6 +82,7 @@ void lv_obj_set_style_x(lv_obj_t * obj, int32_t value, lv_style_selector_t selec
     lv_obj_set_local_style_prop(obj, LV_STYLE_X, v, selector);
 }
 
+LV_FUNC_SECTION
 void lv_obj_set_style_y(lv_obj_t * obj, int32_t value, lv_style_selector_t selector)
 {
     lv_style_value_t v = {
@@ -82,6 +91,7 @@ void lv_obj_set_style_y(lv_obj_t * obj, int32_t value, lv_style_selector_t selec
     lv_obj_set_local_style_prop(obj, LV_STYLE_Y, v, selector);
 }
 
+LV_FUNC_SECTION
 void lv_obj_set_style_align(lv_obj_t * obj, lv_align_t value, lv_style_selector_t selector)
 {
     lv_style_value_t v = {
@@ -90,6 +100,7 @@ void lv_obj_set_style_align(lv_obj_t * obj, lv_align_t value, lv_style_selector_
     lv_obj_set_local_style_prop(obj, LV_STYLE_ALIGN, v, selector);
 }
 
+LV_FUNC_SECTION
 void lv_obj_set_style_transform_width(lv_obj_t * obj, int32_t value, lv_style_selector_t selector)
 {
     lv_style_value_t v = {
@@ -98,6 +109,7 @@ void lv_obj_set_style_transform_width(lv_obj_t * obj, int32_t value, lv_style_se
     lv_obj_set_local_style_prop(obj, LV_STYLE_TRANSFORM_WIDTH, v, selector);
 }
 
+LV_FUNC_SECTION
 void lv_obj_set_style_transform_height(lv_obj_t * obj, int32_t value, lv_style_selector_t selector)
 {
     lv_style_value_t v = {
@@ -106,6 +118,7 @@ void lv_obj_set_style_transform_height(lv_obj_t * obj, int32_t value, lv_style_s
     lv_obj_set_local_style_prop(obj, LV_STYLE_TRANSFORM_HEIGHT, v, selector);
 }
 
+LV_FUNC_SECTION
 void lv_obj_set_style_translate_x(lv_obj_t * obj, int32_t value, lv_style_selector_t selector)
 {
     lv_style_value_t v = {
@@ -114,6 +127,7 @@ void lv_obj_set_style_translate_x(lv_obj_t * obj, int32_t value, lv_style_select
     lv_obj_set_local_style_prop(obj, LV_STYLE_TRANSLATE_X, v, selector);
 }
 
+LV_FUNC_SECTION
 void lv_obj_set_style_translate_y(lv_obj_t * obj, int32_t value, lv_style_selector_t selector)
 {
     lv_style_value_t v = {
@@ -122,6 +136,7 @@ void lv_obj_set_style_translate_y(lv_obj_t * obj, int32_t value, lv_style_select
     lv_obj_set_local_style_prop(obj, LV_STYLE_TRANSLATE_Y, v, selector);
 }
 
+LV_FUNC_SECTION
 void lv_obj_set_style_transform_scale_x(lv_obj_t * obj, int32_t value, lv_style_selector_t selector)
 {
     lv_style_value_t v = {
@@ -130,6 +145,7 @@ void lv_obj_set_style_transform_scale_x(lv_obj_t * obj, int32_t value, lv_style_
     lv_obj_set_local_style_prop(obj, LV_STYLE_TRANSFORM_SCALE_X, v, selector);
 }
 
+LV_FUNC_SECTION
 void lv_obj_set_style_transform_scale_y(lv_obj_t * obj, int32_t value, lv_style_selector_t selector)
 {
     lv_style_value_t v = {
@@ -138,6 +154,7 @@ void lv_obj_set_style_transform_scale_y(lv_obj_t * obj, int32_t value, lv_style_
     lv_obj_set_local_style_prop(obj, LV_STYLE_TRANSFORM_SCALE_Y, v, selector);
 }
 
+LV_FUNC_SECTION
 void lv_obj_set_style_transform_rotation(lv_obj_t * obj, int32_t value, lv_style_selector_t selector)
 {
     lv_style_value_t v = {
@@ -146,6 +163,7 @@ void lv_obj_set_style_transform_rotation(lv_obj_t * obj, int32_t value, lv_style
     lv_obj_set_local_style_prop(obj, LV_STYLE_TRANSFORM_ROTATION, v, selector);
 }
 
+LV_FUNC_SECTION
 void lv_obj_set_style_transform_pivot_x(lv_obj_t * obj, int32_t value, lv_style_selector_t selector)
 {
     lv_style_value_t v = {
@@ -154,6 +172,7 @@ void lv_obj_set_style_transform_pivot_x(lv_obj_t * obj, int32_t value, lv_style_
     lv_obj_set_local_style_prop(obj, LV_STYLE_TRANSFORM_PIVOT_X, v, selector);
 }
 
+LV_FUNC_SECTION
 void lv_obj_set_style_transform_pivot_y(lv_obj_t * obj, int32_t value, lv_style_selector_t selector)
 {
     lv_style_value_t v = {
@@ -162,6 +181,7 @@ void lv_obj_set_style_transform_pivot_y(lv_obj_t * obj, int32_t value, lv_style_
     lv_obj_set_local_style_prop(obj, LV_STYLE_TRANSFORM_PIVOT_Y, v, selector);
 }
 
+LV_FUNC_SECTION
 void lv_obj_set_style_transform_skew_x(lv_obj_t * obj, int32_t value, lv_style_selector_t selector)
 {
     lv_style_value_t v = {
@@ -170,6 +190,7 @@ void lv_obj_set_style_transform_skew_x(lv_obj_t * obj, int32_t value, lv_style_s
     lv_obj_set_local_style_prop(obj, LV_STYLE_TRANSFORM_SKEW_X, v, selector);
 }
 
+LV_FUNC_SECTION
 void lv_obj_set_style_transform_skew_y(lv_obj_t * obj, int32_t value, lv_style_selector_t selector)
 {
     lv_style_value_t v = {
@@ -178,6 +199,7 @@ void lv_obj_set_style_transform_skew_y(lv_obj_t * obj, int32_t value, lv_style_s
     lv_obj_set_local_style_prop(obj, LV_STYLE_TRANSFORM_SKEW_Y, v, selector);
 }
 
+LV_FUNC_SECTION
 void lv_obj_set_style_pad_top(lv_obj_t * obj, int32_t value, lv_style_selector_t selector)
 {
     lv_style_value_t v = {
@@ -186,6 +208,7 @@ void lv_obj_set_style_pad_top(lv_obj_t * obj, int32_t value, lv_style_selector_t
     lv_obj_set_local_style_prop(obj, LV_STYLE_PAD_TOP, v, selector);
 }
 
+LV_FUNC_SECTION
 void lv_obj_set_style_pad_bottom(lv_obj_t * obj, int32_t value, lv_style_selector_t selector)
 {
     lv_style_value_t v = {
@@ -194,6 +217,7 @@ void lv_obj_set_style_pad_bottom(lv_obj_t * obj, int32_t value, lv_style_selecto
     lv_obj_set_local_style_prop(obj, LV_STYLE_PAD_BOTTOM, v, selector);
 }
 
+LV_FUNC_SECTION
 void lv_obj_set_style_pad_left(lv_obj_t * obj, int32_t value, lv_style_selector_t selector)
 {
     lv_style_value_t v = {
@@ -202,6 +226,7 @@ void lv_obj_set_style_pad_left(lv_obj_t * obj, int32_t value, lv_style_selector_
     lv_obj_set_local_style_prop(obj, LV_STYLE_PAD_LEFT, v, selector);
 }
 
+LV_FUNC_SECTION
 void lv_obj_set_style_pad_right(lv_obj_t * obj, int32_t value, lv_style_selector_t selector)
 {
     lv_style_value_t v = {
@@ -210,6 +235,7 @@ void lv_obj_set_style_pad_right(lv_obj_t * obj, int32_t value, lv_style_selector
     lv_obj_set_local_style_prop(obj, LV_STYLE_PAD_RIGHT, v, selector);
 }
 
+LV_FUNC_SECTION
 void lv_obj_set_style_pad_row(lv_obj_t * obj, int32_t value, lv_style_selector_t selector)
 {
     lv_style_value_t v = {
@@ -218,6 +244,7 @@ void lv_obj_set_style_pad_row(lv_obj_t * obj, int32_t value, lv_style_selector_t
     lv_obj_set_local_style_prop(obj, LV_STYLE_PAD_ROW, v, selector);
 }
 
+LV_FUNC_SECTION
 void lv_obj_set_style_pad_column(lv_obj_t * obj, int32_t value, lv_style_selector_t selector)
 {
     lv_style_value_t v = {
@@ -226,6 +253,7 @@ void lv_obj_set_style_pad_column(lv_obj_t * obj, int32_t value, lv_style_selecto
     lv_obj_set_local_style_prop(obj, LV_STYLE_PAD_COLUMN, v, selector);
 }
 
+LV_FUNC_SECTION
 void lv_obj_set_style_margin_top(lv_obj_t * obj, int32_t value, lv_style_selector_t selector)
 {
     lv_style_value_t v = {
@@ -234,6 +262,7 @@ void lv_obj_set_style_margin_top(lv_obj_t * obj, int32_t value, lv_style_selecto
     lv_obj_set_local_style_prop(obj, LV_STYLE_MARGIN_TOP, v, selector);
 }
 
+LV_FUNC_SECTION
 void lv_obj_set_style_margin_bottom(lv_obj_t * obj, int32_t value, lv_style_selector_t selector)
 {
     lv_style_value_t v = {
@@ -242,6 +271,7 @@ void lv_obj_set_style_margin_bottom(lv_obj_t * obj, int32_t value, lv_style_sele
     lv_obj_set_local_style_prop(obj, LV_STYLE_MARGIN_BOTTOM, v, selector);
 }
 
+LV_FUNC_SECTION
 void lv_obj_set_style_margin_left(lv_obj_t * obj, int32_t value, lv_style_selector_t selector)
 {
     lv_style_value_t v = {
@@ -250,6 +280,7 @@ void lv_obj_set_style_margin_left(lv_obj_t * obj, int32_t value, lv_style_select
     lv_obj_set_local_style_prop(obj, LV_STYLE_MARGIN_LEFT, v, selector);
 }
 
+LV_FUNC_SECTION
 void lv_obj_set_style_margin_right(lv_obj_t * obj, int32_t value, lv_style_selector_t selector)
 {
     lv_style_value_t v = {
@@ -258,6 +289,7 @@ void lv_obj_set_style_margin_right(lv_obj_t * obj, int32_t value, lv_style_selec
     lv_obj_set_local_style_prop(obj, LV_STYLE_MARGIN_RIGHT, v, selector);
 }
 
+LV_FUNC_SECTION
 void lv_obj_set_style_bg_color(lv_obj_t * obj, lv_color_t value, lv_style_selector_t selector)
 {
     lv_style_value_t v = {
@@ -266,6 +298,7 @@ void lv_obj_set_style_bg_color(lv_obj_t * obj, lv_color_t value, lv_style_select
     lv_obj_set_local_style_prop(obj, LV_STYLE_BG_COLOR, v, selector);
 }
 
+LV_FUNC_SECTION
 void lv_obj_set_style_bg_opa(lv_obj_t * obj, lv_opa_t value, lv_style_selector_t selector)
 {
     lv_style_value_t v = {
@@ -274,6 +307,7 @@ void lv_obj_set_style_bg_opa(lv_obj_t * obj, lv_opa_t value, lv_style_selector_t
     lv_obj_set_local_style_prop(obj, LV_STYLE_BG_OPA, v, selector);
 }
 
+LV_FUNC_SECTION
 void lv_obj_set_style_bg_grad_color(lv_obj_t * obj, lv_color_t value, lv_style_selector_t selector)
 {
     lv_style_value_t v = {
@@ -282,6 +316,7 @@ void lv_obj_set_style_bg_grad_color(lv_obj_t * obj, lv_color_t value, lv_style_s
     lv_obj_set_local_style_prop(obj, LV_STYLE_BG_GRAD_COLOR, v, selector);
 }
 
+LV_FUNC_SECTION
 void lv_obj_set_style_bg_grad_dir(lv_obj_t * obj, lv_grad_dir_t value, lv_style_selector_t selector)
 {
     lv_style_value_t v = {
@@ -290,6 +325,7 @@ void lv_obj_set_style_bg_grad_dir(lv_obj_t * obj, lv_grad_dir_t value, lv_style_
     lv_obj_set_local_style_prop(obj, LV_STYLE_BG_GRAD_DIR, v, selector);
 }
 
+LV_FUNC_SECTION
 void lv_obj_set_style_bg_main_stop(lv_obj_t * obj, int32_t value, lv_style_selector_t selector)
 {
     lv_style_value_t v = {
@@ -298,6 +334,7 @@ void lv_obj_set_style_bg_main_stop(lv_obj_t * obj, int32_t value, lv_style_selec
     lv_obj_set_local_style_prop(obj, LV_STYLE_BG_MAIN_STOP, v, selector);
 }
 
+LV_FUNC_SECTION
 void lv_obj_set_style_bg_grad_stop(lv_obj_t * obj, int32_t value, lv_style_selector_t selector)
 {
     lv_style_value_t v = {
@@ -306,6 +343,7 @@ void lv_obj_set_style_bg_grad_stop(lv_obj_t * obj, int32_t value, lv_style_selec
     lv_obj_set_local_style_prop(obj, LV_STYLE_BG_GRAD_STOP, v, selector);
 }
 
+LV_FUNC_SECTION
 void lv_obj_set_style_bg_main_opa(lv_obj_t * obj, lv_opa_t value, lv_style_selector_t selector)
 {
     lv_style_value_t v = {
@@ -314,6 +352,7 @@ void lv_obj_set_style_bg_main_opa(lv_obj_t * obj, lv_opa_t value, lv_style_selec
     lv_obj_set_local_style_prop(obj, LV_STYLE_BG_MAIN_OPA, v, selector);
 }
 
+LV_FUNC_SECTION
 void lv_obj_set_style_bg_grad_opa(lv_obj_t * obj, lv_opa_t value, lv_style_selector_t selector)
 {
     lv_style_value_t v = {
@@ -322,6 +361,7 @@ void lv_obj_set_style_bg_grad_opa(lv_obj_t * obj, lv_opa_t value, lv_style_selec
     lv_obj_set_local_style_prop(obj, LV_STYLE_BG_GRAD_OPA, v, selector);
 }
 
+LV_FUNC_SECTION
 void lv_obj_set_style_bg_grad(lv_obj_t * obj, const lv_grad_dsc_t * value, lv_style_selector_t selector)
 {
     lv_style_value_t v = {
@@ -330,6 +370,7 @@ void lv_obj_set_style_bg_grad(lv_obj_t * obj, const lv_grad_dsc_t * value, lv_st
     lv_obj_set_local_style_prop(obj, LV_STYLE_BG_GRAD, v, selector);
 }
 
+LV_FUNC_SECTION
 void lv_obj_set_style_bg_image_src(lv_obj_t * obj, const void * value, lv_style_selector_t selector)
 {
     lv_style_value_t v = {
@@ -338,6 +379,7 @@ void lv_obj_set_style_bg_image_src(lv_obj_t * obj, const void * value, lv_style_
     lv_obj_set_local_style_prop(obj, LV_STYLE_BG_IMAGE_SRC, v, selector);
 }
 
+LV_FUNC_SECTION
 void lv_obj_set_style_bg_image_opa(lv_obj_t * obj, lv_opa_t value, lv_style_selector_t selector)
 {
     lv_style_value_t v = {
@@ -346,6 +388,7 @@ void lv_obj_set_style_bg_image_opa(lv_obj_t * obj, lv_opa_t value, lv_style_sele
     lv_obj_set_local_style_prop(obj, LV_STYLE_BG_IMAGE_OPA, v, selector);
 }
 
+LV_FUNC_SECTION
 void lv_obj_set_style_bg_image_recolor(lv_obj_t * obj, lv_color_t value, lv_style_selector_t selector)
 {
     lv_style_value_t v = {
@@ -354,6 +397,7 @@ void lv_obj_set_style_bg_image_recolor(lv_obj_t * obj, lv_color_t value, lv_styl
     lv_obj_set_local_style_prop(obj, LV_STYLE_BG_IMAGE_RECOLOR, v, selector);
 }
 
+LV_FUNC_SECTION
 void lv_obj_set_style_bg_image_recolor_opa(lv_obj_t * obj, lv_opa_t value, lv_style_selector_t selector)
 {
     lv_style_value_t v = {
@@ -362,6 +406,7 @@ void lv_obj_set_style_bg_image_recolor_opa(lv_obj_t * obj, lv_opa_t value, lv_st
     lv_obj_set_local_style_prop(obj, LV_STYLE_BG_IMAGE_RECOLOR_OPA, v, selector);
 }
 
+LV_FUNC_SECTION
 void lv_obj_set_style_bg_image_tiled(lv_obj_t * obj, bool value, lv_style_selector_t selector)
 {
     lv_style_value_t v = {
@@ -370,6 +415,7 @@ void lv_obj_set_style_bg_image_tiled(lv_obj_t * obj, bool value, lv_style_select
     lv_obj_set_local_style_prop(obj, LV_STYLE_BG_IMAGE_TILED, v, selector);
 }
 
+LV_FUNC_SECTION
 void lv_obj_set_style_border_color(lv_obj_t * obj, lv_color_t value, lv_style_selector_t selector)
 {
     lv_style_value_t v = {
@@ -378,6 +424,7 @@ void lv_obj_set_style_border_color(lv_obj_t * obj, lv_color_t value, lv_style_se
     lv_obj_set_local_style_prop(obj, LV_STYLE_BORDER_COLOR, v, selector);
 }
 
+LV_FUNC_SECTION
 void lv_obj_set_style_border_opa(lv_obj_t * obj, lv_opa_t value, lv_style_selector_t selector)
 {
     lv_style_value_t v = {
@@ -386,6 +433,7 @@ void lv_obj_set_style_border_opa(lv_obj_t * obj, lv_opa_t value, lv_style_select
     lv_obj_set_local_style_prop(obj, LV_STYLE_BORDER_OPA, v, selector);
 }
 
+LV_FUNC_SECTION
 void lv_obj_set_style_border_width(lv_obj_t * obj, int32_t value, lv_style_selector_t selector)
 {
     lv_style_value_t v = {
@@ -394,6 +442,7 @@ void lv_obj_set_style_border_width(lv_obj_t * obj, int32_t value, lv_style_selec
     lv_obj_set_local_style_prop(obj, LV_STYLE_BORDER_WIDTH, v, selector);
 }
 
+LV_FUNC_SECTION
 void lv_obj_set_style_border_side(lv_obj_t * obj, lv_border_side_t value, lv_style_selector_t selector)
 {
     lv_style_value_t v = {
@@ -402,6 +451,7 @@ void lv_obj_set_style_border_side(lv_obj_t * obj, lv_border_side_t value, lv_sty
     lv_obj_set_local_style_prop(obj, LV_STYLE_BORDER_SIDE, v, selector);
 }
 
+LV_FUNC_SECTION
 void lv_obj_set_style_border_post(lv_obj_t * obj, bool value, lv_style_selector_t selector)
 {
     lv_style_value_t v = {
@@ -410,6 +460,7 @@ void lv_obj_set_style_border_post(lv_obj_t * obj, bool value, lv_style_selector_
     lv_obj_set_local_style_prop(obj, LV_STYLE_BORDER_POST, v, selector);
 }
 
+LV_FUNC_SECTION
 void lv_obj_set_style_outline_width(lv_obj_t * obj, int32_t value, lv_style_selector_t selector)
 {
     lv_style_value_t v = {
@@ -418,6 +469,7 @@ void lv_obj_set_style_outline_width(lv_obj_t * obj, int32_t value, lv_style_sele
     lv_obj_set_local_style_prop(obj, LV_STYLE_OUTLINE_WIDTH, v, selector);
 }
 
+LV_FUNC_SECTION
 void lv_obj_set_style_outline_color(lv_obj_t * obj, lv_color_t value, lv_style_selector_t selector)
 {
     lv_style_value_t v = {
@@ -426,6 +478,7 @@ void lv_obj_set_style_outline_color(lv_obj_t * obj, lv_color_t value, lv_style_s
     lv_obj_set_local_style_prop(obj, LV_STYLE_OUTLINE_COLOR, v, selector);
 }
 
+LV_FUNC_SECTION
 void lv_obj_set_style_outline_opa(lv_obj_t * obj, lv_opa_t value, lv_style_selector_t selector)
 {
     lv_style_value_t v = {
@@ -434,6 +487,7 @@ void lv_obj_set_style_outline_opa(lv_obj_t * obj, lv_opa_t value, lv_style_selec
     lv_obj_set_local_style_prop(obj, LV_STYLE_OUTLINE_OPA, v, selector);
 }
 
+LV_FUNC_SECTION
 void lv_obj_set_style_outline_pad(lv_obj_t * obj, int32_t value, lv_style_selector_t selector)
 {
     lv_style_value_t v = {
@@ -442,6 +496,7 @@ void lv_obj_set_style_outline_pad(lv_obj_t * obj, int32_t value, lv_style_select
     lv_obj_set_local_style_prop(obj, LV_STYLE_OUTLINE_PAD, v, selector);
 }
 
+LV_FUNC_SECTION
 void lv_obj_set_style_shadow_width(lv_obj_t * obj, int32_t value, lv_style_selector_t selector)
 {
     lv_style_value_t v = {
@@ -450,6 +505,7 @@ void lv_obj_set_style_shadow_width(lv_obj_t * obj, int32_t value, lv_style_selec
     lv_obj_set_local_style_prop(obj, LV_STYLE_SHADOW_WIDTH, v, selector);
 }
 
+LV_FUNC_SECTION
 void lv_obj_set_style_shadow_offset_x(lv_obj_t * obj, int32_t value, lv_style_selector_t selector)
 {
     lv_style_value_t v = {
@@ -458,6 +514,7 @@ void lv_obj_set_style_shadow_offset_x(lv_obj_t * obj, int32_t value, lv_style_se
     lv_obj_set_local_style_prop(obj, LV_STYLE_SHADOW_OFFSET_X, v, selector);
 }
 
+LV_FUNC_SECTION
 void lv_obj_set_style_shadow_offset_y(lv_obj_t * obj, int32_t value, lv_style_selector_t selector)
 {
     lv_style_value_t v = {
@@ -466,6 +523,7 @@ void lv_obj_set_style_shadow_offset_y(lv_obj_t * obj, int32_t value, lv_style_se
     lv_obj_set_local_style_prop(obj, LV_STYLE_SHADOW_OFFSET_Y, v, selector);
 }
 
+LV_FUNC_SECTION
 void lv_obj_set_style_shadow_spread(lv_obj_t * obj, int32_t value, lv_style_selector_t selector)
 {
     lv_style_value_t v = {
@@ -474,6 +532,7 @@ void lv_obj_set_style_shadow_spread(lv_obj_t * obj, int32_t value, lv_style_sele
     lv_obj_set_local_style_prop(obj, LV_STYLE_SHADOW_SPREAD, v, selector);
 }
 
+LV_FUNC_SECTION
 void lv_obj_set_style_shadow_color(lv_obj_t * obj, lv_color_t value, lv_style_selector_t selector)
 {
     lv_style_value_t v = {
@@ -482,6 +541,7 @@ void lv_obj_set_style_shadow_color(lv_obj_t * obj, lv_color_t value, lv_style_se
     lv_obj_set_local_style_prop(obj, LV_STYLE_SHADOW_COLOR, v, selector);
 }
 
+LV_FUNC_SECTION
 void lv_obj_set_style_shadow_opa(lv_obj_t * obj, lv_opa_t value, lv_style_selector_t selector)
 {
     lv_style_value_t v = {
@@ -490,6 +550,7 @@ void lv_obj_set_style_shadow_opa(lv_obj_t * obj, lv_opa_t value, lv_style_select
     lv_obj_set_local_style_prop(obj, LV_STYLE_SHADOW_OPA, v, selector);
 }
 
+LV_FUNC_SECTION
 void lv_obj_set_style_image_opa(lv_obj_t * obj, lv_opa_t value, lv_style_selector_t selector)
 {
     lv_style_value_t v = {
@@ -498,6 +559,7 @@ void lv_obj_set_style_image_opa(lv_obj_t * obj, lv_opa_t value, lv_style_selecto
     lv_obj_set_local_style_prop(obj, LV_STYLE_IMAGE_OPA, v, selector);
 }
 
+LV_FUNC_SECTION
 void lv_obj_set_style_image_recolor(lv_obj_t * obj, lv_color_t value, lv_style_selector_t selector)
 {
     lv_style_value_t v = {
@@ -506,6 +568,7 @@ void lv_obj_set_style_image_recolor(lv_obj_t * obj, lv_color_t value, lv_style_s
     lv_obj_set_local_style_prop(obj, LV_STYLE_IMAGE_RECOLOR, v, selector);
 }
 
+LV_FUNC_SECTION
 void lv_obj_set_style_image_recolor_opa(lv_obj_t * obj, lv_opa_t value, lv_style_selector_t selector)
 {
     lv_style_value_t v = {
@@ -514,6 +577,7 @@ void lv_obj_set_style_image_recolor_opa(lv_obj_t * obj, lv_opa_t value, lv_style
     lv_obj_set_local_style_prop(obj, LV_STYLE_IMAGE_RECOLOR_OPA, v, selector);
 }
 
+LV_FUNC_SECTION
 void lv_obj_set_style_line_width(lv_obj_t * obj, int32_t value, lv_style_selector_t selector)
 {
     lv_style_value_t v = {
@@ -522,6 +586,7 @@ void lv_obj_set_style_line_width(lv_obj_t * obj, int32_t value, lv_style_selecto
     lv_obj_set_local_style_prop(obj, LV_STYLE_LINE_WIDTH, v, selector);
 }
 
+LV_FUNC_SECTION
 void lv_obj_set_style_line_dash_width(lv_obj_t * obj, int32_t value, lv_style_selector_t selector)
 {
     lv_style_value_t v = {
@@ -530,6 +595,7 @@ void lv_obj_set_style_line_dash_width(lv_obj_t * obj, int32_t value, lv_style_se
     lv_obj_set_local_style_prop(obj, LV_STYLE_LINE_DASH_WIDTH, v, selector);
 }
 
+LV_FUNC_SECTION
 void lv_obj_set_style_line_dash_gap(lv_obj_t * obj, int32_t value, lv_style_selector_t selector)
 {
     lv_style_value_t v = {
@@ -538,6 +604,7 @@ void lv_obj_set_style_line_dash_gap(lv_obj_t * obj, int32_t value, lv_style_sele
     lv_obj_set_local_style_prop(obj, LV_STYLE_LINE_DASH_GAP, v, selector);
 }
 
+LV_FUNC_SECTION
 void lv_obj_set_style_line_rounded(lv_obj_t * obj, bool value, lv_style_selector_t selector)
 {
     lv_style_value_t v = {
@@ -546,6 +613,7 @@ void lv_obj_set_style_line_rounded(lv_obj_t * obj, bool value, lv_style_selector
     lv_obj_set_local_style_prop(obj, LV_STYLE_LINE_ROUNDED, v, selector);
 }
 
+LV_FUNC_SECTION
 void lv_obj_set_style_line_color(lv_obj_t * obj, lv_color_t value, lv_style_selector_t selector)
 {
     lv_style_value_t v = {
@@ -554,6 +622,7 @@ void lv_obj_set_style_line_color(lv_obj_t * obj, lv_color_t value, lv_style_sele
     lv_obj_set_local_style_prop(obj, LV_STYLE_LINE_COLOR, v, selector);
 }
 
+LV_FUNC_SECTION
 void lv_obj_set_style_line_opa(lv_obj_t * obj, lv_opa_t value, lv_style_selector_t selector)
 {
     lv_style_value_t v = {
@@ -562,6 +631,7 @@ void lv_obj_set_style_line_opa(lv_obj_t * obj, lv_opa_t value, lv_style_selector
     lv_obj_set_local_style_prop(obj, LV_STYLE_LINE_OPA, v, selector);
 }
 
+LV_FUNC_SECTION
 void lv_obj_set_style_arc_width(lv_obj_t * obj, int32_t value, lv_style_selector_t selector)
 {
     lv_style_value_t v = {
@@ -570,6 +640,7 @@ void lv_obj_set_style_arc_width(lv_obj_t * obj, int32_t value, lv_style_selector
     lv_obj_set_local_style_prop(obj, LV_STYLE_ARC_WIDTH, v, selector);
 }
 
+LV_FUNC_SECTION
 void lv_obj_set_style_arc_rounded(lv_obj_t * obj, bool value, lv_style_selector_t selector)
 {
     lv_style_value_t v = {
@@ -578,6 +649,7 @@ void lv_obj_set_style_arc_rounded(lv_obj_t * obj, bool value, lv_style_selector_
     lv_obj_set_local_style_prop(obj, LV_STYLE_ARC_ROUNDED, v, selector);
 }
 
+LV_FUNC_SECTION
 void lv_obj_set_style_arc_color(lv_obj_t * obj, lv_color_t value, lv_style_selector_t selector)
 {
     lv_style_value_t v = {
@@ -586,6 +658,7 @@ void lv_obj_set_style_arc_color(lv_obj_t * obj, lv_color_t value, lv_style_selec
     lv_obj_set_local_style_prop(obj, LV_STYLE_ARC_COLOR, v, selector);
 }
 
+LV_FUNC_SECTION
 void lv_obj_set_style_arc_opa(lv_obj_t * obj, lv_opa_t value, lv_style_selector_t selector)
 {
     lv_style_value_t v = {
@@ -594,6 +667,7 @@ void lv_obj_set_style_arc_opa(lv_obj_t * obj, lv_opa_t value, lv_style_selector_
     lv_obj_set_local_style_prop(obj, LV_STYLE_ARC_OPA, v, selector);
 }
 
+LV_FUNC_SECTION
 void lv_obj_set_style_arc_image_src(lv_obj_t * obj, const void * value, lv_style_selector_t selector)
 {
     lv_style_value_t v = {
@@ -602,6 +676,7 @@ void lv_obj_set_style_arc_image_src(lv_obj_t * obj, const void * value, lv_style
     lv_obj_set_local_style_prop(obj, LV_STYLE_ARC_IMAGE_SRC, v, selector);
 }
 
+LV_FUNC_SECTION
 void lv_obj_set_style_text_color(lv_obj_t * obj, lv_color_t value, lv_style_selector_t selector)
 {
     lv_style_value_t v = {
@@ -610,6 +685,7 @@ void lv_obj_set_style_text_color(lv_obj_t * obj, lv_color_t value, lv_style_sele
     lv_obj_set_local_style_prop(obj, LV_STYLE_TEXT_COLOR, v, selector);
 }
 
+LV_FUNC_SECTION
 void lv_obj_set_style_text_opa(lv_obj_t * obj, lv_opa_t value, lv_style_selector_t selector)
 {
     lv_style_value_t v = {
@@ -618,6 +694,7 @@ void lv_obj_set_style_text_opa(lv_obj_t * obj, lv_opa_t value, lv_style_selector
     lv_obj_set_local_style_prop(obj, LV_STYLE_TEXT_OPA, v, selector);
 }
 
+LV_FUNC_SECTION
 void lv_obj_set_style_text_font(lv_obj_t * obj, const lv_font_t * value, lv_style_selector_t selector)
 {
     lv_style_value_t v = {
@@ -626,6 +703,7 @@ void lv_obj_set_style_text_font(lv_obj_t * obj, const lv_font_t * value, lv_styl
     lv_obj_set_local_style_prop(obj, LV_STYLE_TEXT_FONT, v, selector);
 }
 
+LV_FUNC_SECTION
 void lv_obj_set_style_text_letter_space(lv_obj_t * obj, int32_t value, lv_style_selector_t selector)
 {
     lv_style_value_t v = {
@@ -634,6 +712,7 @@ void lv_obj_set_style_text_letter_space(lv_obj_t * obj, int32_t value, lv_style_
     lv_obj_set_local_style_prop(obj, LV_STYLE_TEXT_LETTER_SPACE, v, selector);
 }
 
+LV_FUNC_SECTION
 void lv_obj_set_style_text_line_space(lv_obj_t * obj, int32_t value, lv_style_selector_t selector)
 {
     lv_style_value_t v = {
@@ -642,6 +721,7 @@ void lv_obj_set_style_text_line_space(lv_obj_t * obj, int32_t value, lv_style_se
     lv_obj_set_local_style_prop(obj, LV_STYLE_TEXT_LINE_SPACE, v, selector);
 }
 
+LV_FUNC_SECTION
 void lv_obj_set_style_text_decor(lv_obj_t * obj, lv_text_decor_t value, lv_style_selector_t selector)
 {
     lv_style_value_t v = {
@@ -650,6 +730,7 @@ void lv_obj_set_style_text_decor(lv_obj_t * obj, lv_text_decor_t value, lv_style
     lv_obj_set_local_style_prop(obj, LV_STYLE_TEXT_DECOR, v, selector);
 }
 
+LV_FUNC_SECTION
 void lv_obj_set_style_text_align(lv_obj_t * obj, lv_text_align_t value, lv_style_selector_t selector)
 {
     lv_style_value_t v = {
@@ -658,6 +739,7 @@ void lv_obj_set_style_text_align(lv_obj_t * obj, lv_text_align_t value, lv_style
     lv_obj_set_local_style_prop(obj, LV_STYLE_TEXT_ALIGN, v, selector);
 }
 
+LV_FUNC_SECTION
 void lv_obj_set_style_radius(lv_obj_t * obj, int32_t value, lv_style_selector_t selector)
 {
     lv_style_value_t v = {
@@ -666,6 +748,7 @@ void lv_obj_set_style_radius(lv_obj_t * obj, int32_t value, lv_style_selector_t
     lv_obj_set_local_style_prop(obj, LV_STYLE_RADIUS, v, selector);
 }
 
+LV_FUNC_SECTION
 void lv_obj_set_style_clip_corner(lv_obj_t * obj, bool value, lv_style_selector_t selector)
 {
     lv_style_value_t v = {
@@ -674,6 +757,7 @@ void lv_obj_set_style_clip_corner(lv_obj_t * obj, bool value, lv_style_selector_
     lv_obj_set_local_style_prop(obj, LV_STYLE_CLIP_CORNER, v, selector);
 }
 
+LV_FUNC_SECTION
 void lv_obj_set_style_opa(lv_obj_t * obj, lv_opa_t value, lv_style_selector_t selector)
 {
     lv_style_value_t v = {
@@ -682,6 +766,7 @@ void lv_obj_set_style_opa(lv_obj_t * obj, lv_opa_t value, lv_style_selector_t se
     lv_obj_set_local_style_prop(obj, LV_STYLE_OPA, v, selector);
 }
 
+LV_FUNC_SECTION
 void lv_obj_set_style_opa_layered(lv_obj_t * obj, lv_opa_t value, lv_style_selector_t selector)
 {
     lv_style_value_t v = {
@@ -690,6 +775,7 @@ void lv_obj_set_style_opa_layered(lv_obj_t * obj, lv_opa_t value, lv_style_selec
     lv_obj_set_local_style_prop(obj, LV_STYLE_OPA_LAYERED, v, selector);
 }
 
+LV_FUNC_SECTION
 void lv_obj_set_style_color_filter_dsc(lv_obj_t * obj, const lv_color_filter_dsc_t * value, lv_style_selector_t selector)
 {
     lv_style_value_t v = {
@@ -698,6 +784,7 @@ void lv_obj_set_style_color_filter_dsc(lv_obj_t * obj, const lv_color_filter_dsc
     lv_obj_set_local_style_prop(obj, LV_STYLE_COLOR_FILTER_DSC, v, selector);
 }
 
+LV_FUNC_SECTION
 void lv_obj_set_style_color_filter_opa(lv_obj_t * obj, lv_opa_t value, lv_style_selector_t selector)
 {
     lv_style_value_t v = {
@@ -706,6 +793,7 @@ void lv_obj_set_style_color_filter_opa(lv_obj_t * obj, lv_opa_t value, lv_style_
     lv_obj_set_local_style_prop(obj, LV_STYLE_COLOR_FILTER_OPA, v, selector);
 }
 
+LV_FUNC_SECTION
 void lv_obj_set_style_anim(lv_obj_t * obj, const lv_anim_t * value, lv_style_selector_t selector)
 {
     lv_style_value_t v = {
@@ -714,6 +802,7 @@ void lv_obj_set_style_anim(lv_obj_t * obj, const lv_anim_t * value, lv_style_sel
     lv_obj_set_local_style_prop(obj, LV_STYLE_ANIM, v, selector);
 }
 
+LV_FUNC_SECTION
 void lv_obj_set_style_anim_duration(lv_obj_t * obj, uint32_t value, lv_style_selector_t selector)
 {
     lv_style_value_t v = {
@@ -722,6 +811,7 @@ void lv_obj_set_style_anim_duration(lv_obj_t * obj, uint32_t value, lv_style_sel
     lv_obj_set_local_style_prop(obj, LV_STYLE_ANIM_DURATION, v, selector);
 }
 
+LV_FUNC_SECTION
 void lv_obj_set_style_transition(lv_obj_t * obj, const lv_style_transition_dsc_t * value, lv_style_selector_t selector)
 {
     lv_style_value_t v = {
@@ -730,6 +820,7 @@ void lv_obj_set_style_transition(lv_obj_t * obj, const lv_style_transition_dsc_t
     lv_obj_set_local_style_prop(obj, LV_STYLE_TRANSITION, v, selector);
 }
 
+LV_FUNC_SECTION
 void lv_obj_set_style_blend_mode(lv_obj_t * obj, lv_blend_mode_t value, lv_style_selector_t selector)
 {
     lv_style_value_t v = {
@@ -738,6 +829,7 @@ void lv_obj_set_style_blend_mode(lv_obj_t * obj, lv_blend_mode_t value, lv_style
     lv_obj_set_local_style_prop(obj, LV_STYLE_BLEND_MODE, v, selector);
 }
 
+LV_FUNC_SECTION
 void lv_obj_set_style_layout(lv_obj_t * obj, uint16_t value, lv_style_selector_t selector)
 {
     lv_style_value_t v = {
@@ -746,6 +838,7 @@ void lv_obj_set_style_layout(lv_obj_t * obj, uint16_t value, lv_style_selector_t
     lv_obj_set_local_style_prop(obj, LV_STYLE_LAYOUT, v, selector);
 }
 
+LV_FUNC_SECTION
 void lv_obj_set_style_base_dir(lv_obj_t * obj, lv_base_dir_t value, lv_style_selector_t selector)
 {
     lv_style_value_t v = {
@@ -754,6 +847,7 @@ void lv_obj_set_style_base_dir(lv_obj_t * obj, lv_base_dir_t value, lv_style_sel
     lv_obj_set_local_style_prop(obj, LV_STYLE_BASE_DIR, v, selector);
 }
 
+LV_FUNC_SECTION
 void lv_obj_set_style_bitmap_mask_src(lv_obj_t * obj, const void * value, lv_style_selector_t selector)
 {
     lv_style_value_t v = {
@@ -762,6 +856,7 @@ void lv_obj_set_style_bitmap_mask_src(lv_obj_t * obj, const void * value, lv_sty
     lv_obj_set_local_style_prop(obj, LV_STYLE_BITMAP_MASK_SRC, v, selector);
 }
 
+LV_FUNC_SECTION
 void lv_obj_set_style_rotary_sensitivity(lv_obj_t * obj, uint32_t value, lv_style_selector_t selector)
 {
     lv_style_value_t v = {
@@ -771,6 +866,7 @@ void lv_obj_set_style_rotary_sensitivity(lv_obj_t * obj, uint32_t value, lv_styl
 }
 #if LV_USE_FLEX
 
+LV_FUNC_SECTION
 void lv_obj_set_style_flex_flow(lv_obj_t * obj, lv_flex_flow_t value, lv_style_selector_t selector)
 {
     lv_style_value_t v = {
@@ -779,6 +875,7 @@ void lv_obj_set_style_flex_flow(lv_obj_t * obj, lv_flex_flow_t value, lv_style_s
     lv_obj_set_local_style_prop(obj, LV_STYLE_FLEX_FLOW, v, selector);
 }
 
+LV_FUNC_SECTION
 void lv_obj_set_style_flex_main_place(lv_obj_t * obj, lv_flex_align_t value, lv_style_selector_t selector)
 {
     lv_style_value_t v = {
@@ -787,6 +884,7 @@ void lv_obj_set_style_flex_main_place(lv_obj_t * obj, lv_flex_align_t value, lv_
     lv_obj_set_local_style_prop(obj, LV_STYLE_FLEX_MAIN_PLACE, v, selector);
 }
 
+LV_FUNC_SECTION
 void lv_obj_set_style_flex_cross_place(lv_obj_t * obj, lv_flex_align_t value, lv_style_selector_t selector)
 {
     lv_style_value_t v = {
@@ -795,6 +893,7 @@ void lv_obj_set_style_flex_cross_place(lv_obj_t * obj, lv_flex_align_t value, lv
     lv_obj_set_local_style_prop(obj, LV_STYLE_FLEX_CROSS_PLACE, v, selector);
 }
 
+LV_FUNC_SECTION
 void lv_obj_set_style_flex_track_place(lv_obj_t * obj, lv_flex_align_t value, lv_style_selector_t selector)
 {
     lv_style_value_t v = {
@@ -803,6 +902,7 @@ void lv_obj_set_style_flex_track_place(lv_obj_t * obj, lv_flex_align_t value, lv
     lv_obj_set_local_style_prop(obj, LV_STYLE_FLEX_TRACK_PLACE, v, selector);
 }
 
+LV_FUNC_SECTION
 void lv_obj_set_style_flex_grow(lv_obj_t * obj, uint8_t value, lv_style_selector_t selector)
 {
     lv_style_value_t v = {
@@ -814,6 +914,7 @@ void lv_obj_set_style_flex_grow(lv_obj_t * obj, uint8_t value, lv_style_selector
 
 #if LV_USE_GRID
 
+LV_FUNC_SECTION
 void lv_obj_set_style_grid_column_dsc_array(lv_obj_t * obj, const int32_t * value, lv_style_selector_t selector)
 {
     lv_style_value_t v = {
@@ -822,6 +923,7 @@ void lv_obj_set_style_grid_column_dsc_array(lv_obj_t * obj, const int32_t * valu
     lv_obj_set_local_style_prop(obj, LV_STYLE_GRID_COLUMN_DSC_ARRAY, v, selector);
 }
 
+LV_FUNC_SECTION
 void lv_obj_set_style_grid_column_align(lv_obj_t * obj, lv_grid_align_t value, lv_style_selector_t selector)
 {
     lv_style_value_t v = {
@@ -830,6 +932,7 @@ void lv_obj_set_style_grid_column_align(lv_obj_t * obj, lv_grid_align_t value, l
     lv_obj_set_local_style_prop(obj, LV_STYLE_GRID_COLUMN_ALIGN, v, selector);
 }
 
+LV_FUNC_SECTION
 void lv_obj_set_style_grid_row_dsc_array(lv_obj_t * obj, const int32_t * value, lv_style_selector_t selector)
 {
     lv_style_value_t v = {
@@ -838,6 +941,7 @@ void lv_obj_set_style_grid_row_dsc_array(lv_obj_t * obj, const int32_t * value,
     lv_obj_set_local_style_prop(obj, LV_STYLE_GRID_ROW_DSC_ARRAY, v, selector);
 }
 
+LV_FUNC_SECTION
 void lv_obj_set_style_grid_row_align(lv_obj_t * obj, lv_grid_align_t value, lv_style_selector_t selector)
 {
     lv_style_value_t v = {
@@ -846,6 +950,7 @@ void lv_obj_set_style_grid_row_align(lv_obj_t * obj, lv_grid_align_t value, lv_s
     lv_obj_set_local_style_prop(obj, LV_STYLE_GRID_ROW_ALIGN, v, selector);
 }
 
+LV_FUNC_SECTION
 void lv_obj_set_style_grid_cell_column_pos(lv_obj_t * obj, int32_t value, lv_style_selector_t selector)
 {
     lv_style_value_t v = {
@@ -854,6 +959,7 @@ void lv_obj_set_style_grid_cell_column_pos(lv_obj_t * obj, int32_t value, lv_sty
     lv_obj_set_local_style_prop(obj, LV_STYLE_GRID_CELL_COLUMN_POS, v, selector);
 }
 
+LV_FUNC_SECTION
 void lv_obj_set_style_grid_cell_x_align(lv_obj_t * obj, lv_grid_align_t value, lv_style_selector_t selector)
 {
     lv_style_value_t v = {
@@ -862,6 +968,7 @@ void lv_obj_set_style_grid_cell_x_align(lv_obj_t * obj, lv_grid_align_t value, l
     lv_obj_set_local_style_prop(obj, LV_STYLE_GRID_CELL_X_ALIGN, v, selector);
 }
 
+LV_FUNC_SECTION
 void lv_obj_set_style_grid_cell_column_span(lv_obj_t * obj, int32_t value, lv_style_selector_t selector)
 {
     lv_style_value_t v = {
@@ -870,6 +977,7 @@ void lv_obj_set_style_grid_cell_column_span(lv_obj_t * obj, int32_t value, lv_st
     lv_obj_set_local_style_prop(obj, LV_STYLE_GRID_CELL_COLUMN_SPAN, v, selector);
 }
 
+LV_FUNC_SECTION
 void lv_obj_set_style_grid_cell_row_pos(lv_obj_t * obj, int32_t value, lv_style_selector_t selector)
 {
     lv_style_value_t v = {
@@ -878,6 +986,7 @@ void lv_obj_set_style_grid_cell_row_pos(lv_obj_t * obj, int32_t value, lv_style_
     lv_obj_set_local_style_prop(obj, LV_STYLE_GRID_CELL_ROW_POS, v, selector);
 }
 
+LV_FUNC_SECTION
 void lv_obj_set_style_grid_cell_y_align(lv_obj_t * obj, lv_grid_align_t value, lv_style_selector_t selector)
 {
     lv_style_value_t v = {
@@ -886,6 +995,7 @@ void lv_obj_set_style_grid_cell_y_align(lv_obj_t * obj, lv_grid_align_t value, l
     lv_obj_set_local_style_prop(obj, LV_STYLE_GRID_CELL_Y_ALIGN, v, selector);
 }
 
+LV_FUNC_SECTION
 void lv_obj_set_style_grid_cell_row_span(lv_obj_t * obj, int32_t value, lv_style_selector_t selector)
 {
     lv_style_value_t v = {
diff --git a/src/core/lv_obj_style_private.h b/src/core/lv_obj_style_private.h
index 7fafc58b1..896cf2d53 100644
--- a/src/core/lv_obj_style_private.h
+++ b/src/core/lv_obj_style_private.h
@@ -36,6 +36,7 @@ struct lv_obj_style_transition_dsc_t {
     uint16_t delay;
     lv_style_selector_t selector;
     lv_style_prop_t prop;
+    __attribute__(( fptrgroup("lv_anim_path_cb") ))
     lv_anim_path_cb_t path_cb;
     void * user_data;
 };
diff --git a/src/core/lv_obj_tree.c b/src/core/lv_obj_tree.c
index 15c069e90..23e982249 100644
--- a/src/core/lv_obj_tree.c
+++ b/src/core/lv_obj_tree.c
@@ -49,6 +49,7 @@ static lv_obj_t * lv_obj_get_first_not_deleting_child(lv_obj_t * obj);
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 void lv_obj_delete(lv_obj_t * obj)
 {
     if(obj->is_deleting)
@@ -87,6 +88,7 @@ void lv_obj_delete(lv_obj_t * obj)
     LV_LOG_TRACE("finished (delete %p)", (void *)obj);
 }
 
+LV_FUNC_SECTION
 void lv_obj_clean(lv_obj_t * obj)
 {
     LV_LOG_TRACE("begin (clean %p)", (void *)obj);
@@ -117,6 +119,7 @@ void lv_obj_clean(lv_obj_t * obj)
     LV_LOG_TRACE("finished (clean %p)", (void *)obj);
 }
 
+LV_FUNC_SECTION
 void lv_obj_delete_delayed(lv_obj_t * obj, uint32_t delay_ms)
 {
     lv_anim_t a;
@@ -129,17 +132,20 @@ void lv_obj_delete_delayed(lv_obj_t * obj, uint32_t delay_ms)
     lv_anim_start(&a);
 }
 
+__attribute__(( fptrgroup("lv_anim_completed_cb") ))
 void lv_obj_delete_anim_completed_cb(lv_anim_t * a)
 {
     lv_obj_delete(a->var);
 }
 
+LV_FUNC_SECTION
 void lv_obj_delete_async(lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
     lv_async_call(lv_obj_delete_async_cb, obj);
 }
 
+LV_FUNC_SECTION
 void lv_obj_set_parent(lv_obj_t * obj, lv_obj_t * parent)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -201,6 +207,7 @@ void lv_obj_set_parent(lv_obj_t * obj, lv_obj_t * parent)
     lv_obj_invalidate(obj);
 }
 
+LV_FUNC_SECTION
 void lv_obj_move_to_index(lv_obj_t * obj, int32_t index)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -250,6 +257,7 @@ void lv_obj_move_to_index(lv_obj_t * obj, int32_t index)
     lv_obj_invalidate(parent);
 }
 
+LV_FUNC_SECTION
 void lv_obj_swap(lv_obj_t * obj1, lv_obj_t * obj2)
 {
     LV_ASSERT_OBJ(obj1, MY_CLASS);
@@ -283,6 +291,7 @@ void lv_obj_swap(lv_obj_t * obj1, lv_obj_t * obj2)
     lv_group_swap_obj(obj1, obj2);
 }
 
+LV_FUNC_SECTION
 lv_obj_t * lv_obj_get_screen(const lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -298,6 +307,7 @@ lv_obj_t * lv_obj_get_screen(const lv_obj_t * obj)
     return (lv_obj_t *)act_par;
 }
 
+LV_FUNC_SECTION
 lv_display_t * lv_obj_get_display(const lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -320,6 +330,7 @@ lv_display_t * lv_obj_get_display(const lv_obj_t * obj)
     return NULL;
 }
 
+LV_FUNC_SECTION
 lv_obj_t * lv_obj_get_parent(const lv_obj_t * obj)
 {
     if(obj == NULL) return NULL;
@@ -328,6 +339,7 @@ lv_obj_t * lv_obj_get_parent(const lv_obj_t * obj)
     return obj->parent;
 }
 
+LV_FUNC_SECTION
 lv_obj_t * lv_obj_get_child(const lv_obj_t * obj, int32_t idx)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -348,6 +360,7 @@ lv_obj_t * lv_obj_get_child(const lv_obj_t * obj, int32_t idx)
     else return obj->spec_attr->children[idx];
 }
 
+LV_FUNC_SECTION
 lv_obj_t * lv_obj_get_child_by_type(const lv_obj_t * obj, int32_t idx, const lv_obj_class_t * class_p)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -376,6 +389,7 @@ lv_obj_t * lv_obj_get_child_by_type(const lv_obj_t * obj, int32_t idx, const lv_
     return NULL;
 }
 
+LV_FUNC_SECTION
 lv_obj_t * lv_obj_get_sibling(const lv_obj_t * obj, int32_t idx)
 {
     lv_obj_t * parent = lv_obj_get_parent(obj);
@@ -385,6 +399,7 @@ lv_obj_t * lv_obj_get_sibling(const lv_obj_t * obj, int32_t idx)
     return lv_obj_get_child(parent, sibling_idx);
 }
 
+LV_FUNC_SECTION
 lv_obj_t * lv_obj_get_sibling_by_type(const lv_obj_t * obj, int32_t idx, const lv_obj_class_t * class_p)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -396,6 +411,7 @@ lv_obj_t * lv_obj_get_sibling_by_type(const lv_obj_t * obj, int32_t idx, const l
     return lv_obj_get_child_by_type(parent, sibling_idx, class_p);
 }
 
+LV_FUNC_SECTION
 uint32_t lv_obj_get_child_count(const lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -403,6 +419,7 @@ uint32_t lv_obj_get_child_count(const lv_obj_t * obj)
     return obj->spec_attr->child_cnt;
 }
 
+LV_FUNC_SECTION
 uint32_t lv_obj_get_child_count_by_type(const lv_obj_t * obj, const lv_obj_class_t * class_p)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -416,6 +433,7 @@ uint32_t lv_obj_get_child_count_by_type(const lv_obj_t * obj, const lv_obj_class
     return cnt;
 }
 
+LV_FUNC_SECTION
 int32_t lv_obj_get_index(const lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -433,6 +451,7 @@ int32_t lv_obj_get_index(const lv_obj_t * obj)
     return -1;
 }
 
+LV_FUNC_SECTION
 int32_t lv_obj_get_index_by_type(const lv_obj_t * obj, const lv_obj_class_t * class_p)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -454,11 +473,13 @@ int32_t lv_obj_get_index_by_type(const lv_obj_t * obj, const lv_obj_class_t * cl
     return -1;
 }
 
+LV_FUNC_SECTION
 void lv_obj_tree_walk(lv_obj_t * start_obj, lv_obj_tree_walk_cb_t cb, void * user_data)
 {
     walk_core(start_obj, cb, user_data);
 }
 
+LV_FUNC_SECTION
 void lv_obj_dump_tree(lv_obj_t * start_obj)
 {
     if(start_obj == NULL) {
@@ -479,7 +500,7 @@ void lv_obj_dump_tree(lv_obj_t * start_obj)
 /**********************
  *   STATIC FUNCTIONS
  **********************/
-
+__attribute__(( fptrgroup("lv_async_info_cb") ))
 static void lv_obj_delete_async_cb(void * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -487,6 +508,7 @@ static void lv_obj_delete_async_cb(void * obj)
     lv_obj_delete(obj);
 }
 
+LV_FUNC_SECTION
 static void obj_indev_reset(lv_indev_t * indev, lv_obj_t * obj)
 {
     /* If the input device is already in the release state,
@@ -501,6 +523,8 @@ static void obj_indev_reset(lv_indev_t * indev, lv_obj_t * obj)
     lv_indev_reset(indev, obj);
 }
 
+#pragma stackfunction 1024
+LV_FUNC_SECTION
 static void obj_delete_core(lv_obj_t * obj)
 {
     if(obj->is_deleting)
@@ -590,6 +614,8 @@ static void obj_delete_core(lv_obj_t * obj)
     lv_free(obj);
 }
 
+#pragma stackfunction 1024
+LV_FUNC_SECTION
 static lv_obj_tree_walk_res_t walk_core(lv_obj_t * obj, lv_obj_tree_walk_cb_t cb, void * user_data)
 {
     lv_obj_tree_walk_res_t res = LV_OBJ_TREE_WALK_NEXT;
@@ -620,6 +646,7 @@ static lv_obj_tree_walk_res_t walk_core(lv_obj_t * obj, lv_obj_tree_walk_cb_t cb
     return LV_OBJ_TREE_WALK_NEXT;
 }
 
+LV_FUNC_SECTION
 static void dump_tree_core(lv_obj_t * obj, int32_t depth)
 {
 #if LV_USE_LOG
@@ -644,6 +671,7 @@ static void dump_tree_core(lv_obj_t * obj, int32_t depth)
     }
 }
 
+LV_FUNC_SECTION
 static lv_obj_t * lv_obj_get_first_not_deleting_child(lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
diff --git a/src/core/lv_refr.c b/src/core/lv_refr.c
index e91fc0059..afc848a24 100644
--- a/src/core/lv_refr.c
+++ b/src/core/lv_refr.c
@@ -72,14 +72,17 @@ static void wait_for_flushing(lv_display_t * disp);
 /**
  * Initialize the screen refresh subsystem
  */
+LV_FUNC_SECTION
 void lv_refr_init(void)
 {
 }
 
+LV_FUNC_SECTION
 void lv_refr_deinit(void)
 {
 }
 
+LV_FUNC_SECTION
 void lv_refr_now(lv_display_t * disp)
 {
     lv_anim_refr_now();
@@ -97,6 +100,7 @@ void lv_refr_now(lv_display_t * disp)
     }
 }
 
+LV_FUNC_SECTION
 void lv_obj_redraw(lv_layer_t * layer, lv_obj_t * obj)
 {
     lv_area_t clip_area_ori = layer->_clip_area;
@@ -254,6 +258,7 @@ void lv_obj_redraw(lv_layer_t * layer, lv_obj_t * obj)
     layer->_clip_area = clip_area_ori;
 }
 
+LV_FUNC_SECTION
 void lv_inv_area(lv_display_t * disp, const lv_area_t * area_p)
 {
     if(!disp) disp = lv_display_get_default();
@@ -331,6 +336,7 @@ void lv_inv_area(lv_display_t * disp, const lv_area_t * area_p)
  * Get the display which is being refreshed
  * @return the display being refreshed
  */
+LV_FUNC_SECTION
 lv_display_t * lv_refr_get_disp_refreshing(void)
 {
     return disp_refr;
@@ -340,11 +346,13 @@ lv_display_t * lv_refr_get_disp_refreshing(void)
  * Get the display which is being refreshed
  * @return the display being refreshed
  */
+LV_FUNC_SECTION
 void lv_refr_set_disp_refreshing(lv_display_t * disp)
 {
     disp_refr = disp;
 }
 
+LV_FUNC_SECTION
 void lv_display_refr_timer(lv_timer_t * tmr)
 {
     LV_PROFILER_BEGIN;
@@ -438,6 +446,7 @@ refr_finish:
 /**
  * Join the areas which has got common parts
  */
+LV_FUNC_SECTION
 static void lv_refr_join_area(void)
 {
     LV_PROFILER_BEGIN;
@@ -477,6 +486,7 @@ static void lv_refr_join_area(void)
 /**
  * Refresh the sync areas
  */
+LV_FUNC_SECTION
 static void refr_sync_areas(void)
 {
     /*Do not sync if not direct or double buffered*/
@@ -555,6 +565,7 @@ static void refr_sync_areas(void)
 /**
  * Refresh the joined areas
  */
+LV_FUNC_SECTION
 static void refr_invalid_areas(void)
 {
     if(disp_refr->inv_p == 0) return;
@@ -595,6 +606,7 @@ static void refr_invalid_areas(void)
  * Reshape the draw buffer if required
  * @param layer  pointer to a layer which will be drawn
  */
+LV_FUNC_SECTION
 static void layer_reshape_draw_buf(lv_layer_t * layer, uint32_t stride)
 {
     lv_draw_buf_t * ret = lv_draw_buf_reshape(
@@ -611,6 +623,7 @@ static void layer_reshape_draw_buf(lv_layer_t * layer, uint32_t stride)
  * Refresh an area if there is Virtual Display Buffer
  * @param area_p  pointer to an area to refresh
  */
+LV_FUNC_SECTION
 static void refr_area(const lv_area_t * area_p)
 {
     LV_PROFILER_BEGIN;
@@ -697,6 +710,7 @@ static void refr_area(const lv_area_t * area_p)
     LV_PROFILER_END;
 }
 
+LV_FUNC_SECTION
 static void refr_area_part(lv_layer_t * layer)
 {
     LV_PROFILER_BEGIN;
@@ -767,6 +781,7 @@ static void refr_area_part(lv_layer_t * layer)
  * @param obj the first object to start the searching (typically a screen)
  * @return
  */
+LV_FUNC_SECTION
 static lv_obj_t * lv_refr_get_top_obj(const lv_area_t * area_p, lv_obj_t * obj)
 {
     lv_obj_t * found_p = NULL;
@@ -807,6 +822,7 @@ static lv_obj_t * lv_refr_get_top_obj(const lv_area_t * area_p, lv_obj_t * obj)
  * @param top_p pointer to an objects. Start the drawing from it.
  * @param mask_p pointer to an area, the objects will be drawn only here
  */
+LV_FUNC_SECTION
 static void refr_obj_and_children(lv_layer_t * layer, lv_obj_t * top_obj)
 {
     /*Normally always will be a top_obj (at least the screen)
@@ -855,6 +871,7 @@ static void refr_obj_and_children(lv_layer_t * layer, lv_obj_t * top_obj)
     LV_PROFILER_END;
 }
 
+LV_FUNC_SECTION
 static lv_result_t layer_get_area(lv_layer_t * layer, lv_obj_t * obj, lv_layer_type_t layer_type,
                                   lv_area_t * layer_area_out, lv_area_t * obj_draw_size_out)
 {
@@ -899,6 +916,7 @@ static lv_result_t layer_get_area(lv_layer_t * layer, lv_obj_t * obj, lv_layer_t
     return LV_RESULT_OK;
 }
 
+LV_FUNC_SECTION
 static bool alpha_test_area_on_obj(lv_obj_t * obj, const lv_area_t * area)
 {
     /*Test for alpha by assuming there is no alpha. If it fails, fall back to rendering with alpha*/
@@ -915,6 +933,7 @@ static bool alpha_test_area_on_obj(lv_obj_t * obj, const lv_area_t * area)
 
 #if LV_DRAW_TRANSFORM_USE_MATRIX
 
+LV_FUNC_SECTION
 static void refr_obj_matrix(lv_layer_t * layer, lv_obj_t * obj)
 {
     lv_matrix_t ori_matrix = layer->matrix;
@@ -987,6 +1006,7 @@ static void refr_obj_matrix(lv_layer_t * layer, lv_obj_t * obj)
     layer->_clip_area = clip_area_ori;
 }
 
+LV_FUNC_SECTION
 static bool refr_check_obj_clip_overflow(lv_layer_t * layer, lv_obj_t * obj)
 {
     if(lv_obj_get_style_transform_rotation(obj, 0) == 0) {
@@ -1012,6 +1032,7 @@ static bool refr_check_obj_clip_overflow(lv_layer_t * layer, lv_obj_t * obj)
 
 #endif /* LV_DRAW_TRANSFORM_USE_MATRIX */
 
+LV_FUNC_SECTION
 static void refr_obj(lv_layer_t * layer, lv_obj_t * obj)
 {
     if(lv_obj_has_flag(obj, LV_OBJ_FLAG_HIDDEN)) return;
@@ -1106,6 +1127,7 @@ static void refr_obj(lv_layer_t * layer, lv_obj_t * obj)
     }
 }
 
+LV_FUNC_SECTION
 static uint32_t get_max_row(lv_display_t * disp, int32_t area_w, int32_t area_h)
 {
     lv_color_format_t cf = disp->color_format;
@@ -1149,6 +1171,7 @@ static uint32_t get_max_row(lv_display_t * disp, int32_t area_w, int32_t area_h)
 /**
  * Flush the content of the draw buffer
  */
+LV_FUNC_SECTION
 static void draw_buf_flush(lv_display_t * disp)
 {
     /*Flush the rendered content to the display*/
@@ -1188,6 +1211,7 @@ static void draw_buf_flush(lv_display_t * disp)
     }
 }
 
+LV_FUNC_SECTION
 static void call_flush_cb(lv_display_t * disp, const lv_area_t * area, uint8_t * px_map)
 {
     LV_PROFILER_BEGIN;
@@ -1214,6 +1238,7 @@ static void call_flush_cb(lv_display_t * disp, const lv_area_t * area, uint8_t *
     LV_PROFILER_END;
 }
 
+LV_FUNC_SECTION
 static void wait_for_flushing(lv_display_t * disp)
 {
     LV_PROFILER_BEGIN;
diff --git a/src/display/lv_display.c b/src/display/lv_display.c
index df4bb9b27..b94cc5092 100644
--- a/src/display/lv_display.c
+++ b/src/display/lv_display.c
@@ -59,6 +59,7 @@ static void disp_event_cb(lv_event_t * e);
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 lv_display_t * lv_display_create(int32_t hor_res, int32_t ver_res)
 {
     lv_display_t * disp = lv_ll_ins_head(disp_ll_p);
@@ -155,6 +156,8 @@ lv_display_t * lv_display_create(int32_t hor_res, int32_t ver_res)
     return disp;
 }
 
+#pragma stackfunction 8192
+__attribute__(( fptrgroup("lv_ll_cleanup") ))
 void lv_display_delete(lv_display_t * disp)
 {
     bool was_default = false;
@@ -211,16 +214,19 @@ void lv_display_delete(lv_display_t * disp)
     if(was_refr) lv_refr_set_disp_refreshing(NULL);
 }
 
+LV_FUNC_SECTION
 void lv_display_set_default(lv_display_t * disp)
 {
     disp_def = disp;
 }
 
+LV_FUNC_SECTION
 lv_display_t * lv_display_get_default(void)
 {
     return disp_def;
 }
 
+LV_FUNC_SECTION
 lv_display_t * lv_display_get_next(lv_display_t * disp)
 {
     if(disp == NULL)
@@ -233,6 +239,7 @@ lv_display_t * lv_display_get_next(lv_display_t * disp)
  * RESOLUTION
  *--------------------*/
 
+LV_FUNC_SECTION
 void lv_display_set_resolution(lv_display_t * disp, int32_t hor_res, int32_t ver_res)
 {
     if(disp == NULL) disp = lv_display_get_default();
@@ -246,6 +253,7 @@ void lv_display_set_resolution(lv_display_t * disp, int32_t hor_res, int32_t ver
     update_resolution(disp);
 }
 
+LV_FUNC_SECTION
 void lv_display_set_physical_resolution(lv_display_t * disp, int32_t hor_res, int32_t ver_res)
 {
     if(disp == NULL) disp = lv_display_get_default();
@@ -258,6 +266,7 @@ void lv_display_set_physical_resolution(lv_display_t * disp, int32_t hor_res, in
 
 }
 
+LV_FUNC_SECTION
 void lv_display_set_offset(lv_display_t * disp, int32_t x, int32_t y)
 {
     if(disp == NULL) disp = lv_display_get_default();
@@ -270,6 +279,7 @@ void lv_display_set_offset(lv_display_t * disp, int32_t x, int32_t y)
 
 }
 
+LV_FUNC_SECTION
 void lv_display_set_dpi(lv_display_t * disp, int32_t dpi)
 {
     if(disp == NULL) disp = lv_display_get_default();
@@ -278,6 +288,7 @@ void lv_display_set_dpi(lv_display_t * disp, int32_t dpi)
     disp->dpi = dpi;
 }
 
+LV_FUNC_SECTION
 int32_t lv_display_get_horizontal_resolution(const lv_display_t * disp)
 {
     if(disp == NULL) disp = lv_display_get_default();
@@ -296,6 +307,7 @@ int32_t lv_display_get_horizontal_resolution(const lv_display_t * disp)
     }
 }
 
+LV_FUNC_SECTION
 int32_t lv_display_get_vertical_resolution(const lv_display_t * disp)
 {
     if(disp == NULL) disp = lv_display_get_default();
@@ -314,6 +326,7 @@ int32_t lv_display_get_vertical_resolution(const lv_display_t * disp)
     }
 }
 
+LV_FUNC_SECTION
 int32_t lv_display_get_physical_horizontal_resolution(const lv_display_t * disp)
 {
     if(disp == NULL) disp = lv_display_get_default();
@@ -332,6 +345,7 @@ int32_t lv_display_get_physical_horizontal_resolution(const lv_display_t * disp)
     }
 }
 
+LV_FUNC_SECTION
 int32_t lv_display_get_physical_vertical_resolution(const lv_display_t * disp)
 {
     if(disp == NULL) disp = lv_display_get_default();
@@ -350,6 +364,7 @@ int32_t lv_display_get_physical_vertical_resolution(const lv_display_t * disp)
     }
 }
 
+LV_FUNC_SECTION
 int32_t lv_display_get_offset_x(const lv_display_t * disp)
 {
     if(disp == NULL) disp = lv_display_get_default();
@@ -371,6 +386,7 @@ int32_t lv_display_get_offset_x(const lv_display_t * disp)
     }
 }
 
+LV_FUNC_SECTION
 int32_t lv_display_get_offset_y(const lv_display_t * disp)
 {
     if(disp == NULL) disp = lv_display_get_default();
@@ -392,6 +408,7 @@ int32_t lv_display_get_offset_y(const lv_display_t * disp)
     }
 }
 
+LV_FUNC_SECTION
 int32_t lv_display_get_dpi(const lv_display_t * disp)
 {
     if(disp == NULL) disp = lv_display_get_default();
@@ -403,6 +420,7 @@ int32_t lv_display_get_dpi(const lv_display_t * disp)
  * BUFFERING
  *--------------------*/
 
+LV_FUNC_SECTION
 void lv_display_set_draw_buffers(lv_display_t * disp, lv_draw_buf_t * buf1, lv_draw_buf_t * buf2)
 {
     if(disp == NULL) disp = lv_display_get_default();
@@ -413,6 +431,7 @@ void lv_display_set_draw_buffers(lv_display_t * disp, lv_draw_buf_t * buf1, lv_d
     disp->buf_act = disp->buf_1;
 }
 
+LV_FUNC_SECTION
 void lv_display_set_buffers(lv_display_t * disp, void * buf1, void * buf2, uint32_t buf_size,
                             lv_display_render_mode_t render_mode)
 {
@@ -444,6 +463,7 @@ void lv_display_set_buffers(lv_display_t * disp, void * buf1, void * buf2, uint3
     lv_display_set_render_mode(disp, render_mode);
 }
 
+LV_FUNC_SECTION
 void lv_display_set_render_mode(lv_display_t * disp, lv_display_render_mode_t render_mode)
 {
     if(disp == NULL) disp = lv_display_get_default();
@@ -451,6 +471,7 @@ void lv_display_set_render_mode(lv_display_t * disp, lv_display_render_mode_t re
     disp->render_mode = render_mode;
 }
 
+LV_FUNC_SECTION
 void lv_display_set_flush_cb(lv_display_t * disp, lv_display_flush_cb_t flush_cb)
 {
     if(disp == NULL) disp = lv_display_get_default();
@@ -459,6 +480,7 @@ void lv_display_set_flush_cb(lv_display_t * disp, lv_display_flush_cb_t flush_cb
     disp->flush_cb = flush_cb;
 }
 
+LV_FUNC_SECTION
 void lv_display_set_flush_wait_cb(lv_display_t * disp, lv_display_flush_wait_cb_t wait_cb)
 {
     if(disp == NULL) disp = lv_display_get_default();
@@ -467,6 +489,7 @@ void lv_display_set_flush_wait_cb(lv_display_t * disp, lv_display_flush_wait_cb_
     disp->flush_wait_cb = wait_cb;
 }
 
+LV_FUNC_SECTION
 void lv_display_set_color_format(lv_display_t * disp, lv_color_format_t color_format)
 {
     if(disp == NULL) disp = lv_display_get_default();
@@ -480,6 +503,7 @@ void lv_display_set_color_format(lv_display_t * disp, lv_color_format_t color_fo
     lv_display_send_event(disp, LV_EVENT_COLOR_FORMAT_CHANGED, NULL);
 }
 
+LV_FUNC_SECTION
 lv_color_format_t lv_display_get_color_format(lv_display_t * disp)
 {
     if(disp == NULL) disp = lv_display_get_default();
@@ -488,6 +512,7 @@ lv_color_format_t lv_display_get_color_format(lv_display_t * disp)
     return disp->color_format;
 }
 
+LV_FUNC_SECTION
 void lv_display_set_antialiasing(lv_display_t * disp, bool en)
 {
     if(disp == NULL) disp = lv_display_get_default();
@@ -496,6 +521,7 @@ void lv_display_set_antialiasing(lv_display_t * disp, bool en)
     disp->antialiasing = en;
 }
 
+LV_FUNC_SECTION
 bool lv_display_get_antialiasing(lv_display_t * disp)
 {
     if(disp == NULL) disp = lv_display_get_default();
@@ -504,16 +530,19 @@ bool lv_display_get_antialiasing(lv_display_t * disp)
     return disp->antialiasing;
 }
 
+LV_FUNC_SECTION
 LV_ATTRIBUTE_FLUSH_READY void lv_display_flush_ready(lv_display_t * disp)
 {
     disp->flushing = 0;
 }
 
+LV_FUNC_SECTION
 LV_ATTRIBUTE_FLUSH_READY bool lv_display_flush_is_last(lv_display_t * disp)
 {
     return disp->flushing_last;
 }
 
+LV_FUNC_SECTION
 bool lv_display_is_double_buffered(lv_display_t * disp)
 {
     return disp->buf_2 != NULL;
@@ -523,6 +552,7 @@ bool lv_display_is_double_buffered(lv_display_t * disp)
   * SCREENS
   *--------------------*/
 
+LV_FUNC_SECTION
 lv_obj_t * lv_display_get_screen_active(lv_display_t * disp)
 {
     if(!disp) disp = lv_display_get_default();
@@ -534,6 +564,7 @@ lv_obj_t * lv_display_get_screen_active(lv_display_t * disp)
     return disp->act_scr;
 }
 
+LV_FUNC_SECTION
 lv_obj_t * lv_display_get_screen_prev(lv_display_t * disp)
 {
     if(!disp) disp = lv_display_get_default();
@@ -545,6 +576,7 @@ lv_obj_t * lv_display_get_screen_prev(lv_display_t * disp)
     return disp->prev_scr;
 }
 
+LV_FUNC_SECTION
 lv_obj_t * lv_display_get_layer_top(lv_display_t * disp)
 {
     if(!disp) disp = lv_display_get_default();
@@ -556,6 +588,7 @@ lv_obj_t * lv_display_get_layer_top(lv_display_t * disp)
     return disp->top_layer;
 }
 
+LV_FUNC_SECTION
 lv_obj_t * lv_display_get_layer_sys(lv_display_t * disp)
 {
     if(!disp) disp = lv_display_get_default();
@@ -567,6 +600,7 @@ lv_obj_t * lv_display_get_layer_sys(lv_display_t * disp)
     return disp->sys_layer;
 }
 
+LV_FUNC_SECTION
 lv_obj_t * lv_display_get_layer_bottom(lv_display_t * disp)
 {
     if(!disp) disp = lv_display_get_default();
@@ -578,11 +612,13 @@ lv_obj_t * lv_display_get_layer_bottom(lv_display_t * disp)
     return disp->bottom_layer;
 }
 
+LV_FUNC_SECTION
 void lv_screen_load(struct lv_obj_t * scr)
 {
     lv_screen_load_anim(scr, LV_SCR_LOAD_ANIM_NONE, 0, 0, false);
 }
 
+LV_FUNC_SECTION
 void lv_screen_load_anim(lv_obj_t * new_scr, lv_screen_load_anim_t anim_type, uint32_t time, uint32_t delay,
                          bool auto_del)
 {
@@ -731,6 +767,7 @@ void lv_screen_load_anim(lv_obj_t * new_scr, lv_screen_load_anim_t anim_type, ui
  * OTHERS
  *--------------------*/
 
+LV_FUNC_SECTION
 void lv_display_add_event_cb(lv_display_t * disp, lv_event_cb_t event_cb, lv_event_code_t filter, void * user_data)
 {
     LV_ASSERT_NULL(disp);
@@ -738,12 +775,14 @@ void lv_display_add_event_cb(lv_display_t * disp, lv_event_cb_t event_cb, lv_eve
     lv_event_add(&disp->event_list, event_cb, filter, user_data);
 }
 
+LV_FUNC_SECTION
 uint32_t lv_display_get_event_count(lv_display_t * disp)
 {
     LV_ASSERT_NULL(disp);
     return lv_event_get_count(&disp->event_list);
 }
 
+LV_FUNC_SECTION
 lv_event_dsc_t * lv_display_get_event_dsc(lv_display_t * disp, uint32_t index)
 {
     LV_ASSERT_NULL(disp);
@@ -751,6 +790,7 @@ lv_event_dsc_t * lv_display_get_event_dsc(lv_display_t * disp, uint32_t index)
 
 }
 
+LV_FUNC_SECTION
 bool lv_display_delete_event(lv_display_t * disp, uint32_t index)
 {
     LV_ASSERT_NULL(disp);
@@ -758,6 +798,7 @@ bool lv_display_delete_event(lv_display_t * disp, uint32_t index)
     return lv_event_remove(&disp->event_list, index);
 }
 
+LV_FUNC_SECTION
 uint32_t lv_display_remove_event_cb_with_user_data(lv_display_t * disp, lv_event_cb_t event_cb, void * user_data)
 {
     LV_ASSERT_NULL(disp);
@@ -777,6 +818,8 @@ uint32_t lv_display_remove_event_cb_with_user_data(lv_display_t * disp, lv_event
     return removed_count;
 }
 
+#pragma stackfunction 1024
+LV_FUNC_SECTION
 lv_result_t lv_display_send_event(lv_display_t * disp, lv_event_code_t code, void * param)
 {
 
@@ -796,6 +839,7 @@ lv_result_t lv_display_send_event(lv_display_t * disp, lv_event_code_t code, voi
     return res;
 }
 
+LV_FUNC_SECTION
 void lv_display_set_rotation(lv_display_t * disp, lv_display_rotation_t rotation)
 {
     if(disp == NULL) disp = lv_display_get_default();
@@ -805,6 +849,7 @@ void lv_display_set_rotation(lv_display_t * disp, lv_display_rotation_t rotation
     update_resolution(disp);
 }
 
+LV_FUNC_SECTION
 lv_display_rotation_t lv_display_get_rotation(lv_display_t * disp)
 {
     if(disp == NULL) disp = lv_display_get_default();
@@ -812,6 +857,7 @@ lv_display_rotation_t lv_display_get_rotation(lv_display_t * disp)
     return disp->rotation;
 }
 
+LV_FUNC_SECTION
 void lv_display_set_theme(lv_display_t * disp, lv_theme_t * th)
 {
     if(!disp) disp = lv_display_get_default();
@@ -830,12 +876,14 @@ void lv_display_set_theme(lv_display_t * disp, lv_theme_t * th)
     }
 }
 
+LV_FUNC_SECTION
 lv_theme_t * lv_display_get_theme(lv_display_t * disp)
 {
     if(disp == NULL) disp = lv_display_get_default();
     return disp->theme;
 }
 
+LV_FUNC_SECTION
 uint32_t lv_display_get_inactive_time(const lv_display_t * disp)
 {
     if(disp) return lv_tick_elaps(disp->last_activity_time);
@@ -852,6 +900,7 @@ uint32_t lv_display_get_inactive_time(const lv_display_t * disp)
     return t;
 }
 
+LV_FUNC_SECTION
 void lv_display_trigger_activity(lv_display_t * disp)
 {
     if(!disp) disp = lv_display_get_default();
@@ -863,6 +912,7 @@ void lv_display_trigger_activity(lv_display_t * disp)
     disp->last_activity_time = lv_tick_get();
 }
 
+LV_FUNC_SECTION
 void lv_display_enable_invalidation(lv_display_t * disp, bool en)
 {
     if(!disp) disp = lv_display_get_default();
@@ -874,6 +924,7 @@ void lv_display_enable_invalidation(lv_display_t * disp, bool en)
     disp->inv_en_cnt += en ? 1 : -1;
 }
 
+LV_FUNC_SECTION
 bool lv_display_is_invalidation_enabled(lv_display_t * disp)
 {
     if(!disp) disp = lv_display_get_default();
@@ -885,6 +936,7 @@ bool lv_display_is_invalidation_enabled(lv_display_t * disp)
     return (disp->inv_en_cnt > 0);
 }
 
+LV_FUNC_SECTION
 lv_timer_t * lv_display_get_refr_timer(lv_display_t * disp)
 {
     if(!disp) disp = lv_display_get_default();
@@ -893,6 +945,7 @@ lv_timer_t * lv_display_get_refr_timer(lv_display_t * disp)
     return disp->refr_timer;
 }
 
+LV_FUNC_SECTION
 void lv_display_delete_refr_timer(lv_display_t * disp)
 {
     if(!disp) disp = lv_display_get_default();
@@ -902,6 +955,7 @@ void lv_display_delete_refr_timer(lv_display_t * disp)
     disp->refr_timer = NULL;
 }
 
+LV_FUNC_SECTION
 void lv_display_set_user_data(lv_display_t * disp, void * user_data)
 {
     if(!disp) disp = lv_display_get_default();
@@ -909,6 +963,7 @@ void lv_display_set_user_data(lv_display_t * disp, void * user_data)
     disp->user_data = user_data;
 }
 
+LV_FUNC_SECTION
 void lv_display_set_driver_data(lv_display_t * disp, void * driver_data)
 {
     if(!disp) disp = lv_display_get_default();
@@ -917,6 +972,7 @@ void lv_display_set_driver_data(lv_display_t * disp, void * driver_data)
     disp->driver_data = driver_data;
 }
 
+LV_FUNC_SECTION
 void * lv_display_get_user_data(lv_display_t * disp)
 {
     if(!disp) disp = lv_display_get_default();
@@ -924,6 +980,7 @@ void * lv_display_get_user_data(lv_display_t * disp)
     return disp->user_data;
 }
 
+LV_FUNC_SECTION
 void * lv_display_get_driver_data(lv_display_t * disp)
 {
     if(!disp) disp = lv_display_get_default();
@@ -932,6 +989,7 @@ void * lv_display_get_driver_data(lv_display_t * disp)
     return disp->driver_data;
 }
 
+LV_FUNC_SECTION
 lv_draw_buf_t * lv_display_get_buf_active(lv_display_t * disp)
 {
     if(!disp) disp = lv_display_get_default();
@@ -939,6 +997,7 @@ lv_draw_buf_t * lv_display_get_buf_active(lv_display_t * disp)
     return disp->buf_act;
 }
 
+LV_FUNC_SECTION
 void lv_display_rotate_area(lv_display_t * disp, lv_area_t * area)
 {
     lv_display_rotation_t rotation = lv_display_get_rotation(disp);
@@ -970,31 +1029,37 @@ void lv_display_rotate_area(lv_display_t * disp, lv_area_t * area)
     }
 }
 
+LV_FUNC_SECTION
 lv_obj_t * lv_screen_active(void)
 {
     return lv_display_get_screen_active(lv_display_get_default());
 }
 
+LV_FUNC_SECTION
 lv_obj_t * lv_layer_top(void)
 {
     return lv_display_get_layer_top(lv_display_get_default());
 }
 
+LV_FUNC_SECTION
 lv_obj_t * lv_layer_sys(void)
 {
     return lv_display_get_layer_sys(lv_display_get_default());
 }
 
+LV_FUNC_SECTION
 lv_obj_t * lv_layer_bottom(void)
 {
     return lv_display_get_layer_bottom(lv_display_get_default());
 }
 
+LV_FUNC_SECTION
 int32_t lv_dpx(int32_t n)
 {
     return LV_DPX(n);
 }
 
+LV_FUNC_SECTION
 int32_t lv_display_dpx(const lv_display_t * disp, int32_t n)
 {
     return LV_DPX_CALC(lv_display_get_dpi(disp), n);
@@ -1004,6 +1069,7 @@ int32_t lv_display_dpx(const lv_display_t * disp, int32_t n)
  *   STATIC FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 static void update_resolution(lv_display_t * disp)
 {
     int32_t hor_res = lv_display_get_horizontal_resolution(disp);
@@ -1040,6 +1106,7 @@ static void update_resolution(lv_display_t * disp)
     lv_display_send_event(disp, LV_EVENT_RESOLUTION_CHANGED, NULL);
 }
 
+LV_FUNC_SECTION
 static lv_obj_tree_walk_res_t invalidate_layout_cb(lv_obj_t * obj, void * user_data)
 {
     LV_UNUSED(user_data);
@@ -1047,6 +1114,7 @@ static lv_obj_tree_walk_res_t invalidate_layout_cb(lv_obj_t * obj, void * user_d
     return LV_OBJ_TREE_WALK_NEXT;
 }
 
+LV_FUNC_SECTION
 static void scr_load_internal(lv_obj_t * scr)
 {
     /*scr must not be NULL, but d->act_scr might be*/
@@ -1070,6 +1138,7 @@ static void scr_load_internal(lv_obj_t * scr)
     lv_obj_invalidate(scr);
 }
 
+__attribute__(( fptrgroup("lv_anim_start_cb") ))
 static void scr_load_anim_start(lv_anim_t * a)
 {
     lv_display_t * d = lv_obj_get_display(a->var);
@@ -1080,21 +1149,25 @@ static void scr_load_anim_start(lv_anim_t * a)
     lv_obj_send_event(d->act_scr, LV_EVENT_SCREEN_LOAD_START, NULL);
 }
 
+__attribute__(( fptrgroup("lv_anim_exec_cb") ))
 static void opa_scale_anim(void * obj, int32_t v)
 {
     lv_obj_set_style_opa(obj, v, 0);
 }
 
+__attribute__(( fptrgroup("lv_anim_exec_cb") ))
 static void set_x_anim(void * obj, int32_t v)
 {
     lv_obj_set_x(obj, v);
 }
 
+__attribute__(( fptrgroup("lv_anim_exec_cb") ))
 static void set_y_anim(void * obj, int32_t v)
 {
     lv_obj_set_y(obj, v);
 }
 
+__attribute__(( fptrgroup("lv_anim_completed_cb") ))
 static void scr_anim_completed(lv_anim_t * a)
 {
     lv_display_t * d = lv_obj_get_display(a->var);
@@ -1110,6 +1183,7 @@ static void scr_anim_completed(lv_anim_t * a)
     lv_obj_invalidate(d->act_scr);
 }
 
+LV_FUNC_SECTION
 static bool is_out_anim(lv_screen_load_anim_t anim_type)
 {
     return anim_type == LV_SCR_LOAD_ANIM_FADE_OUT  ||
@@ -1119,6 +1193,7 @@ static bool is_out_anim(lv_screen_load_anim_t anim_type)
            anim_type == LV_SCR_LOAD_ANIM_OUT_BOTTOM;
 }
 
+__attribute__(( fptrgroup("lv_event_cb") ))
 static void disp_event_cb(lv_event_t * e)
 {
     lv_event_code_t code = lv_event_get_code(e);
diff --git a/src/display/lv_display_private.h b/src/display/lv_display_private.h
index 7dc9f189f..27c7a33c8 100644
--- a/src/display/lv_display_private.h
+++ b/src/display/lv_display_private.h
@@ -71,12 +71,14 @@ struct lv_display_t {
 
     /** MANDATORY: Write the internal buffer (draw_buf) to the display. 'lv_display_flush_ready()' has to be
      * called when finished*/
+    __attribute__(( fptrgroup("lv_display_flush_cb") ))
     lv_display_flush_cb_t flush_cb;
 
     /**
      * Used to wait while flushing is ready.
      * It can do any complex logic to wait, including semaphores, mutexes, polling flags, etc.
      * If not set `flushing` flag is used which can be cleared with `lv_display_flush_ready()` */
+    __attribute__(( fptrgroup("lv_display_flush_wait_cb") ))
     lv_display_flush_wait_cb_t flush_wait_cb;
 
     /** 1: flushing is in progress. (It can't be a bit field because when it's cleared from IRQ
@@ -112,7 +114,9 @@ struct lv_display_t {
      * Layer
      *--------------------*/
     lv_layer_t * layer_head;
+    __attribute__(( fptrgroup("lv_display_layer_init") ))
     void (*layer_init)(lv_display_t * disp, lv_layer_t * layer);
+    __attribute__(( fptrgroup("lv_display_layer_deinit") ))
     void (*layer_deinit)(lv_display_t * disp, lv_layer_t * layer);
 
     /*---------------------
diff --git a/src/draw/lv_draw.c b/src/draw/lv_draw.c
index dbaec7028..07d83ae9c 100644
--- a/src/draw/lv_draw.c
+++ b/src/draw/lv_draw.c
@@ -32,6 +32,7 @@
  **********************/
 static bool is_independent(lv_layer_t * layer, lv_draw_task_t * t_check);
 
+LV_FUNC_SECTION
 static inline uint32_t get_layer_size_kb(uint32_t size_byte)
 {
     return size_byte < 1024 ? 1 : size_byte >> 10;
@@ -52,6 +53,7 @@ static inline uint32_t get_layer_size_kb(uint32_t size_byte)
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 void lv_draw_init(void)
 {
 #if LV_USE_OS
@@ -59,6 +61,7 @@ void lv_draw_init(void)
 #endif
 }
 
+LV_FUNC_SECTION
 void lv_draw_deinit(void)
 {
 #if LV_USE_OS
@@ -76,6 +79,7 @@ void lv_draw_deinit(void)
     _draw_info.unit_head = NULL;
 }
 
+LV_FUNC_SECTION
 void * lv_draw_create_unit(size_t size)
 {
     lv_draw_unit_t * new_unit = lv_malloc_zeroed(size);
@@ -87,6 +91,7 @@ void * lv_draw_create_unit(size_t size)
     return new_unit;
 }
 
+LV_FUNC_SECTION
 lv_draw_task_t * lv_draw_add_task(lv_layer_t * layer, const lv_area_t * coords)
 {
     LV_PROFILER_BEGIN;
@@ -115,6 +120,7 @@ lv_draw_task_t * lv_draw_add_task(lv_layer_t * layer, const lv_area_t * coords)
     return new_task;
 }
 
+LV_FUNC_SECTION
 void lv_draw_finalize_task_creation(lv_layer_t * layer, lv_draw_task_t * t)
 {
     LV_PROFILER_BEGIN;
@@ -159,6 +165,7 @@ void lv_draw_finalize_task_creation(lv_layer_t * layer, lv_draw_task_t * t)
     LV_PROFILER_END;
 }
 
+LV_FUNC_SECTION
 void lv_draw_wait_for_finish(void)
 {
 #if LV_USE_OS
@@ -171,6 +178,7 @@ void lv_draw_wait_for_finish(void)
 #endif
 }
 
+LV_FUNC_SECTION
 void lv_draw_dispatch(void)
 {
     LV_PROFILER_BEGIN;
@@ -192,6 +200,7 @@ void lv_draw_dispatch(void)
     LV_PROFILER_END;
 }
 
+LV_FUNC_SECTION
 bool lv_draw_dispatch_layer(lv_display_t * disp, lv_layer_t * layer)
 {
     LV_PROFILER_BEGIN;
@@ -283,6 +292,7 @@ bool lv_draw_dispatch_layer(lv_display_t * disp, lv_layer_t * layer)
     return task_dispatched;
 }
 
+LV_FUNC_SECTION
 void lv_draw_dispatch_wait_for_request(void)
 {
 #if LV_USE_OS
@@ -293,6 +303,7 @@ void lv_draw_dispatch_wait_for_request(void)
 #endif
 }
 
+LV_FUNC_SECTION
 void lv_draw_dispatch_request(void)
 {
 #if LV_USE_OS
@@ -302,11 +313,13 @@ void lv_draw_dispatch_request(void)
 #endif
 }
 
+LV_FUNC_SECTION
 uint32_t lv_draw_get_unit_count(void)
 {
     return _draw_info.unit_cnt;
 }
 
+LV_FUNC_SECTION
 lv_draw_task_t * lv_draw_get_next_available_task(lv_layer_t * layer, lv_draw_task_t * t_prev, uint8_t draw_unit_id)
 {
     LV_PROFILER_BEGIN;
@@ -374,6 +387,7 @@ lv_draw_task_t * lv_draw_get_next_available_task(lv_layer_t * layer, lv_draw_tas
     return NULL;
 }
 
+LV_FUNC_SECTION
 uint32_t lv_draw_get_dependent_count(lv_draw_task_t * t_check)
 {
     if(t_check == NULL) return 0;
@@ -395,6 +409,7 @@ uint32_t lv_draw_get_dependent_count(lv_draw_task_t * t_check)
     return cnt;
 }
 
+LV_FUNC_SECTION
 lv_layer_t * lv_draw_layer_create(lv_layer_t * parent_layer, lv_color_format_t color_format, const lv_area_t * area)
 {
     lv_display_t * disp = lv_refr_get_disp_refreshing();
@@ -424,6 +439,7 @@ lv_layer_t * lv_draw_layer_create(lv_layer_t * parent_layer, lv_color_format_t c
     return new_layer;
 }
 
+LV_FUNC_SECTION
 void * lv_draw_layer_alloc_buf(lv_layer_t * layer)
 {
     /*If the buffer of the layer is already allocated return it*/
@@ -453,21 +469,25 @@ void * lv_draw_layer_alloc_buf(lv_layer_t * layer)
     return layer->draw_buf->data;
 }
 
+LV_FUNC_SECTION
 void * lv_draw_layer_go_to_xy(lv_layer_t * layer, int32_t x, int32_t y)
 {
     return lv_draw_buf_goto_xy(layer->draw_buf, x, y);
 }
 
+LV_FUNC_SECTION
 lv_draw_task_type_t lv_draw_task_get_type(const lv_draw_task_t * t)
 {
     return t->type;
 }
 
+LV_FUNC_SECTION
 void * lv_draw_task_get_draw_dsc(const lv_draw_task_t * t)
 {
     return t->draw_dsc;
 }
 
+LV_FUNC_SECTION
 void lv_draw_task_get_area(const lv_draw_task_t * t, lv_area_t * area)
 {
     *area = t->area;
@@ -483,6 +503,7 @@ void lv_draw_task_get_area(const lv_draw_task_t * t, lv_area_t * area)
  * @param t_check       check this task if it overlaps with the older ones
  * @return              true: `t_check` is not overlapping with older tasks so it's independent
  */
+LV_FUNC_SECTION
 static bool is_independent(lv_layer_t * layer, lv_draw_task_t * t_check)
 {
     LV_PROFILER_BEGIN;
diff --git a/src/draw/lv_draw_arc.c b/src/draw/lv_draw_arc.c
index f092ea73f..c990e6521 100644
--- a/src/draw/lv_draw_arc.c
+++ b/src/draw/lv_draw_arc.c
@@ -36,6 +36,7 @@
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 void lv_draw_arc_dsc_init(lv_draw_arc_dsc_t * dsc)
 {
     lv_memzero(dsc, sizeof(lv_draw_arc_dsc_t));
@@ -45,11 +46,13 @@ void lv_draw_arc_dsc_init(lv_draw_arc_dsc_t * dsc)
     dsc->base.dsc_size = sizeof(lv_draw_arc_dsc_t);
 }
 
+LV_FUNC_SECTION
 lv_draw_arc_dsc_t * lv_draw_task_get_arc_dsc(lv_draw_task_t * task)
 {
     return task->type == LV_DRAW_TASK_TYPE_ARC ? (lv_draw_arc_dsc_t *)task->draw_dsc : NULL;
 }
 
+LV_FUNC_SECTION
 void lv_draw_arc(lv_layer_t * layer, const lv_draw_arc_dsc_t * dsc)
 {
     if(dsc->opa <= LV_OPA_MIN) return;
@@ -73,6 +76,7 @@ void lv_draw_arc(lv_layer_t * layer, const lv_draw_arc_dsc_t * dsc)
     LV_PROFILER_END;
 }
 
+LV_FUNC_SECTION
 void lv_draw_arc_get_area(int32_t x, int32_t y, uint16_t radius,  lv_value_precise_t start_angle,
                           lv_value_precise_t end_angle,
                           int32_t w, bool rounded, lv_area_t * area)
diff --git a/src/draw/lv_draw_buf.c b/src/draw/lv_draw_buf.c
index a6dc29bb1..0c95bdd23 100644
--- a/src/draw/lv_draw_buf.c
+++ b/src/draw/lv_draw_buf.c
@@ -49,6 +49,7 @@ static void draw_buf_get_full_area(const lv_draw_buf_t * draw_buf, lv_area_t * f
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 void lv_draw_buf_init_handlers(void)
 {
     lv_draw_buf_init_with_default_handlers(&default_handlers);
@@ -56,11 +57,13 @@ void lv_draw_buf_init_handlers(void)
     lv_draw_buf_init_with_default_handlers(&image_cache_draw_buf_handlers);
 }
 
+LV_FUNC_SECTION
 void lv_draw_buf_init_with_default_handlers(lv_draw_buf_handlers_t * handlers)
 {
     lv_draw_buf_handlers_init(handlers, buf_malloc, buf_free, buf_align, NULL, NULL, width_to_stride);
 }
 
+LV_FUNC_SECTION
 void lv_draw_buf_handlers_init(lv_draw_buf_handlers_t * handlers,
                                lv_draw_buf_malloc_cb buf_malloc_cb,
                                lv_draw_buf_free_cb buf_free_cb,
@@ -78,26 +81,31 @@ void lv_draw_buf_handlers_init(lv_draw_buf_handlers_t * handlers,
     handlers->width_to_stride_cb = width_to_stride_cb;
 }
 
+LV_FUNC_SECTION
 lv_draw_buf_handlers_t * lv_draw_buf_get_handlers(void)
 {
     return &default_handlers;
 }
 
+LV_FUNC_SECTION
 lv_draw_buf_handlers_t * lv_draw_buf_get_font_handlers(void)
 {
     return &font_draw_buf_handlers;
 }
 
+LV_FUNC_SECTION
 lv_draw_buf_handlers_t * lv_draw_buf_get_image_handlers(void)
 {
     return &image_cache_draw_buf_handlers;
 }
 
+LV_FUNC_SECTION
 uint32_t lv_draw_buf_width_to_stride(uint32_t w, lv_color_format_t color_format)
 {
     return lv_draw_buf_width_to_stride_ex(&default_handlers, w, color_format);
 }
 
+LV_FUNC_SECTION
 uint32_t lv_draw_buf_width_to_stride_ex(const lv_draw_buf_handlers_t * handlers, uint32_t w,
                                         lv_color_format_t color_format)
 {
@@ -105,17 +113,20 @@ uint32_t lv_draw_buf_width_to_stride_ex(const lv_draw_buf_handlers_t * handlers,
     else return 0;
 }
 
+LV_FUNC_SECTION
 void * lv_draw_buf_align(void * data, lv_color_format_t color_format)
 {
     return lv_draw_buf_align_ex(&default_handlers, data, color_format);
 }
 
+LV_FUNC_SECTION
 void * lv_draw_buf_align_ex(const lv_draw_buf_handlers_t * handlers, void * data, lv_color_format_t color_format)
 {
     if(handlers->align_pointer_cb) return handlers->align_pointer_cb(data, color_format);
     else return NULL;
 }
 
+LV_FUNC_SECTION
 void lv_draw_buf_invalidate_cache(const lv_draw_buf_t * draw_buf, const lv_area_t * area)
 {
     LV_ASSERT_NULL(draw_buf);
@@ -135,6 +146,7 @@ void lv_draw_buf_invalidate_cache(const lv_draw_buf_t * draw_buf, const lv_area_
     handlers->invalidate_cache_cb(draw_buf, area);
 }
 
+LV_FUNC_SECTION
 void lv_draw_buf_flush_cache(const lv_draw_buf_t * draw_buf, const lv_area_t * area)
 {
     LV_ASSERT_NULL(draw_buf);
@@ -154,6 +166,7 @@ void lv_draw_buf_flush_cache(const lv_draw_buf_t * draw_buf, const lv_area_t * a
     handlers->flush_cache_cb(draw_buf, area);
 }
 
+LV_FUNC_SECTION
 void lv_draw_buf_clear(lv_draw_buf_t * draw_buf, const lv_area_t * a)
 {
     LV_ASSERT_NULL(draw_buf);
@@ -188,6 +201,7 @@ void lv_draw_buf_clear(lv_draw_buf_t * draw_buf, const lv_area_t * a)
     }
 }
 
+LV_FUNC_SECTION
 void lv_draw_buf_copy(lv_draw_buf_t * dest, const lv_area_t * dest_area,
                       const lv_draw_buf_t * src, const lv_area_t * src_area)
 {
@@ -243,6 +257,7 @@ void lv_draw_buf_copy(lv_draw_buf_t * dest, const lv_area_t * dest_area,
     }
 }
 
+LV_FUNC_SECTION
 lv_result_t lv_draw_buf_init(lv_draw_buf_t * draw_buf, uint32_t w, uint32_t h, lv_color_format_t cf, uint32_t stride,
                              void * data, uint32_t data_size)
 {
@@ -275,11 +290,13 @@ lv_result_t lv_draw_buf_init(lv_draw_buf_t * draw_buf, uint32_t w, uint32_t h, l
     return LV_RESULT_OK;
 }
 
+LV_FUNC_SECTION
 lv_draw_buf_t * lv_draw_buf_create(uint32_t w, uint32_t h, lv_color_format_t cf, uint32_t stride)
 {
     return lv_draw_buf_create_ex(&default_handlers, w, h, cf, stride);
 }
 
+LV_FUNC_SECTION
 lv_draw_buf_t * lv_draw_buf_create_ex(const lv_draw_buf_handlers_t * handlers, uint32_t w, uint32_t h,
                                       lv_color_format_t cf, uint32_t stride)
 {
@@ -312,11 +329,13 @@ lv_draw_buf_t * lv_draw_buf_create_ex(const lv_draw_buf_handlers_t * handlers, u
     return draw_buf;
 }
 
+LV_FUNC_SECTION
 lv_draw_buf_t * lv_draw_buf_dup(const lv_draw_buf_t * draw_buf)
 {
     return lv_draw_buf_dup_ex(&default_handlers, draw_buf);
 }
 
+LV_FUNC_SECTION
 lv_draw_buf_t * lv_draw_buf_dup_ex(const lv_draw_buf_handlers_t * handlers, const lv_draw_buf_t * draw_buf)
 {
     const lv_image_header_t * header = &draw_buf->header;
@@ -334,6 +353,7 @@ lv_draw_buf_t * lv_draw_buf_dup_ex(const lv_draw_buf_handlers_t * handlers, cons
     return new_buf;
 }
 
+LV_FUNC_SECTION
 lv_draw_buf_t * lv_draw_buf_reshape(lv_draw_buf_t * draw_buf, lv_color_format_t cf, uint32_t w, uint32_t h,
                                     uint32_t stride)
 {
@@ -358,6 +378,7 @@ lv_draw_buf_t * lv_draw_buf_reshape(lv_draw_buf_t * draw_buf, lv_color_format_t
     return draw_buf;
 }
 
+LV_FUNC_SECTION
 void lv_draw_buf_destroy(lv_draw_buf_t * draw_buf)
 {
     LV_ASSERT_NULL(draw_buf);
@@ -375,6 +396,7 @@ void lv_draw_buf_destroy(lv_draw_buf_t * draw_buf)
     }
 }
 
+LV_FUNC_SECTION
 void * lv_draw_buf_goto_xy(const lv_draw_buf_t * buf, uint32_t x, uint32_t y)
 {
     LV_ASSERT_NULL(buf);
@@ -391,6 +413,7 @@ void * lv_draw_buf_goto_xy(const lv_draw_buf_t * buf, uint32_t x, uint32_t y)
     return data + x * lv_color_format_get_bpp(buf->header.cf) / 8;
 }
 
+LV_FUNC_SECTION
 lv_result_t lv_draw_buf_adjust_stride(lv_draw_buf_t * src, uint32_t stride)
 {
     LV_ASSERT_NULL(src);
@@ -454,6 +477,7 @@ lv_result_t lv_draw_buf_adjust_stride(lv_draw_buf_t * src, uint32_t stride)
     return LV_RESULT_OK;
 }
 
+LV_FUNC_SECTION
 lv_result_t lv_draw_buf_premultiply(lv_draw_buf_t * draw_buf)
 {
     LV_ASSERT_NULL(draw_buf);
@@ -532,6 +556,7 @@ lv_result_t lv_draw_buf_premultiply(lv_draw_buf_t * draw_buf)
     return LV_RESULT_OK;
 }
 
+LV_FUNC_SECTION
 void lv_draw_buf_set_palette(lv_draw_buf_t * draw_buf, uint8_t index, lv_color32_t color)
 {
     LV_ASSERT_NULL(draw_buf);
@@ -546,21 +571,25 @@ void lv_draw_buf_set_palette(lv_draw_buf_t * draw_buf, uint8_t index, lv_color32
     palette[index] = color;
 }
 
+LV_FUNC_SECTION
 bool lv_draw_buf_has_flag(const lv_draw_buf_t * draw_buf, lv_image_flags_t flag)
 {
     return draw_buf->header.flags & flag;
 }
 
+LV_FUNC_SECTION
 void lv_draw_buf_set_flag(lv_draw_buf_t * draw_buf, lv_image_flags_t flag)
 {
     draw_buf->header.flags |= flag;
 }
 
+LV_FUNC_SECTION
 void lv_draw_buf_clear_flag(lv_draw_buf_t * draw_buf, lv_image_flags_t flag)
 {
     draw_buf->header.flags &= ~flag;
 }
 
+LV_FUNC_SECTION
 void lv_draw_buf_from_image(lv_draw_buf_t * buf, const lv_image_dsc_t * img)
 {
     lv_draw_buf_init(buf, img->header.w, img->header.h, img->header.cf, img->header.stride,
@@ -568,17 +597,20 @@ void lv_draw_buf_from_image(lv_draw_buf_t * buf, const lv_image_dsc_t * img)
     buf->header.flags = img->header.flags;
 }
 
+LV_FUNC_SECTION
 void lv_draw_buf_to_image(const lv_draw_buf_t * buf, lv_image_dsc_t * img)
 {
     lv_memcpy((void *)img, buf, sizeof(lv_image_dsc_t));
 }
 
+LV_FUNC_SECTION
 void lv_image_buf_set_palette(lv_image_dsc_t * dsc, uint8_t id, lv_color32_t c)
 {
     LV_LOG_WARN("Deprecated API, use lv_draw_buf_set_palette instead.");
     lv_draw_buf_set_palette((lv_draw_buf_t *)dsc, id, c);
 }
 
+LV_FUNC_SECTION
 void lv_image_buf_free(lv_image_dsc_t * dsc)
 {
     LV_LOG_WARN("Deprecated API, use lv_draw_buf_destroy instead.");
@@ -593,7 +625,7 @@ void lv_image_buf_free(lv_image_dsc_t * dsc)
 /**********************
  *   STATIC FUNCTIONS
  **********************/
-
+__attribute__(( fptrgroup("lv_draw_buf_malloc_cb") ))
 static void * buf_malloc(size_t size_bytes, lv_color_format_t color_format)
 {
     LV_UNUSED(color_format);
@@ -603,11 +635,13 @@ static void * buf_malloc(size_t size_bytes, lv_color_format_t color_format)
     return lv_malloc(size_bytes);
 }
 
+__attribute__(( fptrgroup("lv_draw_buf_free_cb") ))
 static void buf_free(void * buf)
 {
     lv_free(buf);
 }
 
+__attribute__(( fptrgroup("lv_draw_align_pointer_cb") ))
 static void * buf_align(void * buf, lv_color_format_t color_format)
 {
     LV_UNUSED(color_format);
@@ -619,6 +653,7 @@ static void * buf_align(void * buf, lv_color_format_t color_format)
     return buf_u8;
 }
 
+__attribute__(( fptrgroup("lv_draw_width_to_stride_cb") ))
 static uint32_t width_to_stride(uint32_t w, lv_color_format_t color_format)
 {
     uint32_t width_byte;
@@ -628,6 +663,7 @@ static uint32_t width_to_stride(uint32_t w, lv_color_format_t color_format)
     return LV_ROUND_UP(width_byte, LV_DRAW_BUF_STRIDE_ALIGN);
 }
 
+LV_FUNC_SECTION
 static void * draw_buf_malloc(const lv_draw_buf_handlers_t * handlers, size_t size_bytes,
                               lv_color_format_t color_format)
 {
@@ -635,6 +671,7 @@ static void * draw_buf_malloc(const lv_draw_buf_handlers_t * handlers, size_t si
     else return NULL;
 }
 
+LV_FUNC_SECTION
 static void draw_buf_free(const lv_draw_buf_handlers_t * handlers, void * buf)
 {
     if(handlers->buf_free_cb)
@@ -644,6 +681,7 @@ static void draw_buf_free(const lv_draw_buf_handlers_t * handlers, void * buf)
 /**
  * For given width, height, color format, and stride, calculate the size needed for a new draw buffer.
  */
+LV_FUNC_SECTION
 static uint32_t _calculate_draw_buf_size(uint32_t w, uint32_t h, lv_color_format_t cf, uint32_t stride)
 {
     uint32_t size;
@@ -662,6 +700,7 @@ static uint32_t _calculate_draw_buf_size(uint32_t w, uint32_t h, lv_color_format
     return size;
 }
 
+LV_FUNC_SECTION
 static void draw_buf_get_full_area(const lv_draw_buf_t * draw_buf, lv_area_t * full_area)
 {
     const lv_image_header_t * header = &draw_buf->header;
diff --git a/src/draw/lv_draw_buf_private.h b/src/draw/lv_draw_buf_private.h
index 051f9ba7c..0a5d88c8d 100644
--- a/src/draw/lv_draw_buf_private.h
+++ b/src/draw/lv_draw_buf_private.h
@@ -25,11 +25,17 @@ extern "C" {
  **********************/
 
 struct lv_draw_buf_handlers_t {
+    __attribute__(( fptrgroup("lv_draw_buf_malloc_cb") ))
     lv_draw_buf_malloc_cb buf_malloc_cb;
+    __attribute__(( fptrgroup("lv_draw_buf_free_cb") ))
     lv_draw_buf_free_cb buf_free_cb;
+    __attribute__(( fptrgroup("lv_draw_align_pointer_cb") ))
     lv_draw_buf_align_cb align_pointer_cb;
+    __attribute__(( fptrgroup("lv_draw_invalidate_cache_cb") ))
     lv_draw_buf_cache_operation_cb invalidate_cache_cb;
+    __attribute__(( fptrgroup("lv_draw_flush_cache_cb") ))
     lv_draw_buf_cache_operation_cb flush_cache_cb;
+    __attribute__(( fptrgroup("lv_draw_width_to_stride_cb") ))
     lv_draw_buf_width_to_stride_cb width_to_stride_cb;
 };
 
diff --git a/src/draw/lv_draw_image.c b/src/draw/lv_draw_image.c
index 45804573e..aab8afd1c 100644
--- a/src/draw/lv_draw_image.c
+++ b/src/draw/lv_draw_image.c
@@ -46,6 +46,7 @@ static void img_decode_and_draw(lv_draw_unit_t * draw_unit, const lv_draw_image_
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 void lv_draw_image_dsc_init(lv_draw_image_dsc_t * dsc)
 {
     lv_memzero(dsc, sizeof(lv_draw_image_dsc_t));
@@ -58,11 +59,13 @@ void lv_draw_image_dsc_init(lv_draw_image_dsc_t * dsc)
     dsc->base.dsc_size = sizeof(lv_draw_image_dsc_t);
 }
 
+LV_FUNC_SECTION
 lv_draw_image_dsc_t * lv_draw_task_get_image_dsc(lv_draw_task_t * task)
 {
     return task->type == LV_DRAW_TASK_TYPE_IMAGE ? (lv_draw_image_dsc_t *)task->draw_dsc : NULL;
 }
 
+LV_FUNC_SECTION
 void lv_draw_layer(lv_layer_t * layer, const lv_draw_image_dsc_t * dsc, const lv_area_t * coords)
 {
     if(dsc->scale_x <= 0 || dsc->scale_y <= 0) {
@@ -87,6 +90,7 @@ void lv_draw_layer(lv_layer_t * layer, const lv_draw_image_dsc_t * dsc, const lv
     lv_draw_finalize_task_creation(layer, t);
 }
 
+LV_FUNC_SECTION
 void lv_draw_image(lv_layer_t * layer, const lv_draw_image_dsc_t * dsc, const lv_area_t * coords)
 {
     if(dsc->src == NULL) {
@@ -123,6 +127,7 @@ void lv_draw_image(lv_layer_t * layer, const lv_draw_image_dsc_t * dsc, const lv
     LV_PROFILER_END;
 }
 
+LV_FUNC_SECTION
 lv_image_src_t lv_image_src_get_type(const void * src)
 {
     if(src == NULL) return LV_IMAGE_SRC_UNKNOWN;
@@ -140,6 +145,7 @@ lv_image_src_t lv_image_src_get_type(const void * src)
     }
 }
 
+LV_FUNC_SECTION
 void lv_draw_image_normal_helper(lv_draw_unit_t * draw_unit, const lv_draw_image_dsc_t * draw_dsc,
                                  const lv_area_t * coords, lv_draw_image_core_cb draw_core_cb)
 {
@@ -180,6 +186,7 @@ void lv_draw_image_normal_helper(lv_draw_unit_t * draw_unit, const lv_draw_image
     lv_image_decoder_close(&decoder_dsc);
 }
 
+LV_FUNC_SECTION
 void lv_draw_image_tiled_helper(lv_draw_unit_t * draw_unit, const lv_draw_image_dsc_t * draw_dsc,
                                 const lv_area_t * coords, lv_draw_image_core_cb draw_core_cb)
 {
@@ -239,6 +246,7 @@ void lv_draw_image_tiled_helper(lv_draw_unit_t * draw_unit, const lv_draw_image_
     lv_image_decoder_close(&decoder_dsc);
 }
 
+LV_FUNC_SECTION
 void lv_image_buf_get_transformed_area(lv_area_t * res, int32_t w, int32_t h, int32_t angle,
                                        uint16_t scale_x, uint16_t scale_y, const lv_point_t * pivot)
 {
@@ -270,6 +278,7 @@ void lv_image_buf_get_transformed_area(lv_area_t * res, int32_t w, int32_t h, in
  *   STATIC FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 static void img_decode_and_draw(lv_draw_unit_t * draw_unit, const lv_draw_image_dsc_t * draw_dsc,
                                 lv_image_decoder_dsc_t * decoder_dsc, lv_area_t * relative_decoded_area,
                                 const lv_area_t * img_area, const lv_area_t * clipped_img_area,
diff --git a/src/draw/lv_draw_label.c b/src/draw/lv_draw_label.c
index e733c40d2..33a946c84 100644
--- a/src/draw/lv_draw_label.c
+++ b/src/draw/lv_draw_label.c
@@ -55,6 +55,7 @@ static void draw_letter(lv_draw_unit_t * draw_unit, lv_draw_glyph_dsc_t * dsc,
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 void lv_draw_label_dsc_init(lv_draw_label_dsc_t * dsc)
 {
     lv_memzero(dsc, sizeof(lv_draw_label_dsc_t));
@@ -69,11 +70,13 @@ void lv_draw_label_dsc_init(lv_draw_label_dsc_t * dsc)
     dsc->base.dsc_size = sizeof(lv_draw_label_dsc_t);
 }
 
+LV_FUNC_SECTION
 lv_draw_label_dsc_t * lv_draw_task_get_label_dsc(lv_draw_task_t * task)
 {
     return task->type == LV_DRAW_TASK_TYPE_LABEL ? (lv_draw_label_dsc_t *)task->draw_dsc : NULL;
 }
 
+LV_FUNC_SECTION
 void lv_draw_glyph_dsc_init(lv_draw_glyph_dsc_t * dsc)
 {
     lv_memzero(dsc, sizeof(lv_draw_glyph_dsc_t));
@@ -146,6 +149,7 @@ void LV_ATTRIBUTE_FAST_MEM lv_draw_character(lv_layer_t * layer, lv_draw_label_d
     LV_PROFILER_END;
 }
 
+LV_FUNC_SECTION
 void lv_draw_label_iterate_characters(lv_draw_unit_t * draw_unit, const lv_draw_label_dsc_t * dsc,
                                       const lv_area_t * coords,
                                       lv_draw_glyph_cb_t cb)
@@ -378,6 +382,7 @@ void lv_draw_label_iterate_characters(lv_draw_unit_t * draw_unit, const lv_draw_
  *   STATIC FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 static void draw_letter(lv_draw_unit_t * draw_unit, lv_draw_glyph_dsc_t * dsc,  const lv_point_t * pos,
                         const lv_font_t * font, uint32_t letter, lv_draw_glyph_cb_t cb)
 {
diff --git a/src/draw/lv_draw_line.c b/src/draw/lv_draw_line.c
index 00fc203b1..045ce65b6 100644
--- a/src/draw/lv_draw_line.c
+++ b/src/draw/lv_draw_line.c
@@ -45,6 +45,7 @@ void LV_ATTRIBUTE_FAST_MEM lv_draw_line_dsc_init(lv_draw_line_dsc_t * dsc)
     dsc->base.dsc_size = sizeof(lv_draw_line_dsc_t);
 }
 
+LV_FUNC_SECTION
 lv_draw_line_dsc_t * lv_draw_task_get_line_dsc(lv_draw_task_t * task)
 {
     return task->type == LV_DRAW_TASK_TYPE_LINE ? (lv_draw_line_dsc_t *)task->draw_dsc : NULL;
diff --git a/src/draw/lv_draw_mask.c b/src/draw/lv_draw_mask.c
index 3ee6b62bc..8aed11867 100644
--- a/src/draw/lv_draw_mask.c
+++ b/src/draw/lv_draw_mask.c
@@ -42,6 +42,7 @@ void LV_ATTRIBUTE_FAST_MEM lv_draw_mask_rect_dsc_init(lv_draw_mask_rect_dsc_t *
     lv_memzero(dsc, sizeof(lv_draw_mask_rect_dsc_t));
 }
 
+LV_FUNC_SECTION
 lv_draw_mask_rect_dsc_t * lv_draw_task_get_mask_rect_dsc(lv_draw_task_t * task)
 {
     return task->type == LV_DRAW_TASK_TYPE_MASK_RECTANGLE ? (lv_draw_mask_rect_dsc_t *)task->draw_dsc : NULL;
diff --git a/src/draw/lv_draw_rect.c b/src/draw/lv_draw_rect.c
index ec2acc57a..278ca6e0f 100644
--- a/src/draw/lv_draw_rect.c
+++ b/src/draw/lv_draw_rect.c
@@ -56,6 +56,7 @@ void LV_ATTRIBUTE_FAST_MEM lv_draw_rect_dsc_init(lv_draw_rect_dsc_t * dsc)
     dsc->border_side = LV_BORDER_SIDE_FULL;
 }
 
+LV_FUNC_SECTION
 void lv_draw_fill_dsc_init(lv_draw_fill_dsc_t * dsc)
 {
     lv_memzero(dsc, sizeof(*dsc));
@@ -63,11 +64,13 @@ void lv_draw_fill_dsc_init(lv_draw_fill_dsc_t * dsc)
     dsc->base.dsc_size = sizeof(lv_draw_fill_dsc_t);
 }
 
+LV_FUNC_SECTION
 lv_draw_fill_dsc_t * lv_draw_task_get_fill_dsc(lv_draw_task_t * task)
 {
     return task->type == LV_DRAW_TASK_TYPE_FILL ? (lv_draw_fill_dsc_t *)task->draw_dsc : NULL;
 }
 
+LV_FUNC_SECTION
 void lv_draw_border_dsc_init(lv_draw_border_dsc_t * dsc)
 {
     lv_memzero(dsc, sizeof(*dsc));
@@ -76,11 +79,13 @@ void lv_draw_border_dsc_init(lv_draw_border_dsc_t * dsc)
     dsc->base.dsc_size = sizeof(lv_draw_border_dsc_t);
 }
 
+LV_FUNC_SECTION
 lv_draw_border_dsc_t * lv_draw_task_get_border_dsc(lv_draw_task_t * task)
 {
     return task->type == LV_DRAW_TASK_TYPE_BORDER ? (lv_draw_border_dsc_t *)task->draw_dsc : NULL;
 }
 
+LV_FUNC_SECTION
 void lv_draw_box_shadow_dsc_init(lv_draw_box_shadow_dsc_t * dsc)
 {
     lv_memzero(dsc, sizeof(*dsc));
@@ -88,11 +93,13 @@ void lv_draw_box_shadow_dsc_init(lv_draw_box_shadow_dsc_t * dsc)
     dsc->base.dsc_size = sizeof(lv_draw_box_shadow_dsc_t);
 }
 
+LV_FUNC_SECTION
 lv_draw_box_shadow_dsc_t * lv_draw_task_get_box_shadow_dsc(lv_draw_task_t * task)
 {
     return task->type == LV_DRAW_TASK_TYPE_BOX_SHADOW ? (lv_draw_box_shadow_dsc_t *)task->draw_dsc : NULL;
 }
 
+LV_FUNC_SECTION
 void lv_draw_rect(lv_layer_t * layer, const lv_draw_rect_dsc_t * dsc, const lv_area_t * coords)
 {
 
diff --git a/src/draw/lv_draw_triangle.c b/src/draw/lv_draw_triangle.c
index 6bf1c7c21..6bf239f31 100644
--- a/src/draw/lv_draw_triangle.c
+++ b/src/draw/lv_draw_triangle.c
@@ -38,6 +38,7 @@
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 void lv_draw_triangle_dsc_init(lv_draw_triangle_dsc_t * dsc)
 {
     LV_PROFILER_BEGIN;
@@ -52,11 +53,13 @@ void lv_draw_triangle_dsc_init(lv_draw_triangle_dsc_t * dsc)
     LV_PROFILER_END;
 }
 
+LV_FUNC_SECTION
 lv_draw_triangle_dsc_t * lv_draw_task_get_triangle_dsc(lv_draw_task_t * task)
 {
     return task->type == LV_DRAW_TASK_TYPE_TRIANGLE ? (lv_draw_triangle_dsc_t *)task->draw_dsc : NULL;
 }
 
+LV_FUNC_SECTION
 void lv_draw_triangle(lv_layer_t * layer, const lv_draw_triangle_dsc_t * dsc)
 {
     if(dsc->bg_opa <= LV_OPA_MIN) return;
diff --git a/src/draw/lv_draw_vector.c b/src/draw/lv_draw_vector.c
index 28a08f289..5ee2b3e06 100644
--- a/src/draw/lv_draw_vector.c
+++ b/src/draw/lv_draw_vector.c
@@ -58,6 +58,7 @@ typedef struct {
  *  STATIC PROTOTYPES
  **********************/
 
+LV_FUNC_SECTION
 static void _copy_draw_dsc(lv_vector_draw_dsc_t * dst, const lv_vector_draw_dsc_t * src)
 {
     lv_memcpy(&(dst->fill_dsc), &(src->fill_dsc), sizeof(lv_vector_fill_dsc_t));
@@ -86,6 +87,7 @@ static void _copy_draw_dsc(lv_vector_draw_dsc_t * dst, const lv_vector_draw_dsc_
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 void lv_matrix_transform_point(const lv_matrix_t * matrix, lv_fpoint_t * point)
 {
     float x = point->x;
@@ -95,6 +97,7 @@ void lv_matrix_transform_point(const lv_matrix_t * matrix, lv_fpoint_t * point)
     point->y = x * matrix->m[0][1] + y * matrix->m[1][1] + matrix->m[1][2];
 }
 
+LV_FUNC_SECTION
 void lv_matrix_transform_path(const lv_matrix_t * matrix, lv_vector_path_t * path)
 {
     lv_fpoint_t * pt = lv_array_front(&path->points);
@@ -105,6 +108,7 @@ void lv_matrix_transform_path(const lv_matrix_t * matrix, lv_vector_path_t * pat
 }
 
 /* path functions */
+LV_FUNC_SECTION
 lv_vector_path_t * lv_vector_path_create(lv_vector_path_quality_t quality)
 {
     lv_vector_path_t * path = lv_malloc(sizeof(lv_vector_path_t));
@@ -116,6 +120,7 @@ lv_vector_path_t * lv_vector_path_create(lv_vector_path_quality_t quality)
     return path;
 }
 
+LV_FUNC_SECTION
 void lv_vector_path_copy(lv_vector_path_t * target_path, const lv_vector_path_t * path)
 {
     target_path->quality = path->quality;
@@ -123,12 +128,14 @@ void lv_vector_path_copy(lv_vector_path_t * target_path, const lv_vector_path_t
     lv_array_copy(&target_path->points, &path->points);
 }
 
+LV_FUNC_SECTION
 void lv_vector_path_clear(lv_vector_path_t * path)
 {
     lv_array_clear(&path->ops);
     lv_array_clear(&path->points);
 }
 
+LV_FUNC_SECTION
 void lv_vector_path_delete(lv_vector_path_t * path)
 {
     lv_array_deinit(&path->ops);
@@ -136,6 +143,7 @@ void lv_vector_path_delete(lv_vector_path_t * path)
     lv_free(path);
 }
 
+LV_FUNC_SECTION
 void lv_vector_path_move_to(lv_vector_path_t * path, const lv_fpoint_t * p)
 {
     CHECK_AND_RESIZE_PATH_CONTAINER(path, 1);
@@ -145,6 +153,7 @@ void lv_vector_path_move_to(lv_vector_path_t * path, const lv_fpoint_t * p)
     lv_array_push_back(&path->points, p);
 }
 
+LV_FUNC_SECTION
 void lv_vector_path_line_to(lv_vector_path_t * path, const lv_fpoint_t * p)
 {
     if(lv_array_is_empty(&path->ops)) {
@@ -159,6 +168,7 @@ void lv_vector_path_line_to(lv_vector_path_t * path, const lv_fpoint_t * p)
     lv_array_push_back(&path->points, p);
 }
 
+LV_FUNC_SECTION
 void lv_vector_path_quad_to(lv_vector_path_t * path, const lv_fpoint_t * p1, const lv_fpoint_t * p2)
 {
     if(lv_array_is_empty(&path->ops)) {
@@ -174,6 +184,7 @@ void lv_vector_path_quad_to(lv_vector_path_t * path, const lv_fpoint_t * p1, con
     lv_array_push_back(&path->points, p2);
 }
 
+LV_FUNC_SECTION
 void lv_vector_path_cubic_to(lv_vector_path_t * path, const lv_fpoint_t * p1, const lv_fpoint_t * p2,
                              const lv_fpoint_t * p3)
 {
@@ -191,6 +202,7 @@ void lv_vector_path_cubic_to(lv_vector_path_t * path, const lv_fpoint_t * p1, co
     lv_array_push_back(&path->points, p3);
 }
 
+LV_FUNC_SECTION
 void lv_vector_path_close(lv_vector_path_t * path)
 {
     if(lv_array_is_empty(&path->ops)) {
@@ -204,6 +216,7 @@ void lv_vector_path_close(lv_vector_path_t * path)
     lv_array_push_back(&path->ops, &op);
 }
 
+LV_FUNC_SECTION
 void lv_vector_path_get_bounding(const lv_vector_path_t * path, lv_area_t * area)
 {
     LV_ASSERT_NULL(path);
@@ -234,6 +247,7 @@ void lv_vector_path_get_bounding(const lv_vector_path_t * path, lv_area_t * area
     area->y2 = (int32_t)y2;
 }
 
+LV_FUNC_SECTION
 void lv_vector_path_append_rect(lv_vector_path_t * path, const lv_area_t * rect, float rx, float ry)
 {
     float x = rect->x1;
@@ -322,6 +336,7 @@ void lv_vector_path_append_rect(lv_vector_path_t * path, const lv_area_t * rect,
     }
 }
 
+LV_FUNC_SECTION
 void lv_vector_path_append_circle(lv_vector_path_t * path, const lv_fpoint_t * c, float rx, float ry)
 {
     float krx = rx * 0.552284f;
@@ -378,6 +393,7 @@ void lv_vector_path_append_circle(lv_vector_path_t * path, const lv_fpoint_t * c
  * @param sweep             the sweep angle for arc, could be negative
  * @param pie               true: draw a pie, false: draw a arc
  */
+LV_FUNC_SECTION
 void lv_vector_path_append_arc(lv_vector_path_t * path, const lv_fpoint_t * c, float radius, float start_angle,
                                float sweep, bool pie)
 {
@@ -450,6 +466,7 @@ void lv_vector_path_append_arc(lv_vector_path_t * path, const lv_fpoint_t * c, f
     }
 }
 
+LV_FUNC_SECTION
 void lv_vector_path_append_path(lv_vector_path_t * path, const lv_vector_path_t * subpath)
 {
     uint32_t ops_size = lv_array_size(&path->ops);
@@ -466,6 +483,7 @@ void lv_vector_path_append_path(lv_vector_path_t * path, const lv_vector_path_t
 
 /* draw dsc functions */
 
+LV_FUNC_SECTION
 lv_vector_dsc_t * lv_vector_dsc_create(lv_layer_t * layer)
 {
     lv_vector_dsc_t * dsc = lv_malloc(sizeof(lv_vector_dsc_t));
@@ -498,6 +516,7 @@ lv_vector_dsc_t * lv_vector_dsc_create(lv_layer_t * layer)
     return dsc;
 }
 
+LV_FUNC_SECTION
 void lv_vector_dsc_delete(lv_vector_dsc_t * dsc)
 {
     if(dsc->tasks.task_list) {
@@ -509,44 +528,52 @@ void lv_vector_dsc_delete(lv_vector_dsc_t * dsc)
     lv_free(dsc);
 }
 
+LV_FUNC_SECTION
 void lv_vector_dsc_set_blend_mode(lv_vector_dsc_t * dsc, lv_vector_blend_t blend)
 {
     dsc->current_dsc.blend_mode = blend;
 }
 
+LV_FUNC_SECTION
 void lv_vector_dsc_set_transform(lv_vector_dsc_t * dsc, const lv_matrix_t * matrix)
 {
     lv_memcpy(&(dsc->current_dsc.matrix), matrix, sizeof(lv_matrix_t));
 }
 
+LV_FUNC_SECTION
 void lv_vector_dsc_set_fill_color(lv_vector_dsc_t * dsc, lv_color_t color)
 {
     dsc->current_dsc.fill_dsc.style = LV_VECTOR_DRAW_STYLE_SOLID;
     dsc->current_dsc.fill_dsc.color = lv_color_to_32(color, 0xFF);
 }
 
+LV_FUNC_SECTION
 void lv_vector_dsc_set_fill_color32(lv_vector_dsc_t * dsc, lv_color32_t color)
 {
     dsc->current_dsc.fill_dsc.style = LV_VECTOR_DRAW_STYLE_SOLID;
     dsc->current_dsc.fill_dsc.color = color;
 }
 
+LV_FUNC_SECTION
 void lv_vector_dsc_set_fill_opa(lv_vector_dsc_t * dsc, lv_opa_t opa)
 {
     dsc->current_dsc.fill_dsc.opa = opa;
 }
 
+LV_FUNC_SECTION
 void lv_vector_dsc_set_fill_rule(lv_vector_dsc_t * dsc, lv_vector_fill_t rule)
 {
     dsc->current_dsc.fill_dsc.fill_rule = rule;
 }
 
+LV_FUNC_SECTION
 void lv_vector_dsc_set_fill_image(lv_vector_dsc_t * dsc, const lv_draw_image_dsc_t * img_dsc)
 {
     dsc->current_dsc.fill_dsc.style = LV_VECTOR_DRAW_STYLE_PATTERN;
     lv_memcpy(&(dsc->current_dsc.fill_dsc.img_dsc), img_dsc, sizeof(lv_draw_image_dsc_t));
 }
 
+LV_FUNC_SECTION
 void lv_vector_dsc_set_fill_linear_gradient(lv_vector_dsc_t * dsc, float x1, float y1, float x2, float y2)
 {
     dsc->current_dsc.fill_dsc.style = LV_VECTOR_DRAW_STYLE_GRADIENT;
@@ -557,6 +584,7 @@ void lv_vector_dsc_set_fill_linear_gradient(lv_vector_dsc_t * dsc, float x1, flo
     dsc->current_dsc.fill_dsc.gradient.y2 = y2;
 }
 
+LV_FUNC_SECTION
 void lv_vector_dsc_set_fill_radial_gradient(lv_vector_dsc_t * dsc, float cx, float cy, float radius)
 {
     dsc->current_dsc.fill_dsc.style = LV_VECTOR_DRAW_STYLE_GRADIENT;
@@ -566,11 +594,13 @@ void lv_vector_dsc_set_fill_radial_gradient(lv_vector_dsc_t * dsc, float cx, flo
     dsc->current_dsc.fill_dsc.gradient.cr = radius;
 }
 
+LV_FUNC_SECTION
 void lv_vector_dsc_set_fill_gradient_spread(lv_vector_dsc_t * dsc, lv_vector_gradient_spread_t spread)
 {
     dsc->current_dsc.fill_dsc.gradient.spread = spread;
 }
 
+LV_FUNC_SECTION
 void lv_vector_dsc_set_fill_gradient_color_stops(lv_vector_dsc_t * dsc, const lv_gradient_stop_t * stops,
                                                  uint16_t count)
 {
@@ -583,38 +613,45 @@ void lv_vector_dsc_set_fill_gradient_color_stops(lv_vector_dsc_t * dsc, const lv
     dsc->current_dsc.fill_dsc.gradient.stops_count = count;
 }
 
+LV_FUNC_SECTION
 void lv_vector_dsc_set_fill_transform(lv_vector_dsc_t * dsc, const lv_matrix_t * matrix)
 {
     lv_memcpy(&(dsc->current_dsc.fill_dsc.matrix), matrix, sizeof(lv_matrix_t));
 }
 
+LV_FUNC_SECTION
 void lv_vector_dsc_set_stroke_transform(lv_vector_dsc_t * dsc, const lv_matrix_t * matrix)
 {
     lv_memcpy(&(dsc->current_dsc.stroke_dsc.matrix), matrix, sizeof(lv_matrix_t));
 }
 
+LV_FUNC_SECTION
 void lv_vector_dsc_set_stroke_color32(lv_vector_dsc_t * dsc, lv_color32_t color)
 {
     dsc->current_dsc.stroke_dsc.style = LV_VECTOR_DRAW_STYLE_SOLID;
     dsc->current_dsc.stroke_dsc.color = color;
 }
 
+LV_FUNC_SECTION
 void lv_vector_dsc_set_stroke_color(lv_vector_dsc_t * dsc, lv_color_t color)
 {
     dsc->current_dsc.stroke_dsc.style = LV_VECTOR_DRAW_STYLE_SOLID;
     dsc->current_dsc.stroke_dsc.color = lv_color_to_32(color, 0xFF);
 }
 
+LV_FUNC_SECTION
 void lv_vector_dsc_set_stroke_opa(lv_vector_dsc_t * dsc, lv_opa_t opa)
 {
     dsc->current_dsc.stroke_dsc.opa = opa;
 }
 
+LV_FUNC_SECTION
 void lv_vector_dsc_set_stroke_width(lv_vector_dsc_t * dsc, float width)
 {
     dsc->current_dsc.stroke_dsc.width = width;
 }
 
+LV_FUNC_SECTION
 void lv_vector_dsc_set_stroke_dash(lv_vector_dsc_t * dsc, float * dash_pattern, uint16_t dash_count)
 {
     lv_array_t * dash_array = &(dsc->current_dsc.stroke_dsc.dash_pattern);
@@ -635,21 +672,25 @@ void lv_vector_dsc_set_stroke_dash(lv_vector_dsc_t * dsc, float * dash_pattern,
     }
 }
 
+LV_FUNC_SECTION
 void lv_vector_dsc_set_stroke_cap(lv_vector_dsc_t * dsc, lv_vector_stroke_cap_t cap)
 {
     dsc->current_dsc.stroke_dsc.cap = cap;
 }
 
+LV_FUNC_SECTION
 void lv_vector_dsc_set_stroke_join(lv_vector_dsc_t * dsc, lv_vector_stroke_join_t join)
 {
     dsc->current_dsc.stroke_dsc.join = join;
 }
 
+LV_FUNC_SECTION
 void lv_vector_dsc_set_stroke_miter_limit(lv_vector_dsc_t * dsc, uint16_t miter_limit)
 {
     dsc->current_dsc.stroke_dsc.miter_limit = miter_limit;
 }
 
+LV_FUNC_SECTION
 void lv_vector_dsc_set_stroke_linear_gradient(lv_vector_dsc_t * dsc, float x1, float y1, float x2, float y2)
 {
     dsc->current_dsc.stroke_dsc.style = LV_VECTOR_DRAW_STYLE_GRADIENT;
@@ -660,6 +701,7 @@ void lv_vector_dsc_set_stroke_linear_gradient(lv_vector_dsc_t * dsc, float x1, f
     dsc->current_dsc.stroke_dsc.gradient.y2 = y2;
 }
 
+LV_FUNC_SECTION
 void lv_vector_dsc_set_stroke_radial_gradient(lv_vector_dsc_t * dsc, float cx, float cy, float radius)
 {
     dsc->current_dsc.stroke_dsc.style = LV_VECTOR_DRAW_STYLE_GRADIENT;
@@ -669,11 +711,13 @@ void lv_vector_dsc_set_stroke_radial_gradient(lv_vector_dsc_t * dsc, float cx, f
     dsc->current_dsc.stroke_dsc.gradient.cr = radius;
 }
 
+LV_FUNC_SECTION
 void lv_vector_dsc_set_stroke_gradient_spread(lv_vector_dsc_t * dsc, lv_vector_gradient_spread_t spread)
 {
     dsc->current_dsc.stroke_dsc.gradient.spread = spread;
 }
 
+LV_FUNC_SECTION
 void lv_vector_dsc_set_stroke_gradient_color_stops(lv_vector_dsc_t * dsc, const lv_gradient_stop_t * stops,
                                                    uint16_t count)
 {
@@ -687,6 +731,7 @@ void lv_vector_dsc_set_stroke_gradient_color_stops(lv_vector_dsc_t * dsc, const
 }
 
 /* draw functions */
+LV_FUNC_SECTION
 void lv_vector_dsc_add_path(lv_vector_dsc_t * dsc, const lv_vector_path_t * path)
 {
     lv_area_t rect;
@@ -715,6 +760,7 @@ void lv_vector_dsc_add_path(lv_vector_dsc_t * dsc, const lv_vector_path_t * path
     new_task->dsc.scissor_area = rect;
 }
 
+LV_FUNC_SECTION
 void lv_vector_clear_area(lv_vector_dsc_t * dsc, const lv_area_t * rect)
 {
     lv_area_t r;
@@ -736,6 +782,7 @@ void lv_vector_clear_area(lv_vector_dsc_t * dsc, const lv_area_t * rect)
     lv_area_copy(&(new_task->dsc.scissor_area), rect);
 }
 
+LV_FUNC_SECTION
 void lv_draw_vector(lv_vector_dsc_t * dsc)
 {
     if(!dsc->tasks.task_list) {
@@ -753,31 +800,37 @@ void lv_draw_vector(lv_vector_dsc_t * dsc)
 }
 
 /* draw dsc transform */
+LV_FUNC_SECTION
 void lv_vector_dsc_identity(lv_vector_dsc_t * dsc)
 {
     lv_matrix_identity(&(dsc->current_dsc.matrix)); /*identity matrix*/
 }
 
+LV_FUNC_SECTION
 void lv_vector_dsc_scale(lv_vector_dsc_t * dsc, float scale_x, float scale_y)
 {
     lv_matrix_scale(&(dsc->current_dsc.matrix), scale_x, scale_y);
 }
 
+LV_FUNC_SECTION
 void lv_vector_dsc_rotate(lv_vector_dsc_t * dsc, float degree)
 {
     lv_matrix_rotate(&(dsc->current_dsc.matrix), degree);
 }
 
+LV_FUNC_SECTION
 void lv_vector_dsc_translate(lv_vector_dsc_t * dsc, float tx, float ty)
 {
     lv_matrix_translate(&(dsc->current_dsc.matrix), tx, ty);
 }
 
+LV_FUNC_SECTION
 void lv_vector_dsc_skew(lv_vector_dsc_t * dsc, float skew_x, float skew_y)
 {
     lv_matrix_skew(&(dsc->current_dsc.matrix), skew_x, skew_y);
 }
 
+LV_FUNC_SECTION
 void lv_vector_for_each_destroy_tasks(lv_ll_t * task_list, vector_draw_task_cb cb, void * data)
 {
     lv_vector_draw_task * task = lv_ll_get_head(task_list);
diff --git a/src/draw/lv_image_decoder.c b/src/draw/lv_image_decoder.c
index 90934c105..2647d8e95 100644
--- a/src/draw/lv_image_decoder.c
+++ b/src/draw/lv_image_decoder.c
@@ -56,6 +56,7 @@ static lv_result_t try_cache(lv_image_decoder_dsc_t * dsc);
 /**
  * Initialize the image decoder module
  */
+LV_FUNC_SECTION
 void lv_image_decoder_init(uint32_t image_cache_size, uint32_t image_header_count)
 {
     lv_ll_init(img_decoder_ll_p, sizeof(lv_image_decoder_t));
@@ -68,6 +69,7 @@ void lv_image_decoder_init(uint32_t image_cache_size, uint32_t image_header_coun
 /**
  * Deinitialize the image decoder module
  */
+LV_FUNC_SECTION
 void lv_image_decoder_deinit(void)
 {
     lv_cache_destroy(img_cache_p, NULL);
@@ -76,6 +78,7 @@ void lv_image_decoder_deinit(void)
     lv_ll_clear(img_decoder_ll_p);
 }
 
+LV_FUNC_SECTION
 lv_result_t lv_image_decoder_get_info(const void * src, lv_image_header_t * header)
 {
     lv_image_decoder_dsc_t dsc;
@@ -89,6 +92,7 @@ lv_result_t lv_image_decoder_get_info(const void * src, lv_image_header_t * head
     return LV_RESULT_OK;
 }
 
+LV_FUNC_SECTION
 lv_result_t lv_image_decoder_open(lv_image_decoder_dsc_t * dsc, const void * src, const lv_image_decoder_args_t * args)
 {
     lv_memzero(dsc, sizeof(lv_image_decoder_dsc_t));
@@ -143,6 +147,7 @@ lv_result_t lv_image_decoder_open(lv_image_decoder_dsc_t * dsc, const void * src
     return res;
 }
 
+LV_FUNC_SECTION
 lv_result_t lv_image_decoder_get_area(lv_image_decoder_dsc_t * dsc, const lv_area_t * full_area,
                                       lv_area_t * decoded_area)
 {
@@ -152,6 +157,7 @@ lv_result_t lv_image_decoder_get_area(lv_image_decoder_dsc_t * dsc, const lv_are
     return res;
 }
 
+LV_FUNC_SECTION
 void lv_image_decoder_close(lv_image_decoder_dsc_t * dsc)
 {
     if(dsc->decoder) {
@@ -168,6 +174,7 @@ void lv_image_decoder_close(lv_image_decoder_dsc_t * dsc)
  * Create a new image decoder
  * @return pointer to the new image decoder
  */
+LV_FUNC_SECTION
 lv_image_decoder_t * lv_image_decoder_create(void)
 {
     lv_image_decoder_t * decoder;
@@ -180,12 +187,14 @@ lv_image_decoder_t * lv_image_decoder_create(void)
     return decoder;
 }
 
+LV_FUNC_SECTION
 void lv_image_decoder_delete(lv_image_decoder_t * decoder)
 {
     lv_ll_remove(img_decoder_ll_p, decoder);
     lv_free(decoder);
 }
 
+LV_FUNC_SECTION
 lv_image_decoder_t * lv_image_decoder_get_next(lv_image_decoder_t * decoder)
 {
     if(decoder == NULL)
@@ -194,26 +203,31 @@ lv_image_decoder_t * lv_image_decoder_get_next(lv_image_decoder_t * decoder)
         return lv_ll_get_next(img_decoder_ll_p, decoder);
 }
 
+LV_FUNC_SECTION
 void lv_image_decoder_set_info_cb(lv_image_decoder_t * decoder, lv_image_decoder_info_f_t info_cb)
 {
     decoder->info_cb = info_cb;
 }
 
+LV_FUNC_SECTION
 void lv_image_decoder_set_open_cb(lv_image_decoder_t * decoder, lv_image_decoder_open_f_t open_cb)
 {
     decoder->open_cb = open_cb;
 }
 
+LV_FUNC_SECTION
 void lv_image_decoder_set_get_area_cb(lv_image_decoder_t * decoder, lv_image_decoder_get_area_cb_t get_area_cb)
 {
     decoder->get_area_cb = get_area_cb;
 }
 
+LV_FUNC_SECTION
 void lv_image_decoder_set_close_cb(lv_image_decoder_t * decoder, lv_image_decoder_close_f_t close_cb)
 {
     decoder->close_cb = close_cb;
 }
 
+LV_FUNC_SECTION
 lv_cache_entry_t * lv_image_decoder_add_to_cache(lv_image_decoder_t * decoder,
                                                  lv_image_cache_data_t * search_key,
                                                  const lv_draw_buf_t * decoded, void * user_data)
@@ -237,6 +251,7 @@ lv_cache_entry_t * lv_image_decoder_add_to_cache(lv_image_decoder_t * decoder,
     return cache_entry;
 }
 
+LV_FUNC_SECTION
 lv_draw_buf_t * lv_image_decoder_post_process(lv_image_decoder_dsc_t * dsc, lv_draw_buf_t * decoded)
 {
     if(decoded == NULL) return NULL; /*No need to adjust*/
@@ -290,6 +305,7 @@ lv_draw_buf_t * lv_image_decoder_post_process(lv_image_decoder_dsc_t * dsc, lv_d
  *   STATIC FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 static lv_image_decoder_t * image_decoder_get_info(lv_image_decoder_dsc_t * dsc, lv_image_header_t * header)
 {
     lv_memzero(header, sizeof(lv_image_header_t));
@@ -383,6 +399,7 @@ static lv_image_decoder_t * image_decoder_get_info(lv_image_decoder_dsc_t * dsc,
     return decoder;
 }
 
+LV_FUNC_SECTION
 static uint32_t img_width_to_stride(lv_image_header_t * header)
 {
     if(header->cf == LV_COLOR_FORMAT_RGB565A8) {
@@ -393,6 +410,7 @@ static uint32_t img_width_to_stride(lv_image_header_t * header)
     }
 }
 
+LV_FUNC_SECTION
 static lv_result_t try_cache(lv_image_decoder_dsc_t * dsc)
 {
     lv_cache_t * cache = dsc->cache;
diff --git a/src/draw/lv_image_decoder_private.h b/src/draw/lv_image_decoder_private.h
index 27ef26140..0b76addf4 100644
--- a/src/draw/lv_image_decoder_private.h
+++ b/src/draw/lv_image_decoder_private.h
@@ -42,9 +42,13 @@ struct lv_image_decoder_args_t {
 };
 
 struct lv_image_decoder_t {
+    __attribute__(( fptrgroup("lv_image_deocder_info_cb") ))
     lv_image_decoder_info_f_t info_cb;
+    __attribute__(( fptrgroup("lv_image_deocder_open_cb") ))
     lv_image_decoder_open_f_t open_cb;
+    __attribute__(( fptrgroup("lv_image_deocder_get_area_cb") ))
     lv_image_decoder_get_area_cb_t get_area_cb;
+    __attribute__(( fptrgroup("lv_image_deocder_close_cb") ))
     lv_image_decoder_close_f_t close_cb;
 
     const char * name;
diff --git a/src/draw/nxp/pxp/lv_draw_buf_pxp.c b/src/draw/nxp/pxp/lv_draw_buf_pxp.c
index 9819cfc64..04dba16f6 100644
--- a/src/draw/nxp/pxp/lv_draw_buf_pxp.c
+++ b/src/draw/nxp/pxp/lv_draw_buf_pxp.c
@@ -49,6 +49,7 @@ static void _invalidate_cache(const lv_draw_buf_t * draw_buf, const lv_area_t *
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 void lv_draw_buf_pxp_init_handlers(void)
 {
     lv_draw_buf_handlers_t * handlers = lv_draw_buf_get_handlers();
@@ -64,6 +65,7 @@ void lv_draw_buf_pxp_init_handlers(void)
  *   STATIC FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 static void _invalidate_cache(const lv_draw_buf_t * draw_buf, const lv_area_t * area)
 {
     const lv_image_header_t * header = &draw_buf->header;
diff --git a/src/draw/nxp/pxp/lv_draw_pxp.c b/src/draw/nxp/pxp/lv_draw_pxp.c
index 636fe4379..6bba7c24c 100644
--- a/src/draw/nxp/pxp/lv_draw_pxp.c
+++ b/src/draw/nxp/pxp/lv_draw_pxp.c
@@ -81,6 +81,7 @@ static void _pxp_execute_drawing(lv_draw_pxp_unit_t * u);
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 void lv_draw_pxp_init(void)
 {
     lv_pxp_init();
@@ -99,11 +100,13 @@ void lv_draw_pxp_init(void)
 #endif /*LV_USE_DRAW_PXP*/
 }
 
+LV_FUNC_SECTION
 void lv_draw_pxp_deinit(void)
 {
     lv_pxp_deinit();
 }
 
+LV_FUNC_SECTION
 void lv_draw_pxp_rotate(const void * src_buf, void * dest_buf, int32_t src_width, int32_t src_height,
                         int32_t src_stride, int32_t dest_stride, lv_display_rotation_t rotation,
                         lv_color_format_t cf)
@@ -170,6 +173,7 @@ void lv_draw_pxp_rotate(const void * src_buf, void * dest_buf, int32_t src_width
  *   STATIC FUNCTIONS
  **********************/
 #if LV_USE_DRAW_PXP
+LV_FUNC_SECTION
 static inline bool _pxp_src_cf_supported(lv_color_format_t cf)
 {
     bool is_cf_supported = false;
@@ -187,6 +191,7 @@ static inline bool _pxp_src_cf_supported(lv_color_format_t cf)
     return is_cf_supported;
 }
 
+LV_FUNC_SECTION
 static inline bool _pxp_dest_cf_supported(lv_color_format_t cf)
 {
     bool is_cf_supported = false;
@@ -205,6 +210,7 @@ static inline bool _pxp_dest_cf_supported(lv_color_format_t cf)
     return is_cf_supported;
 }
 
+LV_FUNC_SECTION
 static bool _pxp_draw_img_supported(const lv_draw_image_dsc_t * draw_dsc)
 {
     const lv_image_dsc_t * img_dsc = draw_dsc->src;
@@ -249,6 +255,7 @@ static bool _pxp_draw_img_supported(const lv_draw_image_dsc_t * draw_dsc)
     return true;
 }
 
+LV_FUNC_SECTION
 static int32_t _pxp_evaluate(lv_draw_unit_t * u, lv_draw_task_t * t)
 {
     LV_UNUSED(u);
@@ -317,6 +324,7 @@ static int32_t _pxp_evaluate(lv_draw_unit_t * u, lv_draw_task_t * t)
     return 0;
 }
 
+LV_FUNC_SECTION
 static int32_t _pxp_dispatch(lv_draw_unit_t * draw_unit, lv_layer_t * layer)
 {
     lv_draw_pxp_unit_t * draw_pxp_unit = (lv_draw_pxp_unit_t *) draw_unit;
@@ -356,6 +364,7 @@ static int32_t _pxp_dispatch(lv_draw_unit_t * draw_unit, lv_layer_t * layer)
     return 1;
 }
 
+LV_FUNC_SECTION
 static int32_t _pxp_delete(lv_draw_unit_t * draw_unit)
 {
 #if LV_USE_PXP_DRAW_THREAD
@@ -377,6 +386,7 @@ static int32_t _pxp_delete(lv_draw_unit_t * draw_unit)
 #endif
 }
 
+LV_FUNC_SECTION
 static void _pxp_execute_drawing(lv_draw_pxp_unit_t * u)
 {
     lv_draw_task_t * t = u->task_act;
@@ -455,6 +465,7 @@ static void _pxp_execute_drawing(lv_draw_pxp_unit_t * u)
 }
 
 #if LV_USE_PXP_DRAW_THREAD
+LV_FUNC_SECTION
 static void _pxp_render_thread_cb(void * ptr)
 {
     lv_draw_pxp_unit_t * u = ptr;
diff --git a/src/draw/nxp/pxp/lv_draw_pxp_fill.c b/src/draw/nxp/pxp/lv_draw_pxp_fill.c
index 33b80473c..89f062a61 100644
--- a/src/draw/nxp/pxp/lv_draw_pxp_fill.c
+++ b/src/draw/nxp/pxp/lv_draw_pxp_fill.c
@@ -47,6 +47,7 @@ static void _pxp_fill(uint8_t * dest_buf, const lv_area_t * dest_area, int32_t d
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 void lv_draw_pxp_fill(lv_draw_unit_t * draw_unit, const lv_draw_fill_dsc_t * dsc,
                       const lv_area_t * coords)
 {
@@ -75,6 +76,7 @@ void lv_draw_pxp_fill(lv_draw_unit_t * draw_unit, const lv_draw_fill_dsc_t * dsc
  *   STATIC FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 static void _pxp_fill(uint8_t * dest_buf, const lv_area_t * dest_area, int32_t dest_stride,
                       lv_color_format_t dest_cf, const lv_draw_fill_dsc_t * dsc)
 {
diff --git a/src/draw/nxp/pxp/lv_draw_pxp_img.c b/src/draw/nxp/pxp/lv_draw_pxp_img.c
index 79f3790e9..010b60cdc 100644
--- a/src/draw/nxp/pxp/lv_draw_pxp_img.c
+++ b/src/draw/nxp/pxp/lv_draw_pxp_img.c
@@ -61,6 +61,7 @@ static void _pxp_blit(uint8_t * dest_buf, const lv_area_t * dest_area, int32_t d
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 void lv_draw_pxp_img(lv_draw_unit_t * draw_unit, const lv_draw_image_dsc_t * dsc,
                      const lv_area_t * coords)
 {
@@ -116,6 +117,7 @@ void lv_draw_pxp_img(lv_draw_unit_t * draw_unit, const lv_draw_image_dsc_t * dsc
  *   STATIC FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 static void _pxp_blit_recolor(uint8_t * dest_buf, const lv_area_t * dest_area, int32_t dest_stride,
                               lv_color_format_t dest_cf, const uint8_t * src_buf, const lv_area_t * src_area,
                               int32_t src_stride, lv_color_format_t src_cf, const lv_draw_image_dsc_t * dsc)
@@ -182,6 +184,7 @@ static void _pxp_blit_recolor(uint8_t * dest_buf, const lv_area_t * dest_area, i
     lv_pxp_run();
 }
 
+LV_FUNC_SECTION
 static void _pxp_blit_transform(uint8_t * dest_buf, const lv_area_t * dest_area, int32_t dest_stride,
                                 lv_color_format_t dest_cf, const uint8_t * src_buf, const lv_area_t * src_area,
                                 int32_t src_stride, lv_color_format_t src_cf, const lv_draw_image_dsc_t * dsc)
@@ -290,6 +293,7 @@ static void _pxp_blit_transform(uint8_t * dest_buf, const lv_area_t * dest_area,
     lv_pxp_run();
 }
 
+LV_FUNC_SECTION
 static void _pxp_blit(uint8_t * dest_buf, const lv_area_t * dest_area, int32_t dest_stride,
                       lv_color_format_t dest_cf, const uint8_t * src_buf, const lv_area_t * src_area,
                       int32_t src_stride, lv_color_format_t src_cf, lv_opa_t opa)
diff --git a/src/draw/nxp/pxp/lv_draw_pxp_layer.c b/src/draw/nxp/pxp/lv_draw_pxp_layer.c
index 34cb285b7..3bc12345e 100644
--- a/src/draw/nxp/pxp/lv_draw_pxp_layer.c
+++ b/src/draw/nxp/pxp/lv_draw_pxp_layer.c
@@ -51,6 +51,7 @@
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 void lv_draw_pxp_layer(lv_draw_unit_t * draw_unit, const lv_draw_image_dsc_t * draw_dsc,
                        const lv_area_t * coords)
 {
diff --git a/src/draw/nxp/pxp/lv_pxp_cfg.c b/src/draw/nxp/pxp/lv_pxp_cfg.c
index 675c1d030..fff7cde1a 100644
--- a/src/draw/nxp/pxp/lv_pxp_cfg.c
+++ b/src/draw/nxp/pxp/lv_pxp_cfg.c
@@ -45,6 +45,7 @@ static pxp_cfg_t * _pxp_cfg;
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 void lv_pxp_init(void)
 {
     _pxp_cfg = pxp_get_default_cfg();
@@ -59,6 +60,7 @@ void lv_pxp_init(void)
     _pxp_cfg->pxp_interrupt_init();
 }
 
+LV_FUNC_SECTION
 void lv_pxp_deinit(void)
 {
     _pxp_cfg->pxp_interrupt_deinit();
@@ -66,6 +68,7 @@ void lv_pxp_deinit(void)
     PXP_Deinit(PXP_ID);
 }
 
+LV_FUNC_SECTION
 void lv_pxp_reset(void)
 {
     PXP_ResetControl(PXP_ID);
@@ -74,12 +77,14 @@ void lv_pxp_reset(void)
     PXP_SetProcessBlockSize(PXP_ID, kPXP_BlockSize16); /*Block size 16x16 for higher performance*/
 }
 
+LV_FUNC_SECTION
 void lv_pxp_run(void)
 {
     _pxp_cfg->pxp_run();
     _pxp_cfg->pxp_wait();
 }
 
+LV_FUNC_SECTION
 void lv_pxp_wait(void)
 {
     _pxp_cfg->pxp_wait();
diff --git a/src/draw/nxp/pxp/lv_pxp_osa.c b/src/draw/nxp/pxp/lv_pxp_osa.c
index 43dd8155b..de5885200 100644
--- a/src/draw/nxp/pxp/lv_pxp_osa.c
+++ b/src/draw/nxp/pxp/lv_pxp_osa.c
@@ -94,6 +94,7 @@ static pxp_cfg_t _pxp_default_cfg = {
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 void PXP_IRQHandler(void)
 {
     if(kPXP_CompleteFlag & PXP_GetStatusFlags(PXP_ID)) {
@@ -106,6 +107,7 @@ void PXP_IRQHandler(void)
     }
 }
 
+LV_FUNC_SECTION
 pxp_cfg_t * pxp_get_default_cfg(void)
 {
     return &_pxp_default_cfg;
@@ -116,12 +118,14 @@ pxp_cfg_t * pxp_get_default_cfg(void)
  **********************/
 
 #if defined(__ZEPHYR__)
+LV_FUNC_SECTION
 static void _pxp_zephyr_irq_handler(void *)
 {
     PXP_IRQHandler();
 }
 #endif
 
+LV_FUNC_SECTION
 static void _pxp_interrupt_init(void)
 {
 #if LV_USE_OS
@@ -144,6 +148,7 @@ static void _pxp_interrupt_init(void)
     ucPXPIdle = true;
 }
 
+LV_FUNC_SECTION
 static void _pxp_interrupt_deinit(void)
 {
 #if defined(__ZEPHYR__)
@@ -160,6 +165,7 @@ static void _pxp_interrupt_deinit(void)
 /**
  * Function to start PXP job.
  */
+LV_FUNC_SECTION
 static void _pxp_run(void)
 {
     ucPXPIdle = false;
@@ -171,6 +177,7 @@ static void _pxp_run(void)
 /**
  * Function to wait for PXP completion.
  */
+LV_FUNC_SECTION
 static void _pxp_wait(void)
 {
     if(ucPXPIdle == true)
diff --git a/src/draw/nxp/pxp/lv_pxp_utils.c b/src/draw/nxp/pxp/lv_pxp_utils.c
index 26acf6ca9..14761caed 100644
--- a/src/draw/nxp/pxp/lv_pxp_utils.c
+++ b/src/draw/nxp/pxp/lv_pxp_utils.c
@@ -38,6 +38,7 @@
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 pxp_output_pixel_format_t pxp_get_out_px_format(lv_color_format_t cf)
 {
     pxp_output_pixel_format_t out_px_format = kPXP_OutputPixelFormatRGB565;
@@ -64,6 +65,7 @@ pxp_output_pixel_format_t pxp_get_out_px_format(lv_color_format_t cf)
     return out_px_format;
 }
 
+LV_FUNC_SECTION
 pxp_as_pixel_format_t pxp_get_as_px_format(lv_color_format_t cf)
 {
     pxp_as_pixel_format_t as_px_format = kPXP_AsPixelFormatRGB565;
@@ -91,6 +93,7 @@ pxp_as_pixel_format_t pxp_get_as_px_format(lv_color_format_t cf)
 }
 
 #if LV_USE_DRAW_PXP
+LV_FUNC_SECTION
 pxp_ps_pixel_format_t pxp_get_ps_px_format(lv_color_format_t cf)
 {
     pxp_ps_pixel_format_t ps_px_format = kPXP_PsPixelFormatRGB565;
@@ -127,6 +130,7 @@ pxp_ps_pixel_format_t pxp_get_ps_px_format(lv_color_format_t cf)
     return ps_px_format;
 }
 
+LV_FUNC_SECTION
 bool pxp_buf_aligned(const void * buf, uint32_t stride)
 {
     /* Test for pointer alignment */
diff --git a/src/draw/nxp/vglite/lv_draw_buf_vglite.c b/src/draw/nxp/vglite/lv_draw_buf_vglite.c
index 85403956f..5d5921955 100644
--- a/src/draw/nxp/vglite/lv_draw_buf_vglite.c
+++ b/src/draw/nxp/vglite/lv_draw_buf_vglite.c
@@ -49,6 +49,7 @@ static uint32_t _width_to_stride(uint32_t w, lv_color_format_t cf);
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 void lv_draw_buf_vglite_init_handlers(void)
 {
     lv_draw_buf_handlers_t * handlers = lv_draw_buf_get_handlers();
@@ -69,6 +70,7 @@ void lv_draw_buf_vglite_init_handlers(void)
  *   STATIC FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 static void _invalidate_cache(const lv_draw_buf_t * draw_buf, const lv_area_t * area)
 {
     const lv_image_header_t * header = &draw_buf->header;
@@ -118,6 +120,7 @@ static void _invalidate_cache(const lv_draw_buf_t * draw_buf, const lv_area_t *
     }
 }
 
+LV_FUNC_SECTION
 static uint32_t _width_to_stride(uint32_t w, lv_color_format_t cf)
 {
     uint8_t bits_per_pixel = lv_color_format_get_bpp(cf);
diff --git a/src/draw/nxp/vglite/lv_draw_vglite.c b/src/draw/nxp/vglite/lv_draw_vglite.c
index c6fc016f4..cc062b987 100644
--- a/src/draw/nxp/vglite/lv_draw_vglite.c
+++ b/src/draw/nxp/vglite/lv_draw_vglite.c
@@ -104,6 +104,7 @@ static void _vglite_execute_drawing(lv_draw_vglite_unit_t * u);
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 void lv_draw_vglite_init(void)
 {
     lv_draw_buf_vglite_init_handlers();
@@ -121,6 +122,7 @@ void lv_draw_vglite_init(void)
 #endif
 }
 
+LV_FUNC_SECTION
 void lv_draw_vglite_deinit(void)
 {
 }
@@ -129,6 +131,7 @@ void lv_draw_vglite_deinit(void)
  *   STATIC FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 static inline bool _vglite_src_cf_supported(lv_color_format_t cf)
 {
     bool is_cf_supported = false;
@@ -159,6 +162,7 @@ static inline bool _vglite_src_cf_supported(lv_color_format_t cf)
     return is_cf_supported;
 }
 
+LV_FUNC_SECTION
 static inline bool _vglite_dest_cf_supported(lv_color_format_t cf)
 {
     bool is_cf_supported = false;
@@ -184,6 +188,7 @@ static inline bool _vglite_dest_cf_supported(lv_color_format_t cf)
     return is_cf_supported;
 }
 
+LV_FUNC_SECTION
 static int32_t _vglite_evaluate(lv_draw_unit_t * u, lv_draw_task_t * t)
 {
     LV_UNUSED(u);
@@ -277,6 +282,7 @@ static int32_t _vglite_evaluate(lv_draw_unit_t * u, lv_draw_task_t * t)
     return 0;
 }
 
+LV_FUNC_SECTION
 static int32_t _vglite_dispatch(lv_draw_unit_t * draw_unit, lv_layer_t * layer)
 {
     lv_draw_vglite_unit_t * draw_vglite_unit = (lv_draw_vglite_unit_t *) draw_unit;
@@ -332,6 +338,7 @@ static int32_t _vglite_dispatch(lv_draw_unit_t * draw_unit, lv_layer_t * layer)
 }
 
 #if LV_USE_VGLITE_DRAW_ASYNC
+LV_FUNC_SECTION
 static int32_t _vglite_wait_for_finish(lv_draw_unit_t * draw_unit)
 {
     lv_draw_vglite_unit_t * draw_vglite_unit = (lv_draw_vglite_unit_t *) draw_unit;
@@ -348,6 +355,7 @@ static int32_t _vglite_wait_for_finish(lv_draw_unit_t * draw_unit)
 }
 #endif
 
+LV_FUNC_SECTION
 static int32_t _vglite_delete(lv_draw_unit_t * draw_unit)
 {
 #if LV_USE_VGLITE_DRAW_THREAD
@@ -369,6 +377,7 @@ static int32_t _vglite_delete(lv_draw_unit_t * draw_unit)
 #endif
 }
 
+LV_FUNC_SECTION
 static void _vglite_execute_drawing(lv_draw_vglite_unit_t * u)
 {
     lv_draw_task_t * t = u->task_act;
@@ -479,6 +488,7 @@ static void _vglite_execute_drawing(lv_draw_vglite_unit_t * u)
 }
 
 #if LV_USE_VGLITE_DRAW_ASYNC
+LV_FUNC_SECTION
 static inline void _vglite_queue_task(lv_draw_task_t * task)
 {
     VGLITE_ASSERT_MSG(((_tail + 1) % VGLITE_TASK_BUF_SIZE) != _head, "VGLite task buffer full.");
@@ -488,6 +498,7 @@ static inline void _vglite_queue_task(lv_draw_task_t * task)
     _tail = (_tail + 1) % VGLITE_TASK_BUF_SIZE;
 }
 
+LV_FUNC_SECTION
 static inline void _vglite_signal_task_ready(lv_draw_task_t * task)
 {
     /* Signal the ready state to dispatcher. */
@@ -497,6 +508,7 @@ static inline void _vglite_signal_task_ready(lv_draw_task_t * task)
     /* No need to cleanup the tasks in buffer as we advance with the _head. */
 }
 
+LV_FUNC_SECTION
 static inline void _vglite_signal_all_task_ready(void)
 {
     int end = (_head <= _tail) ? _tail : _tail + VGLITE_TASK_BUF_SIZE;
@@ -508,6 +520,7 @@ static inline void _vglite_signal_all_task_ready(void)
     }
 }
 
+LV_FUNC_SECTION
 static inline void _vglite_signal_flushed_task_ready(void)
 {
     if(vglite_cmd_buf_is_flushed()) {
@@ -530,6 +543,7 @@ static inline void _vglite_signal_flushed_task_ready(void)
 #endif
 
 #if LV_USE_VGLITE_DRAW_THREAD
+LV_FUNC_SECTION
 static void _vglite_render_thread_cb(void * ptr)
 {
     lv_draw_vglite_unit_t * u = ptr;
diff --git a/src/draw/nxp/vglite/lv_draw_vglite_arc.c b/src/draw/nxp/vglite/lv_draw_vglite_arc.c
index 6b0d4fe55..91f601f57 100644
--- a/src/draw/nxp/vglite/lv_draw_vglite_arc.c
+++ b/src/draw/nxp/vglite/lv_draw_vglite_arc.c
@@ -96,6 +96,7 @@ static void _vglite_draw_arc(const lv_point_t * center, const lv_area_t * clip_a
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 void lv_draw_vglite_arc(lv_draw_unit_t * draw_unit, const lv_draw_arc_dsc_t * dsc,
                         const lv_area_t * coords)
 {
@@ -122,6 +123,7 @@ void lv_draw_vglite_arc(lv_draw_unit_t * draw_unit, const lv_draw_arc_dsc_t * ds
  *   STATIC FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 static void _copy_arc(vg_arc * dst, vg_arc * src)
 {
     dst->quarter = src->quarter;
@@ -140,6 +142,7 @@ static void _copy_arc(vg_arc * dst, vg_arc * src)
 /**
  * Rotate the point according given rotation angle rotation center is 0,0
  */
+LV_FUNC_SECTION
 static void _rotate_point(int32_t angle, int32_t * x, int32_t * y)
 {
     int32_t ori_x = *x;
@@ -157,6 +160,7 @@ static void _rotate_point(int32_t angle, int32_t * x, int32_t * y)
  * ---+---
  * Q1 | Q0
  */
+LV_FUNC_SECTION
 static void _set_full_arc(vg_arc * fullarc)
 {
     /* the tangent length for the bezier circle approx */
@@ -216,6 +220,7 @@ static void _set_full_arc(vg_arc * fullarc)
  * Linear interpolation between two points 'a' and 'b'
  * 't' parameter is the proportion ratio expressed in range [0 ; T_FRACTION ]
  */
+LV_FUNC_SECTION
 static inline float _lerp(float coord_a, float coord_b, uint16_t t)
 {
     float tf = (float)t;
@@ -225,6 +230,7 @@ static inline float _lerp(float coord_a, float coord_b, uint16_t t)
 /**
  * Computes a point of bezier curve given 't' param
  */
+LV_FUNC_SECTION
 static inline float _comp_bezier_point(float t, cubic_cont_pt cp)
 {
     float t_sq = t * t;
@@ -241,6 +247,7 @@ static inline float _comp_bezier_point(float t, cubic_cont_pt cp)
  * bezier curve is defined by control points [p0 p1 p2 p3]
  * 'dec' tells if curve is decreasing (true) or increasing (false)
  */
+LV_FUNC_SECTION
 static uint16_t _get_bez_t_from_pos(float pt, cubic_cont_pt cp, bool dec)
 {
     /* initialize dichotomy with boundary 't' values */
@@ -269,6 +276,7 @@ static uint16_t _get_bez_t_from_pos(float pt, cubic_cont_pt cp, bool dec)
  * Gives relative coords of the control points
  * for the sub-arc starting at angle with given angle span
  */
+LV_FUNC_SECTION
 static void _get_subarc_control_points(vg_arc * arc, int32_t span)
 {
     vg_arc fullarc = {0};
@@ -362,6 +370,7 @@ static void _get_subarc_control_points(vg_arc * arc, int32_t span)
 /**
  * Gives relative coords of the control points
  */
+LV_FUNC_SECTION
 static void _get_arc_control_points(vg_arc * arc, bool start)
 {
     vg_arc fullarc = {0};
@@ -427,6 +436,7 @@ static void _get_arc_control_points(vg_arc * arc, bool start)
  * center: (in) the center of the circle in draw coordinates
  * cw: (in) true if arc is clockwise
  */
+LV_FUNC_SECTION
 static void _add_split_arc_path(int32_t * arc_path, int * pidx, vg_arc * q_arc, const lv_point_t * center, bool cw)
 {
     /* assumes first control point already in array arc_path[] */
@@ -477,6 +487,7 @@ static void _add_split_arc_path(int32_t * arc_path, int * pidx, vg_arc * q_arc,
     *pidx = idx;
 }
 
+LV_FUNC_SECTION
 static void _add_arc_path(int32_t * arc_path, int * pidx, int32_t radius,
                           int32_t start_angle, int32_t end_angle, const lv_point_t * center, bool cw)
 {
@@ -559,6 +570,7 @@ static void _add_arc_path(int32_t * arc_path, int * pidx, int32_t radius,
     }
 }
 
+LV_FUNC_SECTION
 static void _vglite_draw_arc(const lv_point_t * center, const lv_area_t * clip_area,
                              const lv_draw_arc_dsc_t * dsc)
 {
diff --git a/src/draw/nxp/vglite/lv_draw_vglite_border.c b/src/draw/nxp/vglite/lv_draw_vglite_border.c
index db762fb61..f3de57c5d 100644
--- a/src/draw/nxp/vglite/lv_draw_vglite_border.c
+++ b/src/draw/nxp/vglite/lv_draw_vglite_border.c
@@ -64,6 +64,7 @@ static void _vglite_draw_border(const lv_area_t * coords, const lv_area_t * clip
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 void lv_draw_vglite_border(lv_draw_unit_t * draw_unit, const lv_draw_border_dsc_t * dsc,
                            const lv_area_t * coords)
 {
@@ -101,6 +102,7 @@ void lv_draw_vglite_border(lv_draw_unit_t * draw_unit, const lv_draw_border_dsc_
  *   STATIC FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 static void _vglite_draw_border(const lv_area_t * coords, const lv_area_t * clip_area,
                                 const lv_draw_border_dsc_t * dsc)
 {
diff --git a/src/draw/nxp/vglite/lv_draw_vglite_fill.c b/src/draw/nxp/vglite/lv_draw_vglite_fill.c
index 97089ce55..a280e41cb 100644
--- a/src/draw/nxp/vglite/lv_draw_vglite_fill.c
+++ b/src/draw/nxp/vglite/lv_draw_vglite_fill.c
@@ -66,6 +66,7 @@ static void _vglite_draw_rect(const lv_area_t * coords, const lv_area_t * clip_a
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 void lv_draw_vglite_fill(lv_draw_unit_t * draw_unit, const lv_draw_fill_dsc_t * dsc,
                          const lv_area_t * coords)
 {
@@ -98,6 +99,7 @@ void lv_draw_vglite_fill(lv_draw_unit_t * draw_unit, const lv_draw_fill_dsc_t *
  *   STATIC FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 static void _vglite_fill(const lv_area_t * dest_area, const lv_draw_fill_dsc_t * dsc)
 {
     vg_lite_buffer_t * vgbuf = vglite_get_dest_buf();
@@ -145,6 +147,7 @@ static void _vglite_fill(const lv_area_t * dest_area, const lv_draw_fill_dsc_t *
     }
 }
 
+LV_FUNC_SECTION
 static void _vglite_draw_rect(const lv_area_t * coords, const lv_area_t * clip_area,
                               const lv_draw_fill_dsc_t * dsc)
 {
diff --git a/src/draw/nxp/vglite/lv_draw_vglite_img.c b/src/draw/nxp/vglite/lv_draw_vglite_img.c
index 49fdffaff..76672bec7 100644
--- a/src/draw/nxp/vglite/lv_draw_vglite_img.c
+++ b/src/draw/nxp/vglite/lv_draw_vglite_img.c
@@ -125,6 +125,7 @@ static vg_lite_color_t _vglite_recolor(const lv_draw_image_dsc_t * dsc);
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 void lv_draw_vglite_img(lv_draw_unit_t * draw_unit, const lv_draw_image_dsc_t * dsc,
                         const lv_area_t * coords)
 {
@@ -184,6 +185,7 @@ void lv_draw_vglite_img(lv_draw_unit_t * draw_unit, const lv_draw_image_dsc_t *
 /**********************
  *   STATIC FUNCTIONS
  **********************/
+LV_FUNC_SECTION
 static void _vglite_blit(const lv_area_t * src_area, const lv_draw_image_dsc_t * dsc)
 {
     vg_lite_buffer_t * dst_vgbuf = vglite_get_dest_buf();
@@ -210,6 +212,7 @@ static void _vglite_blit(const lv_area_t * src_area, const lv_draw_image_dsc_t *
 }
 
 #if LV_USE_VGLITE_BLIT_SPLIT
+LV_FUNC_SECTION
 static void _move_buf_close_to_area(void ** buf, lv_area_t * area, uint32_t stride, lv_color_format_t cf)
 {
     uint8_t ** buf_u8 = (uint8_t **)buf;
@@ -235,6 +238,7 @@ static void _move_buf_close_to_area(void ** buf, lv_area_t * area, uint32_t stri
     }
 }
 
+LV_FUNC_SECTION
 static void _vglite_blit_split(void * dest_buf, lv_area_t * dest_area, uint32_t dest_stride, lv_color_format_t dest_cf,
                                const void * src_buf, lv_area_t * src_area, uint32_t src_stride, lv_color_format_t src_cf,
                                const lv_draw_image_dsc_t * dsc)
@@ -372,6 +376,7 @@ static void _vglite_blit_split(void * dest_buf, lv_area_t * dest_area, uint32_t
 }
 #endif /*LV_USE_VGLITE_BLIT_SPLIT*/
 
+LV_FUNC_SECTION
 static void _vglite_draw_pattern(const lv_area_t * clip_area, const lv_area_t * coords,
                                  const lv_draw_image_dsc_t * dsc)
 {
@@ -418,6 +423,7 @@ static void _vglite_draw_pattern(const lv_area_t * clip_area, const lv_area_t *
                                             0, vgcol, filter));
 }
 
+LV_FUNC_SECTION
 static vg_lite_color_t _vglite_recolor(const lv_draw_image_dsc_t * dsc)
 {
     lv_color_t color;
diff --git a/src/draw/nxp/vglite/lv_draw_vglite_label.c b/src/draw/nxp/vglite/lv_draw_vglite_label.c
index 9af7c6837..2576bb5a6 100644
--- a/src/draw/nxp/vglite/lv_draw_vglite_label.c
+++ b/src/draw/nxp/vglite/lv_draw_vglite_label.c
@@ -64,6 +64,7 @@ static void _vglite_draw_letter(const lv_area_t * mask_area, lv_color_t color, l
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 void lv_draw_vglite_label(lv_draw_unit_t * draw_unit, const lv_draw_label_dsc_t * dsc,
                           const lv_area_t * coords)
 {
@@ -76,6 +77,7 @@ void lv_draw_vglite_label(lv_draw_unit_t * draw_unit, const lv_draw_label_dsc_t
  *   STATIC FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 static void _draw_vglite_letter(lv_draw_unit_t * draw_unit, lv_draw_glyph_dsc_t * glyph_draw_dsc,
                                 lv_draw_fill_dsc_t * fill_draw_dsc, const lv_area_t * fill_area)
 {
@@ -150,6 +152,7 @@ static void _draw_vglite_letter(lv_draw_unit_t * draw_unit, lv_draw_glyph_dsc_t
     }
 }
 
+LV_FUNC_SECTION
 static void _vglite_draw_letter(const lv_area_t * mask_area, lv_color_t color, lv_opa_t opa)
 {
     vg_lite_buffer_t * dst_vgbuf = vglite_get_dest_buf();
diff --git a/src/draw/nxp/vglite/lv_draw_vglite_layer.c b/src/draw/nxp/vglite/lv_draw_vglite_layer.c
index ce3f59ea5..5a7205dd8 100644
--- a/src/draw/nxp/vglite/lv_draw_vglite_layer.c
+++ b/src/draw/nxp/vglite/lv_draw_vglite_layer.c
@@ -46,6 +46,7 @@
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 void lv_draw_vglite_layer(lv_draw_unit_t * draw_unit, const lv_draw_image_dsc_t * draw_dsc,
                           const lv_area_t * coords)
 {
diff --git a/src/draw/nxp/vglite/lv_draw_vglite_line.c b/src/draw/nxp/vglite/lv_draw_vglite_line.c
index f70c02b20..87713992f 100644
--- a/src/draw/nxp/vglite/lv_draw_vglite_line.c
+++ b/src/draw/nxp/vglite/lv_draw_vglite_line.c
@@ -55,6 +55,7 @@ static void _vglite_draw_line(const lv_point_t * point1, const lv_point_t * poin
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 void lv_draw_vglite_line(lv_draw_unit_t * draw_unit, const lv_draw_line_dsc_t * dsc)
 {
     if(dsc->width == 0)
@@ -86,6 +87,7 @@ void lv_draw_vglite_line(lv_draw_unit_t * draw_unit, const lv_draw_line_dsc_t *
  *   STATIC FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 static void _vglite_draw_line(const lv_point_t * point1, const lv_point_t * point2,
                               const lv_area_t * clip_area, const lv_draw_line_dsc_t * dsc)
 {
diff --git a/src/draw/nxp/vglite/lv_draw_vglite_triangle.c b/src/draw/nxp/vglite/lv_draw_vglite_triangle.c
index 8556fdf2a..db2688f9c 100644
--- a/src/draw/nxp/vglite/lv_draw_vglite_triangle.c
+++ b/src/draw/nxp/vglite/lv_draw_vglite_triangle.c
@@ -57,6 +57,7 @@ static void _vglite_draw_triangle(const lv_area_t * coords, const lv_area_t * cl
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 void lv_draw_vglite_triangle(lv_draw_unit_t * draw_unit, const lv_draw_triangle_dsc_t * dsc)
 {
     if(dsc->bg_opa <= (lv_opa_t)LV_OPA_MIN)
@@ -86,6 +87,7 @@ void lv_draw_vglite_triangle(lv_draw_unit_t * draw_unit, const lv_draw_triangle_
  *   STATIC FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 static void _vglite_draw_triangle(const lv_area_t * coords, const lv_area_t * clip_area,
                                   const lv_draw_triangle_dsc_t * dsc)
 {
diff --git a/src/draw/nxp/vglite/lv_vglite_buf.c b/src/draw/nxp/vglite/lv_vglite_buf.c
index a72c8e554..f41a6a4e5 100644
--- a/src/draw/nxp/vglite/lv_vglite_buf.c
+++ b/src/draw/nxp/vglite/lv_vglite_buf.c
@@ -49,38 +49,45 @@ static vg_lite_buffer_t _src_vgbuf;
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 vg_lite_buffer_t * vglite_get_dest_buf(void)
 {
     return &_dest_vgbuf;
 }
 
+LV_FUNC_SECTION
 vg_lite_buffer_t * vglite_get_src_buf(void)
 {
     return &_src_vgbuf;
 }
 
+LV_FUNC_SECTION
 void vglite_set_dest_buf_ptr(void * buf)
 {
     _set_vgbuf_ptr(&_dest_vgbuf, buf);
 }
 
+LV_FUNC_SECTION
 void vglite_set_src_buf_ptr(const void * buf)
 {
     _set_vgbuf_ptr(&_src_vgbuf, (void *)buf);
 }
 
+LV_FUNC_SECTION
 void vglite_set_dest_buf(const void * buf, uint32_t width, uint32_t height, uint32_t stride,
                          lv_color_format_t cf)
 {
     vglite_set_buf(&_dest_vgbuf, (void *)buf, width, height, stride, cf);
 }
 
+LV_FUNC_SECTION
 void vglite_set_src_buf(const void * buf, uint32_t width, uint32_t height, uint32_t stride,
                         lv_color_format_t cf)
 {
     vglite_set_buf(&_src_vgbuf, (void *)buf, width, height, stride, cf);
 }
 
+LV_FUNC_SECTION
 void vglite_set_buf(vg_lite_buffer_t * vgbuf, void * buf,
                     uint32_t width, uint32_t height, uint32_t stride,
                     lv_color_format_t cf)
@@ -107,6 +114,7 @@ void vglite_set_buf(vg_lite_buffer_t * vgbuf, void * buf,
  *   STATIC FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 static inline void _set_vgbuf_ptr(vg_lite_buffer_t * vgbuf, void * buf)
 {
     vgbuf->memory = buf;
diff --git a/src/draw/nxp/vglite/lv_vglite_matrix.c b/src/draw/nxp/vglite/lv_vglite_matrix.c
index 0594b53dc..df166874c 100644
--- a/src/draw/nxp/vglite/lv_vglite_matrix.c
+++ b/src/draw/nxp/vglite/lv_vglite_matrix.c
@@ -43,17 +43,20 @@ static vg_lite_matrix_t _vgmatrix;
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 vg_lite_matrix_t * vglite_get_matrix(void)
 {
     return &_vgmatrix;
 }
 
+LV_FUNC_SECTION
 void vglite_set_translation_matrix(const lv_area_t * dest_area)
 {
     vg_lite_identity(&_vgmatrix);
     vg_lite_translate((vg_lite_float_t)dest_area->x1, (vg_lite_float_t)dest_area->y1, &_vgmatrix);
 }
 
+LV_FUNC_SECTION
 void vglite_set_transformation_matrix(const lv_area_t * dest_area, const lv_draw_image_dsc_t * dsc)
 {
     vglite_set_translation_matrix(dest_area);
diff --git a/src/draw/nxp/vglite/lv_vglite_path.c b/src/draw/nxp/vglite/lv_vglite_path.c
index 6f8b759c8..4184afa7f 100644
--- a/src/draw/nxp/vglite/lv_vglite_path.c
+++ b/src/draw/nxp/vglite/lv_vglite_path.c
@@ -42,6 +42,7 @@
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 void vglite_create_rect_path_data(int32_t * path_data, uint32_t * path_data_size,
                                   int32_t radius,
                                   const lv_area_t * coords)
diff --git a/src/draw/nxp/vglite/lv_vglite_utils.c b/src/draw/nxp/vglite/lv_vglite_utils.c
index b3afa5a40..a982f21c6 100644
--- a/src/draw/nxp/vglite/lv_vglite_utils.c
+++ b/src/draw/nxp/vglite/lv_vglite_utils.c
@@ -48,6 +48,7 @@
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 const char * vglite_error_to_string(vg_lite_error_t error)
 {
     switch(error) {
@@ -71,12 +72,14 @@ const char * vglite_error_to_string(vg_lite_error_t error)
 }
 
 #if LV_USE_VGLITE_DRAW_ASYNC
+LV_FUNC_SECTION
 bool vglite_cmd_buf_is_flushed(void)
 {
     return _cmd_buf_flushed;
 }
 #endif
 
+LV_FUNC_SECTION
 void vglite_run(void)
 {
 #if LV_USE_VGLITE_DRAW_ASYNC
@@ -105,12 +108,14 @@ void vglite_run(void)
 }
 
 #if LV_USE_VGLITE_DRAW_ASYNC
+LV_FUNC_SECTION
 void vglite_wait_for_finish(void)
 {
     VGLITE_CHECK_ERROR(vg_lite_finish());
 }
 #endif
 
+LV_FUNC_SECTION
 vg_lite_color_t vglite_get_color(lv_color32_t lv_col32, bool gradient)
 {
     vg_lite_color_t vg_col32;
@@ -132,6 +137,7 @@ vg_lite_color_t vglite_get_color(lv_color32_t lv_col32, bool gradient)
     return vg_col32;
 }
 
+LV_FUNC_SECTION
 vg_lite_blend_t vglite_get_blend_mode(lv_blend_mode_t lv_blend_mode)
 {
     vg_lite_blend_t vg_blend_mode = VG_LITE_BLEND_NONE;
@@ -178,6 +184,7 @@ vg_lite_blend_t vglite_get_blend_mode(lv_blend_mode_t lv_blend_mode)
     return vg_blend_mode;
 }
 
+LV_FUNC_SECTION
 vg_lite_buffer_format_t vglite_get_buf_format(lv_color_format_t cf)
 {
     vg_lite_buffer_format_t vg_buffer_format = VG_LITE_BGR565;
@@ -225,6 +232,7 @@ vg_lite_buffer_format_t vglite_get_buf_format(lv_color_format_t cf)
     return vg_buffer_format;
 }
 
+LV_FUNC_SECTION
 uint8_t vglite_get_stride_alignment(lv_color_format_t cf)
 {
     uint8_t align_bytes = LV_COLOR_DEPTH / 8 * 16; /*16 pixels*/
@@ -260,6 +268,7 @@ uint8_t vglite_get_stride_alignment(lv_color_format_t cf)
     return align_bytes;
 }
 
+LV_FUNC_SECTION
 bool vglite_src_buf_aligned(const void * buf, uint32_t stride, lv_color_format_t cf)
 {
     /* No alignment requirement for destination buffer when using mode VG_LITE_LINEAR */
diff --git a/src/draw/renesas/dave2d/lv_draw_dave2d.c b/src/draw/renesas/dave2d/lv_draw_dave2d.c
index 08a814c1a..56bdda740 100644
--- a/src/draw/renesas/dave2d/lv_draw_dave2d.c
+++ b/src/draw/renesas/dave2d/lv_draw_dave2d.c
@@ -71,6 +71,7 @@ lv_ll_t  _ll_Dave2D_Tasks;
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 void lv_draw_dave2d_init(void)
 {
     d2_s32 result = D2_OK;
@@ -107,6 +108,7 @@ void lv_draw_dave2d_init(void)
  *   STATIC FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 static void lv_draw_buf_dave2d_init_handlers(void)
 {
 
@@ -120,6 +122,7 @@ static void lv_draw_buf_dave2d_init_handlers(void)
 
 #if defined(RENESAS_CORTEX_M85)
 #if (BSP_CFG_DCACHE_ENABLED)
+LV_FUNC_SECTION
 static void _dave2d_buf_invalidate_cache_cb(const lv_draw_buf_t * draw_buf, const lv_area_t * area)
 {
     const lv_image_header_t * header = &draw_buf->header;
@@ -211,6 +214,7 @@ static void _dave2d_buf_copy(void * dest_buf, uint32_t dest_w, uint32_t dest_h,
 
 #define USE_D2 (1)
 
+LV_FUNC_SECTION
 static int32_t _dave2d_evaluate(lv_draw_unit_t * u, lv_draw_task_t * t)
 {
     LV_UNUSED(u);
@@ -334,6 +338,7 @@ static int32_t _dave2d_evaluate(lv_draw_unit_t * u, lv_draw_task_t * t)
 
 #define DAVE2D_REFERRING_WATERMARK  10
 
+LV_FUNC_SECTION
 static int32_t lv_draw_dave2d_dispatch(lv_draw_unit_t * draw_unit, lv_layer_t * layer)
 {
     lv_draw_dave2d_unit_t * draw_dave2d_unit = (lv_draw_dave2d_unit_t *) draw_unit;
@@ -402,6 +407,7 @@ static int32_t lv_draw_dave2d_dispatch(lv_draw_unit_t * draw_unit, lv_layer_t *
 }
 
 #if LV_USE_OS
+LV_FUNC_SECTION
 static void _dave2d_render_thread_cb(void * ptr)
 {
     lv_draw_dave2d_unit_t * u = ptr;
@@ -427,6 +433,7 @@ static void _dave2d_render_thread_cb(void * ptr)
 }
 #endif
 
+LV_FUNC_SECTION
 static void execute_drawing(lv_draw_dave2d_unit_t * u)
 {
     /*Render the draw task*/
@@ -493,6 +500,7 @@ static void execute_drawing(lv_draw_dave2d_unit_t * u)
 
 }
 
+LV_FUNC_SECTION
 static d2_s32 lv_dave2d_init(void)
 {
     d2_s32 result = D2_OK;
@@ -557,6 +565,7 @@ static d2_s32 lv_dave2d_init(void)
     return result;
 }
 
+LV_FUNC_SECTION
 void dave2d_execute_dlist_and_flush(void)
 {
 #if LV_USE_OS
diff --git a/src/draw/renesas/dave2d/lv_draw_dave2d_arc.c b/src/draw/renesas/dave2d/lv_draw_dave2d_arc.c
index 71e03affc..a7c4fe1a9 100644
--- a/src/draw/renesas/dave2d/lv_draw_dave2d_arc.c
+++ b/src/draw/renesas/dave2d/lv_draw_dave2d_arc.c
@@ -3,6 +3,7 @@
 
 #include "../../../misc/lv_area_private.h"
 
+LV_FUNC_SECTION
 void lv_draw_dave2d_arc(lv_draw_dave2d_unit_t * u, const lv_draw_arc_dsc_t * dsc, const lv_area_t * coords)
 {
 
diff --git a/src/draw/renesas/dave2d/lv_draw_dave2d_border.c b/src/draw/renesas/dave2d/lv_draw_dave2d_border.c
index e402e7ff8..709edce22 100644
--- a/src/draw/renesas/dave2d/lv_draw_dave2d_border.c
+++ b/src/draw/renesas/dave2d/lv_draw_dave2d_border.c
@@ -11,6 +11,7 @@ static void dave2d_draw_border_simple(lv_draw_dave2d_unit_t * draw_unit, const l
                                       const lv_area_t * inner_area,
                                       lv_color_t color, lv_opa_t opa);
 
+LV_FUNC_SECTION
 void lv_draw_dave2d_border(lv_draw_dave2d_unit_t * draw_unit, const lv_draw_border_dsc_t * dsc,
                            const lv_area_t * coords)
 {
@@ -44,6 +45,7 @@ void lv_draw_dave2d_border(lv_draw_dave2d_unit_t * draw_unit, const lv_draw_bord
 
 }
 
+LV_FUNC_SECTION
 static void dave2d_draw_border_simple(lv_draw_dave2d_unit_t * u, const lv_area_t * outer_area,
                                       const lv_area_t * inner_area,
                                       lv_color_t color, lv_opa_t opa)
@@ -155,6 +157,7 @@ static void dave2d_draw_border_simple(lv_draw_dave2d_unit_t * u, const lv_area_t
 #endif
 }
 
+LV_FUNC_SECTION
 static void dave2d_draw_border_complex(lv_draw_dave2d_unit_t * u, const lv_area_t * orig_outer_area,
                                        const lv_area_t * orig_inner_area,
                                        int32_t rout, int32_t rin, lv_color_t color, lv_opa_t opa)
diff --git a/src/draw/renesas/dave2d/lv_draw_dave2d_fill.c b/src/draw/renesas/dave2d/lv_draw_dave2d_fill.c
index 546dac318..b942a986e 100644
--- a/src/draw/renesas/dave2d/lv_draw_dave2d_fill.c
+++ b/src/draw/renesas/dave2d/lv_draw_dave2d_fill.c
@@ -3,6 +3,7 @@
 
 #include "../../../misc/lv_area_private.h"
 
+LV_FUNC_SECTION
 void lv_draw_dave2d_fill(lv_draw_dave2d_unit_t * u, const lv_draw_fill_dsc_t * dsc, const lv_area_t * coords)
 {
     lv_area_t draw_area;
diff --git a/src/draw/renesas/dave2d/lv_draw_dave2d_image.c b/src/draw/renesas/dave2d/lv_draw_dave2d_image.c
index ee2438099..fd9a76802 100644
--- a/src/draw/renesas/dave2d/lv_draw_dave2d_image.c
+++ b/src/draw/renesas/dave2d/lv_draw_dave2d_image.c
@@ -39,6 +39,7 @@ static void img_draw_core(lv_draw_unit_t * u_base, const lv_draw_image_dsc_t * d
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 void lv_draw_dave2d_image(lv_draw_dave2d_unit_t * draw_unit, const lv_draw_image_dsc_t * draw_dsc,
                           const lv_area_t * coords)
 {
@@ -54,6 +55,7 @@ void lv_draw_dave2d_image(lv_draw_dave2d_unit_t * draw_unit, const lv_draw_image
  *   STATIC FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 static void img_draw_core(lv_draw_unit_t * u_base, const lv_draw_image_dsc_t * draw_dsc,
                           const lv_image_decoder_dsc_t * decoder_dsc, lv_draw_image_sup_t * sup,
                           const lv_area_t * img_coords, const lv_area_t * clipped_img_area)
diff --git a/src/draw/renesas/dave2d/lv_draw_dave2d_label.c b/src/draw/renesas/dave2d/lv_draw_dave2d_label.c
index abc417375..3cd7ca448 100644
--- a/src/draw/renesas/dave2d/lv_draw_dave2d_label.c
+++ b/src/draw/renesas/dave2d/lv_draw_dave2d_label.c
@@ -9,6 +9,7 @@ static void lv_draw_dave2d_draw_letter_cb(lv_draw_unit_t * draw_unit, lv_draw_gl
 
 static lv_draw_dave2d_unit_t * unit = NULL;
 
+LV_FUNC_SECTION
 void lv_draw_dave2d_label(lv_draw_dave2d_unit_t * u, const lv_draw_label_dsc_t * dsc, const lv_area_t * coords)
 {
     if(dsc->opa <= LV_OPA_MIN) return;
@@ -19,6 +20,7 @@ void lv_draw_dave2d_label(lv_draw_dave2d_unit_t * u, const lv_draw_label_dsc_t *
 
 }
 
+LV_FUNC_SECTION
 static void lv_draw_dave2d_draw_letter_cb(lv_draw_unit_t * u, lv_draw_glyph_dsc_t * glyph_draw_dsc,
                                           lv_draw_fill_dsc_t * fill_draw_dsc, const lv_area_t * fill_area)
 {
diff --git a/src/draw/renesas/dave2d/lv_draw_dave2d_line.c b/src/draw/renesas/dave2d/lv_draw_dave2d_line.c
index 37719260d..6c710e614 100644
--- a/src/draw/renesas/dave2d/lv_draw_dave2d_line.c
+++ b/src/draw/renesas/dave2d/lv_draw_dave2d_line.c
@@ -3,6 +3,7 @@
 
 #include "../../../misc/lv_area_private.h"
 
+LV_FUNC_SECTION
 void lv_draw_dave2d_line(lv_draw_dave2d_unit_t * u, const lv_draw_line_dsc_t * dsc)
 {
 
diff --git a/src/draw/renesas/dave2d/lv_draw_dave2d_mask_rectangle.c b/src/draw/renesas/dave2d/lv_draw_dave2d_mask_rectangle.c
index 57dbce800..30b3fc640 100644
--- a/src/draw/renesas/dave2d/lv_draw_dave2d_mask_rectangle.c
+++ b/src/draw/renesas/dave2d/lv_draw_dave2d_mask_rectangle.c
@@ -3,6 +3,7 @@
 
 #include "../../../misc/lv_area_private.h"
 
+LV_FUNC_SECTION
 void lv_draw_dave2d_mask_rect(lv_draw_dave2d_unit_t * u, const lv_draw_mask_rect_dsc_t * dsc, const lv_area_t * coords)
 {
     lv_area_t clipped_area;
diff --git a/src/draw/renesas/dave2d/lv_draw_dave2d_triangle.c b/src/draw/renesas/dave2d/lv_draw_dave2d_triangle.c
index c6f3bac76..a2a2e5b18 100644
--- a/src/draw/renesas/dave2d/lv_draw_dave2d_triangle.c
+++ b/src/draw/renesas/dave2d/lv_draw_dave2d_triangle.c
@@ -3,6 +3,7 @@
 
 #include "../../../misc/lv_area_private.h"
 
+LV_FUNC_SECTION
 void lv_draw_dave2d_triangle(lv_draw_dave2d_unit_t * u, const lv_draw_triangle_dsc_t * dsc)
 {
     lv_area_t clipped_area;
diff --git a/src/draw/renesas/dave2d/lv_draw_dave2d_utils.c b/src/draw/renesas/dave2d/lv_draw_dave2d_utils.c
index 98fb80609..911f1a8e8 100644
--- a/src/draw/renesas/dave2d/lv_draw_dave2d_utils.c
+++ b/src/draw/renesas/dave2d/lv_draw_dave2d_utils.c
@@ -34,6 +34,7 @@
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 d2_color  lv_draw_dave2d_lv_colour_to_d2_colour(lv_color_t color)
 {
     uint8_t alpha, red, green, blue;
@@ -64,6 +65,7 @@ d2_color  lv_draw_dave2d_lv_colour_to_d2_colour(lv_color_t color)
            | (blue) << 0UL;
 }
 
+LV_FUNC_SECTION
 d2_s32 lv_draw_dave2d_cf_fb_get(void)
 {
     d2_s32 d2_fb_mode = 0;
@@ -94,6 +96,7 @@ d2_s32 lv_draw_dave2d_cf_fb_get(void)
     return d2_fb_mode;
 }
 
+LV_FUNC_SECTION
 d2_u32 lv_draw_dave2d_lv_colour_fmt_to_d2_fmt(lv_color_format_t colour_format)
 {
     d2_u32 d2_lvgl_mode = 0;
@@ -120,6 +123,7 @@ d2_u32 lv_draw_dave2d_lv_colour_fmt_to_d2_fmt(lv_color_format_t colour_format)
     return d2_lvgl_mode;
 }
 
+LV_FUNC_SECTION
 void d2_framebuffer_from_layer(d2_device * handle, lv_layer_t * layer)
 {
     lv_draw_buf_t * draw_buf = layer->draw_buf;
diff --git a/src/draw/sdl/lv_draw_sdl.c b/src/draw/sdl/lv_draw_sdl.c
index c155ac114..ee50b305a 100644
--- a/src/draw/sdl/lv_draw_sdl.c
+++ b/src/draw/sdl/lv_draw_sdl.c
@@ -59,11 +59,13 @@ static SDL_Texture * layer_get_texture(lv_layer_t * layer);
 /**********************
  *   GLOBAL FUNCTIONS
  **********************/
+__attribute__(( fptrgroup("lv_cache_create_cb") ))
 static bool sdl_texture_cache_create_cb(cache_data_t * cached_data, void * user_data)
 {
     return draw_to_texture((lv_draw_sdl_unit_t *)user_data, cached_data);
 }
 
+__attribute__(( fptrgroup("lv_cache_free_cb") ))
 static void sdl_texture_cache_free_cb(cache_data_t * cached_data, void * user_data)
 {
     LV_UNUSED(user_data);
@@ -74,6 +76,7 @@ static void sdl_texture_cache_free_cb(cache_data_t * cached_data, void * user_da
     cached_data->texture = NULL;
 }
 
+__attribute__(( fptrgroup("lv_cache_compare_cb") ))
 static lv_cache_compare_res_t sdl_texture_cache_compare_cb(const cache_data_t * lhs, const cache_data_t * rhs)
 {
     if(lhs == rhs) return 0;
@@ -106,6 +109,7 @@ static lv_cache_compare_res_t sdl_texture_cache_compare_cb(const cache_data_t *
     return 0;
 }
 
+LV_FUNC_SECTION
 void lv_draw_sdl_init(void)
 {
     lv_draw_sdl_unit_t * draw_sdl_unit = lv_draw_create_unit(sizeof(lv_draw_sdl_unit_t));
@@ -124,6 +128,7 @@ void lv_draw_sdl_init(void)
  *   STATIC FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 static int32_t dispatch(lv_draw_unit_t * draw_unit, lv_layer_t * layer)
 {
     lv_draw_sdl_unit_t * draw_sdl_unit = (lv_draw_sdl_unit_t *) draw_unit;
@@ -163,6 +168,7 @@ static int32_t dispatch(lv_draw_unit_t * draw_unit, lv_layer_t * layer)
     return 1;
 }
 
+LV_FUNC_SECTION
 static int32_t evaluate(lv_draw_unit_t * draw_unit, lv_draw_task_t * task)
 {
     LV_UNUSED(draw_unit);
@@ -174,6 +180,7 @@ static int32_t evaluate(lv_draw_unit_t * draw_unit, lv_draw_task_t * task)
     return 0;
 }
 
+LV_FUNC_SECTION
 static bool draw_to_texture(lv_draw_sdl_unit_t * u, cache_data_t * cache_data)
 {
     lv_draw_task_t * task = u->task_act;
@@ -314,6 +321,7 @@ static bool draw_to_texture(lv_draw_sdl_unit_t * u, cache_data_t * cache_data)
     return true;
 }
 
+LV_FUNC_SECTION
 static void blend_texture_layer(lv_draw_sdl_unit_t * u)
 {
     lv_display_t * disp = lv_refr_get_disp_refreshing();
@@ -354,6 +362,7 @@ static void blend_texture_layer(lv_draw_sdl_unit_t * u)
     SDL_RenderSetClipRect(renderer, NULL);
 }
 
+LV_FUNC_SECTION
 static void draw_from_cached_texture(lv_draw_sdl_unit_t * u)
 {
     lv_draw_task_t * t = u->task_act;
@@ -427,6 +436,7 @@ static void draw_from_cached_texture(lv_draw_sdl_unit_t * u)
     }
 }
 
+LV_FUNC_SECTION
 static void execute_drawing(lv_draw_sdl_unit_t * u)
 {
     lv_draw_task_t * t = u->task_act;
@@ -461,6 +471,7 @@ static void execute_drawing(lv_draw_sdl_unit_t * u)
     draw_from_cached_texture(u);
 }
 
+LV_FUNC_SECTION
 static SDL_Texture * layer_get_texture(lv_layer_t * layer)
 {
     return layer->user_data;
diff --git a/src/draw/sw/blend/lv_draw_sw_blend.c b/src/draw/sw/blend/lv_draw_sw_blend.c
index 6f48eba64..ec7058cd5 100644
--- a/src/draw/sw/blend/lv_draw_sw_blend.c
+++ b/src/draw/sw/blend/lv_draw_sw_blend.c
@@ -53,6 +53,7 @@
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 void lv_draw_sw_blend(lv_draw_unit_t * draw_unit, const lv_draw_sw_blend_dsc_t * blend_dsc)
 {
     /*Do not draw transparent things*/
diff --git a/src/draw/sw/blend/lv_draw_sw_blend_to_al88.c b/src/draw/sw/blend/lv_draw_sw_blend_to_al88.c
index 9c3194c20..8163489d4 100644
--- a/src/draw/sw/blend/lv_draw_sw_blend_to_al88.c
+++ b/src/draw/sw/blend/lv_draw_sw_blend_to_al88.c
@@ -926,6 +926,7 @@ static void LV_ATTRIBUTE_FAST_MEM argb8888_image_blend(lv_draw_sw_blend_image_ds
  * @param c2    the second color
  * @return      true: equal
  */
+LV_FUNC_SECTION
 static inline bool lv_color16a_eq(lv_color16a_t c1, lv_color16a_t c2)
 {
     return *((uint16_t *)&c1) == *((uint16_t *)&c2);
@@ -986,6 +987,7 @@ static inline void LV_ATTRIBUTE_FAST_MEM lv_color_16a_16a_mix(lv_color16a_t fg,
     }
 }
 
+LV_FUNC_SECTION
 void lv_color_mix_with_alpha_cache_init(lv_color_mix_alpha_cache_t * cache)
 {
     lv_memzero(&cache->fg_saved, sizeof(lv_color16a_t));
diff --git a/src/draw/sw/blend/lv_draw_sw_blend_to_argb8888.c b/src/draw/sw/blend/lv_draw_sw_blend_to_argb8888.c
index 4bf3ef491..e0c7fe557 100644
--- a/src/draw/sw/blend/lv_draw_sw_blend_to_argb8888.c
+++ b/src/draw/sw/blend/lv_draw_sw_blend_to_argb8888.c
@@ -1008,6 +1008,7 @@ static inline lv_color32_t LV_ATTRIBUTE_FAST_MEM lv_color_32_32_mix(lv_color32_t
     }
 }
 
+LV_FUNC_SECTION
 void lv_color_mix_with_alpha_cache_init(lv_color_mix_alpha_cache_t * cache)
 {
     lv_memzero(&cache->fg_saved, sizeof(lv_color32_t));
diff --git a/src/draw/sw/lv_draw_sw.c b/src/draw/sw/lv_draw_sw.c
index 4e144b12d..bad32f4cd 100644
--- a/src/draw/sw/lv_draw_sw.c
+++ b/src/draw/sw/lv_draw_sw.c
@@ -162,6 +162,7 @@ static void rotate270_l8(const uint8_t * src, uint8_t * dst, int32_t src_width,
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 void lv_draw_sw_init(void)
 {
 
@@ -187,6 +188,7 @@ void lv_draw_sw_init(void)
 #endif
 }
 
+LV_FUNC_SECTION
 void lv_draw_sw_deinit(void)
 {
 #if LV_USE_VECTOR_GRAPHIC && LV_USE_THORVG
@@ -198,6 +200,7 @@ void lv_draw_sw_deinit(void)
 #endif
 }
 
+LV_FUNC_SECTION
 static int32_t lv_draw_sw_delete(lv_draw_unit_t * draw_unit)
 {
 #if LV_USE_OS
@@ -217,6 +220,7 @@ static int32_t lv_draw_sw_delete(lv_draw_unit_t * draw_unit)
 #endif
 }
 
+LV_FUNC_SECTION
 void lv_draw_sw_rgb565_swap(void * buf, uint32_t buf_size_px)
 {
     if(LV_DRAW_SW_RGB565_SWAP(buf, buf_size_px) == LV_RESULT_OK) return;
@@ -251,6 +255,7 @@ void lv_draw_sw_rgb565_swap(void * buf, uint32_t buf_size_px)
 
 }
 
+LV_FUNC_SECTION
 void lv_draw_sw_i1_invert(void * buf, uint32_t buf_size)
 {
     if(buf == NULL) return;
@@ -282,6 +287,7 @@ void lv_draw_sw_i1_invert(void * buf, uint32_t buf_size)
     }
 }
 
+LV_FUNC_SECTION
 void lv_draw_sw_rotate(const void * src, void * dest, int32_t src_width, int32_t src_height, int32_t src_stride,
                        int32_t dest_stride, lv_display_rotation_t rotation, lv_color_format_t color_format)
 {
@@ -379,6 +385,7 @@ void lv_draw_sw_rotate(const void * src, void * dest, int32_t src_width, int32_t
 /**********************
  *   STATIC FUNCTIONS
  **********************/
+LV_FUNC_SECTION
 static inline void execute_drawing_unit(lv_draw_sw_unit_t * u)
 {
     execute_drawing(u);
@@ -390,6 +397,7 @@ static inline void execute_drawing_unit(lv_draw_sw_unit_t * u)
     lv_draw_dispatch_request();
 }
 
+LV_FUNC_SECTION
 static int32_t evaluate(lv_draw_unit_t * draw_unit, lv_draw_task_t * task)
 {
     LV_UNUSED(draw_unit);
@@ -428,6 +436,7 @@ static int32_t evaluate(lv_draw_unit_t * draw_unit, lv_draw_task_t * task)
     return 0;
 }
 
+LV_FUNC_SECTION
 static int32_t dispatch(lv_draw_unit_t * draw_unit, lv_layer_t * layer)
 {
     LV_PROFILER_BEGIN;
@@ -468,6 +477,7 @@ static int32_t dispatch(lv_draw_unit_t * draw_unit, lv_layer_t * layer)
 }
 
 #if LV_USE_OS
+LV_FUNC_SECTION
 static void render_thread_cb(void * ptr)
 {
     lv_draw_sw_unit_t * u = ptr;
@@ -497,6 +507,7 @@ static void render_thread_cb(void * ptr)
 }
 #endif
 
+LV_FUNC_SECTION
 static void execute_drawing(lv_draw_sw_unit_t * u)
 {
     LV_PROFILER_BEGIN;
@@ -588,6 +599,7 @@ static void execute_drawing(lv_draw_sw_unit_t * u)
 
 #if LV_DRAW_SW_SUPPORT_ARGB8888
 
+LV_FUNC_SECTION
 static void rotate270_argb8888(const uint32_t * src, uint32_t * dst, int32_t src_width, int32_t src_height,
                                int32_t src_stride,
                                int32_t dst_stride)
@@ -609,6 +621,7 @@ static void rotate270_argb8888(const uint32_t * src, uint32_t * dst, int32_t src
     }
 }
 
+LV_FUNC_SECTION
 static void rotate180_argb8888(const uint32_t * src, uint32_t * dst, int32_t width, int32_t height, int32_t src_stride,
                                int32_t dest_stride)
 {
@@ -628,6 +641,7 @@ static void rotate180_argb8888(const uint32_t * src, uint32_t * dst, int32_t wid
     }
 }
 
+LV_FUNC_SECTION
 static void rotate90_argb8888(const uint32_t * src, uint32_t * dst, int32_t src_width, int32_t src_height,
                               int32_t src_stride, int32_t dst_stride)
 {
@@ -652,6 +666,7 @@ static void rotate90_argb8888(const uint32_t * src, uint32_t * dst, int32_t src_
 
 #if LV_DRAW_SW_SUPPORT_RGB888
 
+LV_FUNC_SECTION
 static void rotate90_rgb888(const uint8_t * src, uint8_t * dst, int32_t src_width, int32_t src_height,
                             int32_t src_stride,
                             int32_t dst_stride)
@@ -671,6 +686,7 @@ static void rotate90_rgb888(const uint8_t * src, uint8_t * dst, int32_t src_widt
     }
 }
 
+LV_FUNC_SECTION
 static void rotate180_rgb888(const uint8_t * src, uint8_t * dst, int32_t width, int32_t height, int32_t src_stride,
                              int32_t dest_stride)
 {
@@ -689,6 +705,7 @@ static void rotate180_rgb888(const uint8_t * src, uint8_t * dst, int32_t width,
     }
 }
 
+LV_FUNC_SECTION
 static void rotate270_rgb888(const uint8_t * src, uint8_t * dst, int32_t width, int32_t height, int32_t src_stride,
                              int32_t dst_stride)
 {
@@ -711,6 +728,7 @@ static void rotate270_rgb888(const uint8_t * src, uint8_t * dst, int32_t width,
 
 #if LV_DRAW_SW_SUPPORT_RGB565
 
+LV_FUNC_SECTION
 static void rotate270_rgb565(const uint16_t * src, uint16_t * dst, int32_t src_width, int32_t src_height,
                              int32_t src_stride,
                              int32_t dst_stride)
@@ -732,6 +750,7 @@ static void rotate270_rgb565(const uint16_t * src, uint16_t * dst, int32_t src_w
     }
 }
 
+LV_FUNC_SECTION
 static void rotate180_rgb565(const uint16_t * src, uint16_t * dst, int32_t width, int32_t height, int32_t src_stride,
                              int32_t dest_stride)
 {
@@ -751,6 +770,7 @@ static void rotate180_rgb565(const uint16_t * src, uint16_t * dst, int32_t width
     }
 }
 
+LV_FUNC_SECTION
 static void rotate90_rgb565(const uint16_t * src, uint16_t * dst, int32_t src_width, int32_t src_height,
                             int32_t src_stride,
                             int32_t dst_stride)
@@ -777,6 +797,7 @@ static void rotate90_rgb565(const uint16_t * src, uint16_t * dst, int32_t src_wi
 
 #if LV_DRAW_SW_SUPPORT_L8
 
+LV_FUNC_SECTION
 static void rotate90_l8(const uint8_t * src, uint8_t * dst, int32_t src_width, int32_t src_height,
                         int32_t src_stride,
                         int32_t dst_stride)
@@ -795,6 +816,7 @@ static void rotate90_l8(const uint8_t * src, uint8_t * dst, int32_t src_width, i
     }
 }
 
+LV_FUNC_SECTION
 static void rotate180_l8(const uint8_t * src, uint8_t * dst, int32_t width, int32_t height, int32_t src_stride,
                          int32_t dest_stride)
 {
@@ -811,6 +833,7 @@ static void rotate180_l8(const uint8_t * src, uint8_t * dst, int32_t width, int3
     }
 }
 
+LV_FUNC_SECTION
 static void rotate270_l8(const uint8_t * src, uint8_t * dst, int32_t src_width, int32_t src_height,
                          int32_t src_stride,
                          int32_t dst_stride)
diff --git a/src/draw/sw/lv_draw_sw_arc.c b/src/draw/sw/lv_draw_sw_arc.c
index ec2fb2fd9..ca0697085 100644
--- a/src/draw/sw/lv_draw_sw_arc.c
+++ b/src/draw/sw/lv_draw_sw_arc.c
@@ -50,6 +50,7 @@ static void get_rounded_area(int16_t angle, int32_t radius, uint8_t thickness, l
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 void lv_draw_sw_arc(lv_draw_unit_t * draw_unit, const lv_draw_arc_dsc_t * dsc, const lv_area_t * coords)
 {
 #if LV_DRAW_SW_COMPLEX
@@ -246,6 +247,7 @@ void lv_draw_sw_arc(lv_draw_unit_t * draw_unit, const lv_draw_arc_dsc_t * dsc, c
  *   STATIC FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 static void add_circle(const lv_opa_t * circle_mask, const lv_area_t * blend_area, const lv_area_t * circle_area,
                        lv_opa_t * mask_buf,  int32_t width)
 {
@@ -266,6 +268,7 @@ static void add_circle(const lv_opa_t * circle_mask, const lv_area_t * blend_are
 
 }
 
+LV_FUNC_SECTION
 static void get_rounded_area(int16_t angle, int32_t radius, uint8_t thickness, lv_area_t * res_area)
 {
     int32_t thick_half = thickness / 2;
@@ -303,6 +306,7 @@ static void get_rounded_area(int16_t angle, int32_t radius, uint8_t thickness, l
 
 #else /*LV_DRAW_SW_COMPLEX*/
 
+LV_FUNC_SECTION
 void lv_draw_sw_arc(lv_draw_unit_t * draw_unit, const lv_draw_arc_dsc_t * dsc, const lv_area_t * coords)
 {
     LV_UNUSED(draw_unit);
diff --git a/src/draw/sw/lv_draw_sw_border.c b/src/draw/sw/lv_draw_sw_border.c
index 07eb18c0e..82d1ee2f6 100644
--- a/src/draw/sw/lv_draw_sw_border.c
+++ b/src/draw/sw/lv_draw_sw_border.c
@@ -51,6 +51,7 @@ static void draw_border_simple(lv_draw_unit_t * draw_unit, const lv_area_t * out
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 void lv_draw_sw_border(lv_draw_unit_t * draw_unit, const lv_draw_border_dsc_t * dsc, const lv_area_t * coords)
 {
     if(dsc->opa <= LV_OPA_MIN) return;
@@ -87,6 +88,7 @@ void lv_draw_sw_border(lv_draw_unit_t * draw_unit, const lv_draw_border_dsc_t *
  *   STATIC FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 void draw_border_complex(lv_draw_unit_t * draw_unit, const lv_area_t * outer_area, const lv_area_t * inner_area,
                          int32_t rout, int32_t rin, lv_color_t color, lv_opa_t opa)
 {
@@ -285,6 +287,7 @@ void draw_border_complex(lv_draw_unit_t * draw_unit, const lv_area_t * outer_are
 
 #endif /*LV_DRAW_SW_COMPLEX*/
 }
+LV_FUNC_SECTION
 static void draw_border_simple(lv_draw_unit_t * draw_unit, const lv_area_t * outer_area, const lv_area_t * inner_area,
                                lv_color_t color, lv_opa_t opa)
 {
diff --git a/src/draw/sw/lv_draw_sw_box_shadow.c b/src/draw/sw/lv_draw_sw_box_shadow.c
index f80287566..ecfb93106 100644
--- a/src/draw/sw/lv_draw_sw_box_shadow.c
+++ b/src/draw/sw/lv_draw_sw_box_shadow.c
@@ -55,6 +55,7 @@ static void /* LV_ATTRIBUTE_FAST_MEM */ shadow_blur_corner(int32_t size, int32_t
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 void lv_draw_sw_box_shadow(lv_draw_unit_t * draw_unit, const lv_draw_box_shadow_dsc_t * dsc, const lv_area_t * coords)
 {
     /*Calculate the rectangle which is blurred to get the shadow in `shadow_area`*/
@@ -729,6 +730,7 @@ static void LV_ATTRIBUTE_FAST_MEM shadow_blur_corner(int32_t size, int32_t sw, u
 
 #else /*LV_DRAW_SW_COMPLEX*/
 
+LV_FUNC_SECTION
 void lv_draw_sw_box_shadow(lv_draw_unit_t * draw_unit, const lv_draw_box_shadow_dsc_t * dsc, const lv_area_t * coords)
 {
     LV_UNUSED(draw_unit);
diff --git a/src/draw/sw/lv_draw_sw_fill.c b/src/draw/sw/lv_draw_sw_fill.c
index 0aeb55994..788a89dd1 100644
--- a/src/draw/sw/lv_draw_sw_fill.c
+++ b/src/draw/sw/lv_draw_sw_fill.c
@@ -45,6 +45,7 @@
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 void lv_draw_sw_fill(lv_draw_unit_t * draw_unit, lv_draw_fill_dsc_t * dsc, const lv_area_t * coords)
 {
     if(dsc->opa <= LV_OPA_MIN) return;
diff --git a/src/draw/sw/lv_draw_sw_gradient.c b/src/draw/sw/lv_draw_sw_gradient.c
index 92627108c..d69ac4cf8 100644
--- a/src/draw/sw/lv_draw_sw_gradient.c
+++ b/src/draw/sw/lv_draw_sw_gradient.c
@@ -89,6 +89,7 @@ static lv_grad_t * allocate_item(const lv_grad_dsc_t * g, int32_t w, int32_t h);
  *   STATIC FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 static lv_grad_t * allocate_item(const lv_grad_dsc_t * g, int32_t w, int32_t h)
 {
     int32_t size;
@@ -120,6 +121,7 @@ static lv_grad_t * allocate_item(const lv_grad_dsc_t * g, int32_t w, int32_t h)
 
 #if LV_USE_DRAW_SW_COMPLEX_GRADIENTS
 
+LV_FUNC_SECTION
 static inline int32_t extend_w(int32_t w, lv_grad_extend_t extend)
 {
     if(extend == LV_GRAD_EXTEND_PAD) {                  /**< Repeat the same color*/
@@ -141,6 +143,7 @@ static inline int32_t extend_w(int32_t w, lv_grad_extend_t extend)
  *     FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 lv_grad_t * lv_gradient_get(const lv_grad_dsc_t * g, int32_t w, int32_t h)
 {
     /* No gradient, no cache */
@@ -214,11 +217,13 @@ void LV_ATTRIBUTE_FAST_MEM lv_gradient_color_calculate(const lv_grad_dsc_t * dsc
     *opa_out = LV_UDIV255(dsc->stops[found_i].opa * mix   + dsc->stops[found_i - 1].opa * imix);
 }
 
+LV_FUNC_SECTION
 void lv_gradient_cleanup(lv_grad_t * grad)
 {
     lv_free(grad);
 }
 
+LV_FUNC_SECTION
 void lv_gradient_init_stops(lv_grad_dsc_t * grad, const lv_color_t colors[], const lv_opa_t opa[],
                             const uint8_t fracs[], int num_stops)
 {
@@ -277,6 +282,7 @@ void lv_gradient_init_stops(lv_grad_dsc_t * grad, const lv_color_t colors[], con
 
 */
 
+LV_FUNC_SECTION
 void lv_gradient_radial_setup(lv_grad_dsc_t * dsc, const lv_area_t * coords)
 {
     lv_point_t start = dsc->params.radial.focal;
@@ -347,6 +353,7 @@ void lv_gradient_radial_setup(lv_grad_dsc_t * dsc, const lv_area_t * coords)
     }
 }
 
+LV_FUNC_SECTION
 void lv_gradient_radial_cleanup(lv_grad_dsc_t * dsc)
 {
     lv_grad_radial_state_t * state = dsc->state;
@@ -466,6 +473,7 @@ void LV_ATTRIBUTE_FAST_MEM lv_gradient_radial_get_line(lv_grad_dsc_t * dsc, int3
 
 */
 
+LV_FUNC_SECTION
 void lv_gradient_linear_setup(lv_grad_dsc_t * dsc, const lv_area_t * coords)
 {
     lv_point_t start = dsc->params.linear.start;
@@ -495,6 +503,7 @@ void lv_gradient_linear_setup(lv_grad_dsc_t * dsc, const lv_area_t * coords)
     state->c = ((start.x * dx + start.y * dy) << 16) / l2;
 }
 
+LV_FUNC_SECTION
 void lv_gradient_linear_cleanup(lv_grad_dsc_t * dsc)
 {
     lv_grad_linear_state_t * state = dsc->state;
@@ -539,6 +548,7 @@ void LV_ATTRIBUTE_FAST_MEM lv_gradient_linear_get_line(lv_grad_dsc_t * dsc, int3
         w is the unknown variable
 */
 
+LV_FUNC_SECTION
 void lv_gradient_conical_setup(lv_grad_dsc_t * dsc, const lv_area_t * coords)
 {
     lv_point_t c0 = dsc->params.conical.center;
@@ -567,6 +577,7 @@ void lv_gradient_conical_setup(lv_grad_dsc_t * dsc, const lv_area_t * coords)
     state->inv_da = (1 << 16) / (beta - alpha);
 }
 
+LV_FUNC_SECTION
 void lv_gradient_conical_cleanup(lv_grad_dsc_t * dsc)
 {
     lv_grad_conical_state_t * state = dsc->state;
@@ -618,6 +629,7 @@ void LV_ATTRIBUTE_FAST_MEM lv_gradient_conical_get_line(lv_grad_dsc_t * dsc, int
     }
 }
 
+LV_FUNC_SECTION
 void lv_grad_linear_init(lv_grad_dsc_t * dsc, int32_t from_x, int32_t from_y, int32_t to_x, int32_t to_y,
                          lv_grad_extend_t extend)
 {
@@ -629,6 +641,7 @@ void lv_grad_linear_init(lv_grad_dsc_t * dsc, int32_t from_x, int32_t from_y, in
     dsc->extend = extend;
 }
 
+LV_FUNC_SECTION
 void lv_grad_radial_init(lv_grad_dsc_t * dsc, int32_t center_x, int32_t center_y, int32_t to_x, int32_t to_y,
                          lv_grad_extend_t extend)
 {
@@ -644,6 +657,7 @@ void lv_grad_radial_init(lv_grad_dsc_t * dsc, int32_t center_x, int32_t center_y
     dsc->extend = extend;
 }
 
+LV_FUNC_SECTION
 void lv_grad_conical_init(lv_grad_dsc_t * dsc, int32_t center_x, int32_t center_y, int32_t start_angle,
                           int32_t end_angle, lv_grad_extend_t extend)
 {
@@ -655,6 +669,7 @@ void lv_grad_conical_init(lv_grad_dsc_t * dsc, int32_t center_x, int32_t center_
     dsc->extend = extend;
 }
 
+LV_FUNC_SECTION
 void lv_grad_radial_set_focal(lv_grad_dsc_t * dsc, int32_t center_x, int32_t center_y, int32_t radius)
 {
     dsc->params.radial.focal.x = center_x;
diff --git a/src/draw/sw/lv_draw_sw_img.c b/src/draw/sw/lv_draw_sw_img.c
index b7341cc72..6c43ed8ee 100644
--- a/src/draw/sw/lv_draw_sw_img.c
+++ b/src/draw/sw/lv_draw_sw_img.c
@@ -72,6 +72,7 @@ static void img_draw_core(lv_draw_unit_t * draw_unit, const lv_draw_image_dsc_t
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 void lv_draw_sw_layer(lv_draw_unit_t * draw_unit, const lv_draw_image_dsc_t * draw_dsc, const lv_area_t * coords)
 {
     lv_layer_t * layer_to_draw = (lv_layer_t *)draw_dsc->src;
@@ -164,6 +165,7 @@ void lv_draw_sw_layer(lv_draw_unit_t * draw_unit, const lv_draw_image_dsc_t * dr
 #endif
 }
 
+LV_FUNC_SECTION
 void lv_draw_sw_image(lv_draw_unit_t * draw_unit, const lv_draw_image_dsc_t * draw_dsc,
                       const lv_area_t * coords)
 {
@@ -179,6 +181,7 @@ void lv_draw_sw_image(lv_draw_unit_t * draw_unit, const lv_draw_image_dsc_t * dr
  *   STATIC FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 static void img_draw_core(lv_draw_unit_t * draw_unit, const lv_draw_image_dsc_t * draw_dsc,
                           const lv_image_decoder_dsc_t * decoder_dsc, lv_draw_image_sup_t * sup,
                           const lv_area_t * img_coords, const lv_area_t * clipped_img_area)
diff --git a/src/draw/sw/lv_draw_sw_letter.c b/src/draw/sw/lv_draw_sw_letter.c
index 3dec220d9..3be73930f 100644
--- a/src/draw/sw/lv_draw_sw_letter.c
+++ b/src/draw/sw/lv_draw_sw_letter.c
@@ -51,6 +51,7 @@ static void /* LV_ATTRIBUTE_FAST_MEM */ draw_letter_cb(lv_draw_unit_t * draw_uni
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 void lv_draw_sw_label(lv_draw_unit_t * draw_unit, const lv_draw_label_dsc_t * dsc, const lv_area_t * coords)
 {
     if(dsc->opa <= LV_OPA_MIN) return;
diff --git a/src/draw/sw/lv_draw_sw_line.c b/src/draw/sw/lv_draw_sw_line.c
index be3b19103..10d4fdf0d 100644
--- a/src/draw/sw/lv_draw_sw_line.c
+++ b/src/draw/sw/lv_draw_sw_line.c
@@ -47,6 +47,7 @@ static void /* LV_ATTRIBUTE_FAST_MEM */ draw_line_ver(lv_draw_unit_t * draw_unit
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 void lv_draw_sw_line(lv_draw_unit_t * draw_unit, const lv_draw_line_dsc_t * dsc)
 {
     if(dsc->width == 0) return;
diff --git a/src/draw/sw/lv_draw_sw_mask.c b/src/draw/sw/lv_draw_sw_mask.c
index c4fd79220..8ba8bea53 100644
--- a/src/draw/sw/lv_draw_sw_mask.c
+++ b/src/draw/sw/lv_draw_sw_mask.c
@@ -78,11 +78,13 @@ static inline lv_opa_t /* LV_ATTRIBUTE_FAST_MEM */ mask_mix(lv_opa_t mask_act, l
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 void lv_draw_sw_mask_init(void)
 {
     lv_mutex_init(&circle_cache_mutex);
 }
 
+LV_FUNC_SECTION
 void lv_draw_sw_mask_deinit(void)
 {
     lv_mutex_delete(&circle_cache_mutex);
@@ -107,6 +109,7 @@ lv_draw_sw_mask_res_t LV_ATTRIBUTE_FAST_MEM lv_draw_sw_mask_apply(void * masks[]
     return changed ? LV_DRAW_SW_MASK_RES_CHANGED : LV_DRAW_SW_MASK_RES_FULL_COVER;
 }
 
+LV_FUNC_SECTION
 void lv_draw_sw_mask_free_param(void * p)
 {
     lv_mutex_lock(&circle_cache_mutex);
@@ -127,6 +130,7 @@ void lv_draw_sw_mask_free_param(void * p)
     lv_mutex_unlock(&circle_cache_mutex);
 }
 
+LV_FUNC_SECTION
 void lv_draw_sw_mask_cleanup(void)
 {
     uint8_t i;
@@ -138,6 +142,7 @@ void lv_draw_sw_mask_cleanup(void)
     }
 }
 
+LV_FUNC_SECTION
 void lv_draw_sw_mask_line_points_init(lv_draw_sw_mask_line_param_t * param, int32_t p1x, int32_t p1y,
                                       int32_t p2x,
                                       int32_t p2y, lv_draw_sw_mask_line_side_t side)
@@ -220,6 +225,7 @@ void lv_draw_sw_mask_line_points_init(lv_draw_sw_mask_line_param_t * param, int3
     if(param->steep < 0) param->spx = -param->spx;
 }
 
+LV_FUNC_SECTION
 void lv_draw_sw_mask_line_angle_init(lv_draw_sw_mask_line_param_t * param, int32_t p1x, int32_t py, int16_t angle,
                                      lv_draw_sw_mask_line_side_t side)
 {
@@ -238,6 +244,7 @@ void lv_draw_sw_mask_line_angle_init(lv_draw_sw_mask_line_param_t * param, int32
     lv_draw_sw_mask_line_points_init(param, p1x, py, p2x, p2y, side);
 }
 
+LV_FUNC_SECTION
 void lv_draw_sw_mask_angle_init(lv_draw_sw_mask_angle_param_t * param, int32_t vertex_x, int32_t vertex_y,
                                 int32_t start_angle, int32_t end_angle)
 {
@@ -291,6 +298,7 @@ void lv_draw_sw_mask_angle_init(lv_draw_sw_mask_angle_param_t * param, int32_t v
     lv_draw_sw_mask_line_angle_init(&param->end_line, vertex_x, vertex_y, end_angle, end_side);
 }
 
+LV_FUNC_SECTION
 void lv_draw_sw_mask_radius_init(lv_draw_sw_mask_radius_param_t * param, const lv_area_t * rect, int32_t radius,
                                  bool inv)
 {
@@ -354,6 +362,7 @@ void lv_draw_sw_mask_radius_init(lv_draw_sw_mask_radius_param_t * param, const l
 
 }
 
+LV_FUNC_SECTION
 void lv_draw_sw_mask_fade_init(lv_draw_sw_mask_fade_param_t * param, const lv_area_t * coords, lv_opa_t opa_top,
                                int32_t y_top,
                                lv_opa_t opa_bottom, int32_t y_bottom)
@@ -367,6 +376,7 @@ void lv_draw_sw_mask_fade_init(lv_draw_sw_mask_fade_param_t * param, const lv_ar
     param->dsc.type = LV_DRAW_SW_MASK_TYPE_FADE;
 }
 
+LV_FUNC_SECTION
 void lv_draw_sw_mask_map_init(lv_draw_sw_mask_map_param_t * param, const lv_area_t * coords, const lv_opa_t * map)
 {
     lv_area_copy(&param->cfg.coords, coords);
@@ -378,7 +388,7 @@ void lv_draw_sw_mask_map_init(lv_draw_sw_mask_map_param_t * param, const lv_area
 /**********************
  *   STATIC FUNCTIONS
  **********************/
-
+__attribute__(( fptrgroup("lv_draw_sw_mask_cb") ))
 static lv_draw_sw_mask_res_t LV_ATTRIBUTE_FAST_MEM lv_draw_mask_line(lv_opa_t * mask_buf, int32_t abs_x,
                                                                      int32_t abs_y, int32_t len,
                                                                      lv_draw_sw_mask_line_param_t * p)
@@ -699,6 +709,7 @@ static lv_draw_sw_mask_res_t LV_ATTRIBUTE_FAST_MEM line_mask_steep(lv_opa_t * ma
     return LV_DRAW_SW_MASK_RES_CHANGED;
 }
 
+__attribute__(( fptrgroup("lv_draw_sw_mask_cb") ))
 static lv_draw_sw_mask_res_t LV_ATTRIBUTE_FAST_MEM lv_draw_mask_angle(lv_opa_t * mask_buf, int32_t abs_x,
                                                                       int32_t abs_y, int32_t len,
                                                                       lv_draw_sw_mask_angle_param_t * p)
@@ -837,6 +848,7 @@ static lv_draw_sw_mask_res_t LV_ATTRIBUTE_FAST_MEM lv_draw_mask_angle(lv_opa_t *
     }
 }
 
+__attribute__(( fptrgroup("lv_draw_sw_mask_cb") ))
 static lv_draw_sw_mask_res_t LV_ATTRIBUTE_FAST_MEM lv_draw_mask_radius(lv_opa_t * mask_buf, int32_t abs_x,
                                                                        int32_t abs_y, int32_t len,
                                                                        lv_draw_sw_mask_radius_param_t * p)
@@ -947,6 +959,7 @@ static lv_draw_sw_mask_res_t LV_ATTRIBUTE_FAST_MEM lv_draw_mask_radius(lv_opa_t
     return LV_DRAW_SW_MASK_RES_CHANGED;
 }
 
+__attribute__(( fptrgroup("lv_draw_sw_mask_cb") ))
 static lv_draw_sw_mask_res_t LV_ATTRIBUTE_FAST_MEM lv_draw_mask_fade(lv_opa_t * mask_buf, int32_t abs_x,
                                                                      int32_t abs_y, int32_t len,
                                                                      lv_draw_sw_mask_fade_param_t * p)
@@ -993,6 +1006,7 @@ static lv_draw_sw_mask_res_t LV_ATTRIBUTE_FAST_MEM lv_draw_mask_fade(lv_opa_t *
     }
 }
 
+__attribute__(( fptrgroup("lv_draw_sw_mask_cb") ))
 static lv_draw_sw_mask_res_t LV_ATTRIBUTE_FAST_MEM lv_draw_mask_map(lv_opa_t * mask_buf, int32_t abs_x,
                                                                     int32_t abs_y, int32_t len,
                                                                     lv_draw_sw_mask_map_param_t * p)
@@ -1033,6 +1047,7 @@ static lv_draw_sw_mask_res_t LV_ATTRIBUTE_FAST_MEM lv_draw_mask_map(lv_opa_t * m
  * @param tmp point to a variable. It will store temporary data
  * @param radius radius of the circle
  */
+LV_FUNC_SECTION
 static void circ_init(lv_point_t * c, int32_t * tmp, int32_t radius)
 {
     c->x = radius;
@@ -1045,6 +1060,7 @@ static void circ_init(lv_point_t * c, int32_t * tmp, int32_t radius)
  * @param c same as in circ_init
  * @return true if the circle is not ready yet
  */
+LV_FUNC_SECTION
 static bool circ_cont(lv_point_t * c)
 {
     return c->y <= c->x;
@@ -1055,6 +1071,7 @@ static bool circ_cont(lv_point_t * c)
  * @param c same as in circ_init. The next point stored here.
  * @param tmp same as in circ_init.
  */
+LV_FUNC_SECTION
 static void circ_next(lv_point_t * c, int32_t * tmp)
 {
 
@@ -1068,6 +1085,7 @@ static void circ_next(lv_point_t * c, int32_t * tmp)
     c->y++;
 }
 
+LV_FUNC_SECTION
 static void circ_calc_aa4(lv_draw_sw_mask_radius_circle_dsc_t * c, int32_t radius)
 {
     if(radius == 0) return;
@@ -1217,6 +1235,7 @@ static void circ_calc_aa4(lv_draw_sw_mask_radius_circle_dsc_t * c, int32_t radiu
     lv_free(cir_x);
 }
 
+LV_FUNC_SECTION
 static lv_opa_t * get_next_line(lv_draw_sw_mask_radius_circle_dsc_t * c, int32_t y, int32_t * len,
                                 int32_t * x_start)
 {
diff --git a/src/draw/sw/lv_draw_sw_mask_private.h b/src/draw/sw/lv_draw_sw_mask_private.h
index aeae9b8ea..448c37c2a 100644
--- a/src/draw/sw/lv_draw_sw_mask_private.h
+++ b/src/draw/sw/lv_draw_sw_mask_private.h
@@ -37,6 +37,7 @@ typedef struct  {
 } lv_draw_sw_mask_radius_circle_dsc_t;
 
 struct lv_draw_sw_mask_common_dsc_t {
+    __attribute__(( fptrgroup("lv_draw_sw_mask_cb") ))
     lv_draw_sw_mask_xcb_t cb;
     lv_draw_sw_mask_type_t type;
 };
diff --git a/src/draw/sw/lv_draw_sw_mask_rect.c b/src/draw/sw/lv_draw_sw_mask_rect.c
index bd28d0d0e..e2b7100e1 100644
--- a/src/draw/sw/lv_draw_sw_mask_rect.c
+++ b/src/draw/sw/lv_draw_sw_mask_rect.c
@@ -43,6 +43,7 @@
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 void lv_draw_sw_mask_rect(lv_draw_unit_t * draw_unit, const lv_draw_mask_rect_dsc_t * dsc, const lv_area_t * coords)
 {
     LV_UNUSED(coords);
@@ -121,6 +122,7 @@ void lv_draw_sw_mask_rect(lv_draw_unit_t * draw_unit, const lv_draw_mask_rect_ds
 
 #else /*LV_DRAW_SW_COMPLEX*/
 
+LV_FUNC_SECTION
 void lv_draw_sw_mask_rect(lv_draw_unit_t * draw_unit, const lv_draw_mask_rect_dsc_t * dsc, const lv_area_t * coords)
 {
     LV_UNUSED(draw_unit);
diff --git a/src/draw/sw/lv_draw_sw_transform.c b/src/draw/sw/lv_draw_sw_transform.c
index 41036d430..5094fd585 100644
--- a/src/draw/sw/lv_draw_sw_transform.c
+++ b/src/draw/sw/lv_draw_sw_transform.c
@@ -97,6 +97,7 @@ static void transform_l8_to_argb8888(const uint8_t * src, int32_t src_w, int32_t
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 void lv_draw_sw_transform(lv_draw_unit_t * draw_unit, const lv_area_t * dest_area, const void * src_buf,
                           int32_t src_w, int32_t src_h, int32_t src_stride,
                           const lv_draw_image_dsc_t * draw_dsc, const lv_draw_image_sup_t * sup, lv_color_format_t src_cf, void * dest_buf)
@@ -292,6 +293,7 @@ void lv_draw_sw_transform(lv_draw_unit_t * draw_unit, const lv_area_t * dest_are
 
 #if LV_DRAW_SW_SUPPORT_RGB888
 
+LV_FUNC_SECTION
 static void transform_rgb888(const uint8_t * src, int32_t src_w, int32_t src_h, int32_t src_stride,
                              int32_t xs_ups, int32_t ys_ups, int32_t xs_step, int32_t ys_step,
                              int32_t x_end, uint8_t * dest_buf, bool aa, uint32_t px_size)
@@ -392,6 +394,7 @@ static void transform_rgb888(const uint8_t * src, int32_t src_w, int32_t src_h,
 
 #if LV_DRAW_SW_SUPPORT_ARGB8888
 
+LV_FUNC_SECTION
 static void transform_argb8888(const uint8_t * src, int32_t src_w, int32_t src_h, int32_t src_stride,
                                int32_t xs_ups, int32_t ys_ups, int32_t xs_step, int32_t ys_step,
                                int32_t x_end, uint8_t * dest_buf, bool aa)
@@ -485,6 +488,7 @@ static void transform_argb8888(const uint8_t * src, int32_t src_w, int32_t src_h
 
 #if LV_DRAW_SW_SUPPORT_RGB565A8
 
+LV_FUNC_SECTION
 static void transform_rgb565a8(const uint8_t * src, int32_t src_w, int32_t src_h, int32_t src_stride,
                                int32_t xs_ups, int32_t ys_ups, int32_t xs_step, int32_t ys_step,
                                int32_t x_end, uint16_t * cbuf, uint8_t * abuf, bool src_has_a8, bool aa)
@@ -600,6 +604,7 @@ static void transform_rgb565a8(const uint8_t * src, int32_t src_w, int32_t src_h
 
 #if LV_DRAW_SW_SUPPORT_A8
 
+LV_FUNC_SECTION
 static void transform_a8(const uint8_t * src, int32_t src_w, int32_t src_h, int32_t src_stride,
                          int32_t xs_ups, int32_t ys_ups, int32_t xs_step, int32_t ys_step,
                          int32_t x_end, uint8_t * abuf, bool aa)
@@ -681,6 +686,7 @@ static void transform_a8(const uint8_t * src, int32_t src_w, int32_t src_h, int3
 #if LV_DRAW_SW_SUPPORT_AL88
 
 /* L8 will be transformed into an AL88 buffer, because it will not be recolored */
+LV_FUNC_SECTION
 static void transform_l8_to_al88(const uint8_t * src, int32_t src_w, int32_t src_h, int32_t src_stride,
                                  int32_t xs_ups, int32_t ys_ups, int32_t xs_step, int32_t ys_step,
                                  int32_t x_end, uint8_t * dest_buf, bool aa)
@@ -762,6 +768,7 @@ static void transform_l8_to_al88(const uint8_t * src, int32_t src_w, int32_t src
 #if LV_DRAW_SW_SUPPORT_ARGB8888
 
 /* L8 has to be transformed into an ARGB8888 buffer, because it will be recolored as well */
+LV_FUNC_SECTION
 static void transform_l8_to_argb8888(const uint8_t * src, int32_t src_w, int32_t src_h, int32_t src_stride,
                                      int32_t xs_ups, int32_t ys_ups, int32_t xs_step, int32_t ys_step,
                                      int32_t x_end, uint8_t * dest_buf, bool aa)
@@ -841,6 +848,7 @@ static void transform_l8_to_argb8888(const uint8_t * src, int32_t src_w, int32_t
 
 #endif
 
+LV_FUNC_SECTION
 static void transform_point_upscaled(point_transform_dsc_t * t, int32_t xin, int32_t yin, int32_t * xout,
                                      int32_t * yout)
 {
diff --git a/src/draw/sw/lv_draw_sw_triangle.c b/src/draw/sw/lv_draw_sw_triangle.c
index 4d42c4e3c..8fae50dda 100644
--- a/src/draw/sw/lv_draw_sw_triangle.c
+++ b/src/draw/sw/lv_draw_sw_triangle.c
@@ -44,6 +44,7 @@
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 void lv_draw_sw_triangle(lv_draw_unit_t * draw_unit, const lv_draw_triangle_dsc_t * dsc)
 {
 #if LV_DRAW_SW_COMPLEX
diff --git a/src/draw/sw/lv_draw_sw_vector.c b/src/draw/sw/lv_draw_sw_vector.c
index 4b99a47e9..f24e0d5d8 100644
--- a/src/draw/sw/lv_draw_sw_vector.c
+++ b/src/draw/sw/lv_draw_sw_vector.c
@@ -52,6 +52,7 @@ typedef struct {
  *      MACROS
  **********************/
 
+LV_FUNC_SECTION
 static void lv_area_to_tvg(_tvg_rect * rect, const lv_area_t * area)
 {
     rect->x = area->x1;
@@ -60,6 +61,7 @@ static void lv_area_to_tvg(_tvg_rect * rect, const lv_area_t * area)
     rect->h = lv_area_get_height(area) - 1;
 }
 
+LV_FUNC_SECTION
 static void lv_color_to_tvg(_tvg_color * color, const lv_color32_t * c, lv_opa_t opa)
 {
     color->r = c->red;
@@ -68,6 +70,7 @@ static void lv_color_to_tvg(_tvg_color * color, const lv_color32_t * c, lv_opa_t
     color->a = LV_OPA_MIX2(c->alpha, opa);
 }
 
+LV_FUNC_SECTION
 static void lv_matrix_to_tvg(Tvg_Matrix * tm, const lv_matrix_t * m)
 {
     tm->e11 = m->m[0][0];
@@ -81,11 +84,13 @@ static void lv_matrix_to_tvg(Tvg_Matrix * tm, const lv_matrix_t * m)
     tm->e33 = m->m[2][2];
 }
 
+LV_FUNC_SECTION
 static void _set_paint_matrix(Tvg_Paint * obj, const Tvg_Matrix * m)
 {
     tvg_paint_set_transform(obj, m);
 }
 
+LV_FUNC_SECTION
 static void _set_paint_shape(Tvg_Paint * obj, const lv_vector_path_t * p)
 {
     uint32_t pidx = 0;
@@ -138,6 +143,7 @@ static void _set_paint_shape(Tvg_Paint * obj, const lv_vector_path_t * p)
     }
 }
 
+LV_FUNC_SECTION
 static Tvg_Stroke_Cap lv_stroke_cap_to_tvg(lv_vector_stroke_cap_t cap)
 {
     switch(cap) {
@@ -152,6 +158,7 @@ static Tvg_Stroke_Cap lv_stroke_cap_to_tvg(lv_vector_stroke_cap_t cap)
     }
 }
 
+LV_FUNC_SECTION
 static Tvg_Stroke_Join lv_stroke_join_to_tvg(lv_vector_stroke_join_t join)
 {
     switch(join) {
@@ -166,6 +173,7 @@ static Tvg_Stroke_Join lv_stroke_join_to_tvg(lv_vector_stroke_join_t join)
     }
 }
 
+LV_FUNC_SECTION
 static Tvg_Stroke_Fill lv_spread_to_tvg(lv_vector_gradient_spread_t sp)
 {
     switch(sp) {
@@ -180,6 +188,7 @@ static Tvg_Stroke_Fill lv_spread_to_tvg(lv_vector_gradient_spread_t sp)
     }
 }
 
+LV_FUNC_SECTION
 static void _setup_gradient(Tvg_Gradient * gradient, const lv_vector_gradient_t * grad,
                             const lv_matrix_t * matrix)
 {
@@ -203,6 +212,7 @@ static void _setup_gradient(Tvg_Gradient * gradient, const lv_vector_gradient_t
     lv_free(stops);
 }
 
+LV_FUNC_SECTION
 static void _set_paint_stroke_gradient(Tvg_Paint * obj, const lv_vector_gradient_t * g, const lv_matrix_t * m)
 {
     Tvg_Gradient * grad = NULL;
@@ -220,6 +230,7 @@ static void _set_paint_stroke_gradient(Tvg_Paint * obj, const lv_vector_gradient
     }
 }
 
+LV_FUNC_SECTION
 static void _set_paint_stroke(Tvg_Paint * obj, const lv_vector_stroke_dsc_t * dsc)
 {
     if(dsc->style == LV_VECTOR_DRAW_STYLE_SOLID) {
@@ -242,6 +253,7 @@ static void _set_paint_stroke(Tvg_Paint * obj, const lv_vector_stroke_dsc_t * ds
     }
 }
 
+LV_FUNC_SECTION
 static Tvg_Fill_Rule lv_fill_rule_to_tvg(lv_vector_fill_t rule)
 {
     switch(rule) {
@@ -254,6 +266,7 @@ static Tvg_Fill_Rule lv_fill_rule_to_tvg(lv_vector_fill_t rule)
     }
 }
 
+LV_FUNC_SECTION
 static void _set_paint_fill_gradient(Tvg_Paint * obj, const lv_vector_gradient_t * g, const lv_matrix_t * m)
 {
     Tvg_Gradient * grad = NULL;
@@ -271,6 +284,7 @@ static void _set_paint_fill_gradient(Tvg_Paint * obj, const lv_vector_gradient_t
     }
 }
 
+LV_FUNC_SECTION
 static void _set_paint_fill_pattern(Tvg_Paint * obj, Tvg_Canvas * canvas, const lv_draw_image_dsc_t * p,
                                     const lv_matrix_t * m)
 {
@@ -312,6 +326,7 @@ static void _set_paint_fill_pattern(Tvg_Paint * obj, Tvg_Canvas * canvas, const
     lv_image_decoder_close(&decoder_dsc);
 }
 
+LV_FUNC_SECTION
 static void _set_paint_fill(Tvg_Paint * obj, Tvg_Canvas * canvas, const lv_vector_fill_dsc_t * dsc,
                             const lv_matrix_t * matrix)
 {
@@ -337,6 +352,7 @@ static void _set_paint_fill(Tvg_Paint * obj, Tvg_Canvas * canvas, const lv_vecto
     }
 }
 
+LV_FUNC_SECTION
 static Tvg_Blend_Method lv_blend_to_tvg(lv_vector_blend_t blend)
 {
     switch(blend) {
@@ -360,11 +376,13 @@ static Tvg_Blend_Method lv_blend_to_tvg(lv_vector_blend_t blend)
     }
 }
 
+LV_FUNC_SECTION
 static void _set_paint_blend_mode(Tvg_Paint * obj, lv_vector_blend_t blend)
 {
     tvg_paint_set_blend_method(obj, lv_blend_to_tvg(blend));
 }
 
+LV_FUNC_SECTION
 static void _task_draw_cb(void * ctx, const lv_vector_path_t * path, const lv_vector_draw_dsc_t * dsc)
 {
     Tvg_Canvas * canvas = (Tvg_Canvas *)ctx;
@@ -405,6 +423,7 @@ static void _task_draw_cb(void * ctx, const lv_vector_path_t * path, const lv_ve
 /**********************
  *   GLOBAL FUNCTIONS
  **********************/
+LV_FUNC_SECTION
 void lv_draw_sw_vector(lv_draw_unit_t * draw_unit, const lv_draw_vector_task_dsc_t * dsc)
 {
     LV_UNUSED(draw_unit);
diff --git a/src/draw/vg_lite/lv_draw_buf_vg_lite.c b/src/draw/vg_lite/lv_draw_buf_vg_lite.c
index de0b4b90b..942548628 100644
--- a/src/draw/vg_lite/lv_draw_buf_vg_lite.c
+++ b/src/draw/vg_lite/lv_draw_buf_vg_lite.c
@@ -40,6 +40,7 @@ static uint32_t width_to_stride(uint32_t w, lv_color_format_t color_format);
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 void lv_draw_buf_vg_lite_init_handlers(void)
 {
     lv_draw_buf_handlers_t * handlers = lv_draw_buf_get_handlers();
@@ -50,6 +51,7 @@ void lv_draw_buf_vg_lite_init_handlers(void)
  *   STATIC FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 static uint32_t width_to_stride(uint32_t w, lv_color_format_t color_format)
 {
     return lv_vg_lite_width_to_stride(w, lv_vg_lite_vg_fmt(color_format));
diff --git a/src/draw/vg_lite/lv_draw_vg_lite.c b/src/draw/vg_lite/lv_draw_vg_lite.c
index 1a991ce0f..92619a693 100644
--- a/src/draw/vg_lite/lv_draw_vg_lite.c
+++ b/src/draw/vg_lite/lv_draw_vg_lite.c
@@ -52,6 +52,7 @@ static int32_t draw_delete(lv_draw_unit_t * draw_unit);
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 void lv_draw_vg_lite_init(void)
 {
 #if LV_VG_LITE_USE_GPU_INIT
@@ -81,6 +82,7 @@ void lv_draw_vg_lite_init(void)
     lv_vg_lite_decoder_init();
 }
 
+LV_FUNC_SECTION
 void lv_draw_vg_lite_deinit(void)
 {
 }
@@ -89,6 +91,7 @@ void lv_draw_vg_lite_deinit(void)
  *   STATIC FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 static bool check_image_is_supported(const lv_draw_image_dsc_t * dsc)
 {
     lv_image_header_t header;
@@ -101,6 +104,7 @@ static bool check_image_is_supported(const lv_draw_image_dsc_t * dsc)
     return lv_vg_lite_is_src_cf_supported(header.cf);
 }
 
+LV_FUNC_SECTION
 static void draw_execute(lv_draw_vg_lite_unit_t * u)
 {
     lv_draw_task_t * t = u->task_act;
@@ -174,6 +178,7 @@ static void draw_execute(lv_draw_vg_lite_unit_t * u)
     lv_vg_lite_flush(u);
 }
 
+LV_FUNC_SECTION
 static int32_t draw_dispatch(lv_draw_unit_t * draw_unit, lv_layer_t * layer)
 {
     lv_draw_vg_lite_unit_t * u = (lv_draw_vg_lite_unit_t *)draw_unit;
@@ -218,6 +223,7 @@ static int32_t draw_dispatch(lv_draw_unit_t * draw_unit, lv_layer_t * layer)
     return 1;
 }
 
+LV_FUNC_SECTION
 static int32_t draw_evaluate(lv_draw_unit_t * draw_unit, lv_draw_task_t * task)
 {
     LV_UNUSED(draw_unit);
@@ -264,6 +270,7 @@ static int32_t draw_evaluate(lv_draw_unit_t * draw_unit, lv_draw_task_t * task)
     return 1;
 }
 
+LV_FUNC_SECTION
 static int32_t draw_delete(lv_draw_unit_t * draw_unit)
 {
     lv_draw_vg_lite_unit_t * unit = (lv_draw_vg_lite_unit_t *)draw_unit;
diff --git a/src/draw/vg_lite/lv_draw_vg_lite_arc.c b/src/draw/vg_lite/lv_draw_vg_lite_arc.c
index be995ceac..18dd301bb 100644
--- a/src/draw/vg_lite/lv_draw_vg_lite_arc.c
+++ b/src/draw/vg_lite/lv_draw_vg_lite_arc.c
@@ -52,6 +52,7 @@
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 void lv_draw_vg_lite_arc(lv_draw_unit_t * draw_unit, const lv_draw_arc_dsc_t * dsc,
                          const lv_area_t * coords)
 {
diff --git a/src/draw/vg_lite/lv_draw_vg_lite_border.c b/src/draw/vg_lite/lv_draw_vg_lite_border.c
index 5860baa1f..da99168ca 100644
--- a/src/draw/vg_lite/lv_draw_vg_lite_border.c
+++ b/src/draw/vg_lite/lv_draw_vg_lite_border.c
@@ -41,6 +41,7 @@
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 void lv_draw_vg_lite_border(lv_draw_unit_t * draw_unit, const lv_draw_border_dsc_t * dsc,
                             const lv_area_t * coords)
 {
diff --git a/src/draw/vg_lite/lv_draw_vg_lite_box_shadow.c b/src/draw/vg_lite/lv_draw_vg_lite_box_shadow.c
index cad9500f8..989c6836e 100644
--- a/src/draw/vg_lite/lv_draw_vg_lite_box_shadow.c
+++ b/src/draw/vg_lite/lv_draw_vg_lite_box_shadow.c
@@ -38,6 +38,7 @@
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 void lv_draw_vg_lite_box_shadow(lv_draw_unit_t * draw_unit, const lv_draw_box_shadow_dsc_t * dsc,
                                 const lv_area_t * coords)
 {
diff --git a/src/draw/vg_lite/lv_draw_vg_lite_fill.c b/src/draw/vg_lite/lv_draw_vg_lite_fill.c
index dbfd63df5..a90e54b4e 100644
--- a/src/draw/vg_lite/lv_draw_vg_lite_fill.c
+++ b/src/draw/vg_lite/lv_draw_vg_lite_fill.c
@@ -45,6 +45,7 @@
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 void lv_draw_vg_lite_fill(lv_draw_unit_t * draw_unit, const lv_draw_fill_dsc_t * dsc, const lv_area_t * coords)
 {
     lv_draw_vg_lite_unit_t * u = (lv_draw_vg_lite_unit_t *)draw_unit;
diff --git a/src/draw/vg_lite/lv_draw_vg_lite_img.c b/src/draw/vg_lite/lv_draw_vg_lite_img.c
index 86e43375e..6a5a68510 100644
--- a/src/draw/vg_lite/lv_draw_vg_lite_img.c
+++ b/src/draw/vg_lite/lv_draw_vg_lite_img.c
@@ -45,6 +45,7 @@
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 void lv_draw_vg_lite_img(lv_draw_unit_t * draw_unit, const lv_draw_image_dsc_t * dsc,
                          const lv_area_t * coords, bool no_cache)
 {
diff --git a/src/draw/vg_lite/lv_draw_vg_lite_label.c b/src/draw/vg_lite/lv_draw_vg_lite_label.c
index 6c4c365d8..408ae2a20 100644
--- a/src/draw/vg_lite/lv_draw_vg_lite_label.c
+++ b/src/draw/vg_lite/lv_draw_vg_lite_label.c
@@ -63,6 +63,7 @@ static void draw_letter_bitmap(lv_draw_vg_lite_unit_t * u, const lv_draw_glyph_d
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 void lv_draw_vg_lite_label(lv_draw_unit_t * draw_unit, const lv_draw_label_dsc_t * dsc,
                            const lv_area_t * coords)
 {
@@ -84,6 +85,7 @@ void lv_draw_vg_lite_label(lv_draw_unit_t * draw_unit, const lv_draw_label_dsc_t
  *   STATIC FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 static void draw_letter_cb(lv_draw_unit_t * draw_unit, lv_draw_glyph_dsc_t * glyph_draw_dsc,
                            lv_draw_fill_dsc_t * fill_draw_dsc, const lv_area_t * fill_area)
 {
@@ -139,6 +141,7 @@ static void draw_letter_cb(lv_draw_unit_t * draw_unit, lv_draw_glyph_dsc_t * gly
     }
 }
 
+LV_FUNC_SECTION
 static void draw_letter_bitmap(lv_draw_vg_lite_unit_t * u, const lv_draw_glyph_dsc_t * dsc)
 {
     lv_area_t clip_area;
@@ -227,6 +230,7 @@ static void draw_letter_bitmap(lv_draw_vg_lite_unit_t * u, const lv_draw_glyph_d
 
 #if LV_USE_FREETYPE
 
+LV_FUNC_SECTION
 static void draw_letter_outline(lv_draw_vg_lite_unit_t * u, const lv_draw_glyph_dsc_t * dsc)
 {
     /* get clip area */
@@ -295,6 +299,7 @@ static void draw_letter_outline(lv_draw_vg_lite_unit_t * u, const lv_draw_glyph_
     LV_PROFILER_END;
 }
 
+LV_FUNC_SECTION
 static void vg_lite_outline_push(const lv_freetype_outline_event_param_t * param)
 {
     LV_PROFILER_BEGIN;
@@ -334,6 +339,7 @@ static void vg_lite_outline_push(const lv_freetype_outline_event_param_t * param
     LV_PROFILER_END;
 }
 
+LV_FUNC_SECTION
 static void freetype_outline_event_cb(lv_event_t * e)
 {
     LV_PROFILER_BEGIN;
diff --git a/src/draw/vg_lite/lv_draw_vg_lite_layer.c b/src/draw/vg_lite/lv_draw_vg_lite_layer.c
index 8f2a17e80..277eb48d1 100644
--- a/src/draw/vg_lite/lv_draw_vg_lite_layer.c
+++ b/src/draw/vg_lite/lv_draw_vg_lite_layer.c
@@ -38,6 +38,7 @@
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 void lv_draw_vg_lite_layer(lv_draw_unit_t * draw_unit, const lv_draw_image_dsc_t * draw_dsc,
                            const lv_area_t * coords)
 {
diff --git a/src/draw/vg_lite/lv_draw_vg_lite_line.c b/src/draw/vg_lite/lv_draw_vg_lite_line.c
index e1ba695b7..003f334c5 100644
--- a/src/draw/vg_lite/lv_draw_vg_lite_line.c
+++ b/src/draw/vg_lite/lv_draw_vg_lite_line.c
@@ -43,6 +43,7 @@
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 void lv_draw_vg_lite_line(lv_draw_unit_t * draw_unit, const lv_draw_line_dsc_t * dsc)
 {
     float p1_x = dsc->p1.x;
diff --git a/src/draw/vg_lite/lv_draw_vg_lite_mask_rect.c b/src/draw/vg_lite/lv_draw_vg_lite_mask_rect.c
index 3d24b2375..faebd5c9f 100644
--- a/src/draw/vg_lite/lv_draw_vg_lite_mask_rect.c
+++ b/src/draw/vg_lite/lv_draw_vg_lite_mask_rect.c
@@ -42,6 +42,7 @@
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 void lv_draw_vg_lite_mask_rect(lv_draw_unit_t * draw_unit, const lv_draw_mask_rect_dsc_t * dsc,
                                const lv_area_t * coords)
 {
diff --git a/src/draw/vg_lite/lv_draw_vg_lite_triangle.c b/src/draw/vg_lite/lv_draw_vg_lite_triangle.c
index 63609130e..f12f9fc30 100644
--- a/src/draw/vg_lite/lv_draw_vg_lite_triangle.c
+++ b/src/draw/vg_lite/lv_draw_vg_lite_triangle.c
@@ -41,6 +41,7 @@
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 void lv_draw_vg_lite_triangle(lv_draw_unit_t * draw_unit, const lv_draw_triangle_dsc_t * dsc)
 {
     lv_area_t tri_area;
diff --git a/src/draw/vg_lite/lv_draw_vg_lite_vector.c b/src/draw/vg_lite/lv_draw_vg_lite_vector.c
index 481be5cdb..54622f7f3 100644
--- a/src/draw/vg_lite/lv_draw_vg_lite_vector.c
+++ b/src/draw/vg_lite/lv_draw_vg_lite_vector.c
@@ -54,6 +54,7 @@ static vg_lite_fill_t lv_fill_to_vg(lv_vector_fill_t fill_rule);
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 void lv_draw_vg_lite_vector(lv_draw_unit_t * draw_unit, const lv_draw_vector_task_dsc_t * dsc)
 {
     if(dsc->task_list == NULL)
@@ -72,6 +73,7 @@ void lv_draw_vg_lite_vector(lv_draw_unit_t * draw_unit, const lv_draw_vector_tas
  *   STATIC FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 static vg_lite_color_t lv_color32_to_vg(lv_color32_t color, lv_opa_t opa)
 {
     uint8_t a = LV_OPA_MIX2(color.alpha, opa);
@@ -83,6 +85,7 @@ static vg_lite_color_t lv_color32_to_vg(lv_color32_t color, lv_opa_t opa)
     return (uint32_t)a << 24 | (uint32_t)color.blue << 16 | (uint32_t)color.green << 8 | color.red;
 }
 
+LV_FUNC_SECTION
 static void task_draw_cb(void * ctx, const lv_vector_path_t * path, const lv_vector_draw_dsc_t * dsc)
 {
     LV_PROFILER_BEGIN;
@@ -291,6 +294,7 @@ static void task_draw_cb(void * ctx, const lv_vector_path_t * path, const lv_vec
     LV_PROFILER_END;
 }
 
+LV_FUNC_SECTION
 static vg_lite_quality_t lv_quality_to_vg(lv_vector_path_quality_t quality)
 {
     switch(quality) {
@@ -305,6 +309,7 @@ static vg_lite_quality_t lv_quality_to_vg(lv_vector_path_quality_t quality)
     }
 }
 
+LV_FUNC_SECTION
 static void lv_path_to_vg(lv_vg_lite_path_t * dest, const lv_vector_path_t * src)
 {
     LV_PROFILER_BEGIN;
@@ -374,6 +379,7 @@ static void lv_path_to_vg(lv_vg_lite_path_t * dest, const lv_vector_path_t * src
     LV_PROFILER_END;
 }
 
+LV_FUNC_SECTION
 static vg_lite_path_type_t lv_path_opa_to_path_type(const lv_vector_draw_dsc_t * dsc)
 {
     lv_opa_t fill_opa = dsc->fill_dsc.opa;
@@ -394,6 +400,7 @@ static vg_lite_path_type_t lv_path_opa_to_path_type(const lv_vector_draw_dsc_t *
     return VG_LITE_DRAW_ZERO;
 }
 
+LV_FUNC_SECTION
 static vg_lite_blend_t lv_blend_to_vg(lv_vector_blend_t blend)
 {
     switch(blend) {
@@ -420,6 +427,7 @@ static vg_lite_blend_t lv_blend_to_vg(lv_vector_blend_t blend)
     }
 }
 
+LV_FUNC_SECTION
 static vg_lite_fill_t lv_fill_to_vg(lv_vector_fill_t fill_rule)
 {
     switch(fill_rule) {
diff --git a/src/draw/vg_lite/lv_vg_lite_decoder.c b/src/draw/vg_lite/lv_vg_lite_decoder.c
index bb7a784bb..e1565725f 100644
--- a/src/draw/vg_lite/lv_vg_lite_decoder.c
+++ b/src/draw/vg_lite/lv_vg_lite_decoder.c
@@ -62,6 +62,7 @@ static void image_color32_pre_mul(lv_color32_t * img_data, uint32_t px_size);
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 void lv_vg_lite_decoder_init(void)
 {
     lv_image_decoder_t * decoder = lv_image_decoder_create();
@@ -72,6 +73,7 @@ void lv_vg_lite_decoder_init(void)
     decoder->name = DECODER_NAME;
 }
 
+LV_FUNC_SECTION
 void lv_vg_lite_decoder_deinit(void)
 {
     lv_image_decoder_t * dec = NULL;
@@ -87,6 +89,7 @@ void lv_vg_lite_decoder_deinit(void)
  *   STATIC FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 static void image_color32_pre_mul(lv_color32_t * img_data, uint32_t px_size)
 {
     while(px_size--) {
@@ -95,6 +98,7 @@ static void image_color32_pre_mul(lv_color32_t * img_data, uint32_t px_size)
     }
 }
 
+LV_FUNC_SECTION
 static uint32_t image_stride(const lv_image_header_t * header)
 {
     /* use stride in header */
@@ -108,6 +112,7 @@ static uint32_t image_stride(const lv_image_header_t * header)
     return ori_stride;
 }
 
+LV_FUNC_SECTION
 static void image_decode_to_index8_line(uint8_t * dest, const uint8_t * src, int32_t w_px,
                                         lv_color_format_t color_format)
 {
@@ -150,6 +155,7 @@ static void image_decode_to_index8_line(uint8_t * dest, const uint8_t * src, int
     }
 }
 
+__attribute__(( fptrgroup("lv_image_deocder_info_cb") ))
 static lv_result_t decoder_info(lv_image_decoder_t * decoder, lv_image_decoder_dsc_t * dsc, lv_image_header_t * header)
 {
     lv_result_t res = lv_bin_decoder_info(decoder, dsc, header);
@@ -170,6 +176,7 @@ static lv_result_t decoder_info(lv_image_decoder_t * decoder, lv_image_decoder_d
     return LV_RESULT_OK;
 }
 
+LV_FUNC_SECTION
 static lv_result_t decoder_open_variable(lv_image_decoder_t * decoder, lv_image_decoder_dsc_t * dsc)
 {
     LV_UNUSED(decoder); /*Unused*/
@@ -232,6 +239,7 @@ static lv_result_t decoder_open_variable(lv_image_decoder_t * decoder, lv_image_
     return LV_RESULT_OK;
 }
 
+LV_FUNC_SECTION
 static lv_result_t decoder_open_file(lv_image_decoder_t * decoder, lv_image_decoder_dsc_t * dsc)
 {
     LV_UNUSED(decoder); /*Unused*/
@@ -343,6 +351,7 @@ failed:
  * @param dsc     pointer to the decoder descriptor
  * @return LV_RESULT_OK: no error; LV_RESULT_INVALID: can't open the image
  */
+__attribute__(( fptrgroup("lv_image_deocder_open_cb") ))
 static lv_result_t decoder_open(lv_image_decoder_t * decoder, lv_image_decoder_dsc_t * dsc)
 {
     lv_result_t res = LV_RESULT_INVALID;
@@ -383,6 +392,7 @@ static lv_result_t decoder_open(lv_image_decoder_t * decoder, lv_image_decoder_d
     return res;
 }
 
+__attribute__(( fptrgroup("lv_image_deocder_close_cb") ))
 static void decoder_close(lv_image_decoder_t * decoder, lv_image_decoder_dsc_t * dsc)
 {
     LV_UNUSED(decoder); /*Unused*/
diff --git a/src/draw/vg_lite/lv_vg_lite_grad.c b/src/draw/vg_lite/lv_vg_lite_grad.c
index 5158d057d..3300e6efd 100644
--- a/src/draw/vg_lite/lv_vg_lite_grad.c
+++ b/src/draw/vg_lite/lv_vg_lite_grad.c
@@ -75,6 +75,7 @@ static vg_lite_gradient_spreadmode_t lv_spread_to_vg(lv_vector_gradient_spread_t
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 void lv_vg_lite_grad_init(struct lv_draw_vg_lite_unit_t * u, uint32_t cache_cnt)
 {
     LV_ASSERT_NULL(u);
@@ -91,6 +92,7 @@ void lv_vg_lite_grad_init(struct lv_draw_vg_lite_unit_t * u, uint32_t cache_cnt)
     lv_vg_lite_pending_set_free_cb(u->grad_pending, grad_cache_release_cb, u->grad_cache);
 }
 
+LV_FUNC_SECTION
 void lv_vg_lite_grad_deinit(struct lv_draw_vg_lite_unit_t * u)
 {
     LV_ASSERT_NULL(u);
@@ -101,6 +103,7 @@ void lv_vg_lite_grad_deinit(struct lv_draw_vg_lite_unit_t * u)
     u->grad_cache = NULL;
 }
 
+LV_FUNC_SECTION
 bool lv_vg_lite_draw_grad(
     struct lv_draw_vg_lite_unit_t * u,
     vg_lite_buffer_t * buffer,
@@ -224,6 +227,7 @@ bool lv_vg_lite_draw_grad(
     return true;
 }
 
+LV_FUNC_SECTION
 bool lv_vg_lite_draw_grad_helper(
     struct lv_draw_vg_lite_unit_t * u,
     vg_lite_buffer_t * buffer,
@@ -322,6 +326,7 @@ bool lv_vg_lite_draw_grad_helper(
  *   STATIC FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 static grad_item_t * grad_get(struct lv_draw_vg_lite_unit_t * u, const lv_vector_gradient_t * grad)
 {
     LV_ASSERT_NULL(u);
@@ -354,6 +359,7 @@ static grad_item_t * grad_get(struct lv_draw_vg_lite_unit_t * u, const lv_vector
     return lv_cache_entry_get_data(cache_node_entry);
 }
 
+LV_FUNC_SECTION
 static void grad_cache_release_cb(void * entry, void * user_data)
 {
     lv_cache_entry_t ** entry_p = entry;
@@ -361,6 +367,7 @@ static void grad_cache_release_cb(void * entry, void * user_data)
     lv_cache_release(cache, * entry_p, NULL);
 }
 
+LV_FUNC_SECTION
 static vg_lite_color_ramp_t * grad_create_color_ramp(const lv_vector_gradient_t * grad)
 {
     LV_ASSERT_NULL(grad);
@@ -385,6 +392,7 @@ static vg_lite_color_ramp_t * grad_create_color_ramp(const lv_vector_gradient_t
     return color_ramp;
 }
 
+LV_FUNC_SECTION
 static bool linear_grad_create(grad_item_t * item)
 {
     LV_PROFILER_BEGIN;
@@ -425,6 +433,7 @@ static bool linear_grad_create(grad_item_t * item)
     return true;
 }
 
+LV_FUNC_SECTION
 static bool linear_ext_grad_create(grad_item_t * item)
 {
     LV_PROFILER_BEGIN;
@@ -477,6 +486,7 @@ static bool linear_ext_grad_create(grad_item_t * item)
     return err == VG_LITE_SUCCESS;
 }
 
+LV_FUNC_SECTION
 static bool radial_grad_create(grad_item_t * item)
 {
     LV_PROFILER_BEGIN;
@@ -530,6 +540,7 @@ static bool radial_grad_create(grad_item_t * item)
     return err == VG_LITE_SUCCESS;
 }
 
+LV_FUNC_SECTION
 static grad_type_t lv_grad_style_to_type(lv_vector_gradient_style_t style)
 {
     if(style == LV_VECTOR_GRADIENT_STYLE_LINEAR) {
@@ -544,6 +555,7 @@ static grad_type_t lv_grad_style_to_type(lv_vector_gradient_style_t style)
     return GRAD_TYPE_UNKNOWN;
 }
 
+LV_FUNC_SECTION
 static void grad_point_to_matrix(vg_lite_matrix_t * grad_matrix, float x1, float y1, float x2, float y2)
 {
     vg_lite_translate(x1, y1, grad_matrix);
@@ -554,6 +566,7 @@ static void grad_point_to_matrix(vg_lite_matrix_t * grad_matrix, float x1, float
     vg_lite_scale(length / 256.0f, 1, grad_matrix);
 }
 
+LV_FUNC_SECTION
 static vg_lite_gradient_spreadmode_t lv_spread_to_vg(lv_vector_gradient_spread_t spread)
 {
     switch(spread) {
@@ -571,6 +584,7 @@ static vg_lite_gradient_spreadmode_t lv_spread_to_vg(lv_vector_gradient_spread_t
     return VG_LITE_GRADIENT_SPREAD_FILL;
 }
 
+__attribute__(( fptrgroup("lv_cache_create_cb") ))
 static bool grad_create_cb(grad_item_t * item, void * user_data)
 {
     LV_UNUSED(user_data);
@@ -593,6 +607,7 @@ static bool grad_create_cb(grad_item_t * item, void * user_data)
     return false;
 }
 
+__attribute__(( fptrgroup("lv_cache_free_cb") ))
 static void grad_free_cb(grad_item_t * item, void * user_data)
 {
     LV_UNUSED(user_data);
@@ -615,6 +630,7 @@ static void grad_free_cb(grad_item_t * item, void * user_data)
     }
 }
 
+__attribute__(( fptrgroup("lv_cache_compare_cb") ))
 static lv_cache_compare_res_t grad_compare_cb(const grad_item_t * lhs, const grad_item_t * rhs)
 {
     /* compare type first */
diff --git a/src/draw/vg_lite/lv_vg_lite_math.c b/src/draw/vg_lite/lv_vg_lite_math.c
index 52b4bb950..7ed86b17b 100644
--- a/src/draw/vg_lite/lv_vg_lite_math.c
+++ b/src/draw/vg_lite/lv_vg_lite_math.c
@@ -37,6 +37,7 @@
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 float math_fast_inv_sqrtf(float number)
 {
     int32_t i;
diff --git a/src/draw/vg_lite/lv_vg_lite_path.c b/src/draw/vg_lite/lv_vg_lite_path.c
index 9a9346b8a..9a4353290 100644
--- a/src/draw/vg_lite/lv_vg_lite_path.c
+++ b/src/draw/vg_lite/lv_vg_lite_path.c
@@ -65,6 +65,7 @@ typedef struct {
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 void lv_vg_lite_path_init(struct lv_draw_vg_lite_unit_t * unit)
 {
     LV_ASSERT_NULL(unit);
@@ -72,6 +73,7 @@ void lv_vg_lite_path_init(struct lv_draw_vg_lite_unit_t * unit)
     unit->path_in_use = false;
 }
 
+LV_FUNC_SECTION
 void lv_vg_lite_path_deinit(struct lv_draw_vg_lite_unit_t * unit)
 {
     LV_ASSERT_NULL(unit);
@@ -80,6 +82,7 @@ void lv_vg_lite_path_deinit(struct lv_draw_vg_lite_unit_t * unit)
     unit->global_path = NULL;
 }
 
+LV_FUNC_SECTION
 lv_vg_lite_path_t * lv_vg_lite_path_create(vg_lite_format_t data_format)
 {
     LV_PROFILER_BEGIN;
@@ -98,6 +101,7 @@ lv_vg_lite_path_t * lv_vg_lite_path_create(vg_lite_format_t data_format)
     return path;
 }
 
+LV_FUNC_SECTION
 void lv_vg_lite_path_destroy(lv_vg_lite_path_t * path)
 {
     LV_PROFILER_BEGIN;
@@ -113,6 +117,7 @@ void lv_vg_lite_path_destroy(lv_vg_lite_path_t * path)
     LV_PROFILER_END;
 }
 
+LV_FUNC_SECTION
 lv_vg_lite_path_t * lv_vg_lite_path_get(struct lv_draw_vg_lite_unit_t * unit, vg_lite_format_t data_format)
 {
     LV_ASSERT_NULL(unit);
@@ -123,6 +128,7 @@ lv_vg_lite_path_t * lv_vg_lite_path_get(struct lv_draw_vg_lite_unit_t * unit, vg
     return unit->global_path;
 }
 
+LV_FUNC_SECTION
 void lv_vg_lite_path_drop(struct lv_draw_vg_lite_unit_t * unit, lv_vg_lite_path_t * path)
 {
     LV_ASSERT_NULL(unit);
@@ -132,6 +138,7 @@ void lv_vg_lite_path_drop(struct lv_draw_vg_lite_unit_t * unit, lv_vg_lite_path_
     unit->path_in_use = false;
 }
 
+LV_FUNC_SECTION
 void lv_vg_lite_path_reset(lv_vg_lite_path_t * path, vg_lite_format_t data_format)
 {
     LV_ASSERT_NULL(path);
@@ -143,12 +150,14 @@ void lv_vg_lite_path_reset(lv_vg_lite_path_t * path, vg_lite_format_t data_forma
     path->has_transform = false;
 }
 
+LV_FUNC_SECTION
 vg_lite_path_t * lv_vg_lite_path_get_path(lv_vg_lite_path_t * path)
 {
     LV_ASSERT_NULL(path);
     return &path->base;
 }
 
+LV_FUNC_SECTION
 void lv_vg_lite_path_set_bonding_box(lv_vg_lite_path_t * path,
                                      float min_x, float min_y,
                                      float max_x, float max_y)
@@ -160,6 +169,7 @@ void lv_vg_lite_path_set_bonding_box(lv_vg_lite_path_t * path,
     path->base.bounding_box[3] = max_y;
 }
 
+LV_FUNC_SECTION
 void lv_vg_lite_path_set_bonding_box_area(lv_vg_lite_path_t * path, const lv_area_t * area)
 {
     LV_ASSERT_NULL(path);
@@ -167,6 +177,7 @@ void lv_vg_lite_path_set_bonding_box_area(lv_vg_lite_path_t * path, const lv_are
     lv_vg_lite_path_set_bonding_box(path, area->x1, area->y1, area->x2 + 1, area->y2 + 1);
 }
 
+LV_FUNC_SECTION
 void lv_vg_lite_path_get_bonding_box(lv_vg_lite_path_t * path,
                                      float * min_x, float * min_y,
                                      float * max_x, float * max_y)
@@ -178,6 +189,7 @@ void lv_vg_lite_path_get_bonding_box(lv_vg_lite_path_t * path,
     if(max_y) *max_y = path->base.bounding_box[3];
 }
 
+LV_FUNC_SECTION
 static void path_bounds_iter_cb(void * user_data, uint8_t op_code, const float * data, uint32_t len)
 {
     LV_UNUSED(op_code);
@@ -208,6 +220,7 @@ static void path_bounds_iter_cb(void * user_data, uint8_t op_code, const float *
     }
 }
 
+LV_FUNC_SECTION
 bool lv_vg_lite_path_update_bonding_box(lv_vg_lite_path_t * path)
 {
     LV_ASSERT_NULL(path);
@@ -237,6 +250,7 @@ bool lv_vg_lite_path_update_bonding_box(lv_vg_lite_path_t * path)
     return true;
 }
 
+LV_FUNC_SECTION
 void lv_vg_lite_path_set_transform(lv_vg_lite_path_t * path, const vg_lite_matrix_t * matrix)
 {
     LV_ASSERT_NULL(path);
@@ -247,12 +261,14 @@ void lv_vg_lite_path_set_transform(lv_vg_lite_path_t * path, const vg_lite_matri
     path->has_transform = matrix ? true : false;
 }
 
+LV_FUNC_SECTION
 void lv_vg_lite_path_set_quality(lv_vg_lite_path_t * path, vg_lite_quality_t quality)
 {
     LV_ASSERT_NULL(path);
     path->base.quality = quality;
 }
 
+LV_FUNC_SECTION
 static void lv_vg_lite_path_append_data(lv_vg_lite_path_t * path, const void * data, size_t len)
 {
     LV_ASSERT_NULL(path);
@@ -273,11 +289,13 @@ static void lv_vg_lite_path_append_data(lv_vg_lite_path_t * path, const void * d
     path->base.path_length += len;
 }
 
+LV_FUNC_SECTION
 static void lv_vg_lite_path_append_op(lv_vg_lite_path_t * path, uint32_t op)
 {
     lv_vg_lite_path_append_data(path, &op, path->format_len);
 }
 
+LV_FUNC_SECTION
 static void lv_vg_lite_path_append_point(lv_vg_lite_path_t * path, float x, float y)
 {
     if(path->has_transform) {
@@ -301,6 +319,7 @@ static void lv_vg_lite_path_append_point(lv_vg_lite_path_t * path, float x, floa
     lv_vg_lite_path_append_data(path, &iy, path->format_len);
 }
 
+LV_FUNC_SECTION
 void lv_vg_lite_path_move_to(lv_vg_lite_path_t * path,
                              float x, float y)
 {
@@ -309,6 +328,7 @@ void lv_vg_lite_path_move_to(lv_vg_lite_path_t * path,
     lv_vg_lite_path_append_point(path, x, y);
 }
 
+LV_FUNC_SECTION
 void lv_vg_lite_path_line_to(lv_vg_lite_path_t * path,
                              float x, float y)
 {
@@ -317,6 +337,7 @@ void lv_vg_lite_path_line_to(lv_vg_lite_path_t * path,
     lv_vg_lite_path_append_point(path, x, y);
 }
 
+LV_FUNC_SECTION
 void lv_vg_lite_path_quad_to(lv_vg_lite_path_t * path,
                              float cx, float cy,
                              float x, float y)
@@ -327,6 +348,7 @@ void lv_vg_lite_path_quad_to(lv_vg_lite_path_t * path,
     lv_vg_lite_path_append_point(path, x, y);
 }
 
+LV_FUNC_SECTION
 void lv_vg_lite_path_cubic_to(lv_vg_lite_path_t * path,
                               float cx1, float cy1,
                               float cx2, float cy2,
@@ -339,12 +361,14 @@ void lv_vg_lite_path_cubic_to(lv_vg_lite_path_t * path,
     lv_vg_lite_path_append_point(path, x, y);
 }
 
+LV_FUNC_SECTION
 void lv_vg_lite_path_close(lv_vg_lite_path_t * path)
 {
     LV_ASSERT_NULL(path);
     lv_vg_lite_path_append_op(path, VLC_OP_CLOSE);
 }
 
+LV_FUNC_SECTION
 void lv_vg_lite_path_end(lv_vg_lite_path_t * path)
 {
     LV_ASSERT_NULL(path);
@@ -352,6 +376,7 @@ void lv_vg_lite_path_end(lv_vg_lite_path_t * path)
     path->base.add_end = 1;
 }
 
+LV_FUNC_SECTION
 void lv_vg_lite_path_append_rect(
     lv_vg_lite_path_t * path,
     float x, float y,
@@ -421,6 +446,7 @@ void lv_vg_lite_path_append_rect(
     LV_PROFILER_END;
 }
 
+LV_FUNC_SECTION
 void lv_vg_lite_path_append_circle(
     lv_vg_lite_path_t * path,
     float cx, float cy,
@@ -440,6 +466,7 @@ void lv_vg_lite_path_append_circle(
     LV_PROFILER_END;
 }
 
+LV_FUNC_SECTION
 void lv_vg_lite_path_append_arc_right_angle(lv_vg_lite_path_t * path,
                                             float start_x, float start_y,
                                             float center_x, float center_y,
@@ -460,6 +487,7 @@ void lv_vg_lite_path_append_arc_right_angle(lv_vg_lite_path_t * path,
     LV_PROFILER_END;
 }
 
+LV_FUNC_SECTION
 void lv_vg_lite_path_append_arc(lv_vg_lite_path_t * path,
                                 float cx, float cy,
                                 float radius,
@@ -533,6 +561,7 @@ void lv_vg_lite_path_append_arc(lv_vg_lite_path_t * path,
     LV_PROFILER_END;
 }
 
+LV_FUNC_SECTION
 uint8_t lv_vg_lite_vlc_op_arg_len(uint8_t vlc_op)
 {
     switch(vlc_op) {
@@ -563,6 +592,7 @@ uint8_t lv_vg_lite_vlc_op_arg_len(uint8_t vlc_op)
     return 0;
 }
 
+LV_FUNC_SECTION
 uint8_t lv_vg_lite_path_format_len(vg_lite_format_t format)
 {
     switch(format) {
@@ -583,6 +613,7 @@ uint8_t lv_vg_lite_path_format_len(vg_lite_format_t format)
     return 0;
 }
 
+LV_FUNC_SECTION
 void lv_vg_lite_path_for_each_data(const vg_lite_path_t * path, lv_vg_lite_path_iter_cb_t cb, void * user_data)
 {
     LV_ASSERT_NULL(path);
@@ -631,6 +662,7 @@ void lv_vg_lite_path_for_each_data(const vg_lite_path_t * path, lv_vg_lite_path_
     }
 }
 
+LV_FUNC_SECTION
 void lv_vg_lite_path_append_path(lv_vg_lite_path_t * dest, const lv_vg_lite_path_t * src)
 {
     LV_ASSERT_NULL(dest);
diff --git a/src/draw/vg_lite/lv_vg_lite_pending.c b/src/draw/vg_lite/lv_vg_lite_pending.c
index b8429f0f5..3846f8a9c 100644
--- a/src/draw/vg_lite/lv_vg_lite_pending.c
+++ b/src/draw/vg_lite/lv_vg_lite_pending.c
@@ -41,6 +41,7 @@ struct lv_vg_lite_pending_t {
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 lv_vg_lite_pending_t * lv_vg_lite_pending_create(size_t obj_size, uint32_t capacity_default)
 {
     lv_vg_lite_pending_t * pending = lv_malloc_zeroed(sizeof(lv_vg_lite_pending_t));
@@ -49,6 +50,7 @@ lv_vg_lite_pending_t * lv_vg_lite_pending_create(size_t obj_size, uint32_t capac
     return pending;
 }
 
+LV_FUNC_SECTION
 void lv_vg_lite_pending_destroy(lv_vg_lite_pending_t * pending)
 {
     LV_ASSERT_NULL(pending);
@@ -58,6 +60,7 @@ void lv_vg_lite_pending_destroy(lv_vg_lite_pending_t * pending)
     lv_free(pending);
 }
 
+LV_FUNC_SECTION
 void lv_vg_lite_pending_set_free_cb(lv_vg_lite_pending_t * pending, lv_vg_lite_pending_free_cb_t free_cb,
                                     void * user_data)
 {
@@ -67,6 +70,7 @@ void lv_vg_lite_pending_set_free_cb(lv_vg_lite_pending_t * pending, lv_vg_lite_p
     pending->user_data = user_data;
 }
 
+LV_FUNC_SECTION
 void lv_vg_lite_pending_add(lv_vg_lite_pending_t * pending, void * obj)
 {
     LV_ASSERT_NULL(pending);
@@ -74,6 +78,7 @@ void lv_vg_lite_pending_add(lv_vg_lite_pending_t * pending, void * obj)
     lv_array_push_back(&pending->objs, obj);
 }
 
+LV_FUNC_SECTION
 void lv_vg_lite_pending_remove_all(lv_vg_lite_pending_t * pending)
 {
     LV_ASSERT_NULL(pending);
diff --git a/src/draw/vg_lite/lv_vg_lite_stroke.c b/src/draw/vg_lite/lv_vg_lite_stroke.c
index 1b8a20248..f93d0e02a 100644
--- a/src/draw/vg_lite/lv_vg_lite_stroke.c
+++ b/src/draw/vg_lite/lv_vg_lite_stroke.c
@@ -56,6 +56,7 @@ static lv_cache_compare_res_t stroke_compare_cb(const stroke_item_t * lhs, const
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 void lv_vg_lite_stroke_init(struct lv_draw_vg_lite_unit_t * unit, uint32_t cache_cnt)
 {
     LV_ASSERT_NULL(unit);
@@ -70,6 +71,7 @@ void lv_vg_lite_stroke_init(struct lv_draw_vg_lite_unit_t * unit, uint32_t cache
     lv_cache_set_name(unit->stroke_cache, "VG_STROKE");
 }
 
+LV_FUNC_SECTION
 void lv_vg_lite_stroke_deinit(struct lv_draw_vg_lite_unit_t * unit)
 {
     LV_ASSERT_NULL(unit);
@@ -78,6 +80,7 @@ void lv_vg_lite_stroke_deinit(struct lv_draw_vg_lite_unit_t * unit)
     unit->stroke_cache = NULL;
 }
 
+LV_FUNC_SECTION
 static vg_lite_cap_style_t lv_stroke_cap_to_vg(lv_vector_stroke_cap_t cap)
 {
     switch(cap) {
@@ -92,6 +95,7 @@ static vg_lite_cap_style_t lv_stroke_cap_to_vg(lv_vector_stroke_cap_t cap)
     }
 }
 
+LV_FUNC_SECTION
 static vg_lite_join_style_t lv_stroke_join_to_vg(lv_vector_stroke_join_t join)
 {
     switch(join) {
@@ -106,6 +110,7 @@ static vg_lite_join_style_t lv_stroke_join_to_vg(lv_vector_stroke_join_t join)
     }
 }
 
+LV_FUNC_SECTION
 lv_cache_entry_t * lv_vg_lite_stroke_get(struct lv_draw_vg_lite_unit_t * unit,
                                          struct lv_vg_lite_path_t * path,
                                          const lv_vector_stroke_dsc_t * dsc)
@@ -147,6 +152,7 @@ lv_cache_entry_t * lv_vg_lite_stroke_get(struct lv_draw_vg_lite_unit_t * unit,
     return cache_node_entry;
 }
 
+LV_FUNC_SECTION
 struct lv_vg_lite_path_t * lv_vg_lite_stroke_get_path(lv_cache_entry_t * cache_entry)
 {
     LV_ASSERT_NULL(cache_entry);
@@ -156,6 +162,7 @@ struct lv_vg_lite_path_t * lv_vg_lite_stroke_get_path(lv_cache_entry_t * cache_e
     return stroke_item->path;
 }
 
+LV_FUNC_SECTION
 void lv_vg_lite_stroke_drop(struct lv_draw_vg_lite_unit_t * unit,
                             lv_cache_entry_t * cache_entry)
 {
@@ -167,7 +174,7 @@ void lv_vg_lite_stroke_drop(struct lv_draw_vg_lite_unit_t * unit,
 /**********************
  *   STATIC FUNCTIONS
  **********************/
-
+__attribute__(( fptrgroup("lv_cache_create_cb") ))
 static bool stroke_create_cb(stroke_item_t * item, void * user_data)
 {
     LV_ASSERT_NULL(item);
@@ -235,6 +242,7 @@ static bool stroke_create_cb(stroke_item_t * item, void * user_data)
     return true;
 }
 
+__attribute__(( fptrgroup("lv_cache_free_cb") ))
 static void stroke_free_cb(stroke_item_t * item, void * user_data)
 {
     LV_UNUSED(user_data);
@@ -245,6 +253,7 @@ static void stroke_free_cb(stroke_item_t * item, void * user_data)
     lv_memzero(item, sizeof(stroke_item_t));
 }
 
+LV_FUNC_SECTION
 static lv_cache_compare_res_t path_compare(const vg_lite_path_t * lhs, const vg_lite_path_t * rhs)
 {
     LV_VG_LITE_ASSERT_PATH(lhs);
@@ -265,6 +274,7 @@ static lv_cache_compare_res_t path_compare(const vg_lite_path_t * lhs, const vg_
     return 0;
 }
 
+__attribute__(( fptrgroup("lv_cache_compare_cb") ))
 static lv_cache_compare_res_t stroke_compare_cb(const stroke_item_t * lhs, const stroke_item_t * rhs)
 {
     if(lhs->width != lhs->width) {
diff --git a/src/draw/vg_lite/lv_vg_lite_utils.c b/src/draw/vg_lite/lv_vg_lite_utils.c
index 116cbde3e..321c4369f 100644
--- a/src/draw/vg_lite/lv_vg_lite_utils.c
+++ b/src/draw/vg_lite/lv_vg_lite_utils.c
@@ -62,6 +62,7 @@ static void image_dsc_free_cb(void * dsc, void * user_data);
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 void lv_vg_lite_dump_info(void)
 {
     char name[64];
@@ -95,6 +96,7 @@ void lv_vg_lite_dump_info(void)
     LV_LOG_USER("Memory Available: %" LV_PRId32 " Bytes", (uint32_t)mem_avail);
 }
 
+LV_FUNC_SECTION
 const char * lv_vg_lite_error_string(vg_lite_error_t error)
 {
     switch(error) {
@@ -116,6 +118,7 @@ const char * lv_vg_lite_error_string(vg_lite_error_t error)
     return "UNKNOW_ERROR";
 }
 
+LV_FUNC_SECTION
 const char * lv_vg_lite_feature_string(vg_lite_feature_t feature)
 {
     switch(feature) {
@@ -171,6 +174,7 @@ const char * lv_vg_lite_feature_string(vg_lite_feature_t feature)
     return "UNKNOW_FEATURE";
 }
 
+LV_FUNC_SECTION
 const char * lv_vg_lite_buffer_format_string(vg_lite_buffer_format_t format)
 {
     switch(format) {
@@ -229,6 +233,7 @@ const char * lv_vg_lite_buffer_format_string(vg_lite_buffer_format_t format)
     return "UNKNOW_BUFFER_FORMAT";
 }
 
+LV_FUNC_SECTION
 const char * lv_vg_lite_vlc_op_string(uint8_t vlc_op)
 {
     switch(vlc_op) {
@@ -257,6 +262,7 @@ const char * lv_vg_lite_vlc_op_string(uint8_t vlc_op)
     return "UNKNOW_VLC_OP";
 }
 
+LV_FUNC_SECTION
 static void path_data_print_cb(void * user_data, uint8_t op_code, const float * data, uint32_t len)
 {
     LV_UNUSED(user_data);
@@ -268,6 +274,7 @@ static void path_data_print_cb(void * user_data, uint8_t op_code, const float *
     LV_LOG("\n");
 }
 
+LV_FUNC_SECTION
 void lv_vg_lite_path_dump_info(const vg_lite_path_t * path)
 {
     LV_ASSERT(path != NULL);
@@ -299,6 +306,7 @@ void lv_vg_lite_path_dump_info(const vg_lite_path_t * path)
     }
 }
 
+LV_FUNC_SECTION
 void lv_vg_lite_stroke_dump_info(const vg_lite_stroke_t * stroke)
 {
     LV_ASSERT(stroke != NULL);
@@ -375,6 +383,7 @@ void lv_vg_lite_stroke_dump_info(const vg_lite_stroke_t * stroke)
     LV_LOG_USER("closed: %d", (int)stroke->closed);
 }
 
+LV_FUNC_SECTION
 void lv_vg_lite_buffer_dump_info(const vg_lite_buffer_t * buffer)
 {
     LV_LOG_USER("memory: %p", (buffer)->memory);
@@ -387,6 +396,7 @@ void lv_vg_lite_buffer_dump_info(const vg_lite_buffer_t * buffer)
     LV_LOG_USER("tiled: %d", (int)((buffer)->tiled));
 }
 
+LV_FUNC_SECTION
 void lv_vg_lite_matrix_dump_info(const vg_lite_matrix_t * matrix)
 {
     for(int i = 0; i < 3; i++) {
@@ -395,6 +405,7 @@ void lv_vg_lite_matrix_dump_info(const vg_lite_matrix_t * matrix)
     }
 }
 
+LV_FUNC_SECTION
 bool lv_vg_lite_is_dest_cf_supported(lv_color_format_t cf)
 {
     switch(cf) {
@@ -414,6 +425,7 @@ bool lv_vg_lite_is_dest_cf_supported(lv_color_format_t cf)
     return false;
 }
 
+LV_FUNC_SECTION
 bool lv_vg_lite_is_src_cf_supported(lv_color_format_t cf)
 {
     switch(cf) {
@@ -444,6 +456,7 @@ bool lv_vg_lite_is_src_cf_supported(lv_color_format_t cf)
     return false;
 }
 
+LV_FUNC_SECTION
 vg_lite_buffer_format_t lv_vg_lite_vg_fmt(lv_color_format_t cf)
 {
     switch(cf) {
@@ -495,6 +508,7 @@ vg_lite_buffer_format_t lv_vg_lite_vg_fmt(lv_color_format_t cf)
     return 0;
 }
 
+LV_FUNC_SECTION
 void lv_vg_lite_buffer_format_bytes(
     vg_lite_buffer_format_t format,
     uint32_t * mul,
@@ -584,6 +598,7 @@ void lv_vg_lite_buffer_format_bytes(
     }
 }
 
+LV_FUNC_SECTION
 uint32_t lv_vg_lite_width_to_stride(uint32_t w, vg_lite_buffer_format_t color_format)
 {
     w = lv_vg_lite_width_align(w);
@@ -593,6 +608,7 @@ uint32_t lv_vg_lite_width_to_stride(uint32_t w, vg_lite_buffer_format_t color_fo
     return LV_VG_LITE_ALIGN(((w * mul + div - 1) / div), align);
 }
 
+LV_FUNC_SECTION
 uint32_t lv_vg_lite_width_align(uint32_t w)
 {
     if(lv_vg_lite_16px_align()) {
@@ -602,6 +618,7 @@ uint32_t lv_vg_lite_width_align(uint32_t w)
     return w;
 }
 
+LV_FUNC_SECTION
 void lv_vg_lite_buffer_init(
     vg_lite_buffer_t * buffer,
     const void * ptr,
@@ -655,6 +672,7 @@ void lv_vg_lite_buffer_init(
     }
 }
 
+LV_FUNC_SECTION
 void lv_vg_lite_buffer_from_draw_buf(vg_lite_buffer_t * buffer, const lv_draw_buf_t * draw_buf)
 {
     LV_ASSERT_NULL(buffer);
@@ -683,6 +701,7 @@ void lv_vg_lite_buffer_from_draw_buf(vg_lite_buffer_t * buffer, const lv_draw_bu
     }
 }
 
+LV_FUNC_SECTION
 void lv_vg_lite_image_matrix(vg_lite_matrix_t * matrix, int32_t x, int32_t y, const lv_draw_image_dsc_t * dsc)
 {
     LV_ASSERT_NULL(matrix);
@@ -713,6 +732,7 @@ void lv_vg_lite_image_matrix(vg_lite_matrix_t * matrix, int32_t x, int32_t y, co
     }
 }
 
+LV_FUNC_SECTION
 bool lv_vg_lite_buffer_open_image(vg_lite_buffer_t * buffer, lv_image_decoder_dsc_t * decoder_dsc, const void * src,
                                   bool no_cache, bool premultiply)
 {
@@ -758,18 +778,21 @@ bool lv_vg_lite_buffer_open_image(vg_lite_buffer_t * buffer, lv_image_decoder_ds
     return true;
 }
 
+LV_FUNC_SECTION
 void lv_vg_lite_image_dsc_init(struct lv_draw_vg_lite_unit_t * unit)
 {
     unit->image_dsc_pending = lv_vg_lite_pending_create(sizeof(lv_image_decoder_dsc_t), 4);
     lv_vg_lite_pending_set_free_cb(unit->image_dsc_pending, image_dsc_free_cb, NULL);
 }
 
+LV_FUNC_SECTION
 void lv_vg_lite_image_dsc_deinit(struct lv_draw_vg_lite_unit_t * unit)
 {
     lv_vg_lite_pending_destroy(unit->image_dsc_pending);
     unit->image_dsc_pending = NULL;
 }
 
+LV_FUNC_SECTION
 void lv_vg_lite_rect(vg_lite_rectangle_t * rect, const lv_area_t * area)
 {
     rect->x = area->x1;
@@ -778,11 +801,13 @@ void lv_vg_lite_rect(vg_lite_rectangle_t * rect, const lv_area_t * area)
     rect->height = lv_area_get_height(area);
 }
 
+LV_FUNC_SECTION
 void lv_vg_lite_matrix(vg_lite_matrix_t * dest, const lv_matrix_t * src)
 {
     lv_memcpy(dest, src, sizeof(lv_matrix_t));
 }
 
+LV_FUNC_SECTION
 uint32_t lv_vg_lite_get_palette_size(vg_lite_buffer_format_t format)
 {
     uint32_t size = 0;
@@ -805,6 +830,7 @@ uint32_t lv_vg_lite_get_palette_size(vg_lite_buffer_format_t format)
     return size;
 }
 
+LV_FUNC_SECTION
 vg_lite_color_t lv_vg_lite_color(lv_color_t color, lv_opa_t opa, bool pre_mul)
 {
     if(pre_mul && opa < LV_OPA_COVER) {
@@ -815,6 +841,7 @@ vg_lite_color_t lv_vg_lite_color(lv_color_t color, lv_opa_t opa, bool pre_mul)
     return (uint32_t)opa << 24 | (uint32_t)color.blue << 16 | (uint32_t)color.green << 8 | color.red;
 }
 
+LV_FUNC_SECTION
 vg_lite_blend_t lv_vg_lite_blend_mode(lv_blend_mode_t blend_mode, bool has_pre_mul)
 {
     if(!has_pre_mul && vg_lite_query_feature(gcFEATURE_BIT_VG_LVGL_SUPPORT)) {
@@ -857,6 +884,7 @@ vg_lite_blend_t lv_vg_lite_blend_mode(lv_blend_mode_t blend_mode, bool has_pre_m
     }
 }
 
+LV_FUNC_SECTION
 bool lv_vg_lite_buffer_check(const vg_lite_buffer_t * buffer, bool is_src)
 {
     uint32_t mul;
@@ -933,6 +961,7 @@ bool lv_vg_lite_buffer_check(const vg_lite_buffer_t * buffer, bool is_src)
     return true;
 }
 
+LV_FUNC_SECTION
 bool lv_vg_lite_path_check(const vg_lite_path_t * path)
 {
     if(path == NULL) {
@@ -1007,6 +1036,7 @@ bool lv_vg_lite_path_check(const vg_lite_path_t * path)
     return true;
 }
 
+LV_FUNC_SECTION
 bool lv_vg_lite_matrix_check(const vg_lite_matrix_t * matrix)
 {
     if(matrix == NULL) {
@@ -1024,6 +1054,7 @@ bool lv_vg_lite_matrix_check(const vg_lite_matrix_t * matrix)
     return true;
 }
 
+LV_FUNC_SECTION
 bool lv_vg_lite_support_blend_normal(void)
 {
     if(vg_lite_query_feature(gcFEATURE_BIT_VG_HW_PREMULTIPLY)) {
@@ -1037,11 +1068,13 @@ bool lv_vg_lite_support_blend_normal(void)
     return false;
 }
 
+LV_FUNC_SECTION
 bool lv_vg_lite_16px_align(void)
 {
     return vg_lite_query_feature(gcFEATURE_BIT_VG_16PIXELS_ALIGN);
 }
 
+LV_FUNC_SECTION
 void lv_vg_lite_matrix_multiply(vg_lite_matrix_t * matrix, const vg_lite_matrix_t * mult)
 {
     vg_lite_matrix_t temp;
@@ -1063,6 +1096,7 @@ void lv_vg_lite_matrix_multiply(vg_lite_matrix_t * matrix, const vg_lite_matrix_
     lv_memcpy(matrix, &temp, sizeof(temp));
 }
 
+LV_FUNC_SECTION
 bool lv_vg_lite_matrix_inverse(vg_lite_matrix_t * result, const vg_lite_matrix_t * matrix)
 {
     vg_lite_float_t det00, det01, det02;
@@ -1118,6 +1152,7 @@ bool lv_vg_lite_matrix_inverse(vg_lite_matrix_t * result, const vg_lite_matrix_t
     return true;
 }
 
+LV_FUNC_SECTION
 lv_point_precise_t lv_vg_lite_matrix_transform_point(const vg_lite_matrix_t * matrix, const lv_point_precise_t * point)
 {
     lv_point_precise_t p;
@@ -1127,6 +1162,7 @@ lv_point_precise_t lv_vg_lite_matrix_transform_point(const vg_lite_matrix_t * ma
     return p;
 }
 
+LV_FUNC_SECTION
 void lv_vg_lite_set_scissor_area(const lv_area_t * area)
 {
 #if VGLITE_RELEASE_VERSION <= VGLITE_MAKE_VERSION(4,0,57)
@@ -1148,6 +1184,7 @@ void lv_vg_lite_set_scissor_area(const lv_area_t * area)
                                area->y2 + 1));
 }
 
+LV_FUNC_SECTION
 void lv_vg_lite_disable_scissor(void)
 {
     /* Restore full screen scissor */
@@ -1158,6 +1195,7 @@ void lv_vg_lite_disable_scissor(void)
                                LV_VER_RES));
 }
 
+LV_FUNC_SECTION
 void lv_vg_lite_flush(struct lv_draw_vg_lite_unit_t * u)
 {
     LV_ASSERT_NULL(u);
@@ -1186,6 +1224,7 @@ void lv_vg_lite_flush(struct lv_draw_vg_lite_unit_t * u)
     LV_PROFILER_END;
 }
 
+LV_FUNC_SECTION
 void lv_vg_lite_finish(struct lv_draw_vg_lite_unit_t * u)
 {
     LV_ASSERT_NULL(u);
@@ -1208,6 +1247,7 @@ void lv_vg_lite_finish(struct lv_draw_vg_lite_unit_t * u)
  *   STATIC FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 static void image_dsc_free_cb(void * dsc, void * user_data)
 {
     LV_UNUSED(user_data);
diff --git a/src/drivers/display/drm/lv_linux_drm.c b/src/drivers/display/drm/lv_linux_drm.c
index 29e0168d9..0b80826ba 100644
--- a/src/drivers/display/drm/lv_linux_drm.c
+++ b/src/drivers/display/drm/lv_linux_drm.c
@@ -110,6 +110,7 @@ static uint32_t tick_get_cb(void);
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 lv_display_t * lv_linux_drm_create(void)
 {
     lv_tick_set_cb(tick_get_cb);
@@ -131,6 +132,7 @@ lv_display_t * lv_linux_drm_create(void)
     return disp;
 }
 
+LV_FUNC_SECTION
 void lv_linux_drm_set_file(lv_display_t * disp, const char * file, int64_t connector_id)
 {
     drm_dev_t * drm_dev = lv_display_get_driver_data(disp);
@@ -177,6 +179,7 @@ void lv_linux_drm_set_file(lv_display_t * disp, const char * file, int64_t conne
  *   STATIC FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 static uint32_t get_plane_property_id(drm_dev_t * drm_dev, const char * name)
 {
     uint32_t i;
@@ -192,6 +195,7 @@ static uint32_t get_plane_property_id(drm_dev_t * drm_dev, const char * name)
     return 0;
 }
 
+LV_FUNC_SECTION
 static uint32_t get_crtc_property_id(drm_dev_t * drm_dev, const char * name)
 {
     uint32_t i;
@@ -207,6 +211,7 @@ static uint32_t get_crtc_property_id(drm_dev_t * drm_dev, const char * name)
     return 0;
 }
 
+LV_FUNC_SECTION
 static uint32_t get_conn_property_id(drm_dev_t * drm_dev, const char * name)
 {
     uint32_t i;
@@ -222,6 +227,7 @@ static uint32_t get_conn_property_id(drm_dev_t * drm_dev, const char * name)
     return 0;
 }
 
+LV_FUNC_SECTION
 static void page_flip_handler(int fd, unsigned int sequence, unsigned int tv_sec, unsigned int tv_usec,
                               void * user_data)
 {
@@ -237,6 +243,7 @@ static void page_flip_handler(int fd, unsigned int sequence, unsigned int tv_sec
     }
 }
 
+LV_FUNC_SECTION
 static int drm_get_plane_props(drm_dev_t * drm_dev)
 {
     uint32_t i;
@@ -258,6 +265,7 @@ static int drm_get_plane_props(drm_dev_t * drm_dev)
     return 0;
 }
 
+LV_FUNC_SECTION
 static int drm_get_crtc_props(drm_dev_t * drm_dev)
 {
     uint32_t i;
@@ -279,6 +287,7 @@ static int drm_get_crtc_props(drm_dev_t * drm_dev)
     return 0;
 }
 
+LV_FUNC_SECTION
 static int drm_get_conn_props(drm_dev_t * drm_dev)
 {
     uint32_t i;
@@ -300,6 +309,7 @@ static int drm_get_conn_props(drm_dev_t * drm_dev)
     return 0;
 }
 
+LV_FUNC_SECTION
 static int drm_add_plane_property(drm_dev_t * drm_dev, const char * name, uint64_t value)
 {
     int ret;
@@ -319,6 +329,7 @@ static int drm_add_plane_property(drm_dev_t * drm_dev, const char * name, uint64
     return 0;
 }
 
+LV_FUNC_SECTION
 static int drm_add_crtc_property(drm_dev_t * drm_dev, const char * name, uint64_t value)
 {
     int ret;
@@ -338,6 +349,7 @@ static int drm_add_crtc_property(drm_dev_t * drm_dev, const char * name, uint64_
     return 0;
 }
 
+LV_FUNC_SECTION
 static int drm_add_conn_property(drm_dev_t * drm_dev, const char * name, uint64_t value)
 {
     int ret;
@@ -357,6 +369,7 @@ static int drm_add_conn_property(drm_dev_t * drm_dev, const char * name, uint64_
     return 0;
 }
 
+LV_FUNC_SECTION
 static int drm_dmabuf_set_plane(drm_dev_t * drm_dev, drm_buffer_t * buf)
 {
     int ret;
@@ -398,6 +411,7 @@ static int drm_dmabuf_set_plane(drm_dev_t * drm_dev, drm_buffer_t * buf)
     return 0;
 }
 
+LV_FUNC_SECTION
 static int find_plane(drm_dev_t * drm_dev, unsigned int fourcc, uint32_t * plane_id, uint32_t crtc_id,
                       uint32_t crtc_idx)
 {
@@ -455,6 +469,7 @@ static int find_plane(drm_dev_t * drm_dev, unsigned int fourcc, uint32_t * plane
     return ret;
 }
 
+LV_FUNC_SECTION
 static int drm_find_connector(drm_dev_t * drm_dev, int64_t connector_id)
 {
     drmModeConnector * conn = NULL;
@@ -610,6 +625,7 @@ free_res:
     return -1;
 }
 
+LV_FUNC_SECTION
 static int drm_open(const char * path)
 {
     int fd, flags;
@@ -643,6 +659,7 @@ err:
     return -1;
 }
 
+LV_FUNC_SECTION
 static int drm_setup(drm_dev_t * drm_dev, const char * device_path, int64_t connector_id, unsigned int fourcc)
 {
     int ret;
@@ -723,6 +740,7 @@ err:
     return -1;
 }
 
+LV_FUNC_SECTION
 static int drm_allocate_dumb(drm_dev_t * drm_dev, drm_buffer_t * buf)
 {
     struct drm_mode_create_dumb creq;
@@ -781,6 +799,7 @@ static int drm_allocate_dumb(drm_dev_t * drm_dev, drm_buffer_t * buf)
     return 0;
 }
 
+LV_FUNC_SECTION
 static int drm_setup_buffers(drm_dev_t * drm_dev)
 {
     int ret;
@@ -797,6 +816,7 @@ static int drm_setup_buffers(drm_dev_t * drm_dev)
     return 0;
 }
 
+__attribute__(( fptrgroup("lv_display_flush_wait_cb") ))
 static void drm_flush_wait(lv_display_t * disp)
 {
     drm_dev_t * drm_dev = lv_display_get_driver_data(disp);
@@ -820,6 +840,7 @@ static void drm_flush_wait(lv_display_t * disp)
     }
 }
 
+__attribute__(( fptrgroup("lv_display_flush_cb") ))
 static void drm_flush(lv_display_t * disp, const lv_area_t * area, uint8_t * px_map)
 {
     if(!lv_display_flush_is_last(disp)) return;
@@ -841,6 +862,7 @@ static void drm_flush(lv_display_t * disp, const lv_area_t * area, uint8_t * px_
     }
 }
 
+LV_FUNC_SECTION
 static uint32_t tick_get_cb(void)
 {
     struct timespec t;
diff --git a/src/drivers/display/fb/lv_linux_fbdev.c b/src/drivers/display/fb/lv_linux_fbdev.c
index 076ada41a..899715377 100644
--- a/src/drivers/display/fb/lv_linux_fbdev.c
+++ b/src/drivers/display/fb/lv_linux_fbdev.c
@@ -94,6 +94,7 @@ static uint32_t tick_get_cb(void);
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 lv_display_t * lv_linux_fbdev_create(void)
 {
     lv_tick_set_cb(tick_get_cb);
@@ -114,6 +115,7 @@ lv_display_t * lv_linux_fbdev_create(void)
     return disp;
 }
 
+LV_FUNC_SECTION
 void lv_linux_fbdev_set_file(lv_display_t * disp, const char * file)
 {
     char * devname = lv_malloc(lv_strlen(file) + 1);
@@ -240,6 +242,7 @@ void lv_linux_fbdev_set_file(lv_display_t * disp, const char * file)
                 hor_res, ver_res, lv_display_get_dpi(disp));
 }
 
+LV_FUNC_SECTION
 void lv_linux_fbdev_set_force_refresh(lv_display_t * disp, bool enabled)
 {
     lv_linux_fb_t * dsc = lv_display_get_driver_data(disp);
@@ -250,6 +253,7 @@ void lv_linux_fbdev_set_force_refresh(lv_display_t * disp, bool enabled)
  *   STATIC FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 static void flush_cb(lv_display_t * disp, const lv_area_t * area, uint8_t * color_p)
 {
     lv_linux_fb_t * dsc = lv_display_get_driver_data(disp);
@@ -348,6 +352,7 @@ static void flush_cb(lv_display_t * disp, const lv_area_t * area, uint8_t * colo
     lv_display_flush_ready(disp);
 }
 
+LV_FUNC_SECTION
 static uint32_t tick_get_cb(void)
 {
     struct timespec t;
diff --git a/src/drivers/display/ili9341/lv_ili9341.c b/src/drivers/display/ili9341/lv_ili9341.c
index a6b2acf7e..535e54507 100644
--- a/src/drivers/display/ili9341/lv_ili9341.c
+++ b/src/drivers/display/ili9341/lv_ili9341.c
@@ -82,6 +82,7 @@ static const uint8_t init_cmd_list[] = {
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 lv_display_t * lv_ili9341_create(uint32_t hor_res, uint32_t ver_res, lv_lcd_flag_t flags,
                                  lv_ili9341_send_cmd_cb_t send_cmd_cb, lv_ili9341_send_color_cb_t send_color_cb)
 {
@@ -90,21 +91,25 @@ lv_display_t * lv_ili9341_create(uint32_t hor_res, uint32_t ver_res, lv_lcd_flag
     return disp;
 }
 
+LV_FUNC_SECTION
 void lv_ili9341_set_gap(lv_display_t * disp, uint16_t x, uint16_t y)
 {
     lv_lcd_generic_mipi_set_gap(disp, x, y);
 }
 
+LV_FUNC_SECTION
 void lv_ili9341_set_invert(lv_display_t * disp, bool invert)
 {
     lv_lcd_generic_mipi_set_invert(disp, invert);
 }
 
+LV_FUNC_SECTION
 void lv_ili9341_set_gamma_curve(lv_display_t * disp, uint8_t gamma)
 {
     lv_lcd_generic_mipi_set_gamma_curve(disp, gamma);
 }
 
+LV_FUNC_SECTION
 void lv_ili9341_send_cmd_list(lv_display_t * disp, const uint8_t * cmd_list)
 {
     lv_lcd_generic_mipi_send_cmd_list(disp, cmd_list);
diff --git a/src/drivers/display/lcd/lv_lcd_generic_mipi.c b/src/drivers/display/lcd/lv_lcd_generic_mipi.c
index e27e4c860..b55120314 100644
--- a/src/drivers/display/lcd/lv_lcd_generic_mipi.c
+++ b/src/drivers/display/lcd/lv_lcd_generic_mipi.c
@@ -45,6 +45,7 @@ static void flush_cb(lv_display_t * disp, const lv_area_t * area, uint8_t * px_m
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 lv_display_t * lv_lcd_generic_mipi_create(uint32_t hor_res, uint32_t ver_res, lv_lcd_flag_t flags,
                                           lv_lcd_send_cmd_cb_t send_cmd_cb, lv_lcd_send_color_cb_t send_color_cb)
 {
@@ -77,6 +78,7 @@ lv_display_t * lv_lcd_generic_mipi_create(uint32_t hor_res, uint32_t ver_res, lv
     return disp;
 }
 
+LV_FUNC_SECTION
 void lv_lcd_generic_mipi_set_gap(lv_display_t * disp, uint16_t x, uint16_t y)
 {
     lv_lcd_generic_mipi_driver_t * drv = get_driver(disp);
@@ -84,12 +86,14 @@ void lv_lcd_generic_mipi_set_gap(lv_display_t * disp, uint16_t x, uint16_t y)
     drv->y_gap = y;
 }
 
+LV_FUNC_SECTION
 void lv_lcd_generic_mipi_set_invert(lv_display_t * disp, bool invert)
 {
     lv_lcd_generic_mipi_driver_t * drv = get_driver(disp);
     send_cmd(drv, invert ? LV_LCD_CMD_ENTER_INVERT_MODE : LV_LCD_CMD_EXIT_INVERT_MODE, NULL, 0);
 }
 
+LV_FUNC_SECTION
 void lv_lcd_generic_mipi_set_address_mode(lv_display_t * disp, bool mirror_x, bool mirror_y, bool swap_xy, bool bgr)
 {
     lv_lcd_generic_mipi_driver_t * drv = get_driver(disp);
@@ -104,6 +108,7 @@ void lv_lcd_generic_mipi_set_address_mode(lv_display_t * disp, bool mirror_x, bo
     set_rotation(drv, lv_display_get_rotation(disp));   /* update screen */
 }
 
+LV_FUNC_SECTION
 void lv_lcd_generic_mipi_set_gamma_curve(lv_display_t * disp, uint8_t gamma)
 {
     lv_lcd_generic_mipi_driver_t * drv = get_driver(disp);
@@ -112,6 +117,7 @@ void lv_lcd_generic_mipi_set_gamma_curve(lv_display_t * disp, uint8_t gamma)
     }, 1);
 }
 
+LV_FUNC_SECTION
 void lv_lcd_generic_mipi_send_cmd_list(lv_display_t * disp, const uint8_t * cmd_list)
 {
     lv_lcd_generic_mipi_driver_t * drv = get_driver(disp);
@@ -143,6 +149,7 @@ void lv_lcd_generic_mipi_send_cmd_list(lv_display_t * disp, const uint8_t * cmd_
  * @param param         parameter buffer
  * @param param_size    number of bytes of the parameters
  */
+LV_FUNC_SECTION
 static void send_cmd(lv_lcd_generic_mipi_driver_t * drv, uint8_t cmd, uint8_t * param, size_t param_size)
 {
     uint8_t cmdbuf = cmd;       /* MIPI uses 8 bit commands */
@@ -156,6 +163,7 @@ static void send_cmd(lv_lcd_generic_mipi_driver_t * drv, uint8_t cmd, uint8_t *
  * @param param         parameter buffer
  * @param param_size    number of bytes of the parameters
  */
+LV_FUNC_SECTION
 static void send_color(lv_lcd_generic_mipi_driver_t * drv, uint8_t cmd, uint8_t * param, size_t param_size)
 {
     uint8_t cmdbuf = cmd;       /* MIPI uses 8 bit commands */
@@ -166,6 +174,7 @@ static void send_color(lv_lcd_generic_mipi_driver_t * drv, uint8_t cmd, uint8_t
  * Initialize LCD driver after a hard reset
  * @param drv           LCD driver object
  */
+LV_FUNC_SECTION
 static void init(lv_lcd_generic_mipi_driver_t * drv, lv_lcd_flag_t flags)
 {
     drv->x_gap = 0;
@@ -212,6 +221,7 @@ static void init(lv_lcd_generic_mipi_driver_t * drv, lv_lcd_flag_t flags)
  * @param mirror_x      false: normal, true: mirrored
  * @param mirror_y      false: normal, true: mirrored
  */
+LV_FUNC_SECTION
 static void set_mirror(lv_lcd_generic_mipi_driver_t * drv, bool mirror_x, bool mirror_y)
 {
     uint8_t mad = drv->madctl_reg & ~(LV_LCD_MASK_COLUMN_ADDRESS_ORDER | LV_LCD_MASK_PAGE_ADDRESS_ORDER);
@@ -229,6 +239,7 @@ static void set_mirror(lv_lcd_generic_mipi_driver_t * drv, bool mirror_x, bool m
  * @param drv           LCD driver object
  * @param swap          false: normal, true: swapped
  */
+LV_FUNC_SECTION
 static void set_swap_xy(lv_lcd_generic_mipi_driver_t * drv, bool swap)
 {
     uint8_t mad = drv->madctl_reg & ~(LV_LCD_MASK_PAGE_COLUMN_ORDER);
@@ -247,6 +258,7 @@ static void set_swap_xy(lv_lcd_generic_mipi_driver_t * drv, bool swap)
  * @note                transfers pixel data to the LCD controller using the callbacks 'send_cmd' and 'send_color', which were
  *                      passed to the 'lv_st7789_create()' function
  */
+__attribute__(( fptrgroup("lv_display_flush_cb") ))
 static void flush_cb(lv_display_t * disp, const lv_area_t * area, uint8_t * px_map)
 {
     lv_lcd_generic_mipi_driver_t * drv = get_driver(disp);
@@ -286,6 +298,7 @@ static void flush_cb(lv_display_t * disp, const lv_area_t * area, uint8_t * px_m
  * @param drv           LCD driver object
  * @param rot           rotation
  */
+LV_FUNC_SECTION
 static void set_rotation(lv_lcd_generic_mipi_driver_t * drv, lv_display_rotation_t rot)
 {
     switch(rot) {
@@ -315,6 +328,7 @@ static void set_rotation(lv_lcd_generic_mipi_driver_t * drv, lv_display_rotation
  * Handle LV_EVENT_RESOLUTION_CHANGED event (handles both resolution and rotation change)
  * @param e             LV_EVENT_RESOLUTION_CHANGED event
  */
+__attribute__(( fptrgroup("lv_event_cb") ))
 static void res_chg_event_cb(lv_event_t * e)
 {
     lv_display_t * disp = lv_event_get_current_target(e);
@@ -332,6 +346,7 @@ static void res_chg_event_cb(lv_event_t * e)
     set_rotation(drv, rot);
 }
 
+LV_FUNC_SECTION
 static lv_lcd_generic_mipi_driver_t * get_driver(lv_display_t * disp)
 {
     return (lv_lcd_generic_mipi_driver_t *)lv_display_get_driver_data(disp);
diff --git a/src/drivers/display/lcd/lv_lcd_generic_mipi.h b/src/drivers/display/lcd/lv_lcd_generic_mipi.h
index 8daa5e044..b37f9c010 100644
--- a/src/drivers/display/lcd/lv_lcd_generic_mipi.h
+++ b/src/drivers/display/lcd/lv_lcd_generic_mipi.h
@@ -158,7 +158,9 @@ typedef void (*lv_lcd_send_color_cb_t)(lv_display_t * disp, const uint8_t * cmd,
  */
 typedef struct {
     lv_display_t      *     disp;          /* the associated LVGL display object */
+    __attribute__(( fptrgroup("lv_lcd_send_cmd_cb") ))
     lv_lcd_send_cmd_cb_t    send_cmd;       /* platform-specific implementation to send a command to the LCD controller */
+    __attribute__(( fptrgroup("lv_lcd_send_color_cb") ))
     lv_lcd_send_color_cb_t  send_color;     /* platform-specific implementation to send pixel data to the LCD controller */
     uint16_t                x_gap;          /* x offset of the (0,0) pixel in VRAM */
     uint16_t                y_gap;          /* y offset of the (0,0) pixel in VRAM */
diff --git a/src/drivers/display/renesas_glcdc/lv_renesas_glcdc.c b/src/drivers/display/renesas_glcdc/lv_renesas_glcdc.c
index 15b67846d..edbebf128 100644
--- a/src/drivers/display/renesas_glcdc/lv_renesas_glcdc.c
+++ b/src/drivers/display/renesas_glcdc/lv_renesas_glcdc.c
@@ -88,12 +88,14 @@ static uint32_t partial_buffer_size = 0;
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 lv_display_t * lv_renesas_glcdc_direct_create(void)
 {
     return glcdc_create(&fb_background[0][0], &fb_background[1][0], sizeof(fb_background[0]),
                         LV_DISPLAY_RENDER_MODE_DIRECT);
 }
 
+LV_FUNC_SECTION
 lv_display_t * lv_renesas_glcdc_partial_create(void * buf1, void * buf2, size_t buf_size)
 {
     partial_buffer_size = buf_size;
@@ -102,6 +104,7 @@ lv_display_t * lv_renesas_glcdc_partial_create(void * buf1, void * buf2, size_t
 
 /*This function is declared in and being used by FSP generated code modules*/
 #ifdef _RENESAS_RA_
+LV_FUNC_SECTION
 void glcdc_callback(display_callback_args_t * p_args)
 {
     if(DISPLAY_EVENT_LINE_DETECTION == p_args->event) {
@@ -118,6 +121,7 @@ void glcdc_callback(display_callback_args_t * p_args)
     }
 }
 #else /* RX */
+LV_FUNC_SECTION
 void glcdc_callback(glcdc_callback_args_t * p_args)
 {
     if(GLCDC_EVENT_LINE_DETECTION == p_args->event) {
@@ -139,6 +143,7 @@ void glcdc_callback(glcdc_callback_args_t * p_args)
  *   STATIC FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 static lv_display_t * glcdc_create(void * buf1, void * buf2, uint32_t buf_size, lv_display_render_mode_t render_mode)
 {
 #ifdef _RENESAS_RA_
@@ -170,6 +175,7 @@ static lv_display_t * glcdc_create(void * buf1, void * buf2, uint32_t buf_size,
     return display;
 }
 
+LV_FUNC_SECTION
 static void give_vsync_sem_and_yield(void)
 {
 #if USE_FREE_RTOS
@@ -184,6 +190,7 @@ static void give_vsync_sem_and_yield(void)
 #endif /*USE_FREE_RTOS*/
 }
 
+LV_FUNC_SECTION
 static void glcdc_init(void)
 {
     /* Fill the Frame buffer with black colour (0x0000 in RGB565), for a clean start after previous runs */
@@ -238,6 +245,7 @@ static void glcdc_init(void)
 #endif /*_RENESAS_RA_*/
 }
 
+__attribute__(( fptrgroup("lv_display_flush_cb") ))
 static void flush_direct(lv_display_t * display, const lv_area_t * area, uint8_t * px_map)
 {
     FSP_PARAMETER_NOT_USED(area);
@@ -265,6 +273,7 @@ static void flush_direct(lv_display_t * display, const lv_area_t * area, uint8_t
 #endif /*_RENESAS_RA_*/
 }
 
+__attribute__(( fptrgroup("lv_display_flush_wait_cb") ))
 static void flush_wait_direct(lv_display_t * display)
 {
     if(!lv_display_flush_is_last(display)) return;
@@ -280,6 +289,7 @@ static void flush_wait_direct(lv_display_t * display)
 
 }
 
+__attribute__(( fptrgroup("lv_display_flush_cb") ))
 static void flush_partial(lv_display_t * display, const lv_area_t * area, uint8_t * px_map)
 {
     uint16_t * img = (uint16_t *)px_map;
@@ -332,6 +342,7 @@ static void flush_partial(lv_display_t * display, const lv_area_t * area, uint8_
     }
 }
 
+__attribute__(( fptrgroup("lv_display_flush_wait_cb") ))
 static void flush_wait_partial(lv_display_t * display)
 {
     LV_UNUSED(display);
@@ -342,6 +353,7 @@ static void flush_wait_partial(lv_display_t * display)
 #ifdef _RENESAS_RX_
 extern void drw_int_isr(void);
 
+LV_FUNC_SECTION
 static void enable_dave2d_drw_interrupt(void)
 {
     bsp_int_ctrl_t grpal1;
diff --git a/src/drivers/display/st7735/lv_st7735.c b/src/drivers/display/st7735/lv_st7735.c
index 6b5e62dcb..ca2249c8a 100644
--- a/src/drivers/display/st7735/lv_st7735.c
+++ b/src/drivers/display/st7735/lv_st7735.c
@@ -78,6 +78,7 @@ static const uint8_t init_cmd_list[] = {
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 lv_display_t * lv_st7735_create(uint32_t hor_res, uint32_t ver_res, lv_lcd_flag_t flags,
                                 lv_st7735_send_cmd_cb_t send_cmd_cb, lv_st7735_send_color_cb_t send_color_cb)
 {
@@ -86,21 +87,25 @@ lv_display_t * lv_st7735_create(uint32_t hor_res, uint32_t ver_res, lv_lcd_flag_
     return disp;
 }
 
+LV_FUNC_SECTION
 void lv_st7735_set_gap(lv_display_t * disp, uint16_t x, uint16_t y)
 {
     lv_lcd_generic_mipi_set_gap(disp, x, y);
 }
 
+LV_FUNC_SECTION
 void lv_st7735_set_invert(lv_display_t * disp, bool invert)
 {
     lv_lcd_generic_mipi_set_invert(disp, invert);
 }
 
+LV_FUNC_SECTION
 void lv_st7735_set_gamma_curve(lv_display_t * disp, uint8_t gamma)
 {
     lv_lcd_generic_mipi_set_gamma_curve(disp, gamma);
 }
 
+LV_FUNC_SECTION
 void lv_st7735_send_cmd_list(lv_display_t * disp, const uint8_t * cmd_list)
 {
     lv_lcd_generic_mipi_send_cmd_list(disp, cmd_list);
diff --git a/src/drivers/display/st7789/lv_st7789.c b/src/drivers/display/st7789/lv_st7789.c
index 76d08bfb2..05a0a741e 100644
--- a/src/drivers/display/st7789/lv_st7789.c
+++ b/src/drivers/display/st7789/lv_st7789.c
@@ -81,6 +81,7 @@ static const uint8_t init_cmd_list[] = {
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 lv_display_t * lv_st7789_create(uint32_t hor_res, uint32_t ver_res, lv_lcd_flag_t flags,
                                 lv_st7789_send_cmd_cb_t send_cmd_cb, lv_st7789_send_color_cb_t send_color_cb)
 {
@@ -89,21 +90,25 @@ lv_display_t * lv_st7789_create(uint32_t hor_res, uint32_t ver_res, lv_lcd_flag_
     return disp;
 }
 
+LV_FUNC_SECTION
 void lv_st7789_set_gap(lv_display_t * disp, uint16_t x, uint16_t y)
 {
     lv_lcd_generic_mipi_set_gap(disp, x, y);
 }
 
+LV_FUNC_SECTION
 void lv_st7789_set_invert(lv_display_t * disp, bool invert)
 {
     lv_lcd_generic_mipi_set_invert(disp, invert);
 }
 
+LV_FUNC_SECTION
 void lv_st7789_set_gamma_curve(lv_display_t * disp, uint8_t gamma)
 {
     lv_lcd_generic_mipi_set_gamma_curve(disp, gamma);
 }
 
+LV_FUNC_SECTION
 void lv_st7789_send_cmd_list(lv_display_t * disp, const uint8_t * cmd_list)
 {
     lv_lcd_generic_mipi_send_cmd_list(disp, cmd_list);
diff --git a/src/drivers/display/st7796/lv_st7796.c b/src/drivers/display/st7796/lv_st7796.c
index 985b39f01..48e1a5eaf 100644
--- a/src/drivers/display/st7796/lv_st7796.c
+++ b/src/drivers/display/st7796/lv_st7796.c
@@ -84,6 +84,7 @@ static const uint8_t init_cmd_list[] = {
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 lv_display_t * lv_st7796_create(uint32_t hor_res, uint32_t ver_res, lv_lcd_flag_t flags,
                                 lv_st7796_send_cmd_cb_t send_cmd_cb, lv_st7796_send_color_cb_t send_color_cb)
 {
@@ -92,16 +93,19 @@ lv_display_t * lv_st7796_create(uint32_t hor_res, uint32_t ver_res, lv_lcd_flag_
     return disp;
 }
 
+LV_FUNC_SECTION
 void lv_st7796_set_gap(lv_display_t * disp, uint16_t x, uint16_t y)
 {
     lv_lcd_generic_mipi_set_gap(disp, x, y);
 }
 
+LV_FUNC_SECTION
 void lv_st7796_set_invert(lv_display_t * disp, bool invert)
 {
     lv_lcd_generic_mipi_set_invert(disp, invert);
 }
 
+LV_FUNC_SECTION
 void lv_st7796_set_gamma_curve(lv_display_t * disp, uint8_t gamma)
 {
     /* NOTE: the generic method is not supported on ST7796, TODO: implement gamma tables */
@@ -109,6 +113,7 @@ void lv_st7796_set_gamma_curve(lv_display_t * disp, uint8_t gamma)
     LV_UNUSED(gamma);
 }
 
+LV_FUNC_SECTION
 void lv_st7796_send_cmd_list(lv_display_t * disp, const uint8_t * cmd_list)
 {
     lv_lcd_generic_mipi_send_cmd_list(disp, cmd_list);
diff --git a/src/drivers/display/tft_espi/lv_tft_espi.cpp b/src/drivers/display/tft_espi/lv_tft_espi.cpp
index 1cb7b45ff..fe09ee96b 100644
--- a/src/drivers/display/tft_espi/lv_tft_espi.cpp
+++ b/src/drivers/display/tft_espi/lv_tft_espi.cpp
@@ -25,6 +25,7 @@ typedef struct {
 /**********************
  *  STATIC PROTOTYPES
  **********************/
+__attribute__(( fptrgroup("lv_display_flush_cb") ))
 static void flush_cb(lv_display_t * disp, const lv_area_t * area, uint8_t * px_map);
 static void resolution_changed_event_cb(lv_event_t * e);
 
@@ -82,6 +83,7 @@ static void flush_cb(lv_display_t * disp, const lv_area_t * area, uint8_t * px_m
 
 }
 
+__attribute__(( fptrgroup("lv_event_cb") ))
 static void resolution_changed_event_cb(lv_event_t * e)
 {
     lv_display_t * disp = (lv_display_t *)lv_event_get_target(e);
diff --git a/src/drivers/evdev/lv_evdev.c b/src/drivers/evdev/lv_evdev.c
index e7d31ecff..7d336da96 100644
--- a/src/drivers/evdev/lv_evdev.c
+++ b/src/drivers/evdev/lv_evdev.c
@@ -49,6 +49,7 @@ typedef struct {
  *   STATIC FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 static int _evdev_process_key(uint16_t code)
 {
     switch(code) {
@@ -82,12 +83,14 @@ static int _evdev_process_key(uint16_t code)
     }
 }
 
+LV_FUNC_SECTION
 static int _evdev_calibrate(int v, int in_min, int in_max, int out_min, int out_max)
 {
     if(in_min != in_max) v = (v - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
     return LV_CLAMP(out_min, v, out_max);
 }
 
+LV_FUNC_SECTION
 static lv_point_t _evdev_process_pointer(lv_indev_t * indev, int x, int y)
 {
     lv_display_t * disp = lv_indev_get_display(indev);
@@ -108,6 +111,7 @@ static lv_point_t _evdev_process_pointer(lv_indev_t * indev, int x, int y)
     return p;
 }
 
+LV_FUNC_SECTION
 static void _evdev_read(lv_indev_t * indev, lv_indev_data_t * data)
 {
     lv_evdev_t * dsc = lv_indev_get_driver_data(indev);
@@ -163,6 +167,7 @@ static void _evdev_read(lv_indev_t * indev, lv_indev_data_t * data)
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 lv_indev_t * lv_evdev_create(lv_indev_type_t indev_type, const char * dev_path)
 {
     lv_evdev_t * dsc = lv_malloc_zeroed(sizeof(lv_evdev_t));
@@ -214,6 +219,7 @@ err_after_malloc:
     return NULL;
 }
 
+LV_FUNC_SECTION
 void lv_evdev_set_swap_axes(lv_indev_t * indev, bool swap_axes)
 {
     lv_evdev_t * dsc = lv_indev_get_driver_data(indev);
@@ -221,6 +227,7 @@ void lv_evdev_set_swap_axes(lv_indev_t * indev, bool swap_axes)
     dsc->swap_axes = swap_axes;
 }
 
+LV_FUNC_SECTION
 void lv_evdev_set_calibration(lv_indev_t * indev, int min_x, int min_y, int max_x, int max_y)
 {
     lv_evdev_t * dsc = lv_indev_get_driver_data(indev);
@@ -231,6 +238,7 @@ void lv_evdev_set_calibration(lv_indev_t * indev, int min_x, int min_y, int max_
     dsc->max_y = max_y;
 }
 
+LV_FUNC_SECTION
 void lv_evdev_delete(lv_indev_t * indev)
 {
     lv_evdev_t * dsc = lv_indev_get_driver_data(indev);
diff --git a/src/drivers/glfw/lv_glfw_window.c b/src/drivers/glfw/lv_glfw_window.c
index 849cbf58b..aabe58fcc 100644
--- a/src/drivers/glfw/lv_glfw_window.c
+++ b/src/drivers/glfw/lv_glfw_window.c
@@ -67,6 +67,7 @@ static lv_ll_t glfw_window_ll;
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 lv_glfw_window_t * lv_glfw_window_create(int32_t hor_res, int32_t ver_res, bool use_mouse_indev)
 {
     if(lv_glfw_init() != 0) {
@@ -104,6 +105,7 @@ lv_glfw_window_t * lv_glfw_window_create(int32_t hor_res, int32_t ver_res, bool
     return window;
 }
 
+LV_FUNC_SECTION
 void lv_glfw_window_delete(lv_glfw_window_t * window)
 {
     glfwDestroyWindow(window->window);
@@ -122,6 +124,7 @@ void lv_glfw_window_delete(lv_glfw_window_t * window)
     }
 }
 
+LV_FUNC_SECTION
 lv_glfw_texture_t * lv_glfw_window_add_texture(lv_glfw_window_t * window, unsigned int texture_id, int32_t w, int32_t h)
 {
     lv_glfw_texture_t * texture = lv_ll_ins_tail(&window->textures);
@@ -154,6 +157,7 @@ lv_glfw_texture_t * lv_glfw_window_add_texture(lv_glfw_window_t * window, unsign
     return texture;
 }
 
+LV_FUNC_SECTION
 void lv_glfw_texture_remove(lv_glfw_texture_t * texture)
 {
     if(texture->indev != NULL) {
@@ -163,21 +167,25 @@ void lv_glfw_texture_remove(lv_glfw_texture_t * texture)
     lv_free(texture);
 }
 
+LV_FUNC_SECTION
 void lv_glfw_texture_set_x(lv_glfw_texture_t * texture, int32_t x)
 {
     lv_area_set_pos(&texture->area, x, texture->area.y1);
 }
 
+LV_FUNC_SECTION
 void lv_glfw_texture_set_y(lv_glfw_texture_t * texture, int32_t y)
 {
     lv_area_set_pos(&texture->area, texture->area.x1, y);
 }
 
+LV_FUNC_SECTION
 void lv_glfw_texture_set_opa(lv_glfw_texture_t * texture, lv_opa_t opa)
 {
     texture->opa = opa;
 }
 
+LV_FUNC_SECTION
 lv_indev_t * lv_glfw_texture_get_mouse_indev(lv_glfw_texture_t * texture)
 {
     return texture->indev;
@@ -187,6 +195,7 @@ lv_indev_t * lv_glfw_texture_get_mouse_indev(lv_glfw_texture_t * texture)
  *   STATIC FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 static int lv_glfw_init(void)
 {
     if(glfw_inited) {
@@ -207,6 +216,7 @@ static int lv_glfw_init(void)
     return 0;
 }
 
+LV_FUNC_SECTION
 static int lv_glew_init(void)
 {
     if(glew_inited) {
@@ -227,6 +237,7 @@ static int lv_glew_init(void)
     return 0;
 }
 
+LV_FUNC_SECTION
 static void lv_glfw_timer_init(void)
 {
     if(update_handler_timer == NULL) {
@@ -235,6 +246,7 @@ static void lv_glfw_timer_init(void)
     }
 }
 
+LV_FUNC_SECTION
 static void lv_glfw_window_config(GLFWwindow * window, bool use_mouse_indev)
 {
     glfwMakeContextCurrent(window);
@@ -253,6 +265,7 @@ static void lv_glfw_window_config(GLFWwindow * window, bool use_mouse_indev)
     glfwSetWindowCloseCallback(window, window_close_callback);
 }
 
+LV_FUNC_SECTION
 static void lv_glfw_window_quit(void)
 {
     lv_timer_delete(update_handler_timer);
@@ -266,6 +279,7 @@ static void lv_glfw_window_quit(void)
     exit(0);
 }
 
+LV_FUNC_SECTION
 static void window_update_handler(lv_timer_t * t)
 {
     LV_UNUSED(t);
@@ -308,22 +322,26 @@ static void window_update_handler(lv_timer_t * t)
     }
 }
 
+LV_FUNC_SECTION
 static void glfw_error_cb(int error, const char * description)
 {
     LV_LOG_ERROR("GLFW Error %d: %s", error, description);
 }
 
+LV_FUNC_SECTION
 static lv_glfw_window_t * lv_glfw_get_lv_window_from_window(GLFWwindow * window)
 {
     return glfwGetWindowUserPointer(window);
 }
 
+LV_FUNC_SECTION
 static void window_close_callback(GLFWwindow * window)
 {
     lv_glfw_window_t * lv_window = lv_glfw_get_lv_window_from_window(window);
     lv_window->closing = 1;
 }
 
+LV_FUNC_SECTION
 static void key_callback(GLFWwindow * window, int key, int scancode, int action, int mods)
 {
     LV_UNUSED(scancode);
@@ -334,6 +352,7 @@ static void key_callback(GLFWwindow * window, int key, int scancode, int action,
     }
 }
 
+LV_FUNC_SECTION
 static void mouse_button_callback(GLFWwindow * window, int button, int action, int mods)
 {
     LV_UNUSED(mods);
@@ -344,6 +363,7 @@ static void mouse_button_callback(GLFWwindow * window, int button, int action, i
     }
 }
 
+LV_FUNC_SECTION
 static void mouse_move_callback(GLFWwindow * window, double xpos, double ypos)
 {
     lv_glfw_window_t * lv_window = lv_glfw_get_lv_window_from_window(window);
@@ -352,6 +372,7 @@ static void mouse_move_callback(GLFWwindow * window, double xpos, double ypos)
     proc_mouse(lv_window);
 }
 
+LV_FUNC_SECTION
 static void proc_mouse(lv_glfw_window_t * window)
 {
     /* mouse activity will affect the topmost LVGL display texture */
@@ -368,6 +389,7 @@ static void proc_mouse(lv_glfw_window_t * window)
     }
 }
 
+LV_FUNC_SECTION
 static void indev_read_cb(lv_indev_t * indev, lv_indev_data_t * data)
 {
     lv_glfw_texture_t * texture = lv_indev_get_driver_data(indev);
@@ -375,6 +397,7 @@ static void indev_read_cb(lv_indev_t * indev, lv_indev_data_t * data)
     data->state = texture->indev_last_state;
 }
 
+LV_FUNC_SECTION
 static void framebuffer_size_callback(GLFWwindow * window, int width, int height)
 {
     lv_glfw_window_t * lv_window = lv_glfw_get_lv_window_from_window(window);
@@ -382,6 +405,7 @@ static void framebuffer_size_callback(GLFWwindow * window, int width, int height
     lv_window->ver_res = height;
 }
 
+LV_FUNC_SECTION
 static uint32_t lv_glfw_tick_count_callback(void)
 {
     double tick = glfwGetTime() * 1000.0;
diff --git a/src/drivers/glfw/lv_opengles_debug.c b/src/drivers/glfw/lv_opengles_debug.c
index 5bf6d0227..e84be4dd6 100644
--- a/src/drivers/glfw/lv_opengles_debug.c
+++ b/src/drivers/glfw/lv_opengles_debug.c
@@ -36,11 +36,13 @@
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 void GLClearError()
 {
     while(glGetError() != GL_NO_ERROR);
 }
 
+LV_FUNC_SECTION
 bool GLLogCall(const char * function, const char * file, int line)
 {
     GLenum error;
diff --git a/src/drivers/glfw/lv_opengles_driver.c b/src/drivers/glfw/lv_opengles_driver.c
index 110e7140f..56d3e71f6 100644
--- a/src/drivers/glfw/lv_opengles_driver.c
+++ b/src/drivers/glfw/lv_opengles_driver.c
@@ -120,6 +120,7 @@ static const char * fragment_shader =
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 void lv_opengles_init(void)
 {
     if(is_init) return;
@@ -157,6 +158,7 @@ void lv_opengles_init(void)
     is_init = true;
 }
 
+LV_FUNC_SECTION
 void lv_opengles_deinit(void)
 {
     if(!is_init) return;
@@ -169,6 +171,7 @@ void lv_opengles_deinit(void)
     is_init = false;
 }
 
+LV_FUNC_SECTION
 void lv_opengles_render_texture(unsigned int texture, const lv_area_t * texture_area, lv_opa_t opa, int32_t disp_w,
                                 int32_t disp_h)
 {
@@ -193,11 +196,13 @@ void lv_opengles_render_texture(unsigned int texture, const lv_area_t * texture_
     lv_opengles_render_draw();
 }
 
+LV_FUNC_SECTION
 void lv_opengles_render_clear(void)
 {
     GL_CALL(glClear(GL_COLOR_BUFFER_BIT));
 }
 
+LV_FUNC_SECTION
 void lv_opengles_viewport(int32_t x, int32_t y, int32_t w, int32_t h)
 {
     glViewport(x, y, w, h);
@@ -207,12 +212,14 @@ void lv_opengles_viewport(int32_t x, int32_t y, int32_t w, int32_t h)
  *   STATIC FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 static void lv_opengles_enable_blending(void)
 {
     glEnable(GL_BLEND);
     glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
 }
 
+LV_FUNC_SECTION
 static void lv_opengles_vertex_buffer_init(const void * data, unsigned int size)
 {
     GL_CALL(glGenBuffers(1, &vertex_buffer_id));
@@ -220,41 +227,49 @@ static void lv_opengles_vertex_buffer_init(const void * data, unsigned int size)
     GL_CALL(glBufferData(GL_ARRAY_BUFFER, size, data, GL_STATIC_DRAW));
 }
 
+LV_FUNC_SECTION
 static void lv_opengles_vertex_buffer_deinit(void)
 {
     GL_CALL(glDeleteBuffers(1, &vertex_buffer_id));
 }
 
+LV_FUNC_SECTION
 static void lv_opengles_vertex_buffer_bind(void)
 {
     GL_CALL(glBindBuffer(GL_ARRAY_BUFFER, vertex_buffer_id));
 }
 
+LV_FUNC_SECTION
 static void lv_opengles_vertex_buffer_unbind(void)
 {
     GL_CALL(glBindBuffer(GL_ARRAY_BUFFER, 0));
 }
 
+LV_FUNC_SECTION
 static void lv_opengles_vertex_array_init(void)
 {
     GL_CALL(glGenVertexArrays(1, &vertex_array_id));
 }
 
+LV_FUNC_SECTION
 static void lv_opengles_vertex_array_deinit(void)
 {
     GL_CALL(glDeleteVertexArrays(1, &vertex_array_id));
 }
 
+LV_FUNC_SECTION
 static void lv_opengles_vertex_array_bind(void)
 {
     GL_CALL(glBindVertexArray(vertex_array_id));
 }
 
+LV_FUNC_SECTION
 static void lv_opengles_vertex_array_unbind(void)
 {
     GL_CALL(glBindVertexArray(0));
 }
 
+LV_FUNC_SECTION
 static void lv_opengles_vertex_array_add_buffer(void)
 {
     lv_opengles_vertex_buffer_bind();
@@ -268,6 +283,7 @@ static void lv_opengles_vertex_array_add_buffer(void)
     }
 }
 
+LV_FUNC_SECTION
 static void lv_opengles_index_buffer_init(const unsigned int * data, unsigned int count)
 {
     index_buffer_count = count;
@@ -278,26 +294,31 @@ static void lv_opengles_index_buffer_init(const unsigned int * data, unsigned in
     GL_CALL(glBufferData(GL_ELEMENT_ARRAY_BUFFER, count * sizeof(GLuint), data, GL_STATIC_DRAW));
 }
 
+LV_FUNC_SECTION
 static void lv_opengles_index_buffer_deinit(void)
 {
     GL_CALL(glDeleteBuffers(1, &index_buffer_id));
 }
 
+LV_FUNC_SECTION
 static unsigned int lv_opengles_index_buffer_get_count(void)
 {
     return index_buffer_count;
 }
 
+LV_FUNC_SECTION
 static void lv_opengles_index_buffer_bind(void)
 {
     GL_CALL(glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, index_buffer_id));
 }
 
+LV_FUNC_SECTION
 static void lv_opengles_index_buffer_unbind(void)
 {
     GL_CALL(glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0));
 }
 
+LV_FUNC_SECTION
 static unsigned int lv_opengles_shader_compile(unsigned int type, const char * source)
 {
     GL_CALL(unsigned int id = glCreateShader(type));
@@ -321,6 +342,7 @@ static unsigned int lv_opengles_shader_compile(unsigned int type, const char * s
     return id;
 }
 
+LV_FUNC_SECTION
 static unsigned int lv_opengles_shader_create(const char * vertexShader, const char * fragmentShader)
 {
     GL_CALL(unsigned int program = glCreateProgram());
@@ -338,26 +360,31 @@ static unsigned int lv_opengles_shader_create(const char * vertexShader, const c
     return program;
 }
 
+LV_FUNC_SECTION
 static void lv_opengles_shader_init(void)
 {
     shader_id = lv_opengles_shader_create(vertex_shader, fragment_shader);
 }
 
+LV_FUNC_SECTION
 static void lv_opengles_shader_deinit(void)
 {
     GL_CALL(glDeleteProgram(shader_id));
 }
 
+LV_FUNC_SECTION
 static void lv_opengles_shader_bind(void)
 {
     GL_CALL(glUseProgram(shader_id));
 }
 
+LV_FUNC_SECTION
 static void lv_opengles_shader_unbind(void)
 {
     GL_CALL(glUseProgram(0));
 }
 
+LV_FUNC_SECTION
 static int lv_opengles_shader_get_uniform_location(const char * name)
 {
     int id = -1;
@@ -382,21 +409,25 @@ static int lv_opengles_shader_get_uniform_location(const char * name)
     return location;
 }
 
+LV_FUNC_SECTION
 static void lv_opengles_shader_set_uniform1i(const char * name, int value)
 {
     GL_CALL(glUniform1i(lv_opengles_shader_get_uniform_location(name), value));
 }
 
+LV_FUNC_SECTION
 static void lv_opengles_shader_set_uniformmatrix3fv(const char * name, int count, bool transpose, const float * values)
 {
     GL_CALL(glUniformMatrix3fv(lv_opengles_shader_get_uniform_location(name), count, transpose, values));
 }
 
+LV_FUNC_SECTION
 static void lv_opengles_shader_set_uniform1f(const char * name, float value)
 {
     GL_CALL(glUniform1f(lv_opengles_shader_get_uniform_location(name), value));
 }
 
+LV_FUNC_SECTION
 static void lv_opengles_render_draw(void)
 {
     lv_opengles_shader_bind();
diff --git a/src/drivers/glfw/lv_opengles_texture.c b/src/drivers/glfw/lv_opengles_texture.c
index 02c9dfa7d..56857ab82 100644
--- a/src/drivers/glfw/lv_opengles_texture.c
+++ b/src/drivers/glfw/lv_opengles_texture.c
@@ -33,6 +33,7 @@ typedef struct {
  *  STATIC PROTOTYPES
  **********************/
 
+ __attribute__(( fptrgroup("lv_display_flush_cb") ))
 static void flush_cb(lv_display_t * disp, const lv_area_t * area, uint8_t * px_map);
 static void release_disp_cb(lv_event_t * e);
 
@@ -48,6 +49,7 @@ static void release_disp_cb(lv_event_t * e);
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 lv_display_t * lv_opengles_texture_create(int32_t w, int32_t h)
 {
     lv_display_t * disp = lv_display_create(w, h);
@@ -85,6 +87,7 @@ lv_display_t * lv_opengles_texture_create(int32_t w, int32_t h)
     return disp;
 }
 
+LV_FUNC_SECTION
 unsigned int lv_opengles_texture_get_texture_id(lv_display_t * disp)
 {
     if(disp->flush_cb != flush_cb) {
@@ -94,6 +97,7 @@ unsigned int lv_opengles_texture_get_texture_id(lv_display_t * disp)
     return dsc->texture_id;
 }
 
+LV_FUNC_SECTION
 lv_display_t * lv_opengles_texture_get_from_texture_id(unsigned int texture_id)
 {
     lv_display_t * disp = NULL;
@@ -110,6 +114,7 @@ lv_display_t * lv_opengles_texture_get_from_texture_id(unsigned int texture_id)
  *   STATIC FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 static void flush_cb(lv_display_t * disp, const lv_area_t * area, uint8_t * px_map)
 {
     LV_UNUSED(area);
@@ -140,6 +145,7 @@ static void flush_cb(lv_display_t * disp, const lv_area_t * area, uint8_t * px_m
     lv_display_flush_ready(disp);
 }
 
+LV_FUNC_SECTION
 static void release_disp_cb(lv_event_t * e)
 {
     lv_display_t * disp = lv_event_get_user_data(e);
diff --git a/src/drivers/libinput/lv_libinput.c b/src/drivers/libinput/lv_libinput.c
index 7410f40fd..d0db82024 100644
--- a/src/drivers/libinput/lv_libinput.c
+++ b/src/drivers/libinput/lv_libinput.c
@@ -90,6 +90,7 @@ static const struct libinput_interface interface = {
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 lv_libinput_capability lv_libinput_query_capability(struct libinput_device * device)
 {
     lv_libinput_capability capability = LV_LIBINPUT_CAPABILITY_NONE;
@@ -106,6 +107,7 @@ lv_libinput_capability lv_libinput_query_capability(struct libinput_device * dev
     return capability;
 }
 
+LV_FUNC_SECTION
 char * lv_libinput_find_dev(lv_libinput_capability capabilities, bool force_rescan)
 {
     char * path = NULL;
@@ -113,6 +115,7 @@ char * lv_libinput_find_dev(lv_libinput_capability capabilities, bool force_resc
     return path;
 }
 
+LV_FUNC_SECTION
 size_t lv_libinput_find_devs(lv_libinput_capability capabilities, char ** found, size_t count, bool force_rescan)
 {
     if((!devices || force_rescan) && !_rescan_devices()) {
@@ -131,6 +134,7 @@ size_t lv_libinput_find_devs(lv_libinput_capability capabilities, char ** found,
     return num_found;
 }
 
+LV_FUNC_SECTION
 lv_indev_t * lv_libinput_create(lv_indev_type_t indev_type, const char * dev_path)
 {
     lv_libinput_t * dsc = lv_malloc_zeroed(sizeof(lv_libinput_t));
@@ -185,6 +189,7 @@ lv_indev_t * lv_libinput_create(lv_indev_type_t indev_type, const char * dev_pat
     return indev;
 }
 
+LV_FUNC_SECTION
 void lv_libinput_delete(lv_indev_t * indev)
 {
     _delete(lv_indev_get_driver_data(indev));
@@ -199,6 +204,7 @@ void lv_libinput_delete(lv_indev_t * indev)
  * rescan all attached evdev devices and store capable ones into the static devices array for quick later filtering
  * @return true if the operation succeeded
  */
+LV_FUNC_SECTION
 static bool _rescan_devices(void)
 {
     _reset_scanned_devices();
@@ -266,6 +272,7 @@ static bool _rescan_devices(void)
  * @param capabilities device input capabilities
  * @return true if the operation succeeded
  */
+LV_FUNC_SECTION
 static bool _add_scanned_device(char * path, lv_libinput_capability capabilities)
 {
     /* Double array size every 2^n elements */
@@ -288,6 +295,7 @@ static bool _add_scanned_device(char * path, lv_libinput_capability capabilities
 /**
  * reset the array of scanned devices and free any dynamically allocated memory
  */
+LV_FUNC_SECTION
 static void _reset_scanned_devices(void)
 {
     if(!devices) {
@@ -303,6 +311,7 @@ static void _reset_scanned_devices(void)
     num_devices = 0;
 }
 
+LV_FUNC_SECTION
 static void * _poll_thread(void * data)
 {
     lv_libinput_t * dsc = (lv_libinput_t *)data;
@@ -340,6 +349,7 @@ static void * _poll_thread(void * data)
     return NULL;
 }
 
+LV_FUNC_SECTION
 lv_libinput_event_t * _get_event(lv_libinput_t * dsc)
 {
     if(dsc->start == dsc->end) {
@@ -354,11 +364,13 @@ lv_libinput_event_t * _get_event(lv_libinput_t * dsc)
     return evt;
 }
 
+LV_FUNC_SECTION
 bool _event_pending(lv_libinput_t * dsc)
 {
     return dsc->start != dsc->end;
 }
 
+LV_FUNC_SECTION
 lv_libinput_event_t * _create_event(lv_libinput_t * dsc)
 {
     lv_libinput_event_t * evt = &dsc->points[dsc->end];
@@ -380,6 +392,7 @@ lv_libinput_event_t * _create_event(lv_libinput_t * dsc)
     return evt;
 }
 
+LV_FUNC_SECTION
 static void _read(lv_indev_t * indev, lv_indev_data_t * data)
 {
     lv_libinput_t * dsc = lv_indev_get_driver_data(indev);
@@ -406,6 +419,7 @@ static void _read(lv_indev_t * indev, lv_indev_data_t * data)
                      data->continue_reading);
 }
 
+LV_FUNC_SECTION
 static void _read_pointer(lv_libinput_t * dsc, struct libinput_event * event)
 {
     struct libinput_event_touch * touch_event = NULL;
@@ -547,6 +561,7 @@ static void _read_pointer(lv_libinput_t * dsc, struct libinput_event * event)
     }
 }
 
+LV_FUNC_SECTION
 static void _read_keypad(lv_libinput_t * dsc, struct libinput_event * event)
 {
     struct libinput_event_keyboard * keyboard_event = NULL;
@@ -623,6 +638,7 @@ static void _read_keypad(lv_libinput_t * dsc, struct libinput_event * event)
     }
 }
 
+LV_FUNC_SECTION
 static int _open_restricted(const char * path, int flags, void * user_data)
 {
     LV_UNUSED(user_data);
@@ -630,12 +646,14 @@ static int _open_restricted(const char * path, int flags, void * user_data)
     return fd < 0 ? -errno : fd;
 }
 
+LV_FUNC_SECTION
 static void _close_restricted(int fd, void * user_data)
 {
     LV_UNUSED(user_data);
     close(fd);
 }
 
+LV_FUNC_SECTION
 static void _delete(lv_libinput_t * dsc)
 {
     if(dsc->fd)
diff --git a/src/drivers/libinput/lv_xkb.c b/src/drivers/libinput/lv_xkb.c
index 1e8ddb10c..09c0d9bb7 100644
--- a/src/drivers/libinput/lv_xkb.c
+++ b/src/drivers/libinput/lv_xkb.c
@@ -48,6 +48,7 @@ static struct xkb_context * context = NULL;
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 bool lv_xkb_init(lv_xkb_t * dsc, struct xkb_rule_names names)
 {
     if(!context) {
@@ -61,6 +62,7 @@ bool lv_xkb_init(lv_xkb_t * dsc, struct xkb_rule_names names)
     return _set_keymap(dsc, names);
 }
 
+LV_FUNC_SECTION
 void lv_xkb_deinit(lv_xkb_t * dsc)
 {
     if(dsc->state) {
@@ -74,6 +76,7 @@ void lv_xkb_deinit(lv_xkb_t * dsc)
     }
 }
 
+LV_FUNC_SECTION
 uint32_t lv_xkb_process_key(lv_xkb_t * dsc, uint32_t scancode, bool down)
 {
     /* Offset the evdev scancode by 8, see https://xkbcommon.org/doc/current/xkbcommon_8h.html#ac29aee92124c08d1953910ab28ee1997 */
@@ -150,6 +153,7 @@ uint32_t lv_xkb_process_key(lv_xkb_t * dsc, uint32_t scancode, bool down)
  *   STATIC FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 static bool _set_keymap(lv_xkb_t * dsc, struct xkb_rule_names names)
 {
     if(dsc->keymap) {
diff --git a/src/drivers/nuttx/lv_nuttx_cache.c b/src/drivers/nuttx/lv_nuttx_cache.c
index 273f49ef8..c73e3460b 100644
--- a/src/drivers/nuttx/lv_nuttx_cache.c
+++ b/src/drivers/nuttx/lv_nuttx_cache.c
@@ -42,6 +42,7 @@ static void flush_cache(const lv_draw_buf_t * draw_buf, const lv_area_t * area);
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 void lv_nuttx_cache_init(void)
 {
     lv_draw_buf_handlers_t * handlers = lv_draw_buf_get_handlers();
@@ -49,6 +50,7 @@ void lv_nuttx_cache_init(void)
     handlers->flush_cache_cb = flush_cache;
 }
 
+LV_FUNC_SECTION
 void lv_nuttx_cache_deinit(void)
 {
     lv_draw_buf_handlers_t * handlers = lv_draw_buf_get_handlers();
@@ -60,6 +62,7 @@ void lv_nuttx_cache_deinit(void)
  *   STATIC FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 static void draw_buf_to_region(
     const lv_draw_buf_t * draw_buf, const lv_area_t * area,
     lv_uintptr_t * start, lv_uintptr_t * end)
@@ -77,6 +80,7 @@ static void draw_buf_to_region(
     *end = *start + h * stride;
 }
 
+LV_FUNC_SECTION
 static void invalidate_cache(const lv_draw_buf_t * draw_buf, const lv_area_t * area)
 {
     lv_uintptr_t start;
@@ -85,6 +89,7 @@ static void invalidate_cache(const lv_draw_buf_t * draw_buf, const lv_area_t * a
     up_invalidate_dcache(start, end);
 }
 
+LV_FUNC_SECTION
 static void flush_cache(const lv_draw_buf_t * draw_buf, const lv_area_t * area)
 {
     lv_uintptr_t start;
diff --git a/src/drivers/nuttx/lv_nuttx_entry.c b/src/drivers/nuttx/lv_nuttx_entry.c
index 57a4d289d..c6a7b4022 100644
--- a/src/drivers/nuttx/lv_nuttx_entry.c
+++ b/src/drivers/nuttx/lv_nuttx_entry.c
@@ -66,6 +66,7 @@ static void check_stack_size(void);
 
 #if LV_ENABLE_GLOBAL_CUSTOM
 
+LV_FUNC_SECTION
 static void lv_global_free(void * data)
 {
     if(data) {
@@ -73,6 +74,7 @@ static void lv_global_free(void * data)
     }
 }
 
+LV_FUNC_SECTION
 lv_global_t * lv_global_default(void)
 {
     static int index = -1;
@@ -93,6 +95,7 @@ lv_global_t * lv_global_default(void)
 }
 #endif
 
+LV_FUNC_SECTION
 void lv_nuttx_dsc_init(lv_nuttx_dsc_t * dsc)
 {
     if(dsc == NULL)
@@ -107,6 +110,7 @@ void lv_nuttx_dsc_init(lv_nuttx_dsc_t * dsc)
 #endif
 }
 
+LV_FUNC_SECTION
 void lv_nuttx_init(const lv_nuttx_dsc_t * dsc, lv_nuttx_result_t * result)
 {
     nuttx_ctx_p = lv_malloc_zeroed(sizeof(lv_nuttx_ctx_t));
@@ -174,6 +178,7 @@ void lv_nuttx_init(const lv_nuttx_dsc_t * dsc, lv_nuttx_result_t * result)
 #endif
 }
 
+LV_FUNC_SECTION
 void lv_nuttx_run(lv_nuttx_result_t * result)
 {
 #ifdef CONFIG_LV_USE_NUTTX_LIBUV
@@ -192,6 +197,7 @@ void lv_nuttx_run(lv_nuttx_result_t * result)
 
 #ifdef CONFIG_SCHED_CPULOAD
 
+LV_FUNC_SECTION
 uint32_t lv_nuttx_get_idle(void)
 {
     struct cpuload_s cpuload;
@@ -210,6 +216,7 @@ uint32_t lv_nuttx_get_idle(void)
 
 #endif
 
+LV_FUNC_SECTION
 void lv_nuttx_deinit(lv_nuttx_result_t * result)
 {
 #if !LV_USE_NUTTX_CUSTOM_INIT
@@ -246,6 +253,7 @@ void lv_nuttx_deinit(lv_nuttx_result_t * result)
  *   STATIC FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 static uint32_t millis(void)
 {
     struct timespec ts;
@@ -257,6 +265,7 @@ static uint32_t millis(void)
 }
 
 #if LV_USE_LOG
+LV_FUNC_SECTION
 static void syslog_print(lv_log_level_t level, const char * buf)
 {
     static const int priority[LV_LOG_LEVEL_NUM] = {
@@ -268,6 +277,7 @@ static void syslog_print(lv_log_level_t level, const char * buf)
 #endif
 
 #ifdef CONFIG_LV_USE_NUTTX_LIBUV
+LV_FUNC_SECTION
 static void lv_nuttx_uv_loop(lv_nuttx_result_t * result)
 {
     uv_loop_t loop;
@@ -290,6 +300,7 @@ static void lv_nuttx_uv_loop(lv_nuttx_result_t * result)
 }
 #endif
 
+LV_FUNC_SECTION
 static void check_stack_size(void)
 {
     pthread_t tid = pthread_self();
diff --git a/src/drivers/nuttx/lv_nuttx_fbdev.c b/src/drivers/nuttx/lv_nuttx_fbdev.c
index 5ff500e28..f30cb7e28 100644
--- a/src/drivers/nuttx/lv_nuttx_fbdev.c
+++ b/src/drivers/nuttx/lv_nuttx_fbdev.c
@@ -50,6 +50,7 @@ typedef struct {
  *  STATIC PROTOTYPES
  **********************/
 
+ __attribute__(( fptrgroup("lv_display_flush_cb") ))
 static void flush_cb(lv_display_t * disp, const lv_area_t * area, uint8_t * color_p);
 static lv_color_format_t fb_fmt_to_color_format(int fmt);
 static int fbdev_get_pinfo(int fd, struct fb_planeinfo_s * pinfo);
@@ -72,6 +73,7 @@ static void display_release_cb(lv_event_t * e);
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 lv_display_t * lv_nuttx_fbdev_create(void)
 {
     lv_nuttx_fb_t * dsc = lv_malloc_zeroed(sizeof(lv_nuttx_fb_t));
@@ -90,6 +92,7 @@ lv_display_t * lv_nuttx_fbdev_create(void)
     return disp;
 }
 
+LV_FUNC_SECTION
 int lv_nuttx_fbdev_set_file(lv_display_t * disp, const char * file)
 {
     int ret;
@@ -186,6 +189,7 @@ errout:
  **********************/
 
 #if defined(CONFIG_FB_UPDATE)
+LV_FUNC_SECTION
 static void fbdev_join_inv_areas(lv_display_t * disp, lv_area_t * final_inv_area)
 {
     uint16_t inv_index;
@@ -213,6 +217,7 @@ static void fbdev_join_inv_areas(lv_display_t * disp, lv_area_t * final_inv_area
 }
 #endif
 
+LV_FUNC_SECTION
 static void display_refr_timer_cb(lv_timer_t * tmr)
 {
     lv_display_t * disp = lv_timer_get_user_data(tmr);
@@ -234,6 +239,7 @@ static void display_refr_timer_cb(lv_timer_t * tmr)
     }
 }
 
+LV_FUNC_SECTION
 static void flush_cb(lv_display_t * disp, const lv_area_t * area, uint8_t * color_p)
 {
     LV_UNUSED(color_p);
@@ -289,6 +295,7 @@ static void flush_cb(lv_display_t * disp, const lv_area_t * area, uint8_t * colo
     lv_display_flush_ready(disp);
 }
 
+LV_FUNC_SECTION
 static lv_color_format_t fb_fmt_to_color_format(int fmt)
 {
     switch(fmt) {
@@ -309,6 +316,7 @@ static lv_color_format_t fb_fmt_to_color_format(int fmt)
     return LV_COLOR_FORMAT_UNKNOWN;
 }
 
+LV_FUNC_SECTION
 static int fbdev_get_pinfo(int fd, FAR struct fb_planeinfo_s * pinfo)
 {
     if(ioctl(fd, FBIOGET_PLANEINFO, (unsigned long)((uintptr_t)pinfo)) < 0) {
@@ -326,6 +334,7 @@ static int fbdev_get_pinfo(int fd, FAR struct fb_planeinfo_s * pinfo)
     return 0;
 }
 
+LV_FUNC_SECTION
 static int fbdev_init_mem2(lv_nuttx_fb_t * dsc)
 {
     uintptr_t buf_offset;
@@ -380,6 +389,7 @@ static int fbdev_init_mem2(lv_nuttx_fb_t * dsc)
     return 0;
 }
 
+LV_FUNC_SECTION
 static void display_release_cb(lv_event_t * e)
 {
     lv_display_t * disp = (lv_display_t *) lv_event_get_user_data(e);
diff --git a/src/drivers/nuttx/lv_nuttx_image_cache.c b/src/drivers/nuttx/lv_nuttx_image_cache.c
index 93f59ed9a..f132b2918 100644
--- a/src/drivers/nuttx/lv_nuttx_image_cache.c
+++ b/src/drivers/nuttx/lv_nuttx_image_cache.c
@@ -60,6 +60,7 @@ static void free_cb(void * draw_buf);
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 void lv_nuttx_image_cache_init(void)
 {
     lv_draw_buf_handlers_t * handlers = image_cache_draw_buf_handlers;
@@ -72,6 +73,7 @@ void lv_nuttx_image_cache_init(void)
     ctx->initialized = false;
 }
 
+LV_FUNC_SECTION
 void lv_nuttx_image_cache_deinit(void)
 {
     if(ctx->initialized == false) goto FREE_CONTEXT;
@@ -89,6 +91,7 @@ FREE_CONTEXT:
  *   STATIC FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 static bool defer_init(void)
 {
     if(ctx->mem != NULL && ctx->heap != NULL) {
@@ -136,6 +139,7 @@ static bool defer_init(void)
     return true;
 }
 
+__attribute__(( fptrgroup("lv_draw_buf_malloc_cb") ))
 static void * malloc_cb(size_t size_bytes, lv_color_format_t color_format)
 {
     LV_UNUSED(color_format);
@@ -168,6 +172,7 @@ static void * malloc_cb(size_t size_bytes, lv_color_format_t color_format)
     }
 }
 
+LV_FUNC_SECTION
 static void free_cb(void * draw_buf)
 {
     mm_free(ctx->heap, draw_buf);
diff --git a/src/drivers/nuttx/lv_nuttx_lcd.c b/src/drivers/nuttx/lv_nuttx_lcd.c
index af49cd44d..8e8838143 100644
--- a/src/drivers/nuttx/lv_nuttx_lcd.c
+++ b/src/drivers/nuttx/lv_nuttx_lcd.c
@@ -64,6 +64,7 @@ static void display_release_cb(lv_event_t * e);
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 lv_display_t * lv_nuttx_lcd_create(const char * dev_path)
 {
     struct fb_videoinfo_s vinfo;
@@ -111,11 +112,13 @@ lv_display_t * lv_nuttx_lcd_create(const char * dev_path)
  *   STATIC FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 static int32_t align_round_up(int32_t v, uint16_t align)
 {
     return (v + align - 1) & ~(align - 1);
 }
 
+LV_FUNC_SECTION
 static void rounder_cb(lv_event_t * e)
 {
     lv_nuttx_lcd_t * lcd = lv_event_get_user_data(e);
@@ -134,6 +137,7 @@ static void rounder_cb(lv_event_t * e)
     area->y2 = area->y1 + h - 1;
 }
 
+__attribute__(( fptrgroup("lv_display_flush_cb") ))
 static void flush_cb(lv_display_t * disp, const lv_area_t * area_p,
                      uint8_t * color_p)
 {
@@ -148,6 +152,7 @@ static void flush_cb(lv_display_t * disp, const lv_area_t * area_p,
     lv_display_flush_ready(disp);
 }
 
+LV_FUNC_SECTION
 static lv_display_t * lcd_init(int fd, int hor_res, int ver_res)
 {
     uint8_t * draw_buf = NULL;
@@ -206,6 +211,7 @@ static lv_display_t * lcd_init(int fd, int hor_res, int ver_res)
     return lcd->disp;
 }
 
+LV_FUNC_SECTION
 static void display_release_cb(lv_event_t * e)
 {
     lv_display_t * disp = (lv_display_t *) lv_event_get_user_data(e);
diff --git a/src/drivers/nuttx/lv_nuttx_libuv.c b/src/drivers/nuttx/lv_nuttx_libuv.c
index 12b8c439c..b659cab6a 100644
--- a/src/drivers/nuttx/lv_nuttx_libuv.c
+++ b/src/drivers/nuttx/lv_nuttx_libuv.c
@@ -74,6 +74,7 @@ static void lv_nuttx_uv_input_deinit(lv_nuttx_uv_ctx_t * uv_ctx);
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 void * lv_nuttx_uv_init(lv_nuttx_uv_t * uv_info)
 {
     lv_nuttx_uv_ctx_t * uv_ctx;
@@ -105,6 +106,7 @@ err_out:
     return NULL;
 }
 
+LV_FUNC_SECTION
 void lv_nuttx_uv_deinit(void ** data)
 {
     lv_nuttx_uv_ctx_t * uv_ctx = *data;
@@ -121,6 +123,7 @@ void lv_nuttx_uv_deinit(void ** data)
  *   STATIC FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 static void lv_nuttx_uv_timer_cb(uv_timer_t * handle)
 {
     uint32_t sleep_ms;
@@ -142,6 +145,7 @@ static void lv_nuttx_uv_timer_cb(uv_timer_t * handle)
     uv_timer_start(handle, lv_nuttx_uv_timer_cb, sleep_ms, 0);
 }
 
+LV_FUNC_SECTION
 static void lv_nuttx_uv_timer_resume(void * data)
 {
     uv_timer_t * timer = (uv_timer_t *)data;
@@ -149,6 +153,7 @@ static void lv_nuttx_uv_timer_resume(void * data)
         uv_timer_start(timer, lv_nuttx_uv_timer_cb, 0, 0);
 }
 
+LV_FUNC_SECTION
 static int lv_nuttx_uv_timer_init(lv_nuttx_uv_t * uv_info, lv_nuttx_uv_ctx_t * uv_ctx)
 {
     uv_loop_t * loop = uv_info->loop;
@@ -165,6 +170,7 @@ static int lv_nuttx_uv_timer_init(lv_nuttx_uv_t * uv_info, lv_nuttx_uv_ctx_t * u
     return 0;
 }
 
+LV_FUNC_SECTION
 static void lv_nuttx_uv_deinit_cb(uv_handle_t * handle)
 {
     lv_nuttx_uv_ctx_t * uv_ctx = handle->data;
@@ -174,6 +180,7 @@ static void lv_nuttx_uv_deinit_cb(uv_handle_t * handle)
     }
 }
 
+LV_FUNC_SECTION
 static void lv_nuttx_uv_timer_deinit(lv_nuttx_uv_ctx_t * uv_ctx)
 {
     lv_timer_handler_set_resume_cb(NULL, NULL);
@@ -181,6 +188,7 @@ static void lv_nuttx_uv_timer_deinit(lv_nuttx_uv_ctx_t * uv_ctx)
     LV_LOG_USER("Done");
 }
 
+LV_FUNC_SECTION
 static void lv_nuttx_uv_vsync_poll_cb(uv_poll_t * handle, int status, int events)
 {
     LV_UNUSED(handle);
@@ -195,6 +203,7 @@ static void lv_nuttx_uv_vsync_poll_cb(uv_poll_t * handle, int status, int events
     }
 }
 
+LV_FUNC_SECTION
 static void lv_nuttx_uv_disp_poll_cb(uv_poll_t * handle, int status, int events)
 {
     lv_nuttx_uv_fb_ctx_t * fb_ctx = &((lv_nuttx_uv_ctx_t *)(handle->data))->fb_ctx;
@@ -206,6 +215,7 @@ static void lv_nuttx_uv_disp_poll_cb(uv_poll_t * handle, int status, int events)
     fb_ctx->polling = false;
 }
 
+LV_FUNC_SECTION
 static void lv_nuttx_uv_disp_refr_req_cb(lv_event_t * e)
 {
     lv_nuttx_uv_fb_ctx_t * fb_ctx = lv_event_get_user_data(e);
@@ -217,6 +227,7 @@ static void lv_nuttx_uv_disp_refr_req_cb(lv_event_t * e)
     uv_poll_start(&fb_ctx->fb_poll, UV_WRITABLE, lv_nuttx_uv_disp_poll_cb);
 }
 
+LV_FUNC_SECTION
 static int lv_nuttx_uv_fb_init(lv_nuttx_uv_t * uv_info, lv_nuttx_uv_ctx_t * uv_ctx)
 {
     uv_loop_t * loop = uv_info->loop;
@@ -263,6 +274,7 @@ static int lv_nuttx_uv_fb_init(lv_nuttx_uv_t * uv_info, lv_nuttx_uv_ctx_t * uv_c
     return 0;
 }
 
+LV_FUNC_SECTION
 static void lv_nuttx_uv_fb_deinit(lv_nuttx_uv_ctx_t * uv_ctx)
 {
     /* should remove event */
@@ -274,6 +286,7 @@ static void lv_nuttx_uv_fb_deinit(lv_nuttx_uv_ctx_t * uv_ctx)
     LV_LOG_USER("Done");
 }
 
+LV_FUNC_SECTION
 static void lv_nuttx_uv_input_poll_cb(uv_poll_t * handle, int status, int events)
 {
     lv_indev_t * indev = ((lv_nuttx_uv_ctx_t *)(handle->data))->input_ctx.indev;
@@ -288,6 +301,7 @@ static void lv_nuttx_uv_input_poll_cb(uv_poll_t * handle, int status, int events
     }
 }
 
+LV_FUNC_SECTION
 static int lv_nuttx_uv_input_init(lv_nuttx_uv_t * uv_info, lv_nuttx_uv_ctx_t * uv_ctx)
 {
     uv_loop_t * loop = uv_info->loop;
@@ -326,6 +340,7 @@ static int lv_nuttx_uv_input_init(lv_nuttx_uv_t * uv_info, lv_nuttx_uv_ctx_t * u
     return 0;
 }
 
+LV_FUNC_SECTION
 static void lv_nuttx_uv_input_deinit(lv_nuttx_uv_ctx_t * uv_ctx)
 {
     lv_nuttx_uv_input_ctx_t * input_ctx = &uv_ctx->input_ctx;
diff --git a/src/drivers/nuttx/lv_nuttx_profiler.c b/src/drivers/nuttx/lv_nuttx_profiler.c
index a17c3a566..37b8c973a 100644
--- a/src/drivers/nuttx/lv_nuttx_profiler.c
+++ b/src/drivers/nuttx/lv_nuttx_profiler.c
@@ -46,6 +46,7 @@ static void flush_cb(const char * buf);
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 void lv_nuttx_profiler_init(void)
 {
     cpu_freq = (uint32_t)up_perf_getfreq() / 1000000;
@@ -67,6 +68,7 @@ void lv_nuttx_profiler_init(void)
  *   STATIC FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 static uint32_t tick_get_cb(void)
 {
     static uint32_t prev_tick = 0;
@@ -88,6 +90,7 @@ static uint32_t tick_get_cb(void)
     return cur_tick_us;
 }
 
+LV_FUNC_SECTION
 static void flush_cb(const char * buf)
 {
     printf("%s", buf);
diff --git a/src/drivers/nuttx/lv_nuttx_touchscreen.c b/src/drivers/nuttx/lv_nuttx_touchscreen.c
index d49f765a3..07e7dd32b 100644
--- a/src/drivers/nuttx/lv_nuttx_touchscreen.c
+++ b/src/drivers/nuttx/lv_nuttx_touchscreen.c
@@ -59,6 +59,7 @@ static lv_indev_t * touchscreen_init(int fd);
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 lv_indev_t * lv_nuttx_touchscreen_create(const char * dev_path)
 {
     lv_indev_t * indev;
@@ -87,6 +88,7 @@ lv_indev_t * lv_nuttx_touchscreen_create(const char * dev_path)
  *   STATIC FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 static void conv_touch_sample(lv_indev_t * drv,
                               lv_indev_data_t * data,
                               struct touch_sample_s * sample)
@@ -108,12 +110,14 @@ static void conv_touch_sample(lv_indev_t * drv,
     }
 }
 
+LV_FUNC_SECTION
 static bool touchscreen_read_sample(int fd, struct touch_sample_s * sample)
 {
     int nbytes = read(fd, sample, sizeof(struct touch_sample_s));
     return nbytes == sizeof(struct touch_sample_s);
 }
 
+LV_FUNC_SECTION
 static void touchscreen_read(lv_indev_t * drv, lv_indev_data_t * data)
 {
     lv_nuttx_touchscreen_t * touchscreen = drv->driver_data;
@@ -156,6 +160,7 @@ static void touchscreen_read(lv_indev_t * drv, lv_indev_data_t * data)
     data->state = touchscreen->last_state;
 }
 
+LV_FUNC_SECTION
 static void touchscreen_delete_cb(lv_event_t * e)
 {
     lv_indev_t * indev = (lv_indev_t *) lv_event_get_user_data(e);
@@ -173,6 +178,7 @@ static void touchscreen_delete_cb(lv_event_t * e)
     }
 }
 
+LV_FUNC_SECTION
 static lv_indev_t * touchscreen_init(int fd)
 {
     lv_nuttx_touchscreen_t * touchscreen;
diff --git a/src/drivers/qnx/lv_qnx.c b/src/drivers/qnx/lv_qnx.c
index f31e72710..b56f3db0f 100644
--- a/src/drivers/qnx/lv_qnx.c
+++ b/src/drivers/qnx/lv_qnx.c
@@ -77,6 +77,7 @@ static screen_context_t context;
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 lv_display_t * lv_qnx_window_create(int32_t hor_res, int32_t ver_res)
 {
     static bool inited = false;
@@ -124,6 +125,7 @@ lv_display_t * lv_qnx_window_create(int32_t hor_res, int32_t ver_res)
     return disp;
 }
 
+LV_FUNC_SECTION
 void lv_qnx_window_set_title(lv_display_t * disp, const char * title)
 {
     lv_qnx_window_t * dsc = lv_display_get_driver_data(disp);
@@ -150,6 +152,7 @@ void lv_qnx_window_set_title(lv_display_t * disp, const char * title)
     screen_inject_event(NULL, event);
 }
 
+LV_FUNC_SECTION
 bool lv_qnx_add_pointer_device(lv_display_t * disp)
 {
     lv_qnx_window_t * dsc = lv_display_get_driver_data(disp);
@@ -177,6 +180,7 @@ bool lv_qnx_add_pointer_device(lv_display_t * disp)
     return true;
 }
 
+LV_FUNC_SECTION
 bool lv_qnx_add_keyboard_device(lv_display_t * disp)
 {
     lv_qnx_window_t * dsc = lv_display_get_driver_data(disp);
@@ -204,6 +208,7 @@ bool lv_qnx_add_keyboard_device(lv_display_t * disp)
     return true;
 }
 
+LV_FUNC_SECTION
 int lv_qnx_event_loop(lv_display_t * disp)
 {
     lv_refr_now(disp);
@@ -263,12 +268,14 @@ int lv_qnx_event_loop(lv_display_t * disp)
  *   STATIC FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 static uint32_t get_ticks(void)
 {
     uint64_t const ns = clock_gettime_mon_ns();
     return (uint32_t)(ns / 1000000UL);
 }
 
+LV_FUNC_SECTION
 static void flush_cb(lv_display_t * disp, const lv_area_t * area, uint8_t * px_map)
 {
     lv_qnx_window_t * dsc = lv_display_get_driver_data(disp);
@@ -284,6 +291,7 @@ static void flush_cb(lv_display_t * disp, const lv_area_t * area, uint8_t * px_m
     lv_display_flush_ready(disp);
 }
 
+LV_FUNC_SECTION
 static bool window_create(lv_display_t * disp)
 {
     /*Create a window*/
@@ -357,6 +365,7 @@ static bool window_create(lv_display_t * disp)
     return true;
 }
 
+LV_FUNC_SECTION
 static bool init_display_from_window(lv_display_t * disp)
 {
     lv_qnx_window_t * dsc = lv_display_get_driver_data(disp);
@@ -388,6 +397,7 @@ static bool init_display_from_window(lv_display_t * disp)
     return true;
 }
 
+LV_FUNC_SECTION
 static void release_disp_cb(lv_event_t * e)
 {
     lv_display_t * disp = (lv_display_t *) lv_event_get_user_data(e);
@@ -409,6 +419,7 @@ static void release_disp_cb(lv_event_t * e)
     lv_display_set_driver_data(disp, NULL);
 }
 
+LV_FUNC_SECTION
 static void get_pointer(lv_indev_t * indev, lv_indev_data_t * data)
 {
     lv_qnx_pointer_t * dsc = lv_indev_get_driver_data(indev);
@@ -423,6 +434,7 @@ static void get_pointer(lv_indev_t * indev, lv_indev_data_t * data)
     }
 }
 
+LV_FUNC_SECTION
 static bool handle_pointer_event(lv_display_t * disp, screen_event_t event)
 {
     lv_qnx_window_t * dsc = lv_display_get_driver_data(disp);
@@ -448,6 +460,7 @@ static bool handle_pointer_event(lv_display_t * disp, screen_event_t event)
     return true;
 }
 
+LV_FUNC_SECTION
 static void get_key(lv_indev_t * indev, lv_indev_data_t * data)
 {
     lv_qnx_keyboard_t * dsc = lv_indev_get_driver_data(indev);
@@ -461,6 +474,7 @@ static void get_key(lv_indev_t * indev, lv_indev_data_t * data)
     }
 }
 
+LV_FUNC_SECTION
 static bool handle_keyboard_event(lv_display_t * disp, screen_event_t event)
 {
     lv_qnx_window_t * dsc = lv_display_get_driver_data(disp);
@@ -530,6 +544,7 @@ static bool handle_keyboard_event(lv_display_t * disp, screen_event_t event)
     return true;
 }
 
+LV_FUNC_SECTION
 static void refresh_cb(lv_timer_t * timer)
 {
     /*Refresh the window on timeout, but disable the timer. Any callback can
diff --git a/src/drivers/sdl/lv_sdl_keyboard.c b/src/drivers/sdl/lv_sdl_keyboard.c
index 0bb94d6e3..9363dd761 100644
--- a/src/drivers/sdl/lv_sdl_keyboard.c
+++ b/src/drivers/sdl/lv_sdl_keyboard.c
@@ -40,6 +40,7 @@ static void release_indev_cb(lv_event_t * e);
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 lv_indev_t * lv_sdl_keyboard_create(void)
 {
     lv_sdl_keyboard_t * dsc = lv_malloc_zeroed(sizeof(lv_sdl_keyboard_t));
@@ -66,6 +67,7 @@ lv_indev_t * lv_sdl_keyboard_create(void)
  *   STATIC FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 static void sdl_keyboard_read(lv_indev_t * indev, lv_indev_data_t * data)
 {
     lv_sdl_keyboard_t * dev = lv_indev_get_driver_data(indev);
@@ -86,6 +88,7 @@ static void sdl_keyboard_read(lv_indev_t * indev, lv_indev_data_t * data)
     }
 }
 
+LV_FUNC_SECTION
 static void release_indev_cb(lv_event_t * e)
 {
     lv_indev_t * indev = (lv_indev_t *) lv_event_get_user_data(e);
@@ -98,6 +101,7 @@ static void release_indev_cb(lv_event_t * e)
     }
 }
 
+LV_FUNC_SECTION
 void lv_sdl_keyboard_handler(SDL_Event * event)
 {
     uint32_t win_id = UINT32_MAX;
@@ -166,6 +170,7 @@ void lv_sdl_keyboard_handler(SDL_Event * event)
  * @param sdl_key the key code
  * @return LV_KEY_* control character or '\0'
  */
+LV_FUNC_SECTION
 static uint32_t keycode_to_ctrl_key(SDL_Keycode sdl_key)
 {
     /*Remap some key to LV_KEY_... to manage groups*/
diff --git a/src/drivers/sdl/lv_sdl_mouse.c b/src/drivers/sdl/lv_sdl_mouse.c
index 98b4f695f..4155d3374 100644
--- a/src/drivers/sdl/lv_sdl_mouse.c
+++ b/src/drivers/sdl/lv_sdl_mouse.c
@@ -44,6 +44,7 @@ typedef struct {
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 lv_indev_t * lv_sdl_mouse_create(void)
 {
     lv_sdl_mouse_t * dsc = lv_malloc_zeroed(sizeof(lv_sdl_mouse_t));
@@ -71,6 +72,7 @@ lv_indev_t * lv_sdl_mouse_create(void)
  *   STATIC FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 static void sdl_mouse_read(lv_indev_t * indev, lv_indev_data_t * data)
 {
     lv_sdl_mouse_t * dsc = lv_indev_get_driver_data(indev);
@@ -85,6 +87,7 @@ static void sdl_mouse_read(lv_indev_t * indev, lv_indev_data_t * data)
 #endif
 }
 
+LV_FUNC_SECTION
 static void release_indev_cb(lv_event_t * e)
 {
     lv_indev_t * indev = (lv_indev_t *) lv_event_get_user_data(e);
@@ -97,6 +100,7 @@ static void release_indev_cb(lv_event_t * e)
     }
 }
 
+LV_FUNC_SECTION
 void lv_sdl_mouse_handler(SDL_Event * event)
 {
     uint32_t win_id = UINT32_MAX;
diff --git a/src/drivers/sdl/lv_sdl_mousewheel.c b/src/drivers/sdl/lv_sdl_mousewheel.c
index b31a72309..d276f7a8f 100644
--- a/src/drivers/sdl/lv_sdl_mousewheel.c
+++ b/src/drivers/sdl/lv_sdl_mousewheel.c
@@ -36,6 +36,7 @@ typedef struct {
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 lv_indev_t * lv_sdl_mousewheel_create(void)
 {
     lv_sdl_mousewheel_t * dsc = lv_malloc_zeroed(sizeof(lv_sdl_mousewheel_t));
@@ -62,6 +63,7 @@ lv_indev_t * lv_sdl_mousewheel_create(void)
  *   STATIC FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 static void sdl_mousewheel_read(lv_indev_t * indev, lv_indev_data_t * data)
 {
     lv_sdl_mousewheel_t * dsc = lv_indev_get_driver_data(indev);
@@ -71,6 +73,7 @@ static void sdl_mousewheel_read(lv_indev_t * indev, lv_indev_data_t * data)
     dsc->diff = 0;
 }
 
+LV_FUNC_SECTION
 static void release_indev_cb(lv_event_t * e)
 {
     lv_indev_t * indev = (lv_indev_t *) lv_event_get_user_data(e);
@@ -83,6 +86,7 @@ static void release_indev_cb(lv_event_t * e)
     }
 }
 
+LV_FUNC_SECTION
 void lv_sdl_mousewheel_handler(SDL_Event * event)
 {
     uint32_t win_id = UINT32_MAX;
diff --git a/src/drivers/sdl/lv_sdl_window.c b/src/drivers/sdl/lv_sdl_window.c
index df8a28e4e..d719ee530 100644
--- a/src/drivers/sdl/lv_sdl_window.c
+++ b/src/drivers/sdl/lv_sdl_window.c
@@ -80,6 +80,7 @@ static lv_timer_t * event_handler_timer;
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 lv_display_t * lv_sdl_window_create(int32_t hor_res, int32_t ver_res)
 {
     if(!inited) {
@@ -139,12 +140,14 @@ lv_display_t * lv_sdl_window_create(int32_t hor_res, int32_t ver_res)
     return disp;
 }
 
+LV_FUNC_SECTION
 void lv_sdl_window_set_resizeable(lv_display_t * disp, bool value)
 {
     lv_sdl_window_t * dsc = lv_display_get_driver_data(disp);
     SDL_SetWindowResizable(dsc->window, value);
 }
 
+LV_FUNC_SECTION
 void lv_sdl_window_set_zoom(lv_display_t * disp, uint8_t zoom)
 {
     lv_sdl_window_t * dsc = lv_display_get_driver_data(disp);
@@ -153,12 +156,14 @@ void lv_sdl_window_set_zoom(lv_display_t * disp, uint8_t zoom)
     lv_refr_now(disp);
 }
 
+LV_FUNC_SECTION
 uint8_t lv_sdl_window_get_zoom(lv_display_t * disp)
 {
     lv_sdl_window_t * dsc = lv_display_get_driver_data(disp);
     return dsc->zoom;
 }
 
+LV_FUNC_SECTION
 lv_display_t * lv_sdl_get_disp_from_win_id(uint32_t win_id)
 {
     lv_display_t * disp = lv_display_get_next(NULL);
@@ -174,18 +179,21 @@ lv_display_t * lv_sdl_get_disp_from_win_id(uint32_t win_id)
     return NULL;
 }
 
+LV_FUNC_SECTION
 void lv_sdl_window_set_title(lv_display_t * disp, const char * title)
 {
     lv_sdl_window_t * dsc = lv_display_get_driver_data(disp);
     SDL_SetWindowTitle(dsc->window, title);
 }
 
+LV_FUNC_SECTION
 void * lv_sdl_window_get_renderer(lv_display_t * disp)
 {
     lv_sdl_window_t * dsc = lv_display_get_driver_data(disp);
     return dsc->renderer;
 }
 
+LV_FUNC_SECTION
 void lv_sdl_quit(void)
 {
     if(inited) {
@@ -200,11 +208,13 @@ void lv_sdl_quit(void)
  *   STATIC FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 static inline int sdl_render_mode(void)
 {
     return LV_SDL_RENDER_MODE;
 }
 
+LV_FUNC_SECTION
 static void flush_cb(lv_display_t * disp, const lv_area_t * area, uint8_t * px_map)
 {
 #if LV_USE_DRAW_SDL == 0
@@ -290,6 +300,7 @@ static void flush_cb(lv_display_t * disp, const lv_area_t * area, uint8_t * px_m
  * SDL main thread. All SDL related task have to be handled here!
  * It initializes SDL, handles drawing and the mouse.
  */
+LV_FUNC_SECTION
 static void sdl_event_handler(lv_timer_t * t)
 {
     LV_UNUSED(t);
@@ -338,6 +349,7 @@ static void sdl_event_handler(lv_timer_t * t)
     }
 }
 
+LV_FUNC_SECTION
 static void window_create(lv_display_t * disp)
 {
     lv_sdl_window_t * dsc = lv_display_get_driver_data(disp);
@@ -372,6 +384,7 @@ static void window_create(lv_display_t * disp)
 #endif /*LV_USE_DRAW_SDL == 0*/
 }
 
+LV_FUNC_SECTION
 static void window_update(lv_display_t * disp)
 {
     lv_sdl_window_t * dsc = lv_display_get_driver_data(disp);
@@ -389,6 +402,7 @@ static void window_update(lv_display_t * disp)
 }
 
 #if LV_USE_DRAW_SDL == 0
+LV_FUNC_SECTION
 static void texture_resize(lv_display_t * disp)
 {
     uint32_t stride = lv_draw_buf_width_to_stride(disp->hor_res, lv_display_get_color_format(disp));
@@ -426,6 +440,7 @@ static void texture_resize(lv_display_t * disp)
     SDL_SetTextureBlendMode(dsc->texture, SDL_BLENDMODE_BLEND);
 }
 
+LV_FUNC_SECTION
 static void * sdl_draw_buf_realloc_aligned(void * ptr, size_t new_size)
 {
     if(ptr) {
@@ -444,6 +459,7 @@ static void * sdl_draw_buf_realloc_aligned(void * ptr, size_t new_size)
 #endif /* _WIN32 */
 }
 
+LV_FUNC_SECTION
 static void sdl_draw_buf_free(void * ptr)
 {
 #ifndef _WIN32
@@ -454,6 +470,7 @@ static void sdl_draw_buf_free(void * ptr)
 }
 #endif
 
+LV_FUNC_SECTION
 static void res_chg_event_cb(lv_event_t * e)
 {
     lv_display_t * disp = lv_event_get_current_target(e);
@@ -468,6 +485,7 @@ static void res_chg_event_cb(lv_event_t * e)
 #endif
 }
 
+LV_FUNC_SECTION
 static void release_disp_cb(lv_event_t * e)
 {
     if(lv_deinit_in_progress) {
diff --git a/src/drivers/wayland/lv_wayland.c b/src/drivers/wayland/lv_wayland.c
index dc71f6677..9a91b1e26 100644
--- a/src/drivers/wayland/lv_wayland.c
+++ b/src/drivers/wayland/lv_wayland.c
@@ -279,6 +279,7 @@ static void wayland_deinit(void);
  * @param struct wl_callback The callback that needs to be destroyed and re-created
  * @param time Timestamp of the event (unused)
  */
+LV_FUNC_SECTION
 static void graphic_obj_frame_done(void * data, struct wl_callback * cb, uint32_t time)
 {
     struct graphic_object * obj;
@@ -303,6 +304,7 @@ static const struct wl_callback_listener wl_surface_frame_listener = {
     .done = graphic_obj_frame_done,
 };
 
+LV_FUNC_SECTION
 static inline bool _is_digit(char ch)
 {
     return (ch >= '0') && (ch <= '9');
@@ -313,6 +315,7 @@ static inline bool _is_digit(char ch)
  *  @description called by the compositor to advertise the supported
  *  color formats for SHM buffers, there is a call per supported format
  */
+LV_FUNC_SECTION
 static void shm_format(void * data, struct wl_shm * wl_shm, uint32_t format)
 {
     struct application * app = data;
@@ -346,6 +349,7 @@ static const struct wl_shm_listener shm_listener = {
     shm_format
 };
 
+LV_FUNC_SECTION
 static void pointer_handle_enter(void * data, struct wl_pointer * pointer,
                                  uint32_t serial, struct wl_surface * surface,
                                  wl_fixed_t sx, wl_fixed_t sy)
@@ -444,6 +448,7 @@ static void pointer_handle_enter(void * data, struct wl_pointer * pointer,
     }
 }
 
+LV_FUNC_SECTION
 static void pointer_handle_leave(void * data, struct wl_pointer * pointer,
                                  uint32_t serial, struct wl_surface * surface)
 {
@@ -457,6 +462,7 @@ static void pointer_handle_leave(void * data, struct wl_pointer * pointer,
     }
 }
 
+LV_FUNC_SECTION
 static void pointer_handle_motion(void * data, struct wl_pointer * pointer,
                                   uint32_t time, wl_fixed_t sx, wl_fixed_t sy)
 {
@@ -473,6 +479,7 @@ static void pointer_handle_motion(void * data, struct wl_pointer * pointer,
     app->pointer_obj->input.pointer.y = LV_MAX(0, LV_MIN(wl_fixed_to_int(sy), app->pointer_obj->height - 1));
 }
 
+LV_FUNC_SECTION
 static void pointer_handle_button(void * data, struct wl_pointer * wl_pointer,
                                   uint32_t serial, uint32_t time, uint32_t button,
                                   uint32_t state)
@@ -643,6 +650,7 @@ static void pointer_handle_button(void * data, struct wl_pointer * wl_pointer,
     }
 }
 
+LV_FUNC_SECTION
 static void pointer_handle_axis(void * data, struct wl_pointer * wl_pointer,
                                 uint32_t time, uint32_t axis, wl_fixed_t value)
 {
@@ -674,6 +682,7 @@ static const struct wl_pointer_listener pointer_listener = {
     .axis   = pointer_handle_axis,
 };
 
+LV_FUNC_SECTION
 static lv_key_t keycode_xkb_to_lv(xkb_keysym_t xkb_key)
 {
     lv_key_t key = 0;
@@ -742,6 +751,7 @@ static lv_key_t keycode_xkb_to_lv(xkb_keysym_t xkb_key)
     return key;
 }
 
+LV_FUNC_SECTION
 static void keyboard_handle_keymap(void * data, struct wl_keyboard * keyboard,
                                    uint32_t format, int fd, uint32_t size)
 {
@@ -789,6 +799,7 @@ static void keyboard_handle_keymap(void * data, struct wl_keyboard * keyboard,
     app->seat.xkb.state = state;
 }
 
+LV_FUNC_SECTION
 static void keyboard_handle_enter(void * data, struct wl_keyboard * keyboard,
                                   uint32_t serial, struct wl_surface * surface,
                                   struct wl_array * keys)
@@ -807,6 +818,7 @@ static void keyboard_handle_enter(void * data, struct wl_keyboard * keyboard,
     }
 }
 
+LV_FUNC_SECTION
 static void keyboard_handle_leave(void * data, struct wl_keyboard * keyboard,
                                   uint32_t serial, struct wl_surface * surface)
 {
@@ -820,6 +832,7 @@ static void keyboard_handle_leave(void * data, struct wl_keyboard * keyboard,
     }
 }
 
+LV_FUNC_SECTION
 static void keyboard_handle_key(void * data, struct wl_keyboard * keyboard,
                                 uint32_t serial, uint32_t time, uint32_t key,
                                 uint32_t state)
@@ -851,6 +864,7 @@ static void keyboard_handle_key(void * data, struct wl_keyboard * keyboard,
     }
 }
 
+LV_FUNC_SECTION
 static void keyboard_handle_modifiers(void * data, struct wl_keyboard * keyboard,
                                       uint32_t serial, uint32_t mods_depressed,
                                       uint32_t mods_latched, uint32_t mods_locked,
@@ -878,6 +892,7 @@ static const struct wl_keyboard_listener keyboard_listener = {
     .modifiers  = keyboard_handle_modifiers,
 };
 
+LV_FUNC_SECTION
 static void touch_handle_down(void * data, struct wl_touch * wl_touch,
                               uint32_t serial, uint32_t time, struct wl_surface * surface,
                               int32_t id, wl_fixed_t x_w, wl_fixed_t y_w)
@@ -923,6 +938,7 @@ static void touch_handle_down(void * data, struct wl_touch * wl_touch,
 #endif
 }
 
+LV_FUNC_SECTION
 static void touch_handle_up(void * data, struct wl_touch * wl_touch,
                             uint32_t serial, uint32_t time, int32_t id)
 {
@@ -971,6 +987,7 @@ static void touch_handle_up(void * data, struct wl_touch * wl_touch,
     app->touch_obj = NULL;
 }
 
+LV_FUNC_SECTION
 static void touch_handle_motion(void * data, struct wl_touch * wl_touch,
                                 uint32_t time, int32_t id, wl_fixed_t x_w, wl_fixed_t y_w)
 {
@@ -988,6 +1005,7 @@ static void touch_handle_motion(void * data, struct wl_touch * wl_touch,
     app->touch_obj->input.touch.y = wl_fixed_to_int(y_w);
 }
 
+LV_FUNC_SECTION
 static void touch_handle_frame(void * data, struct wl_touch * wl_touch)
 {
     LV_UNUSED(wl_touch);
@@ -995,6 +1013,7 @@ static void touch_handle_frame(void * data, struct wl_touch * wl_touch)
 
 }
 
+LV_FUNC_SECTION
 static void touch_handle_cancel(void * data, struct wl_touch * wl_touch)
 {
     LV_UNUSED(wl_touch);
@@ -1009,6 +1028,7 @@ static const struct wl_touch_listener touch_listener = {
     .cancel = touch_handle_cancel,
 };
 
+LV_FUNC_SECTION
 static void seat_handle_capabilities(void * data, struct wl_seat * wl_seat, enum wl_seat_capability caps)
 {
     struct application * app = data;
@@ -1053,6 +1073,7 @@ static const struct wl_seat_listener seat_listener = {
     .capabilities = seat_handle_capabilities,
 };
 
+LV_FUNC_SECTION
 static void draw_window(struct window * window, uint32_t width, uint32_t height)
 {
 
@@ -1083,11 +1104,13 @@ static void draw_window(struct window * window, uint32_t width, uint32_t height)
 }
 
 #if LV_WAYLAND_WL_SHELL
+LV_FUNC_SECTION
 static void wl_shell_handle_ping(void * data, struct wl_shell_surface * shell_surface, uint32_t serial)
 {
     return wl_shell_surface_pong(shell_surface, serial);
 }
 
+LV_FUNC_SECTION
 static void wl_shell_handle_configure(void * data, struct wl_shell_surface * shell_surface,
                                       uint32_t edges, int32_t width, int32_t height)
 {
@@ -1112,6 +1135,7 @@ static const struct wl_shell_surface_listener shell_surface_listener = {
 #endif
 
 #if LV_WAYLAND_XDG_SHELL
+LV_FUNC_SECTION
 static void xdg_surface_handle_configure(void * data, struct xdg_surface * xdg_surface, uint32_t serial)
 {
     struct window * window = (struct window *)data;
@@ -1142,6 +1166,7 @@ static const struct xdg_surface_listener xdg_surface_listener = {
     .configure = xdg_surface_handle_configure,
 };
 
+LV_FUNC_SECTION
 static void xdg_toplevel_handle_configure(void * data, struct xdg_toplevel * xdg_toplevel,
                                           int32_t width, int32_t height, struct wl_array * states)
 {
@@ -1173,6 +1198,7 @@ static void xdg_toplevel_handle_configure(void * data, struct xdg_toplevel * xdg
     }
 }
 
+LV_FUNC_SECTION
 static void xdg_toplevel_handle_close(void * data, struct xdg_toplevel * xdg_toplevel)
 {
     struct window * window = (struct window *)data;
@@ -1181,6 +1207,7 @@ static void xdg_toplevel_handle_close(void * data, struct xdg_toplevel * xdg_top
     LV_UNUSED(xdg_toplevel);
 }
 
+LV_FUNC_SECTION
 static void xdg_toplevel_handle_configure_bounds(void * data, struct xdg_toplevel * xdg_toplevel,
                                                  int32_t width, int32_t height)
 {
@@ -1201,6 +1228,7 @@ static const struct xdg_toplevel_listener xdg_toplevel_listener = {
     .configure_bounds = xdg_toplevel_handle_configure_bounds
 };
 
+LV_FUNC_SECTION
 static void xdg_wm_base_ping(void * data, struct xdg_wm_base * xdg_wm_base, uint32_t serial)
 {
     LV_UNUSED(data);
@@ -1216,6 +1244,7 @@ static const struct xdg_wm_base_listener xdg_wm_base_listener = {
 #endif
 
 
+LV_FUNC_SECTION
 static void handle_global(void * data, struct wl_registry * registry,
                           uint32_t name, const char * interface, uint32_t version)
 {
@@ -1253,6 +1282,7 @@ static void handle_global(void * data, struct wl_registry * registry,
 #endif
 }
 
+LV_FUNC_SECTION
 static void handle_global_remove(void * data, struct wl_registry * registry, uint32_t name)
 {
 
@@ -1267,6 +1297,7 @@ static const struct wl_registry_listener registry_listener = {
     .global_remove  = handle_global_remove
 };
 
+LV_FUNC_SECTION
 static void handle_wl_buffer_release(void * data, struct wl_buffer * wl_buffer)
 {
     const struct smm_buffer_properties * props;
@@ -1289,12 +1320,14 @@ static const struct wl_buffer_listener wl_buffer_listener = {
     .release = handle_wl_buffer_release,
 };
 
+LV_FUNC_SECTION
 static void cache_clear(struct window * window)
 {
     window->dmg_cache.start = window->dmg_cache.end;
     window->dmg_cache.size = 0;
 }
 
+LV_FUNC_SECTION
 static void cache_purge(struct window * window, smm_buffer_t * buf)
 {
     lv_area_t * next_dmg;
@@ -1314,6 +1347,7 @@ static void cache_purge(struct window * window, smm_buffer_t * buf)
     }
 }
 
+LV_FUNC_SECTION
 static void cache_add_area(struct window * window, smm_buffer_t * buf, const lv_area_t * area)
 {
     if(SMM_BUFFER_PROPERTIES(buf)->tag[TAG_BUFFER_DAMAGE] == NULL) {
@@ -1343,6 +1377,7 @@ done:
     return;
 }
 
+LV_FUNC_SECTION
 static void cache_apply_areas(struct window * window, void * dest, void * src, smm_buffer_t * src_buf)
 {
     unsigned long offset;
@@ -1384,6 +1419,7 @@ static void cache_apply_areas(struct window * window, void * dest, void * src, s
 
 }
 
+LV_FUNC_SECTION
 static bool sme_new_pool(void * ctx, smm_pool_t * pool)
 {
     struct wl_shm_pool * wl_pool;
@@ -1400,6 +1436,7 @@ static bool sme_new_pool(void * ctx, smm_pool_t * pool)
     return (wl_pool == NULL);
 }
 
+LV_FUNC_SECTION
 static void sme_expand_pool(void * ctx, smm_pool_t * pool)
 {
     const struct smm_pool_properties * props = SMM_POOL_PROPERTIES(pool);
@@ -1409,6 +1446,7 @@ static void sme_expand_pool(void * ctx, smm_pool_t * pool)
     wl_shm_pool_resize(props->tag[TAG_LOCAL], props->size);
 }
 
+LV_FUNC_SECTION
 static void sme_free_pool(void * ctx, smm_pool_t * pool)
 {
     struct wl_shm_pool * wl_pool = SMM_POOL_PROPERTIES(pool)->tag[TAG_LOCAL];
@@ -1418,6 +1456,7 @@ static void sme_free_pool(void * ctx, smm_pool_t * pool)
     wl_shm_pool_destroy(wl_pool);
 }
 
+LV_FUNC_SECTION
 static bool sme_new_buffer(void * ctx, smm_buffer_t * buf)
 {
     struct wl_buffer * wl_buf;
@@ -1448,6 +1487,7 @@ static bool sme_new_buffer(void * ctx, smm_buffer_t * buf)
     return fail_alloc;
 }
 
+LV_FUNC_SECTION
 static bool sme_init_buffer(void * ctx, smm_buffer_t * buf)
 {
     smm_buffer_t * src;
@@ -1521,6 +1561,7 @@ done:
     return fail_init;
 }
 
+LV_FUNC_SECTION
 static void sme_free_buffer(void * ctx, smm_buffer_t * buf)
 {
     struct wl_buffer * wl_buf = SMM_BUFFER_PROPERTIES(buf)->tag[TAG_LOCAL];
@@ -1530,6 +1571,7 @@ static void sme_free_buffer(void * ctx, smm_buffer_t * buf)
     wl_buffer_destroy(wl_buf);
 }
 
+LV_FUNC_SECTION
 static struct graphic_object * create_graphic_obj(struct application * app, struct window * window,
                                                   enum object_type type,
                                                   struct graphic_object * parent)
@@ -1577,6 +1619,7 @@ err_out:
     return NULL;
 }
 
+LV_FUNC_SECTION
 static void destroy_graphic_obj(struct graphic_object * obj)
 {
     if(obj->subsurface) {
@@ -1589,6 +1632,7 @@ static void destroy_graphic_obj(struct graphic_object * obj)
 }
 
 #if LV_WAYLAND_WINDOW_DECORATIONS
+LV_FUNC_SECTION
 static bool attach_decoration(struct window * window, struct graphic_object * decoration,
                               smm_buffer_t * decoration_buffer, struct graphic_object * parent)
 {
@@ -1690,6 +1734,7 @@ err_destroy_surface:
  * @param height height of the filled area
  *
  */
+LV_FUNC_SECTION
 static void color_fill(void * pixels, lv_color_t color, uint32_t width, uint32_t height)
 {
 
@@ -1706,6 +1751,7 @@ static void color_fill(void * pixels, lv_color_t color, uint32_t width, uint32_t
     }
 }
 
+LV_FUNC_SECTION
 static void color_fill_XRGB8888(void * pixels, lv_color_t color, uint32_t width, uint32_t height)
 {
     unsigned char * buf = pixels;
@@ -1722,6 +1768,7 @@ static void color_fill_XRGB8888(void * pixels, lv_color_t color, uint32_t width,
 
 }
 
+LV_FUNC_SECTION
 static void color_fill_RGB565(void * pixels, lv_color_t color, uint32_t width, uint32_t height)
 {
     uint16_t * buf = pixels;
@@ -1734,6 +1781,7 @@ static void color_fill_RGB565(void * pixels, lv_color_t color, uint32_t width, u
     }
 }
 
+LV_FUNC_SECTION
 static bool create_decoration(struct window * window,
                               struct graphic_object * decoration,
                               int window_width, int window_height)
@@ -1871,6 +1919,7 @@ static bool create_decoration(struct window * window,
     return attach_decoration(window, decoration, buf, window->body);
 }
 
+LV_FUNC_SECTION
 static void detach_decoration(struct window * window,
                               struct graphic_object * decoration)
 {
@@ -1884,6 +1933,7 @@ static void detach_decoration(struct window * window,
 }
 #endif
 
+LV_FUNC_SECTION
 static bool resize_window(struct window * window, int width, int height)
 {
     struct smm_buffer_t * body_buf1;
@@ -1981,6 +2031,7 @@ static bool resize_window(struct window * window, int width, int height)
  * @param width the height of the window w/decorations
  * @param height the width of the window w/decorations
 */
+LV_FUNC_SECTION
 static struct window * create_window(struct application * app, int width, int height, const char * title)
 {
     struct window * window;
@@ -2080,6 +2131,7 @@ err_free_window:
     return NULL;
 }
 
+LV_FUNC_SECTION
 static void destroy_window(struct window * window)
 {
     if(!window) {
@@ -2111,6 +2163,7 @@ static void destroy_window(struct window * window)
     destroy_graphic_obj(window->body);
 }
 
+LV_FUNC_SECTION
 static void _lv_wayland_flush(lv_display_t * disp, const lv_area_t * area, unsigned char * color_p)
 {
     unsigned long offset;
@@ -2220,6 +2273,7 @@ skip:
     }
 }
 
+LV_FUNC_SECTION
 static void _lv_wayland_handle_input(void)
 {
     int prepare_read = wl_display_prepare_read(application.display);
@@ -2231,6 +2285,7 @@ static void _lv_wayland_handle_input(void)
     wl_display_dispatch_pending(application.display);
 }
 
+LV_FUNC_SECTION
 static void _lv_wayland_handle_output(void)
 {
     struct window * window;
@@ -2293,6 +2348,7 @@ static void _lv_wayland_handle_output(void)
     }
 }
 
+LV_FUNC_SECTION
 static void _lv_wayland_pointer_read(lv_indev_t * drv, lv_indev_data_t * data)
 {
     struct window * window = lv_display_get_user_data(lv_indev_get_display(drv));
@@ -2306,6 +2362,7 @@ static void _lv_wayland_pointer_read(lv_indev_t * drv, lv_indev_data_t * data)
     data->state = window->body->input.pointer.left_button;
 }
 
+LV_FUNC_SECTION
 static void _lv_wayland_pointeraxis_read(lv_indev_t * drv, lv_indev_data_t * data)
 {
     struct window * window = lv_display_get_user_data(lv_indev_get_display(drv));
@@ -2320,6 +2377,7 @@ static void _lv_wayland_pointeraxis_read(lv_indev_t * drv, lv_indev_data_t * dat
     window->body->input.pointer.wheel_diff = 0;
 }
 
+LV_FUNC_SECTION
 static void _lv_wayland_keyboard_read(lv_indev_t * drv, lv_indev_data_t * data)
 {
     struct window * window = lv_display_get_user_data(lv_indev_get_display(drv));
@@ -2331,6 +2389,7 @@ static void _lv_wayland_keyboard_read(lv_indev_t * drv, lv_indev_data_t * data)
     data->state = window->body->input.keyboard.state;
 }
 
+LV_FUNC_SECTION
 static void _lv_wayland_touch_read(lv_indev_t * drv, lv_indev_data_t * data)
 {
     struct window * window = lv_display_get_user_data(lv_indev_get_display(drv));
@@ -2350,6 +2409,7 @@ static void _lv_wayland_touch_read(lv_indev_t * drv, lv_indev_data_t * data)
 /**
  * Initialize Wayland driver
  */
+LV_FUNC_SECTION
 static void wayland_init(void)
 {
     struct smm_events evs = {
@@ -2424,6 +2484,7 @@ static void wayland_init(void)
 /**
  * De-initialize Wayland driver
  */
+LV_FUNC_SECTION
 static void wayland_deinit(void)
 {
     struct window * window = NULL;
@@ -2472,6 +2533,7 @@ static void wayland_deinit(void)
 
 }
 
+LV_FUNC_SECTION
 static uint32_t tick_get_cb(void)
 {
     struct timespec t;
@@ -2484,6 +2546,7 @@ static uint32_t tick_get_cb(void)
  * Get Wayland display file descriptor
  * @return Wayland display file descriptor
  */
+LV_FUNC_SECTION
 int lv_wayland_get_fd(void)
 {
     return wl_display_get_fd(application.display);
@@ -2497,6 +2560,7 @@ int lv_wayland_get_fd(void)
  * @param close_cb function to be called when the window gets closed by the user (optional)
  * @return new display backed by a Wayland window, or NULL on error
  */
+LV_FUNC_SECTION
 lv_display_t * lv_wayland_window_create(uint32_t hor_res, uint32_t ver_res, char * title,
                                         lv_wayland_display_close_f_t close_cb)
 {
@@ -2594,6 +2658,7 @@ lv_display_t * lv_wayland_window_create(uint32_t hor_res, uint32_t ver_res, char
  * Close wayland window
  * @param disp LVGL display using window to be closed
  */
+LV_FUNC_SECTION
 void lv_wayland_window_close(lv_display_t * disp)
 {
     struct window * window = lv_display_get_user_data(disp);
@@ -2610,6 +2675,7 @@ void lv_wayland_window_close(lv_display_t * disp)
  * argument is NULL), check if any Wayland window is open.
  * @return true if window open, false otherwise
  */
+LV_FUNC_SECTION
 bool lv_wayland_window_is_open(lv_display_t * disp)
 {
     struct window * window;
@@ -2637,6 +2703,7 @@ bool lv_wayland_window_is_open(lv_display_t * disp)
  * @param disp LVGL display using window to be set/unset maximization
  * @param Maximization requested status (true = maximized)
  */
+LV_FUNC_SECTION
 void lv_wayland_window_set_maximized(lv_display_t * disp, bool maximized)
 {
     struct window * window = lv_display_get_user_data(disp);
@@ -2682,6 +2749,7 @@ void lv_wayland_window_set_maximized(lv_display_t * disp, bool maximized)
  * @param disp LVGL display using window to be set/unset fullscreen
  * @param fullscreen requested status (true = fullscreen)
  */
+LV_FUNC_SECTION
 void lv_wayland_window_set_fullscreen(lv_display_t * disp, bool fullscreen)
 {
     struct window * window = lv_display_get_user_data(disp);
@@ -2730,6 +2798,7 @@ void lv_wayland_window_set_fullscreen(lv_display_t * disp, bool fullscreen)
  * @param disp LVGL display
  * @return input device connected to pointer events, or NULL on error
  */
+LV_FUNC_SECTION
 lv_indev_t * lv_wayland_get_pointer(lv_display_t * disp)
 {
     struct window * window = lv_display_get_user_data(disp);
@@ -2744,6 +2813,7 @@ lv_indev_t * lv_wayland_get_pointer(lv_display_t * disp)
  * @param disp LVGL display
  * @return input device connected to pointer axis events, or NULL on error
  */
+LV_FUNC_SECTION
 lv_indev_t * lv_wayland_get_pointeraxis(lv_display_t * disp)
 {
     struct window * window = lv_display_get_user_data(disp);
@@ -2758,6 +2828,7 @@ lv_indev_t * lv_wayland_get_pointeraxis(lv_display_t * disp)
  * @param disp LVGL display
  * @return input device connected to keyboard, or NULL on error
  */
+LV_FUNC_SECTION
 lv_indev_t * lv_wayland_get_keyboard(lv_display_t * disp)
 {
     struct window * window = lv_display_get_user_data(disp);
@@ -2772,6 +2843,7 @@ lv_indev_t * lv_wayland_get_keyboard(lv_display_t * disp)
  * @param disp LVGL display
  * @return input device connected to touchscreen, or NULL on error
  */
+LV_FUNC_SECTION
 lv_indev_t * lv_wayland_get_touchscreen(lv_display_t * disp)
 {
     struct window * window = lv_display_get_user_data(disp);
@@ -2784,6 +2856,7 @@ lv_indev_t * lv_wayland_get_touchscreen(lv_display_t * disp)
 /**
  * Wayland specific timer handler (use in place of LVGL lv_timer_handler)
  */
+LV_FUNC_SECTION
 bool lv_wayland_timer_handler(void)
 {
     struct window * window;
diff --git a/src/drivers/wayland/lv_wayland_smm.c b/src/drivers/wayland/lv_wayland_smm.c
index 7cb982a0f..9a4b2a23d 100644
--- a/src/drivers/wayland/lv_wayland_smm.c
+++ b/src/drivers/wayland/lv_wayland_smm.c
@@ -144,6 +144,7 @@ static struct {
 } smm_instance;
 
 
+LV_FUNC_SECTION
 void smm_init(struct smm_events * evs)
 {
     memcpy(&smm_instance.cbs, evs, sizeof(struct smm_events));
@@ -153,6 +154,7 @@ void smm_init(struct smm_events * evs)
 }
 
 
+LV_FUNC_SECTION
 void smm_deinit(void)
 {
     struct smm_group * grp;
@@ -165,12 +167,14 @@ void smm_deinit(void)
 }
 
 
+LV_FUNC_SECTION
 void smm_setctx(void * ctx)
 {
     smm_instance.cbs.ctx = ctx;
 }
 
 
+LV_FUNC_SECTION
 smm_group_t * smm_create(void)
 {
     struct smm_group * grp;
@@ -192,6 +196,7 @@ smm_group_t * smm_create(void)
 }
 
 
+LV_FUNC_SECTION
 void smm_resize(smm_group_t * grp, size_t sz)
 {
     struct smm_buffer * buf;
@@ -214,6 +219,7 @@ void smm_resize(smm_group_t * grp, size_t sz)
 }
 
 
+LV_FUNC_SECTION
 void smm_destroy(smm_group_t * grp)
 {
     struct smm_buffer * buf;
@@ -239,6 +245,7 @@ void smm_destroy(smm_group_t * grp)
 }
 
 
+LV_FUNC_SECTION
 smm_buffer_t * smm_acquire(smm_group_t * grp)
 {
     struct smm_buffer * buf;
@@ -278,6 +285,7 @@ smm_buffer_t * smm_acquire(smm_group_t * grp)
 }
 
 
+LV_FUNC_SECTION
 void * smm_map(smm_buffer_t * buf)
 {
     struct smm_buffer * mbuf = buf;
@@ -317,6 +325,7 @@ void * smm_map(smm_buffer_t * buf)
 }
 
 
+LV_FUNC_SECTION
 void smm_release(smm_buffer_t * buf)
 {
     struct smm_buffer * rbuf = buf;
@@ -346,6 +355,7 @@ void smm_release(smm_buffer_t * buf)
 }
 
 
+LV_FUNC_SECTION
 smm_buffer_t * smm_latest(smm_group_t * grp)
 {
     struct smm_group * lgrp = grp;
@@ -354,6 +364,7 @@ smm_buffer_t * smm_latest(smm_group_t * grp)
 }
 
 
+LV_FUNC_SECTION
 smm_buffer_t * smm_next(smm_buffer_t * buf)
 {
     struct smm_buffer * ibuf;
@@ -370,6 +381,7 @@ smm_buffer_t * smm_next(smm_buffer_t * buf)
     return ibuf;
 }
 
+LV_FUNC_SECTION
 void purge_history(struct smm_buffer * buf)
 {
     struct smm_buffer * ibuf;
@@ -387,6 +399,7 @@ void purge_history(struct smm_buffer * buf)
 }
 
 
+LV_FUNC_SECTION
 size_t calc_buffer_size(struct smm_buffer * buf)
 {
     size_t buf_sz;
@@ -403,6 +416,7 @@ size_t calc_buffer_size(struct smm_buffer * buf)
 }
 
 
+LV_FUNC_SECTION
 struct smm_buffer * get_from_pool(struct smm_group * grp)
 {
     int ret;
@@ -527,6 +541,7 @@ struct smm_buffer * get_from_pool(struct smm_group * grp)
 }
 
 
+LV_FUNC_SECTION
 void return_to_pool(struct smm_buffer * buf)
 {
     struct smm_group * grp = buf->props.group;
@@ -580,6 +595,7 @@ void return_to_pool(struct smm_buffer * buf)
 }
 
 
+LV_FUNC_SECTION
 struct smm_pool * alloc_pool(void)
 {
     struct smm_pool * pool;
@@ -623,6 +639,7 @@ struct smm_pool * alloc_pool(void)
 }
 
 
+LV_FUNC_SECTION
 void free_pool(struct smm_pool * pool)
 {
     if(pool->map != NULL) {
@@ -634,6 +651,7 @@ void free_pool(struct smm_pool * pool)
 }
 
 
+LV_FUNC_SECTION
 struct smm_buffer * alloc_buffer(struct smm_buffer * last, size_t offset)
 {
     struct smm_buffer * buf;
@@ -662,6 +680,7 @@ struct smm_buffer * alloc_buffer(struct smm_buffer * last, size_t offset)
 }
 
 
+LV_FUNC_SECTION
 void free_buffer(struct smm_buffer * buf)
 {
     struct smm_pool * buf_pool = buf->props.pool;
diff --git a/src/drivers/windows/lv_windows_context.c b/src/drivers/windows/lv_windows_context.c
index 7bf20385a..d12604ba3 100644
--- a/src/drivers/windows/lv_windows_context.c
+++ b/src/drivers/windows/lv_windows_context.c
@@ -61,6 +61,7 @@ static LRESULT CALLBACK lv_windows_window_message_callback(
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 void lv_windows_platform_init(void)
 {
     lv_tick_set_cb(lv_windows_tick_count_callback);
@@ -100,6 +101,7 @@ void lv_windows_platform_init(void)
     LV_ASSERT(RegisterClassExW(&window_class));
 }
 
+LV_FUNC_SECTION
 lv_windows_window_context_t * lv_windows_get_window_context(
     HWND window_handle)
 {
@@ -111,6 +113,7 @@ lv_windows_window_context_t * lv_windows_get_window_context(
  *   STATIC FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 static uint32_t lv_windows_tick_count_callback(void)
 {
     LARGE_INTEGER Frequency;
@@ -124,6 +127,7 @@ static uint32_t lv_windows_tick_count_callback(void)
     return (uint32_t)GetTickCount64();
 }
 
+LV_FUNC_SECTION
 static void lv_windows_delay_callback(uint32_t ms)
 {
     HANDLE timer_handle = CreateWaitableTimerExW(
@@ -142,6 +146,7 @@ static void lv_windows_delay_callback(uint32_t ms)
     }
 }
 
+LV_FUNC_SECTION
 static void lv_windows_check_display_existence_timer_callback(
     lv_timer_t * timer)
 {
@@ -153,6 +158,7 @@ static void lv_windows_check_display_existence_timer_callback(
     }
 }
 
+LV_FUNC_SECTION
 static HDC lv_windows_create_frame_buffer(
     HWND window_handle,
     LONG width,
@@ -226,6 +232,7 @@ static HDC lv_windows_create_frame_buffer(
     return frame_buffer_dc_handle;
 }
 
+LV_FUNC_SECTION
 static void lv_windows_display_timer_callback(lv_timer_t * timer)
 {
     lv_windows_window_context_t * context = lv_timer_get_user_data(timer);
@@ -277,6 +284,7 @@ static void lv_windows_display_timer_callback(lv_timer_t * timer)
     context->requested_display_resolution.y = 0;
 }
 
+LV_FUNC_SECTION
 static void lv_windows_display_driver_flush_callback(
     lv_display_t * display,
     const lv_area_t * area,
@@ -344,6 +352,7 @@ static void lv_windows_display_driver_flush_callback(
     lv_display_flush_ready(display);
 }
 
+LV_FUNC_SECTION
 static UINT lv_windows_get_dpi_for_window(HWND window_handle)
 {
     UINT result = (UINT)(-1);
@@ -396,6 +405,7 @@ static UINT lv_windows_get_dpi_for_window(HWND window_handle)
     return result;
 }
 
+LV_FUNC_SECTION
 static BOOL lv_windows_register_touch_window(
     HWND window_handle,
     ULONG flags)
@@ -416,6 +426,7 @@ static BOOL lv_windows_register_touch_window(
     return function(window_handle, flags);
 }
 
+LV_FUNC_SECTION
 static BOOL lv_windows_enable_child_window_dpi_message(
     HWND WindowHandle)
 {
@@ -459,6 +470,7 @@ static BOOL lv_windows_enable_child_window_dpi_message(
     return function(WindowHandle, TRUE);
 }
 
+LV_FUNC_SECTION
 static bool lv_windows_window_message_callback_nolock(
     HWND hWnd,
     UINT uMsg,
@@ -696,6 +708,7 @@ static bool lv_windows_window_message_callback_nolock(
     return true;
 }
 
+LV_FUNC_SECTION
 static LRESULT CALLBACK lv_windows_window_message_callback(
     HWND hWnd,
     UINT uMsg,
diff --git a/src/drivers/windows/lv_windows_display.c b/src/drivers/windows/lv_windows_display.c
index 958338ec6..1a6715764 100644
--- a/src/drivers/windows/lv_windows_display.c
+++ b/src/drivers/windows/lv_windows_display.c
@@ -41,6 +41,7 @@ static unsigned int __stdcall lv_windows_display_thread_entrypoint(
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 lv_display_t * lv_windows_create_display(
     const wchar_t * title,
     int32_t hor_res,
@@ -86,26 +87,31 @@ lv_display_t * lv_windows_create_display(
     return data.display;
 }
 
+LV_FUNC_SECTION
 HWND lv_windows_get_display_window_handle(lv_display_t * display)
 {
     return (HWND)lv_display_get_driver_data(display);
 }
 
+LV_FUNC_SECTION
 int32_t lv_windows_zoom_to_logical(int32_t physical, int32_t zoom_level)
 {
     return MulDiv(physical, LV_WINDOWS_ZOOM_BASE_LEVEL, zoom_level);
 }
 
+LV_FUNC_SECTION
 int32_t lv_windows_zoom_to_physical(int32_t logical, int32_t zoom_level)
 {
     return MulDiv(logical, zoom_level, LV_WINDOWS_ZOOM_BASE_LEVEL);
 }
 
+LV_FUNC_SECTION
 int32_t lv_windows_dpi_to_logical(int32_t physical, int32_t dpi)
 {
     return MulDiv(physical, USER_DEFAULT_SCREEN_DPI, dpi);
 }
 
+LV_FUNC_SECTION
 int32_t lv_windows_dpi_to_physical(int32_t logical, int32_t dpi)
 {
     return MulDiv(logical, dpi, USER_DEFAULT_SCREEN_DPI);
@@ -115,6 +121,7 @@ int32_t lv_windows_dpi_to_physical(int32_t logical, int32_t dpi)
  *   STATIC FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 static unsigned int __stdcall lv_windows_display_thread_entrypoint(
     void * parameter)
 {
diff --git a/src/drivers/windows/lv_windows_input.c b/src/drivers/windows/lv_windows_input.c
index d3b781646..83d070187 100644
--- a/src/drivers/windows/lv_windows_input.c
+++ b/src/drivers/windows/lv_windows_input.c
@@ -67,11 +67,13 @@ static void lv_windows_release_encoder_device_event_callback(lv_event_t * e);
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 HWND lv_windows_get_indev_window_handle(lv_indev_t * indev)
 {
     return lv_windows_get_display_window_handle(lv_indev_get_display(indev));
 }
 
+LV_FUNC_SECTION
 lv_indev_t * lv_windows_acquire_pointer_indev(lv_display_t * display)
 {
     HWND window_handle = lv_windows_get_display_window_handle(display);
@@ -115,6 +117,7 @@ lv_indev_t * lv_windows_acquire_pointer_indev(lv_display_t * display)
     return context->pointer.indev;
 }
 
+LV_FUNC_SECTION
 lv_indev_t * lv_windows_acquire_keypad_indev(lv_display_t * display)
 {
     HWND window_handle = lv_windows_get_display_window_handle(display);
@@ -160,6 +163,7 @@ lv_indev_t * lv_windows_acquire_keypad_indev(lv_display_t * display)
     return context->keypad.indev;
 }
 
+LV_FUNC_SECTION
 lv_indev_t * lv_windows_acquire_encoder_indev(lv_display_t * display)
 {
     HWND window_handle = lv_windows_get_display_window_handle(display);
@@ -206,6 +210,7 @@ lv_indev_t * lv_windows_acquire_encoder_indev(lv_display_t * display)
  *   STATIC FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 static void lv_windows_pointer_driver_read_callback(
     lv_indev_t * indev,
     lv_indev_data_t * data)
@@ -220,6 +225,7 @@ static void lv_windows_pointer_driver_read_callback(
     data->point = context->pointer.point;
 }
 
+LV_FUNC_SECTION
 static void lv_windows_release_pointer_device_event_callback(lv_event_t * e)
 {
     lv_indev_t * indev = (lv_indev_t *)lv_event_get_user_data(e);
@@ -245,6 +251,7 @@ static void lv_windows_release_pointer_device_event_callback(lv_event_t * e)
     context->pointer.indev = NULL;
 }
 
+LV_FUNC_SECTION
 static BOOL lv_windows_get_touch_input_info(
     HTOUCHINPUT touch_input_handle,
     UINT input_count,
@@ -267,6 +274,7 @@ static BOOL lv_windows_get_touch_input_info(
     return function(touch_input_handle, input_count, inputs, item_size);
 }
 
+LV_FUNC_SECTION
 static BOOL lv_windows_close_touch_input_handle(
     HTOUCHINPUT touch_input_handle)
 {
@@ -286,6 +294,7 @@ static BOOL lv_windows_close_touch_input_handle(
     return function(touch_input_handle);
 }
 
+LV_FUNC_SECTION
 bool lv_windows_pointer_device_window_message_handler(
     HWND hWnd,
     UINT uMsg,
@@ -411,6 +420,7 @@ bool lv_windows_pointer_device_window_message_handler(
     return true;
 }
 
+LV_FUNC_SECTION
 static void lv_windows_keypad_driver_read_callback(
     lv_indev_t * indev,
     lv_indev_data_t * data)
@@ -434,6 +444,7 @@ static void lv_windows_keypad_driver_read_callback(
     }
 }
 
+LV_FUNC_SECTION
 static void lv_windows_release_keypad_device_event_callback(lv_event_t * e)
 {
     lv_indev_t * indev = (lv_indev_t *)lv_event_get_user_data(e);
@@ -459,6 +470,7 @@ static void lv_windows_release_keypad_device_event_callback(lv_event_t * e)
     context->keypad.indev = NULL;
 }
 
+LV_FUNC_SECTION
 static void lv_windows_push_key_to_keyboard_queue(
     lv_windows_window_context_t * context,
     uint32_t key,
@@ -472,6 +484,7 @@ static void lv_windows_push_key_to_keyboard_queue(
     }
 }
 
+LV_FUNC_SECTION
 static HIMC lv_windows_imm_get_context(
     HWND window_handle)
 {
@@ -491,6 +504,7 @@ static HIMC lv_windows_imm_get_context(
     return function(window_handle);
 }
 
+LV_FUNC_SECTION
 static BOOL lv_windows_imm_release_context(
     HWND window_handle,
     HIMC imm_context_handle)
@@ -511,6 +525,7 @@ static BOOL lv_windows_imm_release_context(
     return function(window_handle, imm_context_handle);
 }
 
+LV_FUNC_SECTION
 static HIMC lv_windows_imm_associate_context(
     HWND window_handle,
     HIMC imm_context_handle)
@@ -531,6 +546,7 @@ static HIMC lv_windows_imm_associate_context(
     return function(window_handle, imm_context_handle);
 }
 
+LV_FUNC_SECTION
 static BOOL lv_windows_imm_set_composition_window(
     HIMC imm_context_handle,
     LPCOMPOSITIONFORM composition_form)
@@ -551,6 +567,7 @@ static BOOL lv_windows_imm_set_composition_window(
     return function(imm_context_handle, composition_form);
 }
 
+LV_FUNC_SECTION
 bool lv_windows_keypad_device_window_message_handler(
     HWND hWnd,
     UINT uMsg,
@@ -740,6 +757,7 @@ bool lv_windows_keypad_device_window_message_handler(
     return true;
 }
 
+LV_FUNC_SECTION
 static void lv_windows_encoder_driver_read_callback(
     lv_indev_t * indev,
     lv_indev_data_t * data)
@@ -755,6 +773,7 @@ static void lv_windows_encoder_driver_read_callback(
     context->encoder.enc_diff = 0;
 }
 
+LV_FUNC_SECTION
 static void lv_windows_release_encoder_device_event_callback(lv_event_t * e)
 {
     lv_indev_t * indev = (lv_indev_t *)lv_event_get_user_data(e);
@@ -779,6 +798,7 @@ static void lv_windows_release_encoder_device_event_callback(lv_event_t * e)
     context->encoder.indev = NULL;
 }
 
+LV_FUNC_SECTION
 bool lv_windows_encoder_device_window_message_handler(
     HWND hWnd,
     UINT uMsg,
diff --git a/src/drivers/x11/lv_x11_display.c b/src/drivers/x11/lv_x11_display.c
index 1a2b83cad..ebce43e11 100644
--- a/src/drivers/x11/lv_x11_display.c
+++ b/src/drivers/x11/lv_x11_display.c
@@ -73,12 +73,14 @@ typedef struct {
 
 #if   LV_COLOR_DEPTH == 32
 typedef lv_color32_t color_t;
+LV_FUNC_SECTION
 static inline lv_color32_t get_px(color_t p)
 {
     return (lv_color32_t)p;
 }
 #elif LV_COLOR_DEPTH == 24
 typedef lv_color_t color_t;
+LV_FUNC_SECTION
 static inline lv_color32_t get_px(color_t p)
 {
     lv_color32_t out = { .red = p.red, .green = p.green, .blue = p.blue };
@@ -86,6 +88,7 @@ static inline lv_color32_t get_px(color_t p)
 }
 #elif LV_COLOR_DEPTH == 16
 typedef lv_color16_t color_t;
+LV_FUNC_SECTION
 static inline lv_color32_t get_px(color_t p)
 {
     lv_color32_t out = { .red = p.red << 3, .green = p.green << 2, .blue = p.blue << 3 };
@@ -93,6 +96,7 @@ static inline lv_color32_t get_px(color_t p)
 }
 #elif LV_COLOR_DEPTH == 8
 typedef uint8_t color_t;
+LV_FUNC_SECTION
 static inline lv_color32_t get_px(color_t p)
 {
     lv_color32_t out = { .red = p, .green = p, .blue = p };
@@ -110,6 +114,7 @@ static inline lv_color32_t get_px(color_t p)
  * @param[in] px_map  contains the rendered image as raw pixel map and it should be copied to `area` on the display.
  * @note              @ref lv_display_flush_ready has to be called when it's finished.
  */
+__attribute__(( fptrgroup("lv_display_flush_cb") ))
 static void x11_flush_cb(lv_display_t * disp, const lv_area_t * area, uint8_t * px_map)
 {
     x11_disp_data_t * xd = lv_display_get_driver_data(disp);
@@ -163,6 +168,7 @@ static void x11_flush_cb(lv_display_t * disp, const lv_area_t * area, uint8_t *
  * event called by lvgl display if resolution has been changed (@ref lv_display_set_resolution has been called)
  * @param[in] e  event data, containing lv_display_t object
  */
+LV_FUNC_SECTION
 static void x11_resolution_evt_cb(lv_event_t * e)
 {
     lv_display_t * disp = lv_event_get_user_data(e);
@@ -192,6 +198,7 @@ static void x11_resolution_evt_cb(lv_event_t * e)
  * event called by lvgl display if display has been closed (@ref lv_display_delete has been called)
  * @param[in] e  event data, containing lv_display_t object
  */
+LV_FUNC_SECTION
 static void x11_disp_delete_evt_cb(lv_event_t * e)
 {
     lv_display_t * disp = lv_event_get_user_data(e);
@@ -218,6 +225,7 @@ static void x11_disp_delete_evt_cb(lv_event_t * e)
 #endif
 }
 
+LV_FUNC_SECTION
 static void x11_hide_cursor(lv_display_t * disp)
 {
     x11_disp_data_t * xd = lv_display_get_driver_data(disp);
@@ -237,6 +245,7 @@ static void x11_hide_cursor(lv_display_t * disp)
  * X11 input event handler, predicated to fetch and handle only display related events
  * (Window changes)
  */
+LV_FUNC_SECTION
 static int is_disp_event(Display * disp, XEvent * event, XPointer arg)
 {
     LV_UNUSED(disp);
@@ -245,6 +254,7 @@ static int is_disp_event(Display * disp, XEvent * event, XPointer arg)
             || (event->type >= DestroyNotify && event->type <= CirculateNotify) /* events from StructureNotifyMask */
             ||  event->type == ClientMessage);
 }
+LV_FUNC_SECTION
 static void x11_event_handler(lv_timer_t * t)
 {
     lv_display_t * disp = lv_timer_get_user_data(t);
@@ -286,6 +296,7 @@ static void x11_event_handler(lv_timer_t * t)
     }
 }
 
+LV_FUNC_SECTION
 static void * x11_tick_thread(void * data)
 {
     x11_disp_data_t * xd = data;
@@ -298,6 +309,7 @@ static void * x11_tick_thread(void * data)
     return NULL;
 }
 
+LV_FUNC_SECTION
 static void x11_window_create(lv_display_t * disp, char const * title)
 {
     x11_disp_data_t * xd = lv_display_get_driver_data(disp);
@@ -356,6 +368,7 @@ static void x11_window_create(lv_display_t * disp, char const * title)
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 lv_display_t * lv_x11_window_create(char const * title, int32_t hor_res, int32_t ver_res)
 {
     x11_disp_data_t * xd = lv_malloc_zeroed(sizeof(x11_disp_data_t));
diff --git a/src/drivers/x11/lv_x11_input.c b/src/drivers/x11/lv_x11_input.c
index ecbd8d4e7..e646f24aa 100644
--- a/src/drivers/x11/lv_x11_input.c
+++ b/src/drivers/x11/lv_x11_input.c
@@ -57,6 +57,7 @@ typedef struct _x11_inp_data {
  * X11 input event handler, predicated to fetch and handle only input related events
  * (MotionNotify, ButtonPress/Release, KeyPress/Release)
  */
+LV_FUNC_SECTION
 static int is_inp_event(Display * disp, XEvent * event, XPointer arg)
 {
     LV_UNUSED(disp);
@@ -65,6 +66,7 @@ static int is_inp_event(Display * disp, XEvent * event, XPointer arg)
              || (event->type >= DestroyNotify && event->type <= CirculateNotify) /* events from StructureNotifyMask */
              ||  event->type == ClientMessage);
 }
+LV_FUNC_SECTION
 static void x11_inp_event_handler(lv_timer_t * t)
 {
     lv_display_t * disp = lv_timer_get_user_data(t);
@@ -183,6 +185,7 @@ static void x11_inp_event_handler(lv_timer_t * t)
  * event called by lvgl display if display has been closed (@ref lv_display_delete has been called)
  * @param[in] e  event data, containing lv_display_t object
  */
+LV_FUNC_SECTION
 static void x11_inp_delete_evt_cb(lv_event_t * e)
 {
     x11_inp_data_t * xd = (x11_inp_data_t *)lv_event_get_user_data(e);
@@ -197,6 +200,7 @@ static void x11_inp_delete_evt_cb(lv_event_t * e)
  * @param[in] disp   the created X11 display object from @lv_x11_window_create
  * @return           pointer to the local user data object @x11_inp_data_t
  */
+LV_FUNC_SECTION
 static x11_inp_data_t * x11_input_get_user_data(lv_display_t * disp)
 {
     _x11_user_hdr_t * disp_hdr = lv_display_get_driver_data(disp);
@@ -216,6 +220,7 @@ static x11_inp_data_t * x11_input_get_user_data(lv_display_t * disp)
     return *inp_data;
 }
 
+LV_FUNC_SECTION
 static void x11_keyboard_read_cb(lv_indev_t * indev, lv_indev_data_t * data)
 {
     lv_display_t * disp = lv_indev_get_driver_data(indev);
@@ -233,6 +238,7 @@ static void x11_keyboard_read_cb(lv_indev_t * indev, lv_indev_data_t * data)
     }
 }
 
+LV_FUNC_SECTION
 static void x11_mouse_read_cb(lv_indev_t * indev, lv_indev_data_t * data)
 {
     lv_display_t * disp = lv_indev_get_driver_data(indev);
@@ -248,6 +254,7 @@ static void x11_mouse_read_cb(lv_indev_t * indev, lv_indev_data_t * data)
     data->state = xd->left_mouse_btn ? LV_INDEV_STATE_PRESSED : LV_INDEV_STATE_RELEASED;
 }
 
+LV_FUNC_SECTION
 static void x11_mousewheel_read_cb(lv_indev_t * indev, lv_indev_data_t * data)
 {
     lv_display_t * disp = lv_indev_get_driver_data(indev);
@@ -258,6 +265,7 @@ static void x11_mousewheel_read_cb(lv_indev_t * indev, lv_indev_data_t * data)
     xd->wheel_cnt  = 0;
 }
 
+LV_FUNC_SECTION
 static lv_indev_t * lv_x11_keyboard_create(lv_display_t * disp)
 {
     lv_indev_t * indev = lv_indev_create();
@@ -270,6 +278,7 @@ static lv_indev_t * lv_x11_keyboard_create(lv_display_t * disp)
     return indev;
 }
 
+LV_FUNC_SECTION
 static lv_indev_t * lv_x11_mouse_create(lv_display_t * disp, lv_image_dsc_t const * symb)
 {
     lv_indev_t * indev = lv_indev_create();
@@ -288,6 +297,7 @@ static lv_indev_t * lv_x11_mouse_create(lv_display_t * disp, lv_image_dsc_t cons
     return indev;
 }
 
+LV_FUNC_SECTION
 static lv_indev_t * lv_x11_mousewheel_create(lv_display_t * disp)
 {
     lv_indev_t * indev = lv_indev_create();
@@ -303,6 +313,7 @@ static lv_indev_t * lv_x11_mousewheel_create(lv_display_t * disp)
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 void lv_x11_inputs_create(lv_display_t * disp, lv_image_dsc_t const * mouse_img)
 {
     x11_inp_data_t * xd = x11_input_get_user_data(disp);
diff --git a/src/font/lv_binfont_loader.c b/src/font/lv_binfont_loader.c
index 4746026f5..851a85bd4 100644
--- a/src/font/lv_binfont_loader.c
+++ b/src/font/lv_binfont_loader.c
@@ -77,6 +77,7 @@ static unsigned int read_bits(bit_iterator_t * it, int n_bits, lv_fs_res_t * res
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 lv_font_t * lv_binfont_create(const char * path)
 {
     LV_ASSERT_NULL(path);
@@ -105,6 +106,7 @@ lv_font_t * lv_binfont_create(const char * path)
 }
 
 #if LV_USE_FS_MEMFS
+LV_FUNC_SECTION
 lv_font_t * lv_binfont_create_from_buffer(void * buffer, uint32_t size)
 {
     lv_fs_path_ex_t mempath;
@@ -114,6 +116,7 @@ lv_font_t * lv_binfont_create_from_buffer(void * buffer, uint32_t size)
 }
 #endif
 
+LV_FUNC_SECTION
 void lv_binfont_destroy(lv_font_t * font)
 {
     if(font == NULL) return;
@@ -158,6 +161,7 @@ void lv_binfont_destroy(lv_font_t * font)
  *   STATIC FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 static bit_iterator_t init_bit_iterator(lv_fs_file_t * fp)
 {
     bit_iterator_t it;
@@ -167,6 +171,7 @@ static bit_iterator_t init_bit_iterator(lv_fs_file_t * fp)
     return it;
 }
 
+LV_FUNC_SECTION
 static unsigned int read_bits(bit_iterator_t * it, int n_bits, lv_fs_res_t * res)
 {
     unsigned int value = 0;
@@ -189,6 +194,7 @@ static unsigned int read_bits(bit_iterator_t * it, int n_bits, lv_fs_res_t * res
     return value;
 }
 
+LV_FUNC_SECTION
 static int read_bits_signed(bit_iterator_t * it, int n_bits, lv_fs_res_t * res)
 {
     unsigned int value = read_bits(it, n_bits, res);
@@ -198,6 +204,7 @@ static int read_bits_signed(bit_iterator_t * it, int n_bits, lv_fs_res_t * res)
     return value;
 }
 
+LV_FUNC_SECTION
 static int read_label(lv_fs_file_t * fp, int start, const char * label)
 {
     lv_fs_seek(fp, start, LV_FS_SEEK_SET);
@@ -215,6 +222,7 @@ static int read_label(lv_fs_file_t * fp, int start, const char * label)
     return length;
 }
 
+LV_FUNC_SECTION
 static bool load_cmaps_tables(lv_fs_file_t * fp, lv_font_fmt_txt_dsc_t * font_dsc,
                               uint32_t cmaps_start, cmap_table_bin_t * cmap_table)
 {
@@ -282,6 +290,7 @@ static bool load_cmaps_tables(lv_fs_file_t * fp, lv_font_fmt_txt_dsc_t * font_ds
     return true;
 }
 
+LV_FUNC_SECTION
 static int32_t load_cmaps(lv_fs_file_t * fp, lv_font_fmt_txt_dsc_t * font_dsc, uint32_t cmaps_start)
 {
     int32_t cmaps_length = read_label(fp, cmaps_start, "cmap");
@@ -311,6 +320,7 @@ static int32_t load_cmaps(lv_fs_file_t * fp, lv_font_fmt_txt_dsc_t * font_dsc, u
     return success ? cmaps_length : -1;
 }
 
+LV_FUNC_SECTION
 static int32_t load_glyph(lv_fs_file_t * fp, lv_font_fmt_txt_dsc_t * font_dsc,
                           uint32_t start, uint32_t * glyph_offset, uint32_t loca_count, font_header_bin_t * header)
 {
@@ -456,6 +466,7 @@ static int32_t load_glyph(lv_fs_file_t * fp, lv_font_fmt_txt_dsc_t * font_dsc,
  * `lv_binfont_destroy` will assume that all non-null pointers are allocated and
  * should be freed.
  */
+LV_FUNC_SECTION
 static bool lvgl_load_font(lv_fs_file_t * fp, lv_font_t * font)
 {
     lv_font_fmt_txt_dsc_t * font_dsc = (lv_font_fmt_txt_dsc_t *)
@@ -561,6 +572,7 @@ static bool lvgl_load_font(lv_fs_file_t * fp, lv_font_t * font)
     return kern_length >= 0;
 }
 
+LV_FUNC_SECTION
 int32_t load_kern(lv_fs_file_t * fp, lv_font_fmt_txt_dsc_t * font_dsc, uint8_t format, uint32_t start)
 {
     int32_t kern_length = read_label(fp, start, "kern");
diff --git a/src/font/lv_font.c b/src/font/lv_font.c
index 35ae352e3..dc25fd65b 100644
--- a/src/font/lv_font.c
+++ b/src/font/lv_font.c
@@ -42,6 +42,7 @@
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 const void * lv_font_get_glyph_bitmap(lv_font_glyph_dsc_t * g_dsc, lv_draw_buf_t * draw_buf)
 {
     const lv_font_t * font_p = g_dsc->resolved_font;
@@ -49,6 +50,7 @@ const void * lv_font_get_glyph_bitmap(lv_font_glyph_dsc_t * g_dsc, lv_draw_buf_t
     return font_p->get_glyph_bitmap(g_dsc, draw_buf);
 }
 
+LV_FUNC_SECTION
 void lv_font_glyph_release_draw_data(lv_font_glyph_dsc_t * g_dsc)
 {
     const lv_font_t * font = g_dsc->resolved_font;
@@ -58,6 +60,7 @@ void lv_font_glyph_release_draw_data(lv_font_glyph_dsc_t * g_dsc)
     }
 }
 
+LV_FUNC_SECTION
 bool lv_font_get_glyph_dsc(const lv_font_t * font_p, lv_font_glyph_dsc_t * dsc_out, uint32_t letter,
                            uint32_t letter_next)
 {
@@ -116,6 +119,7 @@ bool lv_font_get_glyph_dsc(const lv_font_t * font_p, lv_font_glyph_dsc_t * dsc_o
     return false;
 }
 
+LV_FUNC_SECTION
 uint16_t lv_font_get_glyph_width(const lv_font_t * font, uint32_t letter, uint32_t letter_next)
 {
     LV_ASSERT_NULL(font);
@@ -128,17 +132,20 @@ uint16_t lv_font_get_glyph_width(const lv_font_t * font, uint32_t letter, uint32
     return g.adv_w;
 }
 
+LV_FUNC_SECTION
 void lv_font_set_kerning(lv_font_t * font, lv_font_kerning_t kerning)
 {
     LV_ASSERT_NULL(font);
     font->kerning = kerning;
 }
 
+LV_FUNC_SECTION
 int32_t lv_font_get_line_height(const lv_font_t * font)
 {
     return font->line_height;
 }
 
+LV_FUNC_SECTION
 const lv_font_t * lv_font_default(void)
 {
     return LV_FONT_DEFAULT;
diff --git a/src/font/lv_font.h b/src/font/lv_font.h
index 2f172b9f8..3c4f8844c 100644
--- a/src/font/lv_font.h
+++ b/src/font/lv_font.h
@@ -87,12 +87,15 @@ typedef enum {
 /** Describe the properties of a font*/
 struct lv_font_t {
     /** Get a glyph's descriptor from a font*/
+    __attribute__(( fptrgroup("lv_font_get_glyph_dsc") ))
     bool (*get_glyph_dsc)(const lv_font_t *, lv_font_glyph_dsc_t *, uint32_t letter, uint32_t letter_next);
 
     /** Get a glyph's bitmap from a font*/
+    __attribute__(( fptrgroup("lv_font_get_glyph_bitmap") ))
     const void * (*get_glyph_bitmap)(lv_font_glyph_dsc_t *, lv_draw_buf_t *);
 
     /** Release a glyph*/
+    __attribute__(( fptrgroup("lv_font_release_glyph") ))
     void (*release_glyph)(const lv_font_t *, lv_font_glyph_dsc_t *);
 
     /*Pointer to the font in a font pack (must have the same line height)*/
diff --git a/src/font/lv_font_fmt_txt.c b/src/font/lv_font_fmt_txt.c
index 5d0130454..982dc251a 100644
--- a/src/font/lv_font_fmt_txt.c
+++ b/src/font/lv_font_fmt_txt.c
@@ -74,7 +74,7 @@ static const uint8_t opa2_table[4] = {0, 85, 170, 255};
 /**********************
  *   GLOBAL FUNCTIONS
  **********************/
-
+__attribute__(( fptrgroup("lv_font_get_glyph_bitmap") ))
 const void * lv_font_get_bitmap_fmt_txt(lv_font_glyph_dsc_t * g_dsc, lv_draw_buf_t * draw_buf)
 {
     const lv_font_t * font = g_dsc->resolved_font;
@@ -165,6 +165,7 @@ const void * lv_font_get_bitmap_fmt_txt(lv_font_glyph_dsc_t * g_dsc, lv_draw_buf
     return NULL;
 }
 
+__attribute__(( fptrgroup("lv_font_get_glyph_dsc") ))
 bool lv_font_get_glyph_dsc_fmt_txt(const lv_font_t * font, lv_font_glyph_dsc_t * dsc_out, uint32_t unicode_letter,
                                    uint32_t unicode_letter_next)
 {
@@ -214,6 +215,7 @@ bool lv_font_get_glyph_dsc_fmt_txt(const lv_font_t * font, lv_font_glyph_dsc_t *
  *   STATIC FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 static uint32_t get_glyph_dsc_id(const lv_font_t * font, uint32_t letter)
 {
     if(letter == '\0') return 0;
@@ -263,6 +265,7 @@ static uint32_t get_glyph_dsc_id(const lv_font_t * font, uint32_t letter)
 
 }
 
+LV_FUNC_SECTION
 static int8_t get_kern_value(const lv_font_t * font, uint32_t gid_left, uint32_t gid_right)
 {
     lv_font_fmt_txt_dsc_t * fdsc = (lv_font_fmt_txt_dsc_t *)font->dsc;
@@ -319,6 +322,7 @@ static int8_t get_kern_value(const lv_font_t * font, uint32_t gid_left, uint32_t
     return value;
 }
 
+__attribute__(( fptrgroup("lv_utils_cmp") ))
 static int kern_pair_8_compare(const void * ref, const void * element)
 {
     const kern_pair_ref_t * ref8_p = ref;
@@ -329,6 +333,7 @@ static int kern_pair_8_compare(const void * ref, const void * element)
     else return ref8_p->gid_right - element8_p[1];
 }
 
+__attribute__(( fptrgroup("lv_utils_cmp") ))
 static int kern_pair_16_compare(const void * ref, const void * element)
 {
     const kern_pair_ref_t * ref16_p = ref;
@@ -349,6 +354,7 @@ static int kern_pair_16_compare(const void * ref, const void * element)
  * @param bpp bit per pixel (bpp = 3 will be converted to bpp = 4)
  * @param prefilter true: the lines are XORed
  */
+LV_FUNC_SECTION
 static void decompress(const uint8_t * in, uint8_t * out, int32_t w, int32_t h, uint8_t bpp, bool prefilter)
 {
     const lv_opa_t * opa_table;
@@ -416,6 +422,7 @@ static void decompress(const uint8_t * in, uint8_t * out, int32_t w, int32_t h,
  * @param out output buffer
  * @param w width of the line in pixel count
  */
+LV_FUNC_SECTION
 static inline void decompress_line(uint8_t * out, int32_t w)
 {
     int32_t i;
@@ -431,6 +438,7 @@ static inline void decompress_line(uint8_t * out, int32_t w)
  * @param len number of bits to read (must be <= 8).
  * @return the read bits
  */
+LV_FUNC_SECTION
 static inline uint8_t get_bits(const uint8_t * in, uint32_t bit_pos, uint8_t len)
 {
     uint8_t bit_mask;
@@ -466,6 +474,7 @@ static inline uint8_t get_bits(const uint8_t * in, uint32_t bit_pos, uint8_t len
     }
 }
 
+LV_FUNC_SECTION
 static inline void rle_init(const uint8_t * in,  uint8_t bpp)
 {
     lv_font_fmt_rle_t * rle = &font_rle;
@@ -477,6 +486,7 @@ static inline void rle_init(const uint8_t * in,  uint8_t bpp)
     rle->count = 0;
 }
 
+LV_FUNC_SECTION
 static inline uint8_t rle_next(void)
 {
     uint8_t v = 0;
@@ -549,6 +559,7 @@ static inline uint8_t rle_next(void)
  *  @retval > 0   Reference is greater than element.
  *
  */
+__attribute__(( fptrgroup("lv_utils_cmp") ))
 static int unicode_list_compare(const void * ref, const void * element)
 {
     return (*(uint16_t *)ref) - (*(uint16_t *)element);
diff --git a/src/indev/lv_indev.c b/src/indev/lv_indev.c
index 3a4a5721a..d5765771e 100644
--- a/src/indev/lv_indev.c
+++ b/src/indev/lv_indev.c
@@ -84,6 +84,7 @@ static lv_result_t send_event(lv_event_code_t code, void * param);
 static void indev_scroll_throw_anim_start(lv_indev_t * indev);
 static void indev_scroll_throw_anim_cb(void * var, int32_t v);
 static void indev_scroll_throw_anim_completed_cb(lv_anim_t * anim);
+LV_FUNC_SECTION
 static inline void indev_scroll_throw_anim_reset(lv_indev_t * indev)
 {
     if(indev) {
@@ -110,6 +111,7 @@ static inline void indev_scroll_throw_anim_reset(lv_indev_t * indev)
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 lv_indev_t * lv_indev_create(void)
 {
     lv_display_t * disp = lv_display_get_default();
@@ -142,6 +144,7 @@ lv_indev_t * lv_indev_create(void)
     return indev;
 }
 
+__attribute__(( fptrgroup("lv_ll_cleanup") ))
 void lv_indev_delete(lv_indev_t * indev)
 {
     LV_ASSERT_NULL(indev);
@@ -158,6 +161,7 @@ void lv_indev_delete(lv_indev_t * indev)
     lv_free(indev);
 }
 
+LV_FUNC_SECTION
 lv_indev_t * lv_indev_get_next(lv_indev_t * indev)
 {
     if(indev == NULL)
@@ -166,6 +170,7 @@ lv_indev_t * lv_indev_get_next(lv_indev_t * indev)
         return lv_ll_get_next(indev_ll_head, indev);
 }
 
+LV_FUNC_SECTION
 void indev_read_core(lv_indev_t * indev, lv_indev_data_t * data)
 {
     LV_PROFILER_BEGIN;
@@ -196,11 +201,13 @@ void indev_read_core(lv_indev_t * indev, lv_indev_data_t * data)
     LV_PROFILER_END;
 }
 
+LV_FUNC_SECTION
 void lv_indev_read_timer_cb(lv_timer_t * timer)
 {
     lv_indev_read(timer->user_data);
 }
 
+LV_FUNC_SECTION
 void lv_indev_read(lv_indev_t * indev)
 {
     if(indev == NULL) return;
@@ -269,6 +276,7 @@ void lv_indev_read(lv_indev_t * indev)
     LV_PROFILER_END;
 }
 
+LV_FUNC_SECTION
 void lv_indev_enable(lv_indev_t * indev, bool enable)
 {
     if(indev) {
@@ -283,11 +291,13 @@ void lv_indev_enable(lv_indev_t * indev, bool enable)
     }
 }
 
+LV_FUNC_SECTION
 lv_indev_t * lv_indev_active(void)
 {
     return indev_act;
 }
 
+LV_FUNC_SECTION
 void lv_indev_set_type(lv_indev_t * indev, lv_indev_type_t indev_type)
 {
     if(indev == NULL) return;
@@ -296,6 +306,7 @@ void lv_indev_set_type(lv_indev_t * indev, lv_indev_type_t indev_type)
     indev->reset_query = 1;
 }
 
+LV_FUNC_SECTION
 void lv_indev_set_read_cb(lv_indev_t * indev, lv_indev_read_cb_t read_cb)
 {
     if(indev == NULL) return;
@@ -303,18 +314,21 @@ void lv_indev_set_read_cb(lv_indev_t * indev, lv_indev_read_cb_t read_cb)
     indev->read_cb = read_cb;
 }
 
+LV_FUNC_SECTION
 void lv_indev_set_user_data(lv_indev_t * indev, void * user_data)
 {
     if(indev == NULL) return;
     indev->user_data = user_data;
 }
 
+LV_FUNC_SECTION
 void lv_indev_set_driver_data(lv_indev_t * indev, void * driver_data)
 {
     if(indev == NULL) return;
     indev->driver_data = driver_data;
 }
 
+LV_FUNC_SECTION
 lv_indev_read_cb_t lv_indev_get_read_cb(lv_indev_t * indev)
 {
     if(indev == NULL) {
@@ -325,6 +339,7 @@ lv_indev_read_cb_t lv_indev_get_read_cb(lv_indev_t * indev)
     return indev->read_cb;
 }
 
+LV_FUNC_SECTION
 lv_indev_type_t lv_indev_get_type(const lv_indev_t * indev)
 {
     if(indev == NULL) return LV_INDEV_TYPE_NONE;
@@ -332,6 +347,7 @@ lv_indev_type_t lv_indev_get_type(const lv_indev_t * indev)
     return indev->type;
 }
 
+LV_FUNC_SECTION
 lv_indev_state_t lv_indev_get_state(const lv_indev_t * indev)
 {
     if(indev == NULL) return LV_INDEV_STATE_RELEASED;
@@ -339,6 +355,7 @@ lv_indev_state_t lv_indev_get_state(const lv_indev_t * indev)
     return indev->state;
 }
 
+LV_FUNC_SECTION
 lv_group_t * lv_indev_get_group(const lv_indev_t * indev)
 {
     if(indev == NULL) return NULL;
@@ -346,6 +363,7 @@ lv_group_t * lv_indev_get_group(const lv_indev_t * indev)
     return indev->group;
 }
 
+LV_FUNC_SECTION
 lv_display_t * lv_indev_get_display(const lv_indev_t * indev)
 {
     if(indev == NULL) return NULL;
@@ -353,6 +371,7 @@ lv_display_t * lv_indev_get_display(const lv_indev_t * indev)
     return indev->disp;
 }
 
+LV_FUNC_SECTION
 void lv_indev_set_display(lv_indev_t * indev, lv_display_t * disp)
 {
     if(indev == NULL) return;
@@ -360,6 +379,7 @@ void lv_indev_set_display(lv_indev_t * indev, lv_display_t * disp)
     indev->disp = disp;
 }
 
+LV_FUNC_SECTION
 void lv_indev_set_long_press_time(lv_indev_t * indev, uint16_t long_press_time)
 {
     if(indev == NULL) return;
@@ -367,6 +387,7 @@ void lv_indev_set_long_press_time(lv_indev_t * indev, uint16_t long_press_time)
     indev->long_press_time = long_press_time;
 }
 
+LV_FUNC_SECTION
 void lv_indev_set_scroll_limit(lv_indev_t * indev, uint8_t scroll_limit)
 {
     if(indev == NULL) return;
@@ -374,6 +395,7 @@ void lv_indev_set_scroll_limit(lv_indev_t * indev, uint8_t scroll_limit)
     indev->scroll_limit = scroll_limit;
 }
 
+LV_FUNC_SECTION
 void lv_indev_set_scroll_throw(lv_indev_t * indev, uint8_t scroll_throw)
 {
     if(indev == NULL) return;
@@ -381,12 +403,14 @@ void lv_indev_set_scroll_throw(lv_indev_t * indev, uint8_t scroll_throw)
     indev->scroll_throw = scroll_throw;
 }
 
+LV_FUNC_SECTION
 void * lv_indev_get_user_data(const lv_indev_t * indev)
 {
     if(indev == NULL) return NULL;
     return indev->user_data;
 }
 
+LV_FUNC_SECTION
 void * lv_indev_get_driver_data(const lv_indev_t * indev)
 {
     if(indev == NULL) return NULL;
@@ -394,6 +418,7 @@ void * lv_indev_get_driver_data(const lv_indev_t * indev)
     return indev->driver_data;
 }
 
+LV_FUNC_SECTION
 bool lv_indev_get_press_moved(const lv_indev_t * indev)
 {
     if(indev == NULL) return false;
@@ -401,6 +426,7 @@ bool lv_indev_get_press_moved(const lv_indev_t * indev)
     return indev->pointer.press_moved;
 }
 
+LV_FUNC_SECTION
 void lv_indev_reset(lv_indev_t * indev, lv_obj_t * obj)
 {
     if(indev) {
@@ -416,12 +442,14 @@ void lv_indev_reset(lv_indev_t * indev, lv_obj_t * obj)
     }
 }
 
+LV_FUNC_SECTION
 void lv_indev_stop_processing(lv_indev_t * indev)
 {
     if(indev == NULL) return;
     indev->stop_processing_query = 1;
 }
 
+LV_FUNC_SECTION
 void lv_indev_reset_long_press(lv_indev_t * indev)
 {
     indev->long_pr_sent         = 0;
@@ -429,6 +457,7 @@ void lv_indev_reset_long_press(lv_indev_t * indev)
     indev->pr_timestamp         = lv_tick_get();
 }
 
+LV_FUNC_SECTION
 void lv_indev_set_cursor(lv_indev_t * indev, lv_obj_t * cur_obj)
 {
     if(indev->type != LV_INDEV_TYPE_POINTER) return;
@@ -440,6 +469,7 @@ void lv_indev_set_cursor(lv_indev_t * indev, lv_obj_t * cur_obj)
     lv_obj_add_flag(indev->cursor, LV_OBJ_FLAG_IGNORE_LAYOUT | LV_OBJ_FLAG_FLOATING);
 }
 
+LV_FUNC_SECTION
 void lv_indev_set_group(lv_indev_t * indev, lv_group_t * group)
 {
     if(indev && (indev->type == LV_INDEV_TYPE_KEYPAD || indev->type == LV_INDEV_TYPE_ENCODER)) {
@@ -447,6 +477,7 @@ void lv_indev_set_group(lv_indev_t * indev, lv_group_t * group)
     }
 }
 
+LV_FUNC_SECTION
 void lv_indev_set_button_points(lv_indev_t * indev, const lv_point_t points[])
 {
     if(indev && indev->type == LV_INDEV_TYPE_BUTTON) {
@@ -454,6 +485,7 @@ void lv_indev_set_button_points(lv_indev_t * indev, const lv_point_t points[])
     }
 }
 
+LV_FUNC_SECTION
 void lv_indev_get_point(const lv_indev_t * indev, lv_point_t * point)
 {
     if(indev == NULL) {
@@ -470,11 +502,13 @@ void lv_indev_get_point(const lv_indev_t * indev, lv_point_t * point)
     }
 }
 
+LV_FUNC_SECTION
 lv_dir_t lv_indev_get_gesture_dir(const lv_indev_t * indev)
 {
     return indev->pointer.gesture_dir;
 }
 
+LV_FUNC_SECTION
 uint32_t lv_indev_get_key(const lv_indev_t * indev)
 {
     uint32_t key = 0;
@@ -485,6 +519,7 @@ uint32_t lv_indev_get_key(const lv_indev_t * indev)
     return key;
 }
 
+LV_FUNC_SECTION
 lv_dir_t lv_indev_get_scroll_dir(const lv_indev_t * indev)
 {
     if(indev == NULL) return false;
@@ -492,6 +527,7 @@ lv_dir_t lv_indev_get_scroll_dir(const lv_indev_t * indev)
     return indev->pointer.scroll_dir;
 }
 
+LV_FUNC_SECTION
 lv_obj_t * lv_indev_get_scroll_obj(const lv_indev_t * indev)
 {
     if(indev == NULL) return NULL;
@@ -499,6 +535,7 @@ lv_obj_t * lv_indev_get_scroll_obj(const lv_indev_t * indev)
     return indev->pointer.scroll_obj;
 }
 
+LV_FUNC_SECTION
 void lv_indev_get_vect(const lv_indev_t * indev, lv_point_t * point)
 {
     point->x = 0;
@@ -512,17 +549,20 @@ void lv_indev_get_vect(const lv_indev_t * indev, lv_point_t * point)
     }
 }
 
+LV_FUNC_SECTION
 void lv_indev_wait_release(lv_indev_t * indev)
 {
     if(indev == NULL)return;
     indev->wait_until_release = 1;
 }
 
+LV_FUNC_SECTION
 lv_obj_t * lv_indev_get_active_obj(void)
 {
     return indev_obj_act;
 }
 
+LV_FUNC_SECTION
 lv_timer_t * lv_indev_get_read_timer(lv_indev_t * indev)
 {
     if(indev == NULL) {
@@ -533,12 +573,14 @@ lv_timer_t * lv_indev_get_read_timer(lv_indev_t * indev)
     return indev->read_timer;
 }
 
+LV_FUNC_SECTION
 lv_indev_mode_t lv_indev_get_mode(lv_indev_t * indev)
 {
     if(indev) return indev->mode;
     return LV_INDEV_MODE_NONE;
 }
 
+LV_FUNC_SECTION
 void lv_indev_set_mode(lv_indev_t * indev, lv_indev_mode_t mode)
 {
     if(indev == NULL || indev->mode == mode)
@@ -557,6 +599,7 @@ void lv_indev_set_mode(lv_indev_t * indev, lv_indev_mode_t mode)
     }
 }
 
+LV_FUNC_SECTION
 lv_obj_t * lv_indev_search_obj(lv_obj_t * obj, lv_point_t * point)
 {
     lv_obj_t * found_p = NULL;
@@ -593,6 +636,7 @@ lv_obj_t * lv_indev_search_obj(lv_obj_t * obj, lv_point_t * point)
     else return NULL;
 }
 
+LV_FUNC_SECTION
 void lv_indev_add_event_cb(lv_indev_t * indev, lv_event_cb_t event_cb, lv_event_code_t filter, void * user_data)
 {
     LV_ASSERT_NULL(indev);
@@ -600,12 +644,14 @@ void lv_indev_add_event_cb(lv_indev_t * indev, lv_event_cb_t event_cb, lv_event_
     lv_event_add(&indev->event_list, event_cb, filter, user_data);
 }
 
+LV_FUNC_SECTION
 uint32_t lv_indev_get_event_count(lv_indev_t * indev)
 {
     LV_ASSERT_NULL(indev);
     return lv_event_get_count(&indev->event_list);
 }
 
+LV_FUNC_SECTION
 lv_event_dsc_t * lv_indev_get_event_dsc(lv_indev_t * indev, uint32_t index)
 {
     LV_ASSERT_NULL(indev);
@@ -613,6 +659,7 @@ lv_event_dsc_t * lv_indev_get_event_dsc(lv_indev_t * indev, uint32_t index)
 
 }
 
+LV_FUNC_SECTION
 bool lv_indev_remove_event(lv_indev_t * indev, uint32_t index)
 {
     LV_ASSERT_NULL(indev);
@@ -620,6 +667,7 @@ bool lv_indev_remove_event(lv_indev_t * indev, uint32_t index)
     return lv_event_remove(&indev->event_list, index);
 }
 
+LV_FUNC_SECTION
 uint32_t lv_indev_remove_event_cb_with_user_data(lv_indev_t * indev, lv_event_cb_t event_cb, void * user_data)
 {
     LV_ASSERT_NULL(indev);
@@ -639,6 +687,7 @@ uint32_t lv_indev_remove_event_cb_with_user_data(lv_indev_t * indev, lv_event_cb
     return removed_count;
 }
 
+LV_FUNC_SECTION
 lv_result_t lv_indev_send_event(lv_indev_t * indev, lv_event_code_t code, void * param)
 {
 
@@ -667,6 +716,7 @@ lv_result_t lv_indev_send_event(lv_indev_t * indev, lv_event_code_t code, void *
  * @param i pointer to an input device
  * @param data pointer to the data read from the input device
  */
+LV_FUNC_SECTION
 static void indev_pointer_proc(lv_indev_t * i, lv_indev_data_t * data)
 {
     lv_display_t * disp = i->disp;
@@ -727,6 +777,7 @@ static void indev_pointer_proc(lv_indev_t * i, lv_indev_data_t * data)
  * @param i pointer to an input device
  * @param data pointer to the data read from the input device
  */
+LV_FUNC_SECTION
 static void indev_keypad_proc(lv_indev_t * i, lv_indev_data_t * data)
 {
     if(data->state == LV_INDEV_STATE_PRESSED && i->wait_until_release) return;
@@ -869,6 +920,7 @@ static void indev_keypad_proc(lv_indev_t * i, lv_indev_data_t * data)
  * @param i pointer to an input device
  * @param data pointer to the data read from the input device
  */
+LV_FUNC_SECTION
 static void indev_encoder_proc(lv_indev_t * i, lv_indev_data_t * data)
 {
     if(data->state == LV_INDEV_STATE_PRESSED && i->wait_until_release) return;
@@ -1098,6 +1150,7 @@ static void indev_encoder_proc(lv_indev_t * i, lv_indev_data_t * data)
  * @param x x coordinate of the next point
  * @param y y coordinate of the next point
  */
+LV_FUNC_SECTION
 static void indev_button_proc(lv_indev_t * i, lv_indev_data_t * data)
 {
     /*Die gracefully if i->btn_points is NULL*/
@@ -1145,6 +1198,7 @@ static void indev_button_proc(lv_indev_t * i, lv_indev_data_t * data)
  * Process the pressed state of LV_INDEV_TYPE_POINTER input devices
  * @param indev pointer to an input device 'proc'
  */
+LV_FUNC_SECTION
 static void indev_proc_press(lv_indev_t * indev)
 {
     LV_LOG_INFO("pressed at x:%d y:%d", (int)indev->pointer.act_point.x,
@@ -1303,6 +1357,7 @@ static void indev_proc_press(lv_indev_t * indev)
  * Process the released state of LV_INDEV_TYPE_POINTER input devices
  * @param proc pointer to an input device 'proc'
  */
+LV_FUNC_SECTION
 static void indev_proc_release(lv_indev_t * indev)
 {
     if(indev->wait_until_release || /*Hover the new widget even if the coordinates didn't changed*/
@@ -1401,6 +1456,7 @@ static void indev_proc_release(lv_indev_t * indev)
     }
 }
 
+LV_FUNC_SECTION
 static void indev_proc_pointer_diff(lv_indev_t * indev)
 {
     lv_obj_t * obj = indev->pointer.last_pressed;
@@ -1435,6 +1491,7 @@ static void indev_proc_pointer_diff(lv_indev_t * indev)
 
 }
 
+LV_FUNC_SECTION
 static lv_obj_t * pointer_search_obj(lv_display_t * disp, lv_point_t * p)
 {
     indev_obj_act = lv_indev_search_obj(lv_display_get_layer_sys(disp), p);
@@ -1458,6 +1515,7 @@ static lv_obj_t * pointer_search_obj(lv_display_t * disp, lv_point_t * p)
  * Reset input device if a reset query has been sent to it
  * @param indev pointer to an input device
  */
+LV_FUNC_SECTION
 static void indev_proc_reset_query_handler(lv_indev_t * indev)
 {
     if(indev->reset_query) {
@@ -1486,6 +1544,7 @@ static void indev_proc_reset_query_handler(lv_indev_t * indev)
  * Handle focus/defocus on click for POINTER input devices
  * @param proc pointer to the state of the indev
  */
+LV_FUNC_SECTION
 static void indev_click_focus(lv_indev_t * indev)
 {
     /*Handle click focus*/
@@ -1554,6 +1613,7 @@ static void indev_click_focus(lv_indev_t * indev)
 * Handle the gesture of indev_proc_p->pointer.act_obj
 * @param indev pointer to an input device state
 */
+LV_FUNC_SECTION
 void indev_gesture(lv_indev_t * indev)
 {
     if(indev->pointer.scroll_obj) return;
@@ -1609,6 +1669,7 @@ void indev_gesture(lv_indev_t * indev)
  * @param proc pointer to an input device 'proc'
  * @return true if indev query should be immediately truncated.
  */
+LV_FUNC_SECTION
 static bool indev_reset_check(lv_indev_t * indev)
 {
     if(indev->reset_query) {
@@ -1623,6 +1684,7 @@ static bool indev_reset_check(lv_indev_t * indev)
  * @param indev pointer to an input device
  * @return true if indev should stop processing the event.
  */
+LV_FUNC_SECTION
 static bool indev_stop_processing_check(lv_indev_t * indev)
 {
     return indev->stop_processing_query;
@@ -1633,6 +1695,7 @@ static bool indev_stop_processing_check(lv_indev_t * indev)
  * @param indev pointer to an input device
  * @param obj pointer to obj
 */
+LV_FUNC_SECTION
 static void indev_reset_core(lv_indev_t * indev, lv_obj_t * obj)
 {
     lv_obj_t * act_obj = NULL;
@@ -1673,6 +1736,7 @@ static void indev_reset_core(lv_indev_t * indev, lv_obj_t * obj)
     }
 }
 
+LV_FUNC_SECTION
 static lv_result_t send_event(lv_event_code_t code, void * param)
 {
     lv_indev_t * indev = indev_act;
@@ -1700,6 +1764,7 @@ static lv_result_t send_event(lv_event_code_t code, void * param)
     return LV_RESULT_OK;
 }
 
+__attribute__(( fptrgroup("lv_anim_exec_cb") ))
 static void indev_scroll_throw_anim_cb(void * var, int32_t v)
 {
     LV_ASSERT_NULL(var);
@@ -1716,6 +1781,7 @@ static void indev_scroll_throw_anim_cb(void * var, int32_t v)
     }
 }
 
+__attribute__(( fptrgroup("lv_anim_completed_cb"), fptrgroup("lv_anim_deleted_cb") ))
 static void indev_scroll_throw_anim_completed_cb(lv_anim_t * anim)
 {
     if(anim) {
@@ -1723,6 +1789,7 @@ static void indev_scroll_throw_anim_completed_cb(lv_anim_t * anim)
     }
 }
 
+LV_FUNC_SECTION
 static void indev_scroll_throw_anim_start(lv_indev_t * indev)
 {
     LV_ASSERT_NULL(indev);
diff --git a/src/indev/lv_indev_private.h b/src/indev/lv_indev_private.h
index a5fa23164..76a8cea5c 100644
--- a/src/indev/lv_indev_private.h
+++ b/src/indev/lv_indev_private.h
@@ -28,6 +28,7 @@ struct lv_indev_t {
     lv_indev_type_t type;
 
     /** Function pointer to read input device data.*/
+    __attribute__(( fptrgroup("lv_indev_read_cb") ))
     lv_indev_read_cb_t read_cb;
 
     lv_indev_state_t state; /**< Current state of the input device.*/
diff --git a/src/indev/lv_indev_scroll.c b/src/indev/lv_indev_scroll.c
index f32786577..627008fc5 100644
--- a/src/indev/lv_indev_scroll.c
+++ b/src/indev/lv_indev_scroll.c
@@ -43,6 +43,7 @@ static int32_t elastic_diff(lv_obj_t * scroll_obj, int32_t diff, int32_t scroll_
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 void lv_indev_scroll_handler(lv_indev_t * indev)
 {
     if(indev->pointer.vect.x == 0 && indev->pointer.vect.y == 0) {
@@ -112,6 +113,7 @@ void lv_indev_scroll_handler(lv_indev_t * indev)
     indev->pointer.scroll_sum.y += diff_y;
 }
 
+LV_FUNC_SECTION
 void lv_indev_scroll_throw_handler(lv_indev_t * indev)
 {
     lv_obj_t * scroll_obj = indev->pointer.scroll_obj;
@@ -224,6 +226,7 @@ void lv_indev_scroll_throw_handler(lv_indev_t * indev)
     }
 }
 
+LV_FUNC_SECTION
 int32_t lv_indev_scroll_throw_predict(lv_indev_t * indev, lv_dir_t dir)
 {
     if(indev == NULL) return 0;
@@ -249,12 +252,14 @@ int32_t lv_indev_scroll_throw_predict(lv_indev_t * indev, lv_dir_t dir)
     return sum;
 }
 
+LV_FUNC_SECTION
 void lv_indev_scroll_get_snap_dist(lv_obj_t * obj, lv_point_t * p)
 {
     p->x = find_snap_point_x(obj, obj->coords.x1, obj->coords.x2, 0);
     p->y = find_snap_point_y(obj, obj->coords.y1, obj->coords.y2, 0);
 }
 
+LV_FUNC_SECTION
 lv_obj_t * lv_indev_find_scroll_obj(lv_indev_t * indev)
 {
     lv_obj_t * obj_candidate = NULL;
@@ -437,6 +442,7 @@ lv_obj_t * lv_indev_find_scroll_obj(lv_indev_t * indev)
  *   STATIC FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 static void init_scroll_limits(lv_indev_t * indev)
 {
     lv_obj_t * obj = indev->pointer.scroll_obj;
@@ -511,6 +517,7 @@ static void init_scroll_limits(lv_indev_t * indev)
  * @return the absolute x coordinate of the nearest snap point
  *         or `LV_COORD_MAX` if there is no snap point in the min..max range
  */
+LV_FUNC_SECTION
 static int32_t find_snap_point_x(const lv_obj_t * obj, int32_t min, int32_t max, int32_t ofs)
 {
     lv_scroll_snap_t align = lv_obj_get_scroll_snap_x(obj);
@@ -567,6 +574,7 @@ static int32_t find_snap_point_x(const lv_obj_t * obj, int32_t min, int32_t max,
  * @return the absolute y coordinate of the nearest snap point
  *         or `LV_COORD_MAX` if there is no snap point in the min..max range
  */
+LV_FUNC_SECTION
 static int32_t find_snap_point_y(const lv_obj_t * obj, int32_t min, int32_t max, int32_t ofs)
 {
     lv_scroll_snap_t align = lv_obj_get_scroll_snap_y(obj);
@@ -613,6 +621,7 @@ static int32_t find_snap_point_y(const lv_obj_t * obj, int32_t min, int32_t max,
     return dist == LV_COORD_MAX ? LV_COORD_MAX : -dist;
 }
 
+LV_FUNC_SECTION
 static void scroll_limit_diff(lv_indev_t * indev, int32_t * diff_x, int32_t * diff_y)
 {
     if(diff_y) {
@@ -636,6 +645,7 @@ static void scroll_limit_diff(lv_indev_t * indev, int32_t * diff_x, int32_t * di
     }
 }
 
+LV_FUNC_SECTION
 static int32_t elastic_diff(lv_obj_t * scroll_obj, int32_t diff, int32_t scroll_start, int32_t scroll_end,
                             lv_dir_t dir)
 {
diff --git a/src/layouts/flex/lv_flex.c b/src/layouts/flex/lv_flex.c
index 2af3bf35a..5800839f1 100644
--- a/src/layouts/flex/lv_flex.c
+++ b/src/layouts/flex/lv_flex.c
@@ -92,18 +92,21 @@ static int32_t lv_obj_get_height_with_margin(const lv_obj_t * obj);
  * Setter functions
  *====================*/
 
+LV_FUNC_SECTION
 void lv_flex_init(void)
 {
     layout_list_def[LV_LAYOUT_FLEX].cb = flex_update;
     layout_list_def[LV_LAYOUT_FLEX].user_data = NULL;
 }
 
+LV_FUNC_SECTION
 void lv_obj_set_flex_flow(lv_obj_t * obj, lv_flex_flow_t flow)
 {
     lv_obj_set_style_flex_flow(obj, flow, 0);
     lv_obj_set_style_layout(obj, LV_LAYOUT_FLEX, 0);
 }
 
+LV_FUNC_SECTION
 void lv_obj_set_flex_align(lv_obj_t * obj, lv_flex_align_t main_place, lv_flex_align_t cross_place,
                            lv_flex_align_t track_place)
 {
@@ -113,6 +116,7 @@ void lv_obj_set_flex_align(lv_obj_t * obj, lv_flex_align_t main_place, lv_flex_a
     lv_obj_set_style_layout(obj, LV_LAYOUT_FLEX, 0);
 }
 
+LV_FUNC_SECTION
 void lv_obj_set_flex_grow(lv_obj_t * obj, uint8_t grow)
 {
     lv_obj_set_style_flex_grow(obj, grow, 0);
@@ -122,7 +126,7 @@ void lv_obj_set_flex_grow(lv_obj_t * obj, uint8_t grow)
 /**********************
  *   STATIC FUNCTIONS
  **********************/
-
+__attribute__(( fptrgroup("lv_layout_dsc_cb") ))
 static void flex_update(lv_obj_t * cont, void * user_data)
 {
     LV_LOG_INFO("update %p container", (void *)cont);
@@ -230,6 +234,7 @@ static void flex_update(lv_obj_t * cont, void * user_data)
 /**
  * Find the last item of a track
  */
+LV_FUNC_SECTION
 static int32_t find_track_end(lv_obj_t * cont, flex_t * f, int32_t item_start_id, int32_t max_main_size,
                               int32_t item_gap, track_t * t)
 {
@@ -314,6 +319,7 @@ static int32_t find_track_end(lv_obj_t * cont, flex_t * f, int32_t item_start_id
 /**
  * Position the children in the same track
  */
+LV_FUNC_SECTION
 static void children_repos(lv_obj_t * cont, flex_t * f, int32_t item_first_id, int32_t item_last_id, int32_t abs_x,
                            int32_t abs_y, int32_t max_main_size, int32_t item_gap, track_t * t)
 {
@@ -466,6 +472,7 @@ static void children_repos(lv_obj_t * cont, flex_t * f, int32_t item_first_id, i
 /**
  * Tell a start coordinate and gap for a placement type.
  */
+LV_FUNC_SECTION
 static void place_content(lv_flex_align_t place, int32_t max_size, int32_t content_size, int32_t item_cnt,
                           int32_t * start_pos, int32_t * gap)
 {
@@ -505,6 +512,7 @@ static void place_content(lv_flex_align_t place, int32_t max_size, int32_t conte
     }
 }
 
+LV_FUNC_SECTION
 static lv_obj_t * get_next_item(lv_obj_t * cont, bool rev, int32_t * item_id)
 {
     if(rev) {
@@ -519,6 +527,7 @@ static lv_obj_t * get_next_item(lv_obj_t * cont, bool rev, int32_t * item_id)
     }
 }
 
+LV_FUNC_SECTION
 static int32_t lv_obj_get_width_with_margin(const lv_obj_t * obj)
 {
     return lv_obj_get_style_margin_left(obj, LV_PART_MAIN)
@@ -526,6 +535,7 @@ static int32_t lv_obj_get_width_with_margin(const lv_obj_t * obj)
            + lv_obj_get_style_margin_right(obj, LV_PART_MAIN);
 }
 
+LV_FUNC_SECTION
 static int32_t lv_obj_get_height_with_margin(const lv_obj_t * obj)
 {
     return lv_obj_get_style_margin_top(obj, LV_PART_MAIN)
diff --git a/src/layouts/grid/lv_grid.c b/src/layouts/grid/lv_grid.c
index 70d3f7936..2d28a86b1 100644
--- a/src/layouts/grid/lv_grid.c
+++ b/src/layouts/grid/lv_grid.c
@@ -64,57 +64,70 @@ static int32_t grid_align(int32_t cont_size, bool auto_size, lv_grid_align_t ali
                           int32_t * size_array, int32_t * pos_array, bool reverse);
 static uint32_t count_tracks(const int32_t * templ);
 
+LV_FUNC_SECTION
 static inline const int32_t * get_col_dsc(lv_obj_t * obj)
 {
     return lv_obj_get_style_grid_column_dsc_array(obj, 0);
 }
+LV_FUNC_SECTION
 static inline const int32_t * get_row_dsc(lv_obj_t * obj)
 {
     return lv_obj_get_style_grid_row_dsc_array(obj, 0);
 }
+LV_FUNC_SECTION
 static inline int32_t get_col_pos(lv_obj_t * obj)
 {
     return lv_obj_get_style_grid_cell_column_pos(obj, 0);
 }
+LV_FUNC_SECTION
 static inline int32_t get_row_pos(lv_obj_t * obj)
 {
     return lv_obj_get_style_grid_cell_row_pos(obj, 0);
 }
+LV_FUNC_SECTION
 static inline int32_t get_col_span(lv_obj_t * obj)
 {
     return lv_obj_get_style_grid_cell_column_span(obj, 0);
 }
+LV_FUNC_SECTION
 static inline int32_t get_row_span(lv_obj_t * obj)
 {
     return lv_obj_get_style_grid_cell_row_span(obj, 0);
 }
+LV_FUNC_SECTION
 static inline lv_grid_align_t get_cell_col_align(lv_obj_t * obj)
 {
     return lv_obj_get_style_grid_cell_x_align(obj, 0);
 }
+LV_FUNC_SECTION
 static inline lv_grid_align_t get_cell_row_align(lv_obj_t * obj)
 {
     return lv_obj_get_style_grid_cell_y_align(obj, 0);
 }
+LV_FUNC_SECTION
 static inline lv_grid_align_t get_grid_col_align(lv_obj_t * obj)
 {
     return lv_obj_get_style_grid_column_align(obj, 0);
 }
+LV_FUNC_SECTION
 static inline lv_grid_align_t get_grid_row_align(lv_obj_t * obj)
 {
     return lv_obj_get_style_grid_row_align(obj, 0);
 }
+LV_FUNC_SECTION
 static inline int32_t get_margin_hor(lv_obj_t * obj)
 {
     return lv_obj_get_style_margin_left(obj, LV_PART_MAIN)
            + lv_obj_get_style_margin_right(obj, LV_PART_MAIN);
 }
+LV_FUNC_SECTION
 static inline int32_t get_margin_ver(lv_obj_t * obj)
 {
     return lv_obj_get_style_margin_top(obj, LV_PART_MAIN)
            + lv_obj_get_style_margin_bottom(obj, LV_PART_MAIN);
 }
 
+LV_FUNC_SECTION
 static inline int32_t div_round_closest(int32_t dividend, int32_t divisor)
 {
     return (dividend + divisor / 2) / divisor;
@@ -141,12 +154,14 @@ static inline int32_t div_round_closest(int32_t dividend, int32_t divisor)
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 void lv_grid_init(void)
 {
     layout_list_def[LV_LAYOUT_GRID].cb = grid_update;
     layout_list_def[LV_LAYOUT_GRID].user_data = NULL;
 }
 
+LV_FUNC_SECTION
 void lv_obj_set_grid_dsc_array(lv_obj_t * obj, const int32_t col_dsc[], const int32_t row_dsc[])
 {
     lv_obj_set_style_grid_column_dsc_array(obj, col_dsc, 0);
@@ -154,6 +169,7 @@ void lv_obj_set_grid_dsc_array(lv_obj_t * obj, const int32_t col_dsc[], const in
     lv_obj_set_style_layout(obj, LV_LAYOUT_GRID, 0);
 }
 
+LV_FUNC_SECTION
 void lv_obj_set_grid_align(lv_obj_t * obj, lv_grid_align_t column_align, lv_grid_align_t row_align)
 {
     lv_obj_set_style_grid_column_align(obj, column_align, 0);
@@ -161,6 +177,7 @@ void lv_obj_set_grid_align(lv_obj_t * obj, lv_grid_align_t column_align, lv_grid
 
 }
 
+LV_FUNC_SECTION
 void lv_obj_set_grid_cell(lv_obj_t * obj, lv_grid_align_t x_align, int32_t col_pos, int32_t col_span,
                           lv_grid_align_t y_align, int32_t row_pos, int32_t row_span)
 
@@ -175,6 +192,7 @@ void lv_obj_set_grid_cell(lv_obj_t * obj, lv_grid_align_t x_align, int32_t col_p
     lv_obj_mark_layout_as_dirty(lv_obj_get_parent(obj));
 }
 
+LV_FUNC_SECTION
 int32_t lv_grid_fr(uint8_t x)
 {
     return LV_GRID_FR(x);
@@ -183,7 +201,7 @@ int32_t lv_grid_fr(uint8_t x)
 /**********************
  *   STATIC FUNCTIONS
  **********************/
-
+__attribute__(( fptrgroup("lv_layout_dsc_cb") ))
 static void grid_update(lv_obj_t * cont, void * user_data)
 {
     LV_LOG_INFO("update %p container", (void *)cont);
@@ -230,6 +248,7 @@ static void grid_update(lv_obj_t * cont, void * user_data)
  * @param calc store the calculated cells sizes here
  * @note `lv_grid_calc_free(calc_out)` needs to be called when `calc_out` is not needed anymore
  */
+LV_FUNC_SECTION
 static void calc(lv_obj_t * cont, lv_grid_calc_t * calc_out)
 {
     if(lv_obj_get_child(cont, 0) == NULL) {
@@ -264,6 +283,7 @@ static void calc(lv_obj_t * cont, lv_grid_calc_t * calc_out)
  * Free the a grid calculation's data
  * @param calc pointer to the calculated grid cell coordinates
  */
+LV_FUNC_SECTION
 static void calc_free(lv_grid_calc_t * calc)
 {
     lv_free(calc->x);
@@ -272,6 +292,7 @@ static void calc_free(lv_grid_calc_t * calc)
     lv_free(calc->h);
 }
 
+LV_FUNC_SECTION
 static void calc_cols(lv_obj_t * cont, lv_grid_calc_t * c)
 {
 
@@ -365,6 +386,7 @@ static void calc_cols(lv_obj_t * cont, lv_grid_calc_t * c)
     }
 }
 
+LV_FUNC_SECTION
 static void calc_rows(lv_obj_t * cont, lv_grid_calc_t * c)
 {
     const int32_t * row_templ;
@@ -461,6 +483,7 @@ static void calc_rows(lv_obj_t * cont, lv_grid_calc_t * c)
  * @param child_id_ext helper value if the ID of the child is know (order from the oldest) else -1
  * @param grid_abs helper value, the absolute position of the grid, NULL if unknown
  */
+LV_FUNC_SECTION
 static void item_repos(lv_obj_t * item, lv_grid_calc_t * c, item_repos_hint_t * hint)
 {
     if(lv_obj_has_flag_any(item, LV_OBJ_FLAG_IGNORE_LAYOUT | LV_OBJ_FLAG_HIDDEN | LV_OBJ_FLAG_FLOATING)) return;
@@ -585,6 +608,7 @@ static void item_repos(lv_obj_t * item, lv_grid_calc_t * c, item_repos_hint_t *
  * @param pos_array write the positions of the tracks here
  * @return the total size of the grid
  */
+LV_FUNC_SECTION
 static int32_t grid_align(int32_t cont_size,  bool auto_size, lv_grid_align_t align, int32_t gap,
                           uint32_t track_num,
                           int32_t * size_array, int32_t * pos_array, bool reverse)
@@ -654,6 +678,7 @@ static int32_t grid_align(int32_t cont_size,  bool auto_size, lv_grid_align_t al
     return total_gird_size;
 }
 
+LV_FUNC_SECTION
 static uint32_t count_tracks(const int32_t * templ)
 {
     uint32_t i;
diff --git a/src/layouts/lv_layout.c b/src/layouts/lv_layout.c
index ddb3b0e5a..82cf439fc 100644
--- a/src/layouts/lv_layout.c
+++ b/src/layouts/lv_layout.c
@@ -36,6 +36,7 @@
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 void lv_layout_init(void)
 {
     /*Malloc a list for the built in layouts*/
@@ -50,11 +51,13 @@ void lv_layout_init(void)
 #endif
 }
 
+LV_FUNC_SECTION
 void lv_layout_deinit(void)
 {
     lv_free(layout_list_def);
 }
 
+LV_FUNC_SECTION
 uint32_t lv_layout_register(lv_layout_update_cb_t cb, void * user_data)
 {
     layout_list_def = lv_realloc(layout_list_def, (layout_cnt + 1) * sizeof(lv_layout_dsc_t));
@@ -65,6 +68,8 @@ uint32_t lv_layout_register(lv_layout_update_cb_t cb, void * user_data)
     return layout_cnt++;
 }
 
+#pragma stackfunction 1024
+LV_FUNC_SECTION
 void lv_layout_apply(lv_obj_t * obj)
 {
     lv_layout_t layout_id = lv_obj_get_style_layout(obj, LV_PART_MAIN);
diff --git a/src/layouts/lv_layout_private.h b/src/layouts/lv_layout_private.h
index dace2fccb..4adb35a9f 100644
--- a/src/layouts/lv_layout_private.h
+++ b/src/layouts/lv_layout_private.h
@@ -25,6 +25,7 @@ extern "C" {
  **********************/
 
 typedef struct {
+    __attribute__(( fptrgroup("lv_layout_dsc_cb") ))
     lv_layout_update_cb_t cb;
     void * user_data;
 } lv_layout_dsc_t;
diff --git a/src/libs/barcode/code128.c b/src/libs/barcode/code128.c
index 4fc00cb66..6e8ce0ae1 100644
--- a/src/libs/barcode/code128.c
+++ b/src/libs/barcode/code128.c
@@ -177,6 +177,7 @@ struct code128_state {
     size_t maxlength;
 };
 
+LV_FUNC_SECTION
 size_t code128_estimate_len(const char * s)
 {
     return CODE128_QUIET_ZONE_LEN
@@ -187,6 +188,7 @@ size_t code128_estimate_len(const char * s)
            + CODE128_QUIET_ZONE_LEN;
 }
 
+LV_FUNC_SECTION
 static void code128_append_pattern(int pattern, int pattern_length, char * out)
 {
     // All patterns have their first bit set by design
@@ -199,6 +201,7 @@ static void code128_append_pattern(int pattern, int pattern_length, char * out)
     }
 }
 
+LV_FUNC_SECTION
 static int code128_append_code(int code, char * out)
 {
     CODE128_ASSERT(code >= 0 && code < (int)(sizeof(code128_pattern) / sizeof(code128_pattern[0])));
@@ -206,12 +209,14 @@ static int code128_append_code(int code, char * out)
     return CODE128_CHAR_LEN;
 }
 
+LV_FUNC_SECTION
 static int code128_append_stop_code(char * out)
 {
     code128_append_pattern(code128_stop_pattern, CODE128_STOP_CODE_LEN, out);
     return CODE128_STOP_CODE_LEN;
 }
 
+LV_FUNC_SECTION
 static signed char code128_switch_code(char from_mode, char to_mode)
 {
     switch(from_mode) {
@@ -249,6 +254,7 @@ static signed char code128_switch_code(char from_mode, char to_mode)
     return -1;
 }
 
+LV_FUNC_SECTION
 static signed char code128a_ascii_to_code(signed char value)
 {
     if(value >= ' ' && value <= '_')
@@ -267,6 +273,7 @@ static signed char code128a_ascii_to_code(signed char value)
         return -1;
 }
 
+LV_FUNC_SECTION
 static signed char code128b_ascii_to_code(signed char value)
 {
     if(value >= ' ')  // value <= 127 is implied
@@ -283,6 +290,7 @@ static signed char code128b_ascii_to_code(signed char value)
         return -1;
 }
 
+LV_FUNC_SECTION
 static signed char code128c_ascii_to_code(const char * values)
 {
     if(values[0] == CODE128_FNC1)
@@ -297,6 +305,7 @@ static signed char code128c_ascii_to_code(const char * values)
     return -1;
 }
 
+LV_FUNC_SECTION
 static int code128_do_a_step(struct code128_step * base, int prev_ix, int ix)
 {
     struct code128_step * previous_step = &base[prev_ix];
@@ -321,6 +330,7 @@ static int code128_do_a_step(struct code128_step * base, int prev_ix, int ix)
     return 1;
 }
 
+LV_FUNC_SECTION
 static int code128_do_b_step(struct code128_step * base, int prev_ix, int ix)
 {
     struct code128_step * previous_step = &base[prev_ix];
@@ -345,6 +355,7 @@ static int code128_do_b_step(struct code128_step * base, int prev_ix, int ix)
     return 1;
 }
 
+LV_FUNC_SECTION
 static int code128_do_c_step(struct code128_step * base, int prev_ix, int ix)
 {
     struct code128_step * previous_step = &base[prev_ix];
@@ -374,6 +385,7 @@ static int code128_do_c_step(struct code128_step * base, int prev_ix, int ix)
     return 1;
 }
 
+LV_FUNC_SECTION
 static struct code128_step * code128_alloc_step(struct code128_state * state)
 {
     if(state->todo_ix >= state->allocated_steps) {
@@ -388,6 +400,7 @@ static struct code128_step * code128_alloc_step(struct code128_state * state)
     return step;
 }
 
+LV_FUNC_SECTION
 static void code128_do_step(struct code128_state * state)
 {
     struct code128_step * step = &state->steps[state->current_ix];
@@ -449,6 +462,7 @@ static void code128_do_step(struct code128_state * state)
     }
 }
 
+LV_FUNC_SECTION
 size_t code128_encode_raw(const char * s, char * out, size_t maxlength)
 {
     struct code128_state state;
@@ -551,6 +565,7 @@ size_t code128_encode_raw(const char * s, char * out, size_t maxlength)
  *
  * @return the length of barcode data in bytes
  */
+LV_FUNC_SECTION
 size_t code128_encode_gs1(const char * s, char * out, size_t maxlength)
 {
     size_t raw_size = CODE128_STRLEN(s) + 1;
diff --git a/src/libs/barcode/lv_barcode.c b/src/libs/barcode/lv_barcode.c
index 56885330b..6afce5686 100644
--- a/src/libs/barcode/lv_barcode.c
+++ b/src/libs/barcode/lv_barcode.c
@@ -52,6 +52,7 @@ const lv_obj_class_t lv_barcode_class = {
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 lv_obj_t * lv_barcode_create(lv_obj_t * parent)
 {
     LV_LOG_INFO("begin");
@@ -60,6 +61,7 @@ lv_obj_t * lv_barcode_create(lv_obj_t * parent)
     return obj;
 }
 
+LV_FUNC_SECTION
 void lv_barcode_set_dark_color(lv_obj_t * obj, lv_color_t color)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -68,6 +70,7 @@ void lv_barcode_set_dark_color(lv_obj_t * obj, lv_color_t color)
     barcode->dark_color = color;
 }
 
+LV_FUNC_SECTION
 void lv_barcode_set_light_color(lv_obj_t * obj, lv_color_t color)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -76,6 +79,7 @@ void lv_barcode_set_light_color(lv_obj_t * obj, lv_color_t color)
     barcode->light_color = color;
 }
 
+LV_FUNC_SECTION
 void lv_barcode_set_scale(lv_obj_t * obj, uint16_t scale)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -88,6 +92,7 @@ void lv_barcode_set_scale(lv_obj_t * obj, uint16_t scale)
     barcode->scale = scale;
 }
 
+LV_FUNC_SECTION
 void lv_barcode_set_direction(lv_obj_t * obj, lv_dir_t direction)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -96,6 +101,7 @@ void lv_barcode_set_direction(lv_obj_t * obj, lv_dir_t direction)
     barcode->direction = direction;
 }
 
+LV_FUNC_SECTION
 void lv_barcode_set_tiled(lv_obj_t * obj, bool tiled)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -105,6 +111,7 @@ void lv_barcode_set_tiled(lv_obj_t * obj, bool tiled)
     lv_image_set_inner_align(obj, tiled ? LV_IMAGE_ALIGN_TILE : LV_IMAGE_ALIGN_DEFAULT);
 }
 
+LV_FUNC_SECTION
 lv_result_t lv_barcode_update(lv_obj_t * obj, const char * data)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -211,6 +218,7 @@ lv_result_t lv_barcode_update(lv_obj_t * obj, const char * data)
     return LV_RESULT_OK;
 }
 
+LV_FUNC_SECTION
 lv_color_t lv_barcode_get_dark_color(lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -219,6 +227,7 @@ lv_color_t lv_barcode_get_dark_color(lv_obj_t * obj)
     return barcode->dark_color;
 }
 
+LV_FUNC_SECTION
 lv_color_t lv_barcode_get_light_color(lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -227,6 +236,7 @@ lv_color_t lv_barcode_get_light_color(lv_obj_t * obj)
     return barcode->light_color;
 }
 
+LV_FUNC_SECTION
 uint16_t lv_barcode_get_scale(lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -239,6 +249,7 @@ uint16_t lv_barcode_get_scale(lv_obj_t * obj)
  *   STATIC FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 static void lv_barcode_constructor(const lv_obj_class_t * class_p, lv_obj_t * obj)
 {
     LV_UNUSED(class_p);
@@ -251,6 +262,7 @@ static void lv_barcode_constructor(const lv_obj_class_t * class_p, lv_obj_t * ob
     lv_image_set_inner_align(obj, LV_IMAGE_ALIGN_DEFAULT);
 }
 
+LV_FUNC_SECTION
 static void lv_barcode_destructor(const lv_obj_class_t * class_p, lv_obj_t * obj)
 {
     LV_UNUSED(class_p);
@@ -263,6 +275,7 @@ static void lv_barcode_destructor(const lv_obj_class_t * class_p, lv_obj_t * obj
     lv_draw_buf_destroy(draw_buf);
 }
 
+LV_FUNC_SECTION
 static bool lv_barcode_change_buf_size(lv_obj_t * obj, int32_t w, int32_t h)
 {
     LV_ASSERT_NULL(obj);
@@ -285,6 +298,7 @@ static bool lv_barcode_change_buf_size(lv_obj_t * obj, int32_t w, int32_t h)
     return true;
 }
 
+LV_FUNC_SECTION
 static void lv_barcode_clear(lv_obj_t * obj)
 {
     lv_draw_buf_t * draw_buf = lv_canvas_get_draw_buf(obj);
diff --git a/src/libs/bin_decoder/lv_bin_decoder.c b/src/libs/bin_decoder/lv_bin_decoder.c
index 45edd65eb..1e515fa12 100644
--- a/src/libs/bin_decoder/lv_bin_decoder.c
+++ b/src/libs/bin_decoder/lv_bin_decoder.c
@@ -92,6 +92,7 @@ static lv_result_t decompress_image(lv_image_decoder_dsc_t * dsc, const lv_image
 /**
  * Initialize the lvgl binary image decoder module
  */
+LV_FUNC_SECTION
 void lv_bin_decoder_init(void)
 {
     lv_image_decoder_t * decoder;
@@ -111,6 +112,7 @@ void lv_bin_decoder_init(void)
     decoder->name = DECODER_NAME;
 }
 
+__attribute__(( fptrgroup("lv_image_deocder_info_cb") ))
 lv_result_t lv_bin_decoder_info(lv_image_decoder_t * decoder, lv_image_decoder_dsc_t * dsc, lv_image_header_t * header)
 {
     LV_UNUSED(decoder); /*Unused*/
@@ -177,6 +179,7 @@ lv_result_t lv_bin_decoder_info(lv_image_decoder_t * decoder, lv_image_decoder_d
  * @param dsc     pointer to the decoder descriptor
  * @return LV_RESULT_OK: no error; LV_RESULT_INVALID: can't open the image
  */
+__attribute__(( fptrgroup("lv_image_deocder_open_cb") ))
 lv_result_t lv_bin_decoder_open(lv_image_decoder_t * decoder, lv_image_decoder_dsc_t * dsc)
 {
     LV_UNUSED(decoder);
@@ -362,6 +365,7 @@ lv_result_t lv_bin_decoder_open(lv_image_decoder_t * decoder, lv_image_decoder_d
     return LV_RESULT_OK;
 }
 
+LV_FUNC_SECTION
 void lv_bin_decoder_close(lv_image_decoder_t * decoder, lv_image_decoder_dsc_t * dsc)
 {
     LV_UNUSED(decoder); /*Unused*/
@@ -375,6 +379,7 @@ void lv_bin_decoder_close(lv_image_decoder_t * decoder, lv_image_decoder_dsc_t *
     free_decoder_data(dsc);
 }
 
+__attribute__(( fptrgroup("lv_image_deocder_get_area_cb") ))
 lv_result_t lv_bin_decoder_get_area(lv_image_decoder_t * decoder, lv_image_decoder_dsc_t * dsc,
                                     const lv_area_t * full_area, lv_area_t * decoded_area)
 {
@@ -517,6 +522,7 @@ lv_result_t lv_bin_decoder_get_area(lv_image_decoder_t * decoder, lv_image_decod
  *   STATIC FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 static decoder_data_t * get_decoder_data(lv_image_decoder_dsc_t * dsc)
 {
     decoder_data_t * data = dsc->user_data;
@@ -534,6 +540,7 @@ static decoder_data_t * get_decoder_data(lv_image_decoder_dsc_t * dsc)
     return data;
 }
 
+LV_FUNC_SECTION
 static void free_decoder_data(lv_image_decoder_dsc_t * dsc)
 {
     decoder_data_t * decoder_data = dsc->user_data;
@@ -551,6 +558,7 @@ static void free_decoder_data(lv_image_decoder_dsc_t * dsc)
     dsc->user_data = NULL;
 }
 
+LV_FUNC_SECTION
 static lv_result_t decode_indexed(lv_image_decoder_t * decoder, lv_image_decoder_dsc_t * dsc)
 {
     LV_UNUSED(decoder); /*Unused*/
@@ -673,6 +681,7 @@ exit_with_buf:
 #endif
 }
 
+LV_FUNC_SECTION
 static lv_result_t load_indexed(lv_image_decoder_t * decoder, lv_image_decoder_dsc_t * dsc)
 {
 #if LV_BIN_DECODER_RAM_LOAD == 0
@@ -767,6 +776,7 @@ static lv_result_t load_indexed(lv_image_decoder_t * decoder, lv_image_decoder_d
 }
 
 #if LV_BIN_DECODER_RAM_LOAD
+LV_FUNC_SECTION
 static lv_result_t decode_rgb(lv_image_decoder_t * decoder, lv_image_decoder_dsc_t * dsc)
 {
     LV_UNUSED(decoder);
@@ -806,6 +816,7 @@ static lv_result_t decode_rgb(lv_image_decoder_t * decoder, lv_image_decoder_dsc
 /**
  * Extend A1/2/4 to A8 with interpolation to reduce rounding error.
  */
+LV_FUNC_SECTION
 static inline uint8_t bit_extend(uint8_t value, uint8_t bpp)
 {
     if(value == 0) return 0;
@@ -820,6 +831,7 @@ static inline uint8_t bit_extend(uint8_t value, uint8_t bpp)
     return res;
 }
 
+LV_FUNC_SECTION
 static lv_result_t decode_alpha_only(lv_image_decoder_t * decoder, lv_image_decoder_dsc_t * dsc)
 {
     LV_UNUSED(decoder);
@@ -891,6 +903,7 @@ static lv_result_t decode_alpha_only(lv_image_decoder_t * decoder, lv_image_deco
     return LV_RESULT_OK;
 }
 
+LV_FUNC_SECTION
 static lv_result_t decode_compressed(lv_image_decoder_t * decoder, lv_image_decoder_dsc_t * dsc)
 {
 #if LV_BIN_DECODER_RAM_LOAD
@@ -1009,6 +1022,7 @@ static lv_result_t decode_compressed(lv_image_decoder_t * decoder, lv_image_deco
 #endif
 }
 
+LV_FUNC_SECTION
 static lv_result_t decode_indexed_line(lv_color_format_t color_format, const lv_color32_t * palette, int32_t x,
                                        int32_t w_px, const uint8_t * in, lv_color32_t * out)
 {
@@ -1057,6 +1071,7 @@ static lv_result_t decode_indexed_line(lv_color_format_t color_format, const lv_
     return LV_RESULT_OK;
 }
 
+LV_FUNC_SECTION
 static lv_fs_res_t fs_read_file_at(lv_fs_file_t * f, uint32_t pos, void * buff, uint32_t btr, uint32_t * br)
 {
     lv_fs_res_t res;
@@ -1075,6 +1090,7 @@ static lv_fs_res_t fs_read_file_at(lv_fs_file_t * f, uint32_t pos, void * buff,
     return LV_FS_RES_OK;
 }
 
+LV_FUNC_SECTION
 static lv_result_t decompress_image(lv_image_decoder_dsc_t * dsc, const lv_image_compressed_t * compressed)
 {
     /*Need to store decompressed data to decoder to free on close*/
diff --git a/src/libs/bmp/lv_bmp.c b/src/libs/bmp/lv_bmp.c
index aeb9dad29..ba066e127 100644
--- a/src/libs/bmp/lv_bmp.c
+++ b/src/libs/bmp/lv_bmp.c
@@ -56,6 +56,7 @@ static void decoder_close(lv_image_decoder_t * dec, lv_image_decoder_dsc_t * dsc
 /**********************
  *   GLOBAL FUNCTIONS
  **********************/
+LV_FUNC_SECTION
 void lv_bmp_init(void)
 {
     lv_image_decoder_t * dec = lv_image_decoder_create();
@@ -67,6 +68,7 @@ void lv_bmp_init(void)
     dec->name = DECODER_NAME;
 }
 
+LV_FUNC_SECTION
 void lv_bmp_deinit(void)
 {
     lv_image_decoder_t * dec = NULL;
@@ -88,6 +90,7 @@ void lv_bmp_deinit(void)
  * @param header store the info here
  * @return LV_RESULT_OK: no error; LV_RESULT_INVALID: can't get the info
  */
+__attribute__(( fptrgroup("lv_image_deocder_info_cb") ))
 static lv_result_t decoder_info(lv_image_decoder_t * decoder, lv_image_decoder_dsc_t * dsc, lv_image_header_t * header)
 {
     LV_UNUSED(decoder);
@@ -144,6 +147,7 @@ static lv_result_t decoder_info(lv_image_decoder_t * decoder, lv_image_decoder_d
  * @param dsc     pointer to the decoder descriptor
  * @return LV_RESULT_OK: no error; LV_RESULT_INVALID: can't open the image
  */
+__attribute__(( fptrgroup("lv_image_deocder_open_cb") ))
 static lv_result_t decoder_open(lv_image_decoder_t * decoder, lv_image_decoder_dsc_t * dsc)
 {
     LV_UNUSED(decoder);
@@ -191,6 +195,7 @@ static lv_result_t decoder_open(lv_image_decoder_t * decoder, lv_image_decoder_d
     return LV_RESULT_INVALID;    /*If not returned earlier then it failed*/
 }
 
+__attribute__(( fptrgroup("lv_image_deocder_get_area_cb") ))
 static lv_result_t decoder_get_area(lv_image_decoder_t * decoder, lv_image_decoder_dsc_t * dsc,
                                     const lv_area_t * full_area, lv_area_t * decoded_area)
 {
@@ -240,6 +245,7 @@ static lv_result_t decoder_get_area(lv_image_decoder_t * decoder, lv_image_decod
 /**
  * Free the allocated resources
  */
+__attribute__(( fptrgroup("lv_image_deocder_close_cb") ))
 static void decoder_close(lv_image_decoder_t * decoder, lv_image_decoder_dsc_t * dsc)
 {
     LV_UNUSED(decoder);
diff --git a/src/libs/ffmpeg/lv_ffmpeg.c b/src/libs/ffmpeg/lv_ffmpeg.c
index 839ab2a19..72295cf6f 100644
--- a/src/libs/ffmpeg/lv_ffmpeg.c
+++ b/src/libs/ffmpeg/lv_ffmpeg.c
@@ -111,6 +111,7 @@ const lv_obj_class_t lv_ffmpeg_player_class = {
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 void lv_ffmpeg_init(void)
 {
     lv_image_decoder_t * dec = lv_image_decoder_create();
@@ -125,6 +126,7 @@ void lv_ffmpeg_init(void)
 #endif
 }
 
+LV_FUNC_SECTION
 int lv_ffmpeg_get_frame_num(const char * path)
 {
     int ret = -1;
@@ -138,6 +140,7 @@ int lv_ffmpeg_get_frame_num(const char * path)
     return ret;
 }
 
+LV_FUNC_SECTION
 lv_obj_t * lv_ffmpeg_player_create(lv_obj_t * parent)
 {
     lv_obj_t * obj = lv_obj_class_create_obj(MY_CLASS, parent);
@@ -145,6 +148,7 @@ lv_obj_t * lv_ffmpeg_player_create(lv_obj_t * parent)
     return obj;
 }
 
+LV_FUNC_SECTION
 lv_result_t lv_ffmpeg_player_set_src(lv_obj_t * obj, const char * path)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -209,6 +213,7 @@ failed:
     return res;
 }
 
+LV_FUNC_SECTION
 void lv_ffmpeg_player_set_cmd(lv_obj_t * obj, lv_ffmpeg_player_cmd_t cmd)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -248,6 +253,7 @@ void lv_ffmpeg_player_set_cmd(lv_obj_t * obj, lv_ffmpeg_player_cmd_t cmd)
     }
 }
 
+LV_FUNC_SECTION
 void lv_ffmpeg_player_set_auto_restart(lv_obj_t * obj, bool en)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -258,7 +264,7 @@ void lv_ffmpeg_player_set_auto_restart(lv_obj_t * obj, bool en)
 /**********************
  *   STATIC FUNCTIONS
  **********************/
-
+__attribute__(( fptrgroup("lv_image_deocder_info_cb") ))
 static lv_result_t decoder_info(lv_image_decoder_t * decoder, lv_image_decoder_dsc_t * dsc, lv_image_header_t * header)
 {
     LV_UNUSED(decoder);
@@ -288,6 +294,7 @@ static lv_result_t decoder_info(lv_image_decoder_t * decoder, lv_image_decoder_d
  * @param dsc     pointer to the decoder descriptor
  * @return LV_RESULT_OK: no error; LV_RESULT_INVALID: can't open the image
  */
+__attribute__(( fptrgroup("lv_image_deocder_open_cb") ))
 static lv_result_t decoder_open(lv_image_decoder_t * decoder, lv_image_decoder_dsc_t * dsc)
 {
     LV_UNUSED(decoder);
@@ -333,6 +340,7 @@ static lv_result_t decoder_open(lv_image_decoder_t * decoder, lv_image_decoder_d
     return LV_RESULT_INVALID;
 }
 
+__attribute__(( fptrgroup("lv_image_deocder_close_cb") ))
 static void decoder_close(lv_image_decoder_t * decoder, lv_image_decoder_dsc_t * dsc)
 {
     LV_UNUSED(decoder);
@@ -340,6 +348,7 @@ static void decoder_close(lv_image_decoder_t * decoder, lv_image_decoder_dsc_t *
     ffmpeg_close(ffmpeg_ctx);
 }
 
+LV_FUNC_SECTION
 static uint8_t * ffmpeg_get_image_data(struct ffmpeg_context_s * ffmpeg_ctx)
 {
     uint8_t * img_data = ffmpeg_ctx->video_dst_data[0];
@@ -351,6 +360,7 @@ static uint8_t * ffmpeg_get_image_data(struct ffmpeg_context_s * ffmpeg_ctx)
     return img_data;
 }
 
+LV_FUNC_SECTION
 static bool ffmpeg_pix_fmt_has_alpha(enum AVPixelFormat pix_fmt)
 {
     const AVPixFmtDescriptor * desc = av_pix_fmt_desc_get(pix_fmt);
@@ -366,6 +376,7 @@ static bool ffmpeg_pix_fmt_has_alpha(enum AVPixelFormat pix_fmt)
     return desc->flags & AV_PIX_FMT_FLAG_ALPHA;
 }
 
+LV_FUNC_SECTION
 static bool ffmpeg_pix_fmt_is_yuv(enum AVPixelFormat pix_fmt)
 {
     const AVPixFmtDescriptor * desc = av_pix_fmt_desc_get(pix_fmt);
@@ -377,6 +388,7 @@ static bool ffmpeg_pix_fmt_is_yuv(enum AVPixelFormat pix_fmt)
     return !(desc->flags & AV_PIX_FMT_FLAG_RGB) && desc->nb_components >= 2;
 }
 
+LV_FUNC_SECTION
 static int ffmpeg_output_video_frame(struct ffmpeg_context_s * ffmpeg_ctx)
 {
     int ret = -1;
@@ -466,6 +478,7 @@ failed:
     return ret;
 }
 
+LV_FUNC_SECTION
 static int ffmpeg_decode_packet(AVCodecContext * dec, const AVPacket * pkt,
                                 struct ffmpeg_context_s * ffmpeg_ctx)
 {
@@ -511,6 +524,7 @@ static int ffmpeg_decode_packet(AVCodecContext * dec, const AVPacket * pkt,
     return 0;
 }
 
+LV_FUNC_SECTION
 static int ffmpeg_open_codec_context(int * stream_idx,
                                      AVCodecContext ** dec_ctx, AVFormatContext * fmt_ctx,
                                      enum AVMediaType type)
@@ -568,6 +582,7 @@ static int ffmpeg_open_codec_context(int * stream_idx,
     return 0;
 }
 
+LV_FUNC_SECTION
 static int ffmpeg_get_image_header(const char * filepath,
                                    lv_image_header_t * header)
 {
@@ -610,6 +625,7 @@ failed:
     return ret;
 }
 
+LV_FUNC_SECTION
 static int ffmpeg_get_frame_refr_period(struct ffmpeg_context_s * ffmpeg_ctx)
 {
     int avg_frame_rate_num = ffmpeg_ctx->video_stream->avg_frame_rate.num;
@@ -622,6 +638,7 @@ static int ffmpeg_get_frame_refr_period(struct ffmpeg_context_s * ffmpeg_ctx)
     return -1;
 }
 
+LV_FUNC_SECTION
 static int ffmpeg_update_next_frame(struct ffmpeg_context_s * ffmpeg_ctx)
 {
     int ret = 0;
@@ -662,6 +679,7 @@ static int ffmpeg_update_next_frame(struct ffmpeg_context_s * ffmpeg_ctx)
     return ret;
 }
 
+LV_FUNC_SECTION
 struct ffmpeg_context_s * ffmpeg_open_file(const char * path)
 {
     if(path == NULL || lv_strlen(path) == 0) {
@@ -719,6 +737,7 @@ failed:
     return NULL;
 }
 
+LV_FUNC_SECTION
 static int ffmpeg_image_allocate(struct ffmpeg_context_s * ffmpeg_ctx)
 {
     int ret;
@@ -774,6 +793,7 @@ static int ffmpeg_image_allocate(struct ffmpeg_context_s * ffmpeg_ctx)
     return 0;
 }
 
+LV_FUNC_SECTION
 static void ffmpeg_close_src_ctx(struct ffmpeg_context_s * ffmpeg_ctx)
 {
     avcodec_free_context(&(ffmpeg_ctx->video_dec_ctx));
@@ -786,6 +806,7 @@ static void ffmpeg_close_src_ctx(struct ffmpeg_context_s * ffmpeg_ctx)
     }
 }
 
+LV_FUNC_SECTION
 static void ffmpeg_close_dst_ctx(struct ffmpeg_context_s * ffmpeg_ctx)
 {
     if(ffmpeg_ctx->video_dst_data[0] != NULL) {
@@ -794,6 +815,7 @@ static void ffmpeg_close_dst_ctx(struct ffmpeg_context_s * ffmpeg_ctx)
     }
 }
 
+LV_FUNC_SECTION
 static void ffmpeg_close(struct ffmpeg_context_s * ffmpeg_ctx)
 {
     if(ffmpeg_ctx == NULL) {
@@ -809,6 +831,7 @@ static void ffmpeg_close(struct ffmpeg_context_s * ffmpeg_ctx)
     LV_LOG_INFO("ffmpeg_ctx closed");
 }
 
+LV_FUNC_SECTION
 static void lv_ffmpeg_player_frame_update_cb(lv_timer_t * timer)
 {
     lv_obj_t * obj = (lv_obj_t *)lv_timer_get_user_data(timer);
@@ -830,6 +853,7 @@ static void lv_ffmpeg_player_frame_update_cb(lv_timer_t * timer)
     lv_obj_invalidate(obj);
 }
 
+LV_FUNC_SECTION
 static void lv_ffmpeg_player_constructor(const lv_obj_class_t * class_p,
                                          lv_obj_t * obj)
 {
@@ -848,6 +872,7 @@ static void lv_ffmpeg_player_constructor(const lv_obj_class_t * class_p,
     LV_TRACE_OBJ_CREATE("finished");
 }
 
+LV_FUNC_SECTION
 static void lv_ffmpeg_player_destructor(const lv_obj_class_t * class_p,
                                         lv_obj_t * obj)
 {
diff --git a/src/libs/freetype/lv_freetype.c b/src/libs/freetype/lv_freetype.c
index b1da8f13e..e3212622f 100755
--- a/src/libs/freetype/lv_freetype.c
+++ b/src/libs/freetype/lv_freetype.c
@@ -63,6 +63,7 @@ static lv_cache_compare_res_t cache_node_cache_compare_cb(const lv_freetype_cach
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 lv_result_t lv_freetype_init(uint32_t max_glyph_cnt)
 {
     if(ft_ctx) {
@@ -102,6 +103,7 @@ lv_result_t lv_freetype_init(uint32_t max_glyph_cnt)
     return LV_RESULT_OK;
 }
 
+LV_FUNC_SECTION
 void lv_freetype_uninit(void)
 {
     lv_freetype_context_t * ctx = lv_freetype_get_context();
@@ -111,6 +113,7 @@ void lv_freetype_uninit(void)
     ft_ctx = NULL;
 }
 
+LV_FUNC_SECTION
 lv_font_t * lv_freetype_font_create(const char * pathname, lv_freetype_font_render_mode_t render_mode, uint32_t size,
                                     lv_freetype_font_style_t style)
 {
@@ -177,6 +180,7 @@ lv_font_t * lv_freetype_font_create(const char * pathname, lv_freetype_font_rend
     return font;
 }
 
+LV_FUNC_SECTION
 void lv_freetype_font_delete(lv_font_t * font)
 {
     LV_ASSERT_NULL(font);
@@ -196,11 +200,13 @@ void lv_freetype_font_delete(lv_font_t * font)
     lv_free(dsc);
 }
 
+LV_FUNC_SECTION
 lv_freetype_context_t * lv_freetype_get_context(void)
 {
     return LV_GLOBAL_DEFAULT()->ft_context;
 }
 
+LV_FUNC_SECTION
 void lv_freetype_italic_transform(FT_Face face)
 {
     LV_ASSERT_NULL(face);
@@ -212,6 +218,7 @@ void lv_freetype_italic_transform(FT_Face face)
     FT_Set_Transform(face, &matrix, NULL);
 }
 
+LV_FUNC_SECTION
 int32_t lv_freetype_italic_transform_on_pos(lv_point_t point)
 {
     return point.x + FT_F16DOT16_TO_INT(point.y * LV_FREETYPE_OBLIQUE_SLANT_DEF);
@@ -221,6 +228,7 @@ int32_t lv_freetype_italic_transform_on_pos(lv_point_t point)
  *   STATIC FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 static bool freetype_on_font_create(lv_freetype_font_dsc_t * dsc, uint32_t max_glyph_cnt)
 {
     /*
@@ -256,6 +264,7 @@ static bool freetype_on_font_create(lv_freetype_font_dsc_t * dsc, uint32_t max_g
     return true;
 }
 
+LV_FUNC_SECTION
 static void freetype_on_font_set_cbs(lv_freetype_font_dsc_t * dsc)
 {
     lv_freetype_set_cbs_glyph(dsc);
@@ -267,6 +276,7 @@ static void freetype_on_font_set_cbs(lv_freetype_font_dsc_t * dsc)
     }
 }
 
+LV_FUNC_SECTION
 static void lv_freetype_cleanup(lv_freetype_context_t * ctx)
 {
     LV_ASSERT_NULL(ctx);
@@ -281,6 +291,7 @@ static void lv_freetype_cleanup(lv_freetype_context_t * ctx)
     }
 }
 
+LV_FUNC_SECTION
 static FTC_FaceID lv_freetype_req_face_id(lv_freetype_context_t * ctx, const char * pathname)
 {
     size_t len = lv_strlen(pathname);
@@ -324,6 +335,7 @@ static FTC_FaceID lv_freetype_req_face_id(lv_freetype_context_t * ctx, const cha
     return node->pathname;
 }
 
+LV_FUNC_SECTION
 static void lv_freetype_drop_face_id(lv_freetype_context_t * ctx, FTC_FaceID face_id)
 {
     lv_ll_t * ll_p = &ctx->face_id_ll;
@@ -348,7 +360,7 @@ static void lv_freetype_drop_face_id(lv_freetype_context_t * ctx, FTC_FaceID fac
 /*-----------------
  * Cache Node Cache Callbacks
  *----------------*/
-
+__attribute__(( fptrgroup("lv_cache_create_cb") ))
 static bool cache_node_cache_create_cb(lv_freetype_cache_node_t * node, void * user_data)
 {
     LV_UNUSED(user_data);
@@ -373,6 +385,7 @@ static bool cache_node_cache_create_cb(lv_freetype_cache_node_t * node, void * u
 
     return true;
 }
+__attribute__(( fptrgroup("lv_cache_free_cb") ))
 static void cache_node_cache_free_cb(lv_freetype_cache_node_t * node, void * user_data)
 {
     FT_Done_Face(node->face);
@@ -387,6 +400,7 @@ static void cache_node_cache_free_cb(lv_freetype_cache_node_t * node, void * use
         node->draw_data_cache = NULL;
     }
 }
+__attribute__(( fptrgroup("lv_cache_compare_cb") ))
 static lv_cache_compare_res_t cache_node_cache_compare_cb(const lv_freetype_cache_node_t * lhs,
                                                           const lv_freetype_cache_node_t * rhs)
 {
diff --git a/src/libs/freetype/lv_freetype_glyph.c b/src/libs/freetype/lv_freetype_glyph.c
index 7ed217883..3b5a854fd 100644
--- a/src/libs/freetype/lv_freetype_glyph.c
+++ b/src/libs/freetype/lv_freetype_glyph.c
@@ -51,6 +51,7 @@ static lv_cache_compare_res_t freetype_glyph_compare_cb(const lv_freetype_glyph_
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 lv_cache_t * lv_freetype_create_glyph_cache(uint32_t cache_size)
 {
     lv_cache_ops_t ops = {
@@ -66,6 +67,7 @@ lv_cache_t * lv_freetype_create_glyph_cache(uint32_t cache_size)
     return glyph_cache;
 }
 
+LV_FUNC_SECTION
 void lv_freetype_set_cbs_glyph(lv_freetype_font_dsc_t * dsc)
 {
     LV_ASSERT_FREETYPE_FONT_DSC(dsc);
@@ -75,7 +77,7 @@ void lv_freetype_set_cbs_glyph(lv_freetype_font_dsc_t * dsc)
 /**********************
  *   STATIC FUNCTIONS
  **********************/
-
+__attribute__(( fptrgroup("lv_font_get_glyph_dsc") ))
 static bool freetype_get_glyph_dsc_cb(const lv_font_t * font, lv_font_glyph_dsc_t * g_dsc, uint32_t unicode_letter,
                                       uint32_t unicode_letter_next)
 {
@@ -123,7 +125,7 @@ static bool freetype_get_glyph_dsc_cb(const lv_font_t * font, lv_font_glyph_dsc_
 /*-----------------
  * Cache Callbacks
  *----------------*/
-
+__attribute__(( fptrgroup("lv_cache_create_cb") ))
 static bool freetype_glyph_create_cb(lv_freetype_glyph_cache_data_t * data, void * user_data)
 {
     lv_freetype_font_dsc_t * dsc = (lv_freetype_font_dsc_t *)user_data;
@@ -181,11 +183,13 @@ static bool freetype_glyph_create_cb(lv_freetype_glyph_cache_data_t * data, void
 
     return true;
 }
+__attribute__(( fptrgroup("lv_cache_free_cb") ))
 static void freetype_glyph_free_cb(lv_freetype_glyph_cache_data_t * data, void * user_data)
 {
     LV_UNUSED(data);
     LV_UNUSED(user_data);
 }
+__attribute__(( fptrgroup("lv_cache_compare_cb") ))
 static lv_cache_compare_res_t freetype_glyph_compare_cb(const lv_freetype_glyph_cache_data_t * lhs,
                                                         const lv_freetype_glyph_cache_data_t * rhs)
 {
diff --git a/src/libs/freetype/lv_freetype_image.c b/src/libs/freetype/lv_freetype_image.c
index ab7dad292..d3196c403 100755
--- a/src/libs/freetype/lv_freetype_image.c
+++ b/src/libs/freetype/lv_freetype_image.c
@@ -56,6 +56,7 @@ static void freetype_image_release_cb(const lv_font_t * font, lv_font_glyph_dsc_
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 lv_cache_t * lv_freetype_create_draw_data_image(uint32_t cache_size)
 {
     lv_cache_ops_t ops = {
@@ -71,6 +72,7 @@ lv_cache_t * lv_freetype_create_draw_data_image(uint32_t cache_size)
     return draw_data_cache;
 }
 
+LV_FUNC_SECTION
 void lv_freetype_set_cbs_image_font(lv_freetype_font_dsc_t * dsc)
 {
     LV_ASSERT_FREETYPE_FONT_DSC(dsc);
@@ -82,6 +84,7 @@ void lv_freetype_set_cbs_image_font(lv_freetype_font_dsc_t * dsc)
  *   STATIC FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 static const void * freetype_get_glyph_bitmap_cb(lv_font_glyph_dsc_t * g_dsc, lv_draw_buf_t * draw_buf)
 {
     LV_UNUSED(draw_buf);
@@ -106,6 +109,7 @@ static const void * freetype_get_glyph_bitmap_cb(lv_font_glyph_dsc_t * g_dsc, lv
     return cache_node->draw_buf;
 }
 
+LV_FUNC_SECTION
 static void freetype_image_release_cb(const lv_font_t * font, lv_font_glyph_dsc_t * g_dsc)
 {
     LV_ASSERT_NULL(font);
@@ -117,7 +121,7 @@ static void freetype_image_release_cb(const lv_font_t * font, lv_font_glyph_dsc_
 /*-----------------
  * Cache Callbacks
  *----------------*/
-
+__attribute__(( fptrgroup("lv_cache_create_cb") ))
 static bool freetype_image_create_cb(lv_freetype_image_cache_data_t * data, void * user_data)
 {
     lv_freetype_font_dsc_t * dsc = (lv_freetype_font_dsc_t *)user_data;
@@ -168,11 +172,13 @@ static bool freetype_image_create_cb(lv_freetype_image_cache_data_t * data, void
 
     return true;
 }
+__attribute__(( fptrgroup("lv_cache_free_cb") ))
 static void freetype_image_free_cb(lv_freetype_image_cache_data_t * data, void * user_data)
 {
     LV_UNUSED(user_data);
     lv_draw_buf_destroy(data->draw_buf);
 }
+__attribute__(( fptrgroup("lv_cache_compare_cb") ))
 static lv_cache_compare_res_t freetype_image_compare_cb(const lv_freetype_image_cache_data_t * lhs,
                                                         const lv_freetype_image_cache_data_t * rhs)
 {
diff --git a/src/libs/freetype/lv_freetype_outline.c b/src/libs/freetype/lv_freetype_outline.c
index 77d40fef3..9072d5b94 100755
--- a/src/libs/freetype/lv_freetype_outline.c
+++ b/src/libs/freetype/lv_freetype_outline.c
@@ -58,6 +58,7 @@ static lv_cache_compare_res_t freetype_glyph_outline_cmp_cb(const lv_freetype_ou
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 lv_cache_t * lv_freetype_create_draw_data_outline(uint32_t cache_size)
 {
     lv_cache_ops_t glyph_outline_cache_ops = {
@@ -74,6 +75,7 @@ lv_cache_t * lv_freetype_create_draw_data_outline(uint32_t cache_size)
     return draw_data_cache;
 }
 
+LV_FUNC_SECTION
 void lv_freetype_set_cbs_outline_font(lv_freetype_font_dsc_t * dsc)
 {
     LV_ASSERT_FREETYPE_FONT_DSC(dsc);
@@ -81,6 +83,7 @@ void lv_freetype_set_cbs_outline_font(lv_freetype_font_dsc_t * dsc)
     dsc->font.release_glyph = freetype_release_glyph_cb;
 }
 
+LV_FUNC_SECTION
 void lv_freetype_outline_add_event(lv_event_cb_t event_cb, lv_event_code_t filter, void * user_data)
 {
     LV_UNUSED(user_data);
@@ -90,6 +93,7 @@ void lv_freetype_outline_add_event(lv_event_cb_t event_cb, lv_event_code_t filte
     ctx->event_cb = event_cb;
 }
 
+LV_FUNC_SECTION
 uint32_t lv_freetype_outline_get_scale(const lv_font_t * font)
 {
     LV_ASSERT_NULL(font);
@@ -99,6 +103,7 @@ uint32_t lv_freetype_outline_get_scale(const lv_font_t * font)
     return FT_INT_TO_F26DOT6(dsc->size) / dsc->cache_node->ref_size;
 }
 
+LV_FUNC_SECTION
 bool lv_freetype_is_outline_font(const lv_font_t * font)
 {
     LV_ASSERT_NULL(font);
@@ -117,7 +122,7 @@ bool lv_freetype_is_outline_font(const lv_font_t * font)
 /*-------------------
  *   OUTLINE CACHE
  *------------------*/
-
+__attribute__(( fptrgroup("lv_cache_create_cb") ))
 static bool freetype_glyph_outline_create_cb(lv_freetype_outline_node_t * node, lv_freetype_font_dsc_t * dsc)
 {
     lv_freetype_outline_t outline;
@@ -140,6 +145,7 @@ static bool freetype_glyph_outline_create_cb(lv_freetype_outline_node_t * node,
     return true;
 }
 
+__attribute__(( fptrgroup("lv_cache_free_cb") ))
 static void freetype_glyph_outline_free_cb(lv_freetype_outline_node_t * node, lv_freetype_font_dsc_t * dsc)
 {
     LV_UNUSED(dsc);
@@ -149,6 +155,7 @@ static void freetype_glyph_outline_free_cb(lv_freetype_outline_node_t * node, lv
     outline_delete(ctx, outline);
 }
 
+__attribute__(( fptrgroup("lv_cache_compare_cb") ))
 static lv_cache_compare_res_t freetype_glyph_outline_cmp_cb(const lv_freetype_outline_node_t * node_a,
                                                             const lv_freetype_outline_node_t * node_b)
 {
@@ -158,6 +165,7 @@ static lv_cache_compare_res_t freetype_glyph_outline_cmp_cb(const lv_freetype_ou
     return node_a->glyph_index > node_b->glyph_index ? 1 : -1;
 }
 
+LV_FUNC_SECTION
 static const void * freetype_get_glyph_bitmap_cb(lv_font_glyph_dsc_t * g_dsc, lv_draw_buf_t * draw_buf)
 {
     LV_UNUSED(draw_buf);
@@ -176,6 +184,7 @@ static const void * freetype_get_glyph_bitmap_cb(lv_font_glyph_dsc_t * g_dsc, lv
     return node ? node->outline : NULL;
 }
 
+LV_FUNC_SECTION
 static void freetype_release_glyph_cb(const lv_font_t * font, lv_font_glyph_dsc_t * g_dsc)
 {
     LV_ASSERT_NULL(font);
@@ -188,6 +197,7 @@ static void freetype_release_glyph_cb(const lv_font_t * font, lv_font_glyph_dsc_
     g_dsc->entry = NULL;
 }
 
+LV_FUNC_SECTION
 static lv_cache_entry_t * lv_freetype_outline_lookup(lv_freetype_font_dsc_t * dsc, FT_UInt glyph_index)
 {
     lv_freetype_cache_node_t * cache_node = dsc->cache_node;
@@ -203,12 +213,14 @@ static lv_cache_entry_t * lv_freetype_outline_lookup(lv_freetype_font_dsc_t * ds
     return entry;
 }
 
+LV_FUNC_SECTION
 static void ft_vector_to_lv_vector(lv_freetype_outline_vector_t * dest, const FT_Vector * src)
 {
     dest->x = src ? src->x : 0;
     dest->y = src ? src->y : 0;
 }
 
+LV_FUNC_SECTION
 static lv_result_t outline_send_event(lv_freetype_context_t * ctx, lv_event_code_t code,
                                       lv_freetype_outline_event_param_t * param)
 {
@@ -228,6 +240,7 @@ static lv_result_t outline_send_event(lv_freetype_context_t * ctx, lv_event_code
     return LV_RESULT_OK;
 }
 
+LV_FUNC_SECTION
 static lv_result_t outline_push_point(
     lv_freetype_outline_t outline,
     lv_freetype_outline_type_t type,
@@ -248,6 +261,7 @@ static lv_result_t outline_push_point(
     return outline_send_event(ctx, LV_EVENT_INSERT, &param);
 }
 
+LV_FUNC_SECTION
 static int outline_move_to_cb(
     const FT_Vector * to,
     void * user)
@@ -257,6 +271,7 @@ static int outline_move_to_cb(
     return FT_Err_Ok;
 }
 
+LV_FUNC_SECTION
 static int outline_line_to_cb(
     const FT_Vector * to,
     void * user)
@@ -266,6 +281,7 @@ static int outline_line_to_cb(
     return FT_Err_Ok;
 }
 
+LV_FUNC_SECTION
 static int outline_conic_to_cb(
     const FT_Vector * control,
     const FT_Vector * to,
@@ -276,6 +292,7 @@ static int outline_conic_to_cb(
     return FT_Err_Ok;
 }
 
+LV_FUNC_SECTION
 static int outline_cubic_to_cb(
     const FT_Vector * control1,
     const FT_Vector * control2,
@@ -287,6 +304,7 @@ static int outline_cubic_to_cb(
     return FT_Err_Ok;
 }
 
+LV_FUNC_SECTION
 static lv_freetype_outline_t outline_create(
     lv_freetype_context_t * ctx,
     FT_Face face,
@@ -361,6 +379,7 @@ static lv_freetype_outline_t outline_create(
     return outline;
 }
 
+LV_FUNC_SECTION
 static lv_result_t outline_delete(lv_freetype_context_t * ctx, lv_freetype_outline_t outline)
 {
     lv_freetype_outline_event_param_t param;
diff --git a/src/libs/freetype/lv_ftsystem.c b/src/libs/freetype/lv_ftsystem.c
index ee0e836b6..72d6515f1 100644
--- a/src/libs/freetype/lv_ftsystem.c
+++ b/src/libs/freetype/lv_ftsystem.c
@@ -87,6 +87,7 @@ ft_free(FT_Memory  memory,
 /* documentation is in ftstream.h */
 
 FT_BASE_DEF(FT_Error)
+LV_FUNC_SECTION
 FT_Stream_Open(FT_Stream    stream,
                const char * filepathname)
 {
@@ -151,6 +152,7 @@ FT_Stream_Open(FT_Stream    stream,
 /* documentation is in ftobjs.h */
 
 FT_BASE_DEF(FT_Memory)
+LV_FUNC_SECTION
 FT_New_Memory(void)
 {
     FT_Memory  memory;
@@ -172,6 +174,7 @@ FT_New_Memory(void)
 /* documentation is in ftobjs.h */
 
 FT_BASE_DEF(void)
+LV_FUNC_SECTION
 FT_Done_Memory(FT_Memory  memory)
 {
 #ifdef FT_DEBUG_MEMORY
@@ -191,6 +194,7 @@ FT_Done_Memory(FT_Memory  memory)
  * @return The address of newly allocated block.
  */
 FT_CALLBACK_DEF(void *)
+LV_FUNC_SECTION
 ft_alloc(FT_Memory  memory,
          long       size)
 {
@@ -208,6 +212,7 @@ ft_alloc(FT_Memory  memory,
  * @return The address of the reallocated memory block.
  */
 FT_CALLBACK_DEF(void *)
+LV_FUNC_SECTION
 ft_realloc(FT_Memory  memory,
            long       cur_size,
            long       new_size,
@@ -225,6 +230,7 @@ ft_realloc(FT_Memory  memory,
  * @param block The address of block in memory to be freed.
  */
 FT_CALLBACK_DEF(void)
+LV_FUNC_SECTION
 ft_free(FT_Memory  memory,
         void   *   block)
 {
@@ -240,6 +246,7 @@ ft_free(FT_Memory  memory,
  * @param stream A pointer to the stream object.
  */
 FT_CALLBACK_DEF(void)
+LV_FUNC_SECTION
 ft_lv_fs_stream_close(FT_Stream  stream)
 {
     lv_fs_file_t * file_p = STREAM_FILE(stream);
@@ -262,6 +269,7 @@ ft_lv_fs_stream_close(FT_Stream  stream)
  *         indicates an error.
  */
 FT_CALLBACK_DEF(unsigned long)
+LV_FUNC_SECTION
 ft_lv_fs_stream_io(FT_Stream       stream,
                    unsigned long   offset,
                    unsigned char * buffer,
diff --git a/src/libs/fsdrv/lv_fs_fatfs.c b/src/libs/fsdrv/lv_fs_fatfs.c
index 79c62a367..5ef3f15ca 100644
--- a/src/libs/fsdrv/lv_fs_fatfs.c
+++ b/src/libs/fsdrv/lv_fs_fatfs.c
@@ -64,6 +64,7 @@ static lv_fs_res_t fs_dir_close(lv_fs_drv_t * drv, void * dir_p);
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 void lv_fs_fatfs_init(void)
 {
     /*----------------------------------------------------
@@ -101,6 +102,7 @@ void lv_fs_fatfs_init(void)
  **********************/
 
 /*Initialize your Storage device and File system.*/
+LV_FUNC_SECTION
 static void fs_init(void)
 {
     /*Initialize the SD card and FatFS itself.
@@ -114,6 +116,7 @@ static void fs_init(void)
  * @param mode  read: FS_MODE_RD, write: FS_MODE_WR, both: FS_MODE_RD | FS_MODE_WR
  * @return pointer to FIL struct or NULL in case of fail
  */
+LV_FUNC_SECTION
 static void * fs_open(lv_fs_drv_t * drv, const char * path, lv_fs_mode_t mode)
 {
     LV_UNUSED(drv);
@@ -143,6 +146,7 @@ static void * fs_open(lv_fs_drv_t * drv, const char * path, lv_fs_mode_t mode)
  * @return LV_FS_RES_OK: no error, the file is read
  *         any error from lv_fs_res_t enum
  */
+LV_FUNC_SECTION
 static lv_fs_res_t fs_close(lv_fs_drv_t * drv, void * file_p)
 {
     LV_UNUSED(drv);
@@ -161,6 +165,7 @@ static lv_fs_res_t fs_close(lv_fs_drv_t * drv, void * file_p)
  * @return LV_FS_RES_OK: no error, the file is read
  *         any error from lv_fs_res_t enum
  */
+LV_FUNC_SECTION
 static lv_fs_res_t fs_read(lv_fs_drv_t * drv, void * file_p, void * buf, uint32_t btr, uint32_t * br)
 {
     LV_UNUSED(drv);
@@ -178,6 +183,7 @@ static lv_fs_res_t fs_read(lv_fs_drv_t * drv, void * file_p, void * buf, uint32_
  * @param bw        the number of real written bytes (Bytes Written). NULL if unused.
  * @return LV_FS_RES_OK or any error from lv_fs_res_t enum
  */
+LV_FUNC_SECTION
 static lv_fs_res_t fs_write(lv_fs_drv_t * drv, void * file_p, const void * buf, uint32_t btw, uint32_t * bw)
 {
     LV_UNUSED(drv);
@@ -195,6 +201,7 @@ static lv_fs_res_t fs_write(lv_fs_drv_t * drv, void * file_p, const void * buf,
  * @return LV_FS_RES_OK: no error, the file is read
  *         any error from lv_fs_res_t enum
  */
+LV_FUNC_SECTION
 static lv_fs_res_t fs_seek(lv_fs_drv_t * drv, void * file_p, uint32_t pos, lv_fs_whence_t whence)
 {
     LV_UNUSED(drv);
@@ -222,6 +229,7 @@ static lv_fs_res_t fs_seek(lv_fs_drv_t * drv, void * file_p, uint32_t pos, lv_fs
  * @return LV_FS_RES_OK: no error, the file is read
  *         any error from lv_fs_res_t enum
  */
+LV_FUNC_SECTION
 static lv_fs_res_t fs_tell(lv_fs_drv_t * drv, void * file_p, uint32_t * pos_p)
 {
     LV_UNUSED(drv);
@@ -235,6 +243,7 @@ static lv_fs_res_t fs_tell(lv_fs_drv_t * drv, void * file_p, uint32_t * pos_p)
  * @param path  path to a directory
  * @return pointer to an initialized 'DIR' variable
  */
+LV_FUNC_SECTION
 static void * fs_dir_open(lv_fs_drv_t * drv, const char * path)
 {
     LV_UNUSED(drv);
@@ -258,6 +267,7 @@ static void * fs_dir_open(lv_fs_drv_t * drv, const char * path)
  * @param fn_len    length of the buffer to store the filename
  * @return LV_FS_RES_OK or any error from lv_fs_res_t enum
  */
+LV_FUNC_SECTION
 static lv_fs_res_t fs_dir_read(lv_fs_drv_t * drv, void * dir_p, char * fn, uint32_t fn_len)
 {
     LV_UNUSED(drv);
@@ -289,6 +299,7 @@ static lv_fs_res_t fs_dir_read(lv_fs_drv_t * drv, void * dir_p, char * fn, uint3
  * @param dir_p pointer to an initialized 'DIR' variable
  * @return LV_FS_RES_OK or any error from lv_fs_res_t enum
  */
+LV_FUNC_SECTION
 static lv_fs_res_t fs_dir_close(lv_fs_drv_t * drv, void * dir_p)
 {
     LV_UNUSED(drv);
diff --git a/src/libs/fsdrv/lv_fs_littlefs.c b/src/libs/fsdrv/lv_fs_littlefs.c
index 490c6feeb..fbb0bf459 100644
--- a/src/libs/fsdrv/lv_fs_littlefs.c
+++ b/src/libs/fsdrv/lv_fs_littlefs.c
@@ -38,6 +38,7 @@ static void * fs_dir_open(lv_fs_drv_t * drv, const char * path);
 static lv_fs_res_t fs_dir_close(lv_fs_drv_t * drv, void * dir_p);
 static lv_fs_res_t fs_dir_read(lv_fs_drv_t * drv, void * dir_p, char * fn, uint32_t fn_len);
 
+LV_FUNC_SECTION
 void lv_littlefs_set_handler(lfs_t * lfs)
 {
     lv_fs_drv_t * drv = lv_fs_get_drv(LV_FS_LITTLEFS_LETTER);
@@ -47,6 +48,7 @@ void lv_littlefs_set_handler(lfs_t * lfs)
 /**
  * Register a driver for the LittleFS File System interface
  */
+LV_FUNC_SECTION
 void lv_fs_littlefs_init(void)
 {
     lv_fs_drv_t * fs_drv = &(LV_GLOBAL_DEFAULT()->littlefs_fs_drv);
@@ -78,6 +80,7 @@ void lv_fs_littlefs_init(void)
  * @param mode      read: FS_MODE_RD, write: FS_MODE_WR, both: FS_MODE_RD | FS_MODE_WR
  * @return          a file descriptor or NULL on error
  */
+LV_FUNC_SECTION
 static void * fs_open(lv_fs_drv_t * drv, const char * path, lv_fs_mode_t mode)
 {
     int flags = 0;
@@ -106,6 +109,7 @@ static void * fs_open(lv_fs_drv_t * drv, const char * path, lv_fs_mode_t mode)
  * @param file_p    pointer to a file_t variable. (opened with fs_open)
  * @return          LV_FS_RES_OK: no error or  any error from @lv_fs_res_t enum
  */
+LV_FUNC_SECTION
 static lv_fs_res_t fs_close(lv_fs_drv_t * drv, void * file_p)
 {
     LittleFile * lf = file_p;
@@ -126,6 +130,7 @@ static lv_fs_res_t fs_close(lv_fs_drv_t * drv, void * file_p)
  * @param br        the real number of read bytes (Byte Read)
  * @return          LV_FS_RES_OK: no error or any error from @lv_fs_res_t enum
  */
+LV_FUNC_SECTION
 static lv_fs_res_t fs_read(lv_fs_drv_t * drv, void * file_p, void * buf, uint32_t btr, uint32_t * br)
 {
     LittleFile * lf = file_p;
@@ -145,6 +150,7 @@ static lv_fs_res_t fs_read(lv_fs_drv_t * drv, void * file_p, void * buf, uint32_
  * @param bw        the number of real written bytes (Bytes Written)
  * @return          LV_FS_RES_OK: no error or  any error from @lv_fs_res_t enum
  */
+LV_FUNC_SECTION
 static lv_fs_res_t fs_write(lv_fs_drv_t * drv, void * file_p, const void * buf, uint32_t btw, uint32_t * bw)
 {
     LittleFile * lf = file_p;
@@ -163,6 +169,7 @@ static lv_fs_res_t fs_write(lv_fs_drv_t * drv, void * file_p, const void * buf,
  * @param whence    tells from where to interpret the `pos`. See @lv_fs_whence_t
  * @return          LV_FS_RES_OK: no error or any error from @lv_fs_res_t enum
  */
+LV_FUNC_SECTION
 static lv_fs_res_t fs_seek(lv_fs_drv_t * drv, void * file_p, uint32_t pos, lv_fs_whence_t whence)
 {
     int mode = 0;
@@ -188,6 +195,7 @@ static lv_fs_res_t fs_seek(lv_fs_drv_t * drv, void * file_p, uint32_t pos, lv_fs
  * @param pos_p     pointer to store the result
  * @return          LV_FS_RES_OK: no error or any error from @lv_fs_res_t enum
  */
+LV_FUNC_SECTION
 static lv_fs_res_t fs_tell(lv_fs_drv_t * drv, void * file_p, uint32_t * pos_p)
 {
     LittleFile * lf = file_p;
@@ -204,6 +212,7 @@ static lv_fs_res_t fs_tell(lv_fs_drv_t * drv, void * file_p, uint32_t * pos_p)
  * @param path      path to the directory beginning with the driver letter (e.g. S:/folder)
  * @return          a directory descriptor or NULL on error
  */
+LV_FUNC_SECTION
 static void * fs_dir_open(lv_fs_drv_t * drv, const char * path)
 {
     LittleDirectory * ld = lv_malloc(sizeof(LittleDirectory));
@@ -225,6 +234,7 @@ static void * fs_dir_open(lv_fs_drv_t * drv, const char * path)
  * @param dir_p    pointer to a dir_p variable. (opened with fs_dir_open)
  * @return         LV_FS_RES_OK: no error or any error from @lv_fs_res_t enum
  */
+LV_FUNC_SECTION
 static lv_fs_res_t fs_dir_close(lv_fs_drv_t * drv, void * dir_p)
 {
     LittleDirectory * ld = dir_p;
@@ -246,6 +256,7 @@ static lv_fs_res_t fs_dir_close(lv_fs_drv_t * drv, void * dir_p)
  * @param fn_len   length of the buffer to store the filename
  * @return         LV_FS_RES_OK: no error or any error from @lv_fs_res_t enum
  */
+LV_FUNC_SECTION
 static lv_fs_res_t fs_dir_read(lv_fs_drv_t * drv, void * dir_p, char * fn, uint32_t fn_len)
 {
     if(fn_len == 0) return LV_FS_RES_INV_PARAM;
diff --git a/src/libs/fsdrv/lv_fs_memfs.c b/src/libs/fsdrv/lv_fs_memfs.c
index c207c76fd..4e3ecf452 100644
--- a/src/libs/fsdrv/lv_fs_memfs.c
+++ b/src/libs/fsdrv/lv_fs_memfs.c
@@ -91,6 +91,7 @@ static lv_fs_drv_t fs_drv; /*A driver descriptor*/
 /**
  * Register a driver for the File system interface
  */
+LV_FUNC_SECTION
 void lv_fs_memfs_init(void)
 {
     /*---------------------------------------------------
@@ -128,6 +129,7 @@ void lv_fs_memfs_init(void)
  * @param mode  read: FS_MODE_RD (currently only reading from the buffer is supported)
  * @return pointer to FIL struct or NULL in case of fail
  */
+LV_FUNC_SECTION
 static void * fs_open(lv_fs_drv_t * drv, const char * path, lv_fs_mode_t mode)
 {
     LV_UNUSED(drv);
@@ -142,6 +144,7 @@ static void * fs_open(lv_fs_drv_t * drv, const char * path, lv_fs_mode_t mode)
  * @return LV_FS_RES_OK: no error, the file is read
  *         any error from lv_fs_res_t enum
  */
+LV_FUNC_SECTION
 static lv_fs_res_t fs_close(lv_fs_drv_t * drv, void * file_p)
 {
     LV_UNUSED(drv);
@@ -159,6 +162,7 @@ static lv_fs_res_t fs_close(lv_fs_drv_t * drv, void * file_p)
  * @return LV_FS_RES_OK: no error, the file is read
  *         any error from lv_fs_res_t enum
  */
+LV_FUNC_SECTION
 static lv_fs_res_t fs_read(lv_fs_drv_t * drv, void * file_p, void * buf, uint32_t btr, uint32_t * br)
 {
     LV_UNUSED(drv);
@@ -177,6 +181,7 @@ static lv_fs_res_t fs_read(lv_fs_drv_t * drv, void * file_p, void * buf, uint32_
  * @return LV_FS_RES_OK: no error, the file is read
  *         any error from lv_fs_res_t enum
  */
+LV_FUNC_SECTION
 static lv_fs_res_t fs_seek(lv_fs_drv_t * drv, void * file_p, uint32_t pos, lv_fs_whence_t whence)
 {
     /* NOTE: this function is only called to determine the end of the buffer when LV_FS_SEEK_END was given to lv_fs_seek() */
@@ -211,6 +216,7 @@ static lv_fs_res_t fs_seek(lv_fs_drv_t * drv, void * file_p, uint32_t pos, lv_fs
  * @return LV_FS_RES_OK: no error, the file is read
  *         any error from lv_fs_res_t enum
  */
+LV_FUNC_SECTION
 static lv_fs_res_t fs_tell(lv_fs_drv_t * drv, void * file_p, uint32_t * pos_p)
 {
     LV_UNUSED(drv);
diff --git a/src/libs/fsdrv/lv_fs_posix.c b/src/libs/fsdrv/lv_fs_posix.c
index f1e66fd23..f86005ae1 100644
--- a/src/libs/fsdrv/lv_fs_posix.c
+++ b/src/libs/fsdrv/lv_fs_posix.c
@@ -73,6 +73,7 @@ static lv_fs_res_t fs_dir_close(lv_fs_drv_t * drv, void * dir_p);
 /**
  * Register a driver for the File system interface
  */
+LV_FUNC_SECTION
 void lv_fs_posix_init(void)
 {
     /*---------------------------------------------------
@@ -111,6 +112,7 @@ void lv_fs_posix_init(void)
  * @param mode  read: FS_MODE_RD, write: FS_MODE_WR, both: FS_MODE_RD | FS_MODE_WR
  * @return a file handle or -1 in case of fail
  */
+LV_FUNC_SECTION
 static void * fs_open(lv_fs_drv_t * drv, const char * path, lv_fs_mode_t mode)
 {
     LV_UNUSED(drv);
@@ -140,6 +142,7 @@ static void * fs_open(lv_fs_drv_t * drv, const char * path, lv_fs_mode_t mode)
  * @return LV_FS_RES_OK: no error, the file is read
  *         any error from lv_fs_res_t enum
  */
+LV_FUNC_SECTION
 static lv_fs_res_t fs_close(lv_fs_drv_t * drv, void * file_p)
 {
     LV_UNUSED(drv);
@@ -164,6 +167,7 @@ static lv_fs_res_t fs_close(lv_fs_drv_t * drv, void * file_p)
  * @return LV_FS_RES_OK: no error, the file is read
  *         any error from lv_fs_res_t enum
  */
+LV_FUNC_SECTION
 static lv_fs_res_t fs_read(lv_fs_drv_t * drv, void * file_p, void * buf, uint32_t btr, uint32_t * br)
 {
     LV_UNUSED(drv);
@@ -188,6 +192,7 @@ static lv_fs_res_t fs_read(lv_fs_drv_t * drv, void * file_p, void * buf, uint32_
  * @param bw        the number of real written bytes (Bytes Written). NULL if unused.
  * @return LV_FS_RES_OK or any error from lv_fs_res_t enum
  */
+LV_FUNC_SECTION
 static lv_fs_res_t fs_write(lv_fs_drv_t * drv, void * file_p, const void * buf, uint32_t btw, uint32_t * bw)
 {
     LV_UNUSED(drv);
@@ -211,6 +216,7 @@ static lv_fs_res_t fs_write(lv_fs_drv_t * drv, void * file_p, const void * buf,
  * @return LV_FS_RES_OK: no error, the file is read
  *         any error from lv_fs_res_t enum
  */
+LV_FUNC_SECTION
 static lv_fs_res_t fs_seek(lv_fs_drv_t * drv, void * file_p, uint32_t pos, lv_fs_whence_t whence)
 {
     LV_UNUSED(drv);
@@ -247,6 +253,7 @@ static lv_fs_res_t fs_seek(lv_fs_drv_t * drv, void * file_p, uint32_t pos, lv_fs
  * @return LV_FS_RES_OK: no error, the file is read
  *         any error from lv_fs_res_t enum
  */
+LV_FUNC_SECTION
 static lv_fs_res_t fs_tell(lv_fs_drv_t * drv, void * file_p, uint32_t * pos_p)
 {
     LV_UNUSED(drv);
@@ -268,6 +275,7 @@ static lv_fs_res_t fs_tell(lv_fs_drv_t * drv, void * file_p, uint32_t * pos_p)
  * @param path  path to a directory
  * @return pointer to an initialized 'DIR' or 'HANDLE' variable
  */
+LV_FUNC_SECTION
 static void * fs_dir_open(lv_fs_drv_t * drv, const char * path)
 {
     LV_UNUSED(drv);
@@ -294,6 +302,7 @@ static void * fs_dir_open(lv_fs_drv_t * drv, const char * path)
  * @param fn_len    length of the buffer to store the filename
  * @return LV_FS_RES_OK or any error from lv_fs_res_t enum
  */
+LV_FUNC_SECTION
 static lv_fs_res_t fs_dir_read(lv_fs_drv_t * drv, void * dir_p, char * fn, uint32_t fn_len)
 {
     LV_UNUSED(drv);
@@ -320,6 +329,7 @@ static lv_fs_res_t fs_dir_read(lv_fs_drv_t * drv, void * dir_p, char * fn, uint3
  * @param dir_p pointer to an initialized 'DIR' or 'HANDLE' variable
  * @return LV_FS_RES_OK or any error from lv_fs_res_t enum
  */
+LV_FUNC_SECTION
 static lv_fs_res_t fs_dir_close(lv_fs_drv_t * drv, void * dir_p)
 {
     LV_UNUSED(drv);
diff --git a/src/libs/fsdrv/lv_fs_stdio.c b/src/libs/fsdrv/lv_fs_stdio.c
index a6c901e15..d11726343 100644
--- a/src/libs/fsdrv/lv_fs_stdio.c
+++ b/src/libs/fsdrv/lv_fs_stdio.c
@@ -76,6 +76,7 @@ static lv_fs_res_t fs_dir_close(lv_fs_drv_t * drv, void * dir_p);
 /**
  * Register a driver for the File system interface
  */
+LV_FUNC_SECTION
 void lv_fs_stdio_init(void)
 {
     /*---------------------------------------------------
@@ -114,6 +115,7 @@ void lv_fs_stdio_init(void)
  * @param mode  read: FS_MODE_RD, write: FS_MODE_WR, both: FS_MODE_RD | FS_MODE_WR
  * @return pointer to FIL struct or NULL in case of fail
  */
+LV_FUNC_SECTION
 static void * fs_open(lv_fs_drv_t * drv, const char * path, lv_fs_mode_t mode)
 {
     LV_UNUSED(drv);
@@ -139,6 +141,7 @@ static void * fs_open(lv_fs_drv_t * drv, const char * path, lv_fs_mode_t mode)
  * @return LV_FS_RES_OK: no error, the file is read
  *         any error from lv_fs_res_t enum
  */
+LV_FUNC_SECTION
 static lv_fs_res_t fs_close(lv_fs_drv_t * drv, void * file_p)
 {
     LV_UNUSED(drv);
@@ -156,6 +159,7 @@ static lv_fs_res_t fs_close(lv_fs_drv_t * drv, void * file_p)
  * @return LV_FS_RES_OK: no error, the file is read
  *         any error from lv_fs_res_t enum
  */
+LV_FUNC_SECTION
 static lv_fs_res_t fs_read(lv_fs_drv_t * drv, void * file_p, void * buf, uint32_t btr, uint32_t * br)
 {
     LV_UNUSED(drv);
@@ -172,6 +176,7 @@ static lv_fs_res_t fs_read(lv_fs_drv_t * drv, void * file_p, void * buf, uint32_
  * @param bw        the number of real written bytes (Bytes Written). NULL if unused.
  * @return LV_FS_RES_OK or any error from lv_fs_res_t enum
  */
+LV_FUNC_SECTION
 static lv_fs_res_t fs_write(lv_fs_drv_t * drv, void * file_p, const void * buf, uint32_t btw, uint32_t * bw)
 {
     LV_UNUSED(drv);
@@ -187,6 +192,7 @@ static lv_fs_res_t fs_write(lv_fs_drv_t * drv, void * file_p, const void * buf,
  * @return LV_FS_RES_OK: no error, the file is read
  *         any error from lv_fs_res_t enum
  */
+LV_FUNC_SECTION
 static lv_fs_res_t fs_seek(lv_fs_drv_t * drv, void * file_p, uint32_t pos, lv_fs_whence_t whence)
 {
     LV_UNUSED(drv);
@@ -217,6 +223,7 @@ static lv_fs_res_t fs_seek(lv_fs_drv_t * drv, void * file_p, uint32_t pos, lv_fs
  * @return LV_FS_RES_OK: no error, the file is read
  *         any error from lv_fs_res_t enum
  */
+LV_FUNC_SECTION
 static lv_fs_res_t fs_tell(lv_fs_drv_t * drv, void * file_p, uint32_t * pos_p)
 {
     LV_UNUSED(drv);
@@ -230,6 +237,7 @@ static lv_fs_res_t fs_tell(lv_fs_drv_t * drv, void * file_p, uint32_t * pos_p)
  * @param path  path to a directory
  * @return pointer to an initialized 'DIR' or 'HANDLE' variable
  */
+LV_FUNC_SECTION
 static void * fs_dir_open(lv_fs_drv_t * drv, const char * path)
 {
     LV_UNUSED(drv);
@@ -286,6 +294,7 @@ static void * fs_dir_open(lv_fs_drv_t * drv, const char * path)
  * @param fn_len    length of the buffer to store the filename
  * @return LV_FS_RES_OK or any error from lv_fs_res_t enum
  */
+LV_FUNC_SECTION
 static lv_fs_res_t fs_dir_read(lv_fs_drv_t * drv, void * dir_p, char * fn, uint32_t fn_len)
 {
     LV_UNUSED(drv);
@@ -337,6 +346,7 @@ static lv_fs_res_t fs_dir_read(lv_fs_drv_t * drv, void * dir_p, char * fn, uint3
  * @param dir_p pointer to an initialized 'DIR' or 'HANDLE' variable
  * @return LV_FS_RES_OK or any error from lv_fs_res_t enum
  */
+LV_FUNC_SECTION
 static lv_fs_res_t fs_dir_close(lv_fs_drv_t * drv, void * dir_p)
 {
     LV_UNUSED(drv);
diff --git a/src/libs/fsdrv/lv_fs_win32.c b/src/libs/fsdrv/lv_fs_win32.c
index d5fb36487..afcb065ed 100644
--- a/src/libs/fsdrv/lv_fs_win32.c
+++ b/src/libs/fsdrv/lv_fs_win32.c
@@ -72,6 +72,7 @@ static lv_fs_res_t fs_dir_close(lv_fs_drv_t * drv, void * dir_p);
 /**
  * Register a driver for the File system interface
  */
+LV_FUNC_SECTION
 void lv_fs_win32_init(void)
 {
     /*---------------------------------------------------
@@ -109,6 +110,7 @@ void lv_fs_win32_init(void)
  * @param name file or dir name
  * @return true if the name is dots name
  */
+LV_FUNC_SECTION
 static bool is_dots_name(const char * name)
 {
     return name[0] == '.' && (!name[1] || (name[1] == '.' && !name[2]));
@@ -120,6 +122,7 @@ static bool is_dots_name(const char * name)
  * @return LV_FS_RES_OK: no error, the file is read
  *         any error from lv_fs_res_t enum
  */
+LV_FUNC_SECTION
 static lv_fs_res_t fs_error_from_win32(DWORD error)
 {
     lv_fs_res_t res;
@@ -216,6 +219,7 @@ static lv_fs_res_t fs_error_from_win32(DWORD error)
  * @param mode  read: FS_MODE_RD, write: FS_MODE_WR, both: FS_MODE_RD | FS_MODE_WR
  * @return pointer to FIL struct or NULL in case of fail
  */
+LV_FUNC_SECTION
 static void * fs_open(lv_fs_drv_t * drv, const char * path, lv_fs_mode_t mode)
 {
     LV_UNUSED(drv);
@@ -252,6 +256,7 @@ static void * fs_open(lv_fs_drv_t * drv, const char * path, lv_fs_mode_t mode)
  * @return LV_FS_RES_OK: no error, the file is read
  *         any error from lv_fs_res_t enum
  */
+LV_FUNC_SECTION
 static lv_fs_res_t fs_close(lv_fs_drv_t * drv, void * file_p)
 {
     LV_UNUSED(drv);
@@ -270,6 +275,7 @@ static lv_fs_res_t fs_close(lv_fs_drv_t * drv, void * file_p)
  * @return LV_FS_RES_OK: no error, the file is read
  *         any error from lv_fs_res_t enum
  */
+LV_FUNC_SECTION
 static lv_fs_res_t fs_read(lv_fs_drv_t * drv, void * file_p, void * buf, uint32_t btr, uint32_t * br)
 {
     LV_UNUSED(drv);
@@ -287,6 +293,7 @@ static lv_fs_res_t fs_read(lv_fs_drv_t * drv, void * file_p, void * buf, uint32_
  * @param bw        the number of real written bytes (Bytes Written). NULL if unused.
  * @return LV_FS_RES_OK or any error from lv_fs_res_t enum
  */
+LV_FUNC_SECTION
 static lv_fs_res_t fs_write(lv_fs_drv_t * drv, void * file_p, const void * buf, uint32_t btw, uint32_t * bw)
 {
     LV_UNUSED(drv);
@@ -303,6 +310,7 @@ static lv_fs_res_t fs_write(lv_fs_drv_t * drv, void * file_p, const void * buf,
  * @return LV_FS_RES_OK: no error, the file is read
  *         any error from lv_fs_res_t enum
  */
+LV_FUNC_SECTION
 static lv_fs_res_t fs_seek(lv_fs_drv_t * drv, void * file_p, uint32_t pos, lv_fs_whence_t whence)
 {
     LV_UNUSED(drv);
@@ -333,6 +341,7 @@ static lv_fs_res_t fs_seek(lv_fs_drv_t * drv, void * file_p, uint32_t pos, lv_fs
  * @return LV_FS_RES_OK: no error, the file is read
  *         any error from lv_fs_res_t enum
  */
+LV_FUNC_SECTION
 static lv_fs_res_t fs_tell(lv_fs_drv_t * drv, void * file_p, uint32_t * pos_p)
 {
     LV_UNUSED(drv);
@@ -370,6 +379,7 @@ static lv_fs_res_t fs_tell(lv_fs_drv_t * drv, void * file_p, uint32_t * pos_p)
  * @param path  path to a directory
  * @return pointer to an initialized 'DIR' or 'HANDLE' variable
  */
+LV_FUNC_SECTION
 static void * fs_dir_open(lv_fs_drv_t * drv, const char * path)
 {
     LV_UNUSED(drv);
@@ -423,6 +433,7 @@ static void * fs_dir_open(lv_fs_drv_t * drv, const char * path)
  * @param fn_len    length of the buffer to store the filename
  * @return LV_FS_RES_OK or any error from lv_fs_res_t enum
  */
+LV_FUNC_SECTION
 static lv_fs_res_t fs_dir_read(lv_fs_drv_t * drv, void * dir_p, char * fn, uint32_t fn_len)
 {
     LV_UNUSED(drv);
@@ -463,6 +474,7 @@ static lv_fs_res_t fs_dir_read(lv_fs_drv_t * drv, void * dir_p, char * fn, uint3
  * @param dir_p pointer to an initialized 'DIR' or 'HANDLE' variable
  * @return LV_FS_RES_OK or any error from lv_fs_res_t enum
  */
+LV_FUNC_SECTION
 static lv_fs_res_t fs_dir_close(lv_fs_drv_t * drv, void * dir_p)
 {
     LV_UNUSED(drv);
diff --git a/src/libs/gif/gifdec.c b/src/libs/gif/gifdec.c
index 3057e0332..5cd01a06b 100644
--- a/src/libs/gif/gifdec.c
+++ b/src/libs/gif/gifdec.c
@@ -40,6 +40,7 @@ static void f_gif_close(gd_GIF * gif);
 #endif
 
 static uint16_t
+LV_FUNC_SECTION
 read_num(gd_GIF * gif)
 {
     uint8_t bytes[2];
@@ -49,6 +50,7 @@ read_num(gd_GIF * gif)
 }
 
 gd_GIF *
+LV_FUNC_SECTION
 gd_open_gif_file(const char * fname)
 {
     gd_GIF gif_base;
@@ -61,6 +63,7 @@ gd_open_gif_file(const char * fname)
 }
 
 gd_GIF *
+LV_FUNC_SECTION
 gd_open_gif_data(const void * data)
 {
     gd_GIF gif_base;
@@ -72,6 +75,7 @@ gd_open_gif_data(const void * data)
     return gif_open(&gif_base);
 }
 
+LV_FUNC_SECTION
 static gd_GIF * gif_open(gd_GIF * gif_base)
 {
     uint8_t sigver[3];
@@ -170,6 +174,7 @@ ok:
 }
 
 static void
+LV_FUNC_SECTION
 discard_sub_blocks(gd_GIF * gif)
 {
     uint8_t size;
@@ -181,6 +186,7 @@ discard_sub_blocks(gd_GIF * gif)
 }
 
 static void
+LV_FUNC_SECTION
 read_plain_text_ext(gd_GIF * gif)
 {
     if(gif->plain_text) {
@@ -209,6 +215,7 @@ read_plain_text_ext(gd_GIF * gif)
 }
 
 static void
+LV_FUNC_SECTION
 read_graphic_control_ext(gd_GIF * gif)
 {
     uint8_t rdit;
@@ -226,6 +233,7 @@ read_graphic_control_ext(gd_GIF * gif)
 }
 
 static void
+LV_FUNC_SECTION
 read_comment_ext(gd_GIF * gif)
 {
     if(gif->comment) {
@@ -238,6 +246,7 @@ read_comment_ext(gd_GIF * gif)
 }
 
 static void
+LV_FUNC_SECTION
 read_application_ext(gd_GIF * gif)
 {
     char app_id[8];
@@ -277,6 +286,7 @@ read_application_ext(gd_GIF * gif)
 }
 
 static void
+LV_FUNC_SECTION
 read_ext(gd_GIF * gif)
 {
     uint8_t label;
@@ -301,6 +311,7 @@ read_ext(gd_GIF * gif)
 }
 
 static uint16_t
+LV_FUNC_SECTION
 get_key(gd_GIF *gif, int key_size, uint8_t *sub_len, uint8_t *shift, uint8_t *byte)
 {
     int bits_read;
@@ -333,6 +344,7 @@ get_key(gd_GIF *gif, int key_size, uint8_t *sub_len, uint8_t *shift, uint8_t *by
 /* Decompress image pixels.
  * Return 0 on success or -1 on out-of-memory (w.r.t. LZW code table) or parse error. */
 static int
+LV_FUNC_SECTION
 read_image_data(gd_GIF *gif, int interlace)
 {
     uint8_t sub_len, shift, byte;
@@ -480,6 +492,7 @@ read_image_data(gd_GIF *gif, int interlace)
 }
 #else
 static Table *
+LV_FUNC_SECTION
 new_table(int key_size)
 {
     int key;
@@ -502,6 +515,7 @@ new_table(int key_size)
  *  +1 if key size must be incremented after this addition
  *  -1 if could not realloc table */
 static int
+LV_FUNC_SECTION
 add_entry(Table ** tablep, uint16_t length, uint16_t prefix, uint8_t suffix)
 {
     Table * table = *tablep;
@@ -523,6 +537,7 @@ add_entry(Table ** tablep, uint16_t length, uint16_t prefix, uint8_t suffix)
 
 /* Compute output index of y-th input line, in frame of height h. */
 static int
+LV_FUNC_SECTION
 interlaced_line_index(int h, int y)
 {
     int p; /* number of lines in current pass */
@@ -546,6 +561,7 @@ interlaced_line_index(int h, int y)
 /* Decompress image pixels.
  * Return 0 on success or -1 on out-of-memory (w.r.t. LZW code table) or parse error. */
 static int
+LV_FUNC_SECTION
 read_image_data(gd_GIF * gif, int interlace)
 {
     uint8_t sub_len, shift, byte;
@@ -627,6 +643,7 @@ read_image_data(gd_GIF * gif, int interlace)
 /* Read image.
  * Return 0 on success or -1 on out-of-memory (w.r.t. LZW code table) or parse error. */
 static int
+LV_FUNC_SECTION
 read_image(gd_GIF * gif)
 {
     uint8_t fisrz;
@@ -658,6 +675,7 @@ read_image(gd_GIF * gif)
 }
 
 static void
+LV_FUNC_SECTION
 render_frame_rect(gd_GIF * gif, uint8_t * buffer)
 {
     int i = gif->fy * gif->width + gif->fx;
@@ -686,6 +704,7 @@ render_frame_rect(gd_GIF * gif, uint8_t * buffer)
 }
 
 static void
+LV_FUNC_SECTION
 dispose(gd_GIF * gif)
 {
     int i;
@@ -723,6 +742,7 @@ dispose(gd_GIF * gif)
 
 /* Return 1 if got a frame; 0 if got GIF trailer; -1 if error. */
 int
+LV_FUNC_SECTION
 gd_get_frame(gd_GIF * gif)
 {
     char sep;
@@ -750,12 +770,14 @@ gd_get_frame(gd_GIF * gif)
 }
 
 void
+LV_FUNC_SECTION
 gd_render_frame(gd_GIF * gif, uint8_t * buffer)
 {
     render_frame_rect(gif, buffer);
 }
 
 void
+LV_FUNC_SECTION
 gd_rewind(gd_GIF * gif)
 {
     gif->loop_count = -1;
@@ -763,12 +785,14 @@ gd_rewind(gd_GIF * gif)
 }
 
 void
+LV_FUNC_SECTION
 gd_close_gif(gd_GIF * gif)
 {
     f_gif_close(gif);
     lv_free(gif);
 }
 
+LV_FUNC_SECTION
 static bool f_gif_open(gd_GIF * gif, const void * path, bool is_file)
 {
     gif->f_rw_p = 0;
@@ -786,6 +810,7 @@ static bool f_gif_open(gd_GIF * gif, const void * path, bool is_file)
     }
 }
 
+LV_FUNC_SECTION
 static void f_gif_read(gd_GIF * gif, void * buf, size_t len)
 {
     if(gif->is_file) {
@@ -797,6 +822,7 @@ static void f_gif_read(gd_GIF * gif, void * buf, size_t len)
     }
 }
 
+LV_FUNC_SECTION
 static int f_gif_seek(gd_GIF * gif, size_t pos, int k)
 {
     if(gif->is_file) {
@@ -812,6 +838,7 @@ static int f_gif_seek(gd_GIF * gif, size_t pos, int k)
     }
 }
 
+LV_FUNC_SECTION
 static void f_gif_close(gd_GIF * gif)
 {
     if(gif->is_file) {
diff --git a/src/libs/gif/lv_gif.c b/src/libs/gif/lv_gif.c
index 920f77689..4105145cc 100644
--- a/src/libs/gif/lv_gif.c
+++ b/src/libs/gif/lv_gif.c
@@ -49,6 +49,7 @@ const lv_obj_class_t lv_gif_class = {
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 lv_obj_t * lv_gif_create(lv_obj_t * parent)
 {
 
@@ -58,6 +59,7 @@ lv_obj_t * lv_gif_create(lv_obj_t * parent)
     return obj;
 }
 
+LV_FUNC_SECTION
 void lv_gif_set_src(lv_obj_t * obj, const void * src)
 {
     lv_gif_t * gifobj = (lv_gif_t *) obj;
@@ -105,6 +107,7 @@ void lv_gif_set_src(lv_obj_t * obj, const void * src)
 
 }
 
+LV_FUNC_SECTION
 void lv_gif_restart(lv_obj_t * obj)
 {
     lv_gif_t * gifobj = (lv_gif_t *) obj;
@@ -119,12 +122,14 @@ void lv_gif_restart(lv_obj_t * obj)
     lv_timer_reset(gifobj->timer);
 }
 
+LV_FUNC_SECTION
 void lv_gif_pause(lv_obj_t * obj)
 {
     lv_gif_t * gifobj = (lv_gif_t *) obj;
     lv_timer_pause(gifobj->timer);
 }
 
+LV_FUNC_SECTION
 void lv_gif_resume(lv_obj_t * obj)
 {
     lv_gif_t * gifobj = (lv_gif_t *) obj;
@@ -137,6 +142,7 @@ void lv_gif_resume(lv_obj_t * obj)
     lv_timer_resume(gifobj->timer);
 }
 
+LV_FUNC_SECTION
 bool lv_gif_is_loaded(lv_obj_t * obj)
 {
     lv_gif_t * gifobj = (lv_gif_t *) obj;
@@ -144,6 +150,7 @@ bool lv_gif_is_loaded(lv_obj_t * obj)
     return (gifobj->gif != NULL);
 }
 
+LV_FUNC_SECTION
 int32_t lv_gif_get_loop_count(lv_obj_t * obj)
 {
     lv_gif_t * gifobj = (lv_gif_t *) obj;
@@ -155,6 +162,7 @@ int32_t lv_gif_get_loop_count(lv_obj_t * obj)
     return gifobj->gif->loop_count;
 }
 
+LV_FUNC_SECTION
 void lv_gif_set_loop_count(lv_obj_t * obj, int32_t count)
 {
     lv_gif_t * gifobj = (lv_gif_t *) obj;
@@ -171,6 +179,7 @@ void lv_gif_set_loop_count(lv_obj_t * obj, int32_t count)
  *   STATIC FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 static void lv_gif_constructor(const lv_obj_class_t * class_p, lv_obj_t * obj)
 {
     LV_UNUSED(class_p);
@@ -182,6 +191,7 @@ static void lv_gif_constructor(const lv_obj_class_t * class_p, lv_obj_t * obj)
     lv_timer_pause(gifobj->timer);
 }
 
+LV_FUNC_SECTION
 static void lv_gif_destructor(const lv_obj_class_t * class_p, lv_obj_t * obj)
 {
     LV_UNUSED(class_p);
@@ -194,6 +204,7 @@ static void lv_gif_destructor(const lv_obj_class_t * class_p, lv_obj_t * obj)
     lv_timer_delete(gifobj->timer);
 }
 
+LV_FUNC_SECTION
 static void next_frame_task_cb(lv_timer_t * t)
 {
     lv_obj_t * obj = t->user_data;
diff --git a/src/libs/libjpeg_turbo/lv_libjpeg_turbo.c b/src/libs/libjpeg_turbo/lv_libjpeg_turbo.c
index f058728e0..30c5f1478 100644
--- a/src/libs/libjpeg_turbo/lv_libjpeg_turbo.c
+++ b/src/libs/libjpeg_turbo/lv_libjpeg_turbo.c
@@ -73,6 +73,7 @@ const int JPEG_LITTLE_ENDIAN_TAG = 0x4949;
 /**
  * Register the JPEG decoder functions in LVGL
  */
+LV_FUNC_SECTION
 void lv_libjpeg_turbo_init(void)
 {
     lv_image_decoder_t * dec = lv_image_decoder_create();
@@ -83,6 +84,7 @@ void lv_libjpeg_turbo_init(void)
     dec->name = DECODER_NAME;
 }
 
+LV_FUNC_SECTION
 void lv_libjpeg_turbo_deinit(void)
 {
     lv_image_decoder_t * dec = NULL;
@@ -104,6 +106,7 @@ void lv_libjpeg_turbo_deinit(void)
  * @param header store the info here
  * @return LV_RESULT_OK: no error; LV_RESULT_INVALID: can't get the info
  */
+__attribute__(( fptrgroup("lv_image_deocder_info_cb") ))
 static lv_result_t decoder_info(lv_image_decoder_t * decoder, lv_image_decoder_dsc_t * dsc, lv_image_header_t * header)
 {
     LV_UNUSED(decoder); /*Unused*/
@@ -157,6 +160,7 @@ static lv_result_t decoder_info(lv_image_decoder_t * decoder, lv_image_decoder_d
  * @param dsc     pointer to the decoder descriptor
  * @return LV_RESULT_OK: no error; LV_RESULT_INVALID: can't open the image
  */
+__attribute__(( fptrgroup("lv_image_deocder_open_cb") ))
 static lv_result_t decoder_open(lv_image_decoder_t * decoder, lv_image_decoder_dsc_t * dsc)
 {
     LV_UNUSED(decoder); /*Unused*/
@@ -199,6 +203,7 @@ static lv_result_t decoder_open(lv_image_decoder_t * decoder, lv_image_decoder_d
 /**
  * Free the allocated resources
  */
+__attribute__(( fptrgroup("lv_image_deocder_close_cb") ))
 static void decoder_close(lv_image_decoder_t * decoder, lv_image_decoder_dsc_t * dsc)
 {
     LV_UNUSED(decoder); /*Unused*/
@@ -207,6 +212,7 @@ static void decoder_close(lv_image_decoder_t * decoder, lv_image_decoder_dsc_t *
        !lv_image_cache_is_enabled()) lv_draw_buf_destroy((lv_draw_buf_t *)dsc->decoded);
 }
 
+LV_FUNC_SECTION
 static uint8_t * read_file(const char * filename, uint32_t * size)
 {
     uint8_t * data = NULL;
@@ -262,6 +268,7 @@ failed:
     return data;
 }
 
+LV_FUNC_SECTION
 static lv_draw_buf_t * decode_jpeg_file(const char * filename)
 {
     /* This struct contains the JPEG decompression parameters and pointers to
@@ -420,6 +427,7 @@ static lv_draw_buf_t * decode_jpeg_file(const char * filename)
     return decoded;
 }
 
+LV_FUNC_SECTION
 static bool get_jpeg_head_info(const char * filename, uint32_t * width, uint32_t * height, uint32_t * orientation)
 {
     uint8_t * data = NULL;
@@ -442,6 +450,7 @@ static bool get_jpeg_head_info(const char * filename, uint32_t * width, uint32_t
     return JPEG_HEADER_OK;
 }
 
+LV_FUNC_SECTION
 static bool get_jpeg_size(uint8_t * data, uint32_t data_size, uint32_t * width, uint32_t * height)
 {
     struct jpeg_decompress_struct cinfo;
@@ -475,6 +484,7 @@ static bool get_jpeg_size(uint8_t * data, uint32_t data_size, uint32_t * width,
     return JPEG_HEADER_OK;
 }
 
+LV_FUNC_SECTION
 static bool get_jpeg_direction(uint8_t * data, uint32_t data_size, uint32_t * orientation)
 {
     struct jpeg_decompress_struct cinfo;
@@ -563,6 +573,7 @@ static bool get_jpeg_direction(uint8_t * data, uint32_t data_size, uint32_t * or
     return JPEG_HEADER_OK;
 }
 
+LV_FUNC_SECTION
 static void rotate_buffer(lv_draw_buf_t * decoded, uint8_t * buffer, uint32_t line_index, uint32_t angle)
 {
     if(angle == 90) {
@@ -588,6 +599,7 @@ static void rotate_buffer(lv_draw_buf_t * decoded, uint8_t * buffer, uint32_t li
     }
 }
 
+LV_FUNC_SECTION
 static void error_exit(j_common_ptr cinfo)
 {
     error_mgr_t * myerr = (error_mgr_t *)cinfo->err;
diff --git a/src/libs/libpng/lv_libpng.c b/src/libs/libpng/lv_libpng.c
index 587e5fc69..ad842a3b9 100644
--- a/src/libs/libpng/lv_libpng.c
+++ b/src/libs/libpng/lv_libpng.c
@@ -50,6 +50,7 @@ static lv_draw_buf_t * decode_png(lv_image_decoder_dsc_t * dsc);
 /**
  * Register the PNG decoder functions in LVGL
  */
+LV_FUNC_SECTION
 void lv_libpng_init(void)
 {
     lv_image_decoder_t * dec = lv_image_decoder_create();
@@ -60,6 +61,7 @@ void lv_libpng_init(void)
     dec->name = DECODER_NAME;
 }
 
+LV_FUNC_SECTION
 void lv_libpng_deinit(void)
 {
     lv_image_decoder_t * dec = NULL;
@@ -81,6 +83,7 @@ void lv_libpng_deinit(void)
  * @param header store the info here
  * @return LV_RESULT_OK: no error; LV_RESULT_INVALID: can't get the info
  */
+__attribute__(( fptrgroup("lv_image_deocder_info_cb") ))
 static lv_result_t decoder_info(lv_image_decoder_t * decoder, lv_image_decoder_dsc_t * dsc, lv_image_header_t * header)
 {
     LV_UNUSED(decoder); /*Unused*/
@@ -135,6 +138,7 @@ static lv_result_t decoder_info(lv_image_decoder_t * decoder, lv_image_decoder_d
  * @param dsc     pointer to the decoder descriptor
  * @return LV_RESULT_OK: no error; LV_RESULT_INVALID: can't open the image
  */
+__attribute__(( fptrgroup("lv_image_deocder_open_cb") ))
 static lv_result_t decoder_open(lv_image_decoder_t * decoder, lv_image_decoder_dsc_t * dsc)
 {
     LV_UNUSED(decoder); /*Unused*/
@@ -184,6 +188,7 @@ static lv_result_t decoder_open(lv_image_decoder_t * decoder, lv_image_decoder_d
 /**
  * Free the allocated resources
  */
+__attribute__(( fptrgroup("lv_image_deocder_close_cb") ))
 static void decoder_close(lv_image_decoder_t * decoder, lv_image_decoder_dsc_t * dsc)
 {
     LV_UNUSED(decoder); /*Unused*/
@@ -192,6 +197,7 @@ static void decoder_close(lv_image_decoder_t * decoder, lv_image_decoder_dsc_t *
        !lv_image_cache_is_enabled()) lv_draw_buf_destroy_user(image_cache_draw_buf_handlers, (lv_draw_buf_t *)dsc->decoded);
 }
 
+LV_FUNC_SECTION
 static uint8_t * alloc_file(const char * filename, uint32_t * size)
 {
     uint8_t * data = NULL;
@@ -247,6 +253,7 @@ failed:
     return data;
 }
 
+LV_FUNC_SECTION
 static lv_draw_buf_t * decode_png(lv_image_decoder_dsc_t * dsc)
 {
     int ret;
diff --git a/src/libs/lodepng/lodepng.c b/src/libs/lodepng/lodepng.c
index a3f0b59a1..0b7130748 100644
--- a/src/libs/lodepng/lodepng.c
+++ b/src/libs/lodepng/lodepng.c
@@ -75,6 +75,7 @@ lodepng source code. Don't forget to remove "static" if you copypaste them
 from here.*/
 
 #ifdef LODEPNG_COMPILE_ALLOCATORS
+LV_FUNC_SECTION
 static void * lodepng_malloc(size_t size)
 {
 #ifdef LODEPNG_MAX_ALLOC
@@ -84,6 +85,7 @@ static void * lodepng_malloc(size_t size)
 }
 
 /* NOTE: when realloc returns NULL, it leaves the original memory untouched */
+LV_FUNC_SECTION
 static void * lodepng_realloc(void * ptr, size_t new_size)
 {
 #ifdef LODEPNG_MAX_ALLOC
@@ -92,6 +94,7 @@ static void * lodepng_realloc(void * ptr, size_t new_size)
     return lv_realloc(ptr, new_size);
 }
 
+LV_FUNC_SECTION
 static void lodepng_free(void * ptr)
 {
     lv_free(ptr);
@@ -124,12 +127,14 @@ void lodepng_free(void * ptr);
 where a full C library is not available. The compiler can recognize them and compile
 to something as fast. */
 
+LV_FUNC_SECTION
 static void lodepng_memcpy(void * LODEPNG_RESTRICT dst,
                            const void * LODEPNG_RESTRICT src, size_t size)
 {
     lv_memcpy(dst, src, size);
 }
 
+LV_FUNC_SECTION
 static void lodepng_memset(void * LODEPNG_RESTRICT dst,
                            int value, size_t num)
 {
@@ -137,6 +142,7 @@ static void lodepng_memset(void * LODEPNG_RESTRICT dst,
 }
 
 /* does not check memory out of bounds, do not use on untrusted data */
+LV_FUNC_SECTION
 static size_t lodepng_strlen(const char * a)
 {
     const char * orig = a;
@@ -152,6 +158,7 @@ static size_t lodepng_strlen(const char * a)
 #if defined(LODEPNG_COMPILE_PNG) || defined(LODEPNG_COMPILE_DECODER)
 /* Safely check if adding two integers will overflow (no undefined
 behavior, compiler removing the code, etc...) and output result. */
+LV_FUNC_SECTION
 static int lodepng_addofl(size_t a, size_t b, size_t * result)
 {
     *result = a + b; /* Unsigned addition is well defined and safe in C90 */
@@ -162,6 +169,7 @@ static int lodepng_addofl(size_t a, size_t b, size_t * result)
 #ifdef LODEPNG_COMPILE_DECODER
 /* Safely check if multiplying two integers will overflow (no undefined
 behavior, compiler removing the code, etc...) and output result. */
+LV_FUNC_SECTION
 static int lodepng_mulofl(size_t a, size_t b, size_t * result)
 {
     *result = a * b; /* Unsigned multiplication is well defined and safe in C90 */
@@ -170,6 +178,7 @@ static int lodepng_mulofl(size_t a, size_t b, size_t * result)
 
 #ifdef LODEPNG_COMPILE_ZLIB
 /* Safely check if a + b > c, even if overflow could happen. */
+LV_FUNC_SECTION
 static int lodepng_gtofl(size_t a, size_t b, size_t c)
 {
     size_t d;
@@ -231,6 +240,7 @@ typedef struct uivector {
     size_t allocsize; /*allocated size in bytes*/
 } uivector;
 
+LV_FUNC_SECTION
 static void uivector_cleanup(void * p)
 {
     ((uivector *)p)->size = ((uivector *)p)->allocsize = 0;
@@ -239,6 +249,7 @@ static void uivector_cleanup(void * p)
 }
 
 /*returns 1 if success, 0 if failure ==> nothing done*/
+LV_FUNC_SECTION
 static unsigned uivector_resize(uivector * p, size_t size)
 {
     size_t allocsize = size * sizeof(unsigned);
@@ -255,6 +266,7 @@ static unsigned uivector_resize(uivector * p, size_t size)
     return 1; /*success*/
 }
 
+LV_FUNC_SECTION
 static void uivector_init(uivector * p)
 {
     p->data = NULL;
@@ -262,6 +274,7 @@ static void uivector_init(uivector * p)
 }
 
 /*returns 1 if success, 0 if failure ==> nothing done*/
+LV_FUNC_SECTION
 static unsigned uivector_push_back(uivector * p, unsigned c)
 {
     if(!uivector_resize(p, p->size + 1)) return 0;
@@ -281,6 +294,7 @@ typedef struct ucvector {
 } ucvector;
 
 /*returns 1 if success, 0 if failure ==> nothing done*/
+LV_FUNC_SECTION
 static unsigned ucvector_reserve(ucvector * p, size_t size)
 {
     if(size > p->allocsize) {
@@ -296,12 +310,14 @@ static unsigned ucvector_reserve(ucvector * p, size_t size)
 }
 
 /*returns 1 if success, 0 if failure ==> nothing done*/
+LV_FUNC_SECTION
 static unsigned ucvector_resize(ucvector * p, size_t size)
 {
     p->size = size;
     return ucvector_reserve(p, size);
 }
 
+LV_FUNC_SECTION
 static ucvector ucvector_init(unsigned char * buffer, size_t size)
 {
     ucvector v;
@@ -316,6 +332,7 @@ static ucvector ucvector_init(unsigned char * buffer, size_t size)
 #ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
 
 /*free string pointer and set it to NULL*/
+LV_FUNC_SECTION
 static void string_cleanup(char ** out)
 {
     lodepng_free(*out);
@@ -323,6 +340,7 @@ static void string_cleanup(char ** out)
 }
 
 /*also appends null termination character*/
+LV_FUNC_SECTION
 static char * alloc_string_sized(const char * in, size_t insize)
 {
     char * out = (char *)lodepng_malloc(insize + 1);
@@ -334,6 +352,7 @@ static char * alloc_string_sized(const char * in, size_t insize)
 }
 
 /* dynamically allocates a new string with a copy of the null terminated input text */
+LV_FUNC_SECTION
 static char * alloc_string(const char * in)
 {
     return alloc_string_sized(in, lodepng_strlen(in));
@@ -344,6 +363,7 @@ static char * alloc_string(const char * in)
 /* ////////////////////////////////////////////////////////////////////////// */
 
 #if defined(LODEPNG_COMPILE_DECODER) || defined(LODEPNG_COMPILE_PNG)
+LV_FUNC_SECTION
 static unsigned lodepng_read32bitInt(const unsigned char * buffer)
 {
     return (((unsigned)buffer[0] << 24u) | ((unsigned)buffer[1] << 16u) |
@@ -353,6 +373,7 @@ static unsigned lodepng_read32bitInt(const unsigned char * buffer)
 
 #if defined(LODEPNG_COMPILE_PNG) || defined(LODEPNG_COMPILE_ENCODER)
 /*buffer must have at least 4 allocated bytes available*/
+LV_FUNC_SECTION
 static void lodepng_set32bitInt(unsigned char * buffer, unsigned value)
 {
     buffer[0] = (unsigned char)((value >> 24) & 0xff);
@@ -369,6 +390,7 @@ static void lodepng_set32bitInt(unsigned char * buffer, unsigned value)
 #ifdef LODEPNG_COMPILE_DISK
 
 /* returns negative value on error. This should be pure C compatible, so no fstat. */
+LV_FUNC_SECTION
 static long lodepng_filesize(const char * filename)
 {
     lv_fs_file_t f;
@@ -386,6 +408,7 @@ static long lodepng_filesize(const char * filename)
 }
 
 /* load file into buffer that already has the correct allocated size. Returns error code.*/
+LV_FUNC_SECTION
 static unsigned lodepng_buffer_file(unsigned char * out, size_t size, const char * filename)
 {
     lv_fs_file_t f;
@@ -402,6 +425,7 @@ static unsigned lodepng_buffer_file(unsigned char * out, size_t size, const char
     return 0;
 }
 
+LV_FUNC_SECTION
 unsigned lodepng_load_file(unsigned char ** out, size_t * outsize, const char * filename)
 {
     long size = lodepng_filesize(filename);
@@ -415,6 +439,7 @@ unsigned lodepng_load_file(unsigned char ** out, size_t * outsize, const char *
 }
 
 /*write given buffer to the file, overwriting the file, it doesn't append to it.*/
+LV_FUNC_SECTION
 unsigned lodepng_save_file(const unsigned char * buffer, size_t buffersize, const char * filename)
 {
     lv_fs_file_t f;
@@ -443,6 +468,7 @@ typedef struct {
     unsigned char bp; /*ok to overflow, indicates bit pos inside byte*/
 } LodePNGBitWriter;
 
+LV_FUNC_SECTION
 static void LodePNGBitWriter_init(LodePNGBitWriter * writer, ucvector * data)
 {
     writer->data = data;
@@ -461,6 +487,7 @@ static void LodePNGBitWriter_init(LodePNGBitWriter * writer, ucvector * data)
     }
 
 /* LSB of value is written first, and LSB of bytes is used first */
+LV_FUNC_SECTION
 static void writeBits(LodePNGBitWriter * writer, unsigned value, size_t nbits)
 {
     if(nbits == 1) { /* compiler should statically compile this case if nbits == 1 */
@@ -476,6 +503,7 @@ static void writeBits(LodePNGBitWriter * writer, unsigned value, size_t nbits)
 }
 
 /* This one is to use for adding huffman symbol, the value bits are written MSB first */
+LV_FUNC_SECTION
 static void writeBitsReversed(LodePNGBitWriter * writer, unsigned value, size_t nbits)
 {
     size_t i;
@@ -497,6 +525,7 @@ typedef struct {
 } LodePNGBitReader;
 
 /* data size argument is in bytes. Returns error if size too large causing overflow */
+LV_FUNC_SECTION
 static unsigned LodePNGBitReader_init(LodePNGBitReader * reader, const unsigned char * data, size_t size)
 {
     size_t temp;
@@ -521,6 +550,7 @@ checking for amount of bits must be done beforehand.
 */
 
 /*See ensureBits documentation above. This one ensures up to 9 bits */
+LV_FUNC_SECTION
 static LODEPNG_INLINE void ensureBits9(LodePNGBitReader * reader, size_t nbits)
 {
     size_t start = reader->bp >> 3u;
@@ -538,6 +568,7 @@ static LODEPNG_INLINE void ensureBits9(LodePNGBitReader * reader, size_t nbits)
 }
 
 /*See ensureBits documentation above. This one ensures up to 17 bits */
+LV_FUNC_SECTION
 static LODEPNG_INLINE void ensureBits17(LodePNGBitReader * reader, size_t nbits)
 {
     size_t start = reader->bp >> 3u;
@@ -557,6 +588,7 @@ static LODEPNG_INLINE void ensureBits17(LodePNGBitReader * reader, size_t nbits)
 }
 
 /*See ensureBits documentation above. This one ensures up to 25 bits */
+LV_FUNC_SECTION
 static LODEPNG_INLINE void ensureBits25(LodePNGBitReader * reader, size_t nbits)
 {
     size_t start = reader->bp >> 3u;
@@ -577,6 +609,7 @@ static LODEPNG_INLINE void ensureBits25(LodePNGBitReader * reader, size_t nbits)
 }
 
 /*See ensureBits documentation above. This one ensures up to 32 bits */
+LV_FUNC_SECTION
 static LODEPNG_INLINE void ensureBits32(LodePNGBitReader * reader, size_t nbits)
 {
     size_t start = reader->bp >> 3u;
@@ -599,6 +632,7 @@ static LODEPNG_INLINE void ensureBits32(LodePNGBitReader * reader, size_t nbits)
 }
 
 /* Get bits without advancing the bit pointer. Must have enough bits available with ensureBits. Max nbits is 31. */
+LV_FUNC_SECTION
 static LODEPNG_INLINE unsigned peekBits(LodePNGBitReader * reader, size_t nbits)
 {
     /* The shift allows nbits to be only up to 31. */
@@ -606,6 +640,7 @@ static LODEPNG_INLINE unsigned peekBits(LodePNGBitReader * reader, size_t nbits)
 }
 
 /* Must have enough bits available with ensureBits */
+LV_FUNC_SECTION
 static LODEPNG_INLINE void advanceBits(LodePNGBitReader * reader, size_t nbits)
 {
     reader->buffer >>= nbits;
@@ -613,6 +648,7 @@ static LODEPNG_INLINE void advanceBits(LodePNGBitReader * reader, size_t nbits)
 }
 
 /* Must have enough bits available with ensureBits */
+LV_FUNC_SECTION
 static LODEPNG_INLINE unsigned readBits(LodePNGBitReader * reader, size_t nbits)
 {
     unsigned result = peekBits(reader, nbits);
@@ -621,6 +657,7 @@ static LODEPNG_INLINE unsigned readBits(LodePNGBitReader * reader, size_t nbits)
 }
 #endif /*LODEPNG_COMPILE_DECODER*/
 
+LV_FUNC_SECTION
 static unsigned reverseBits(unsigned bits, unsigned num)
 {
     /*TODO: implement faster lookup table based version when needed*/
@@ -686,6 +723,7 @@ typedef struct HuffmanTree {
     unsigned short * table_value; /*value of symbol from lookup table, or pointer to secondary table if needed*/
 } HuffmanTree;
 
+LV_FUNC_SECTION
 static void HuffmanTree_init(HuffmanTree * tree)
 {
     tree->codes = 0;
@@ -694,6 +732,7 @@ static void HuffmanTree_init(HuffmanTree * tree)
     tree->table_value = 0;
 }
 
+LV_FUNC_SECTION
 static void HuffmanTree_cleanup(HuffmanTree * tree)
 {
     lodepng_free(tree->codes);
@@ -711,6 +750,7 @@ which is possible in case of only 0 or 1 present symbols. */
 #define INVALIDSYMBOL 65535u
 
 /* make table for huffman decoding */
+LV_FUNC_SECTION
 static unsigned HuffmanTree_makeTable(HuffmanTree * tree)
 {
     static const unsigned headsize = 1u << FIRSTBITS; /*size of the first table*/
@@ -835,6 +875,7 @@ Second step for the ...makeFromLengths and ...makeFromFrequencies functions.
 numcodes, lengths and maxbitlen must already be filled in correctly. return
 value is error.
 */
+LV_FUNC_SECTION
 static unsigned HuffmanTree_makeFromLengths2(HuffmanTree * tree)
 {
     unsigned * blcount;
@@ -877,6 +918,7 @@ given the code lengths (as stored in the PNG file), generate the tree as defined
 by Deflate. maxbitlen is the maximum bits that a code in the tree can have.
 return value is error.
 */
+LV_FUNC_SECTION
 static unsigned HuffmanTree_makeFromLengths(HuffmanTree * tree, const unsigned * bitlen,
                                             size_t numcodes, unsigned maxbitlen)
 {
@@ -917,6 +959,7 @@ typedef struct BPMLists {
 } BPMLists;
 
 /*creates a new chain node with the given parameters, from the memory in the lists */
+LV_FUNC_SECTION
 static BPMNode * bpmnode_create(BPMLists * lists, int weight, unsigned index, BPMNode * tail)
 {
     unsigned i;
@@ -947,6 +990,7 @@ static BPMNode * bpmnode_create(BPMLists * lists, int weight, unsigned index, BP
 }
 
 /*sort the leaves with stable mergesort*/
+LV_FUNC_SECTION
 static void bpmnode_sort(BPMNode * leaves, size_t num)
 {
     BPMNode * mem = (BPMNode *)lodepng_malloc(sizeof(*leaves) * num);
@@ -971,6 +1015,7 @@ static void bpmnode_sort(BPMNode * leaves, size_t num)
 }
 
 /*Boundary Package Merge step, numpresent is the amount of leaves, and c is the current chain.*/
+LV_FUNC_SECTION
 static void boundaryPM(BPMLists * lists, BPMNode * leaves, size_t numpresent, int c, int num)
 {
     unsigned lastindex = lists->chains1[c]->index;
@@ -998,6 +1043,7 @@ static void boundaryPM(BPMLists * lists, BPMNode * leaves, size_t numpresent, in
     }
 }
 
+LV_FUNC_SECTION
 unsigned lodepng_huffman_code_lengths(unsigned * lengths, const unsigned * frequencies,
                                       size_t numcodes, unsigned maxbitlen)
 {
@@ -1080,6 +1126,7 @@ unsigned lodepng_huffman_code_lengths(unsigned * lengths, const unsigned * frequ
 }
 
 /*Create the Huffman tree given the symbol frequencies*/
+LV_FUNC_SECTION
 static unsigned HuffmanTree_makeFromFrequencies(HuffmanTree * tree, const unsigned * frequencies,
                                                 size_t mincodes, size_t numcodes, unsigned maxbitlen)
 {
@@ -1097,6 +1144,7 @@ static unsigned HuffmanTree_makeFromFrequencies(HuffmanTree * tree, const unsign
 #endif /*LODEPNG_COMPILE_ENCODER*/
 
 /*get the literal and length code tree of a deflated block with fixed tree, as per the deflate specification*/
+LV_FUNC_SECTION
 static unsigned generateFixedLitLenTree(HuffmanTree * tree)
 {
     unsigned i, error = 0;
@@ -1116,6 +1164,7 @@ static unsigned generateFixedLitLenTree(HuffmanTree * tree)
 }
 
 /*get the distance code tree of a deflated block with fixed tree, as specified in the deflate specification*/
+LV_FUNC_SECTION
 static unsigned generateFixedDistanceTree(HuffmanTree * tree)
 {
     unsigned i, error = 0;
@@ -1135,6 +1184,7 @@ static unsigned generateFixedDistanceTree(HuffmanTree * tree)
 /*
 returns the code. The bit reader must already have been ensured at least 15 bits
 */
+LV_FUNC_SECTION
 static unsigned huffmanDecodeSymbol(LodePNGBitReader * reader, const HuffmanTree * codetree)
 {
     unsigned short code = peekBits(reader, FIRSTBITS);
@@ -1161,6 +1211,7 @@ static unsigned huffmanDecodeSymbol(LodePNGBitReader * reader, const HuffmanTree
 
 /*get the tree of a deflated block with fixed tree, as specified in the deflate specification
 Returns error code.*/
+LV_FUNC_SECTION
 static unsigned getTreeInflateFixed(HuffmanTree * tree_ll, HuffmanTree * tree_d)
 {
     unsigned error = generateFixedLitLenTree(tree_ll);
@@ -1169,6 +1220,7 @@ static unsigned getTreeInflateFixed(HuffmanTree * tree_ll, HuffmanTree * tree_d)
 }
 
 /*get the tree of a deflated block with dynamic tree, the tree itself is also Huffman compressed with a known tree*/
+LV_FUNC_SECTION
 static unsigned getTreeInflateDynamic(HuffmanTree * tree_ll, HuffmanTree * tree_d,
                                       LodePNGBitReader * reader)
 {
@@ -1308,6 +1360,7 @@ static unsigned getTreeInflateDynamic(HuffmanTree * tree_ll, HuffmanTree * tree_
 }
 
 /*inflate a block with dynamic of fixed Huffman tree. btype must be 1 or 2.*/
+LV_FUNC_SECTION
 static unsigned inflateHuffmanBlock(ucvector * out, LodePNGBitReader * reader,
                                     unsigned btype, size_t max_output_size)
 {
@@ -1423,6 +1476,7 @@ static unsigned inflateHuffmanBlock(ucvector * out, LodePNGBitReader * reader,
     return error;
 }
 
+LV_FUNC_SECTION
 static unsigned inflateNoCompression(ucvector * out, LodePNGBitReader * reader,
                                      const LodePNGDecompressSettings * settings)
 {
@@ -1461,6 +1515,7 @@ static unsigned inflateNoCompression(ucvector * out, LodePNGBitReader * reader,
     return error;
 }
 
+LV_FUNC_SECTION
 static unsigned lodepng_inflatev(ucvector * out,
                                  const unsigned char * in, size_t insize,
                                  const LodePNGDecompressSettings * settings)
@@ -1488,6 +1543,7 @@ static unsigned lodepng_inflatev(ucvector * out,
     return error;
 }
 
+LV_FUNC_SECTION
 unsigned lodepng_inflate(unsigned char ** out, size_t * outsize,
                          const unsigned char * in, size_t insize,
                          const LodePNGDecompressSettings * settings)
@@ -1499,6 +1555,7 @@ unsigned lodepng_inflate(unsigned char ** out, size_t * outsize,
     return error;
 }
 
+LV_FUNC_SECTION
 static unsigned inflatev(ucvector * out, const unsigned char * in, size_t insize,
                          const LodePNGDecompressSettings * settings)
 {
@@ -1530,6 +1587,7 @@ static const unsigned MAX_SUPPORTED_DEFLATE_LENGTH = 258;
 
 /*search the index in the array, that has the largest value smaller than or equal to the given value,
 given array must be sorted (if no value is smaller, it returns the size of the given array)*/
+LV_FUNC_SECTION
 static size_t searchCodeIndex(const unsigned * array, size_t array_size, size_t value)
 {
     /*binary search (only small gain over linear). TODO: use CPU log2 instruction for getting symbols instead*/
@@ -1545,6 +1603,7 @@ static size_t searchCodeIndex(const unsigned * array, size_t array_size, size_t
     return left;
 }
 
+LV_FUNC_SECTION
 static void addLengthDistance(uivector * values, size_t length, size_t distance)
 {
     /*values in encoded vector are those used by deflate:
@@ -1587,6 +1646,7 @@ typedef struct Hash {
     unsigned short * zeros; /*length of zeros streak, used as a second hash chain*/
 } Hash;
 
+LV_FUNC_SECTION
 static unsigned hash_init(Hash * hash, unsigned windowsize)
 {
     unsigned i;
@@ -1613,6 +1673,7 @@ static unsigned hash_init(Hash * hash, unsigned windowsize)
     return 0;
 }
 
+LV_FUNC_SECTION
 static void hash_cleanup(Hash * hash)
 {
     lodepng_free(hash->head);
@@ -1626,6 +1687,7 @@ static void hash_cleanup(Hash * hash)
 
 
 
+LV_FUNC_SECTION
 static unsigned getHash(const unsigned char * data, size_t size, size_t pos)
 {
     unsigned result = 0;
@@ -1647,6 +1709,7 @@ static unsigned getHash(const unsigned char * data, size_t size, size_t pos)
     return result & HASH_BIT_MASK;
 }
 
+LV_FUNC_SECTION
 static unsigned countZeros(const unsigned char * data, size_t size, size_t pos)
 {
     const unsigned char * start = data + pos;
@@ -1659,6 +1722,7 @@ static unsigned countZeros(const unsigned char * data, size_t size, size_t pos)
 }
 
 /*wpos = pos & (windowsize - 1)*/
+LV_FUNC_SECTION
 static void updateHashChain(Hash * hash, size_t wpos, unsigned hashval, unsigned short numzeros)
 {
     hash->val[wpos] = (int)hashval;
@@ -1679,6 +1743,7 @@ sliding window (of windowsize) is used, and all past bytes in that window can be
 the "dictionary". A brute force search through all possible distances would be slow, and
 this hash technique is one out of several ways to speed this up.
 */
+LV_FUNC_SECTION
 static unsigned encodeLZ77(uivector * out, Hash * hash,
                            const unsigned char * in, size_t inpos, size_t insize, unsigned windowsize,
                            unsigned minmatch, unsigned nicematch, unsigned lazymatching)
@@ -1837,6 +1902,7 @@ static unsigned encodeLZ77(uivector * out, Hash * hash,
 
 /* /////////////////////////////////////////////////////////////////////////// */
 
+LV_FUNC_SECTION
 static unsigned deflateNoCompression(ucvector * out, const unsigned char * data, size_t datasize)
 {
     /*non compressed deflate block data: 1 bit BFINAL,2 bits BTYPE,(5 bits): it jumps to start of next byte,
@@ -1876,6 +1942,7 @@ write the lz77-encoded data, which has lit, len and dist codes, to compressed st
 tree_ll: the tree for lit and len codes.
 tree_d: the tree for distance codes.
 */
+LV_FUNC_SECTION
 static void writeLZ77data(LodePNGBitWriter * writer, const uivector * lz77_encoded,
                           const HuffmanTree * tree_ll, const HuffmanTree * tree_d)
 {
@@ -1902,6 +1969,7 @@ static void writeLZ77data(LodePNGBitWriter * writer, const uivector * lz77_encod
 }
 
 /*Deflate for a block of type "dynamic", that is, with freely, optimally, created huffman trees*/
+LV_FUNC_SECTION
 static unsigned deflateDynamic(LodePNGBitWriter * writer, Hash * hash,
                                const unsigned char * data, size_t datapos, size_t dataend,
                                const LodePNGCompressSettings * settings, unsigned final)
@@ -2130,6 +2198,7 @@ static unsigned deflateDynamic(LodePNGBitWriter * writer, Hash * hash,
     return error;
 }
 
+LV_FUNC_SECTION
 static unsigned deflateFixed(LodePNGBitWriter * writer, Hash * hash,
                              const unsigned char * data,
                              size_t datapos, size_t dataend,
@@ -2177,6 +2246,7 @@ static unsigned deflateFixed(LodePNGBitWriter * writer, Hash * hash,
     return error;
 }
 
+LV_FUNC_SECTION
 static unsigned lodepng_deflatev(ucvector * out, const unsigned char * in, size_t insize,
                                  const LodePNGCompressSettings * settings)
 {
@@ -2219,6 +2289,7 @@ static unsigned lodepng_deflatev(ucvector * out, const unsigned char * in, size_
     return error;
 }
 
+LV_FUNC_SECTION
 unsigned lodepng_deflate(unsigned char ** out, size_t * outsize,
                          const unsigned char * in, size_t insize,
                          const LodePNGCompressSettings * settings)
@@ -2230,6 +2301,7 @@ unsigned lodepng_deflate(unsigned char ** out, size_t * outsize,
     return error;
 }
 
+LV_FUNC_SECTION
 static unsigned deflate(unsigned char ** out, size_t * outsize,
                         const unsigned char * in, size_t insize,
                         const LodePNGCompressSettings * settings)
@@ -2250,6 +2322,7 @@ static unsigned deflate(unsigned char ** out, size_t * outsize,
 /* / Adler32                                                                / */
 /* ////////////////////////////////////////////////////////////////////////// */
 
+LV_FUNC_SECTION
 static unsigned update_adler32(unsigned adler, const unsigned char * data, unsigned len)
 {
     unsigned s1 = adler & 0xffffu;
@@ -2272,6 +2345,7 @@ static unsigned update_adler32(unsigned adler, const unsigned char * data, unsig
 }
 
 /*Return the adler32 of the bytes data[0..len-1]*/
+LV_FUNC_SECTION
 static unsigned adler32(const unsigned char * data, unsigned len)
 {
     return update_adler32(1u, data, len);
@@ -2283,6 +2357,7 @@ static unsigned adler32(const unsigned char * data, unsigned len)
 
 #ifdef LODEPNG_COMPILE_DECODER
 
+LV_FUNC_SECTION
 static unsigned lodepng_zlib_decompressv(ucvector * out,
                                          const unsigned char * in, size_t insize,
                                          const LodePNGDecompressSettings * settings)
@@ -2326,6 +2401,7 @@ static unsigned lodepng_zlib_decompressv(ucvector * out,
 }
 
 
+LV_FUNC_SECTION
 unsigned lodepng_zlib_decompress(unsigned char ** out, size_t * outsize, const unsigned char * in,
                                  size_t insize, const LodePNGDecompressSettings * settings)
 {
@@ -2337,6 +2413,7 @@ unsigned lodepng_zlib_decompress(unsigned char ** out, size_t * outsize, const u
 }
 
 /*expected_size is expected output size, to avoid intermediate allocations. Set to 0 if not known. */
+LV_FUNC_SECTION
 static unsigned zlib_decompress(unsigned char ** out, size_t * outsize, size_t expected_size,
                                 const unsigned char * in, size_t insize, const LodePNGDecompressSettings * settings)
 {
@@ -2368,6 +2445,7 @@ static unsigned zlib_decompress(unsigned char ** out, size_t * outsize, size_t e
 
 #ifdef LODEPNG_COMPILE_ENCODER
 
+LV_FUNC_SECTION
 unsigned lodepng_zlib_compress(unsigned char ** out, size_t * outsize, const unsigned char * in,
                                size_t insize, const LodePNGCompressSettings * settings)
 {
@@ -2407,6 +2485,7 @@ unsigned lodepng_zlib_compress(unsigned char ** out, size_t * outsize, const uns
 }
 
 /* compress using the default or custom zlib function */
+LV_FUNC_SECTION
 static unsigned zlib_compress(unsigned char ** out, size_t * outsize, const unsigned char * in,
                               size_t insize, const LodePNGCompressSettings * settings)
 {
@@ -2425,6 +2504,7 @@ static unsigned zlib_compress(unsigned char ** out, size_t * outsize, const unsi
 #else /*no LODEPNG_COMPILE_ZLIB*/
 
 #ifdef LODEPNG_COMPILE_DECODER
+LV_FUNC_SECTION
 static unsigned zlib_decompress(unsigned char ** out, size_t * outsize, size_t expected_size,
                                 const unsigned char * in, size_t insize, const LodePNGDecompressSettings * settings)
 {
@@ -2434,6 +2514,7 @@ static unsigned zlib_decompress(unsigned char ** out, size_t * outsize, size_t e
 }
 #endif /*LODEPNG_COMPILE_DECODER*/
 #ifdef LODEPNG_COMPILE_ENCODER
+LV_FUNC_SECTION
 static unsigned zlib_compress(unsigned char ** out, size_t * outsize, const unsigned char * in,
                               size_t insize, const LodePNGCompressSettings * settings)
 {
@@ -2451,6 +2532,7 @@ static unsigned zlib_compress(unsigned char ** out, size_t * outsize, const unsi
 /*this is a good tradeoff between speed and compression ratio*/
 #define DEFAULT_WINDOWSIZE 2048
 
+LV_FUNC_SECTION
 void lodepng_compress_settings_init(LodePNGCompressSettings * settings)
 {
     /*compress with dynamic huffman tree (not in the mathematical sense, just not the predefined one)*/
@@ -2473,6 +2555,7 @@ const LodePNGCompressSettings lodepng_default_compress_settings = {2, 1, DEFAULT
 
 #ifdef LODEPNG_COMPILE_DECODER
 
+LV_FUNC_SECTION
 void lodepng_decompress_settings_init(LodePNGDecompressSettings * settings)
 {
     settings->ignore_adler32 = 0;
@@ -2784,6 +2867,7 @@ static const unsigned lodepng_crc32_table7[256] = {
 };
 
 /* Computes the cyclic redundancy check as used by PNG chunks*/
+LV_FUNC_SECTION
 unsigned lodepng_crc32(const unsigned char * data, size_t length)
 {
     /*Using the Slicing by Eight algorithm*/
@@ -2835,6 +2919,7 @@ unsigned lodepng_crc32(const unsigned char * data, size_t length);
 /* The color channel bits of less-than-8-bit pixels are read with the MSB of bytes first,
 so LodePNGBitWriter and LodePNGBitReader can't be used for those. */
 
+LV_FUNC_SECTION
 static unsigned char readBitFromReversedStream(size_t * bitpointer, const unsigned char * bitstream)
 {
     unsigned char result = (unsigned char)((bitstream[(*bitpointer) >> 3] >> (7 - ((*bitpointer) & 0x7))) & 1);
@@ -2843,6 +2928,7 @@ static unsigned char readBitFromReversedStream(size_t * bitpointer, const unsign
 }
 
 /* TODO: make this faster */
+LV_FUNC_SECTION
 static unsigned readBitsFromReversedStream(size_t * bitpointer, const unsigned char * bitstream, size_t nbits)
 {
     unsigned result = 0;
@@ -2854,6 +2940,7 @@ static unsigned readBitsFromReversedStream(size_t * bitpointer, const unsigned c
     return result;
 }
 
+LV_FUNC_SECTION
 static void setBitOfReversedStream(size_t * bitpointer, unsigned char * bitstream, unsigned char bit)
 {
     /*the current bit in bitstream may be 0 or 1 for this to work*/
@@ -2866,11 +2953,13 @@ static void setBitOfReversedStream(size_t * bitpointer, unsigned char * bitstrea
 /* / PNG chunks                                                             / */
 /* ////////////////////////////////////////////////////////////////////////// */
 
+LV_FUNC_SECTION
 unsigned lodepng_chunk_length(const unsigned char * chunk)
 {
     return lodepng_read32bitInt(chunk);
 }
 
+LV_FUNC_SECTION
 void lodepng_chunk_type(char type[5], const unsigned char * chunk)
 {
     unsigned i;
@@ -2878,37 +2967,44 @@ void lodepng_chunk_type(char type[5], const unsigned char * chunk)
     type[4] = 0; /*null termination char*/
 }
 
+LV_FUNC_SECTION
 unsigned char lodepng_chunk_type_equals(const unsigned char * chunk, const char * type)
 {
     if(lodepng_strlen(type) != 4) return 0;
     return (chunk[4] == type[0] && chunk[5] == type[1] && chunk[6] == type[2] && chunk[7] == type[3]);
 }
 
+LV_FUNC_SECTION
 unsigned char lodepng_chunk_ancillary(const unsigned char * chunk)
 {
     return((chunk[4] & 32) != 0);
 }
 
+LV_FUNC_SECTION
 unsigned char lodepng_chunk_private(const unsigned char * chunk)
 {
     return((chunk[6] & 32) != 0);
 }
 
+LV_FUNC_SECTION
 unsigned char lodepng_chunk_safetocopy(const unsigned char * chunk)
 {
     return((chunk[7] & 32) != 0);
 }
 
+LV_FUNC_SECTION
 unsigned char * lodepng_chunk_data(unsigned char * chunk)
 {
     return &chunk[8];
 }
 
+LV_FUNC_SECTION
 const unsigned char * lodepng_chunk_data_const(const unsigned char * chunk)
 {
     return &chunk[8];
 }
 
+LV_FUNC_SECTION
 unsigned lodepng_chunk_check_crc(const unsigned char * chunk)
 {
     unsigned length = lodepng_chunk_length(chunk);
@@ -2919,6 +3015,7 @@ unsigned lodepng_chunk_check_crc(const unsigned char * chunk)
     else return 0;
 }
 
+LV_FUNC_SECTION
 void lodepng_chunk_generate_crc(unsigned char * chunk)
 {
     unsigned length = lodepng_chunk_length(chunk);
@@ -2926,6 +3023,7 @@ void lodepng_chunk_generate_crc(unsigned char * chunk)
     lodepng_set32bitInt(chunk + 8 + length, CRC);
 }
 
+LV_FUNC_SECTION
 unsigned char * lodepng_chunk_next(unsigned char * chunk, unsigned char * end)
 {
     size_t available_size = (size_t)(end - chunk);
@@ -2943,6 +3041,7 @@ unsigned char * lodepng_chunk_next(unsigned char * chunk, unsigned char * end)
     }
 }
 
+LV_FUNC_SECTION
 const unsigned char * lodepng_chunk_next_const(const unsigned char * chunk, const unsigned char * end)
 {
     size_t available_size = (size_t)(end - chunk);
@@ -2960,6 +3059,7 @@ const unsigned char * lodepng_chunk_next_const(const unsigned char * chunk, cons
     }
 }
 
+LV_FUNC_SECTION
 unsigned char * lodepng_chunk_find(unsigned char * chunk, unsigned char * end, const char type[5])
 {
     for(;;) {
@@ -2969,6 +3069,7 @@ unsigned char * lodepng_chunk_find(unsigned char * chunk, unsigned char * end, c
     }
 }
 
+LV_FUNC_SECTION
 const unsigned char * lodepng_chunk_find_const(const unsigned char * chunk, const unsigned char * end,
                                                const char type[5])
 {
@@ -2979,6 +3080,7 @@ const unsigned char * lodepng_chunk_find_const(const unsigned char * chunk, cons
     }
 }
 
+LV_FUNC_SECTION
 unsigned lodepng_chunk_append(unsigned char ** out, size_t * outsize, const unsigned char * chunk)
 {
     unsigned i;
@@ -3003,6 +3105,7 @@ unsigned lodepng_chunk_append(unsigned char ** out, size_t * outsize, const unsi
 set data or crc yet. Returns the start of the chunk in chunk. The start of
 the data is at chunk + 8. To finalize chunk, add the data, then use
 lodepng_chunk_generate_crc */
+LV_FUNC_SECTION
 static unsigned lodepng_chunk_init(unsigned char ** chunk,
                                    ucvector * out,
                                    size_t length, const char * type)
@@ -3023,6 +3126,7 @@ static unsigned lodepng_chunk_init(unsigned char ** chunk,
 }
 
 /* like lodepng_chunk_create but with custom allocsize */
+LV_FUNC_SECTION
 static unsigned lodepng_chunk_createv(ucvector * out,
                                       size_t length, const char * type, const unsigned char * data)
 {
@@ -3038,6 +3142,7 @@ static unsigned lodepng_chunk_createv(ucvector * out,
     return 0;
 }
 
+LV_FUNC_SECTION
 unsigned lodepng_chunk_create(unsigned char ** out, size_t * outsize,
                               size_t length, const char * type, const unsigned char * data)
 {
@@ -3054,6 +3159,7 @@ unsigned lodepng_chunk_create(unsigned char ** out, size_t * outsize,
 
 /*checks if the colortype is valid and the bitdepth bd is allowed for this colortype.
 Return value is a LodePNG error code.*/
+LV_FUNC_SECTION
 static unsigned checkColorValidity(LodePNGColorType colortype, unsigned bd)
 {
     switch(colortype) {
@@ -3080,6 +3186,7 @@ static unsigned checkColorValidity(LodePNGColorType colortype, unsigned bd)
     return 0; /*allowed color type / bits combination*/
 }
 
+LV_FUNC_SECTION
 static unsigned getNumColorChannels(LodePNGColorType colortype)
 {
     switch(colortype) {
@@ -3100,6 +3207,7 @@ static unsigned getNumColorChannels(LodePNGColorType colortype)
     }
 }
 
+LV_FUNC_SECTION
 static unsigned lodepng_get_bpp_lct(LodePNGColorType colortype, unsigned bitdepth)
 {
     /*bits per pixel is amount of channels * bits per channel*/
@@ -3108,6 +3216,7 @@ static unsigned lodepng_get_bpp_lct(LodePNGColorType colortype, unsigned bitdept
 
 /* ////////////////////////////////////////////////////////////////////////// */
 
+LV_FUNC_SECTION
 void lodepng_color_mode_init(LodePNGColorMode * info)
 {
     info->key_defined = 0;
@@ -3119,6 +3228,7 @@ void lodepng_color_mode_init(LodePNGColorMode * info)
 }
 
 /*allocates palette memory if needed, and initializes all colors to black*/
+LV_FUNC_SECTION
 static void lodepng_color_mode_alloc_palette(LodePNGColorMode * info)
 {
     size_t i;
@@ -3137,11 +3247,13 @@ static void lodepng_color_mode_alloc_palette(LodePNGColorMode * info)
     }
 }
 
+LV_FUNC_SECTION
 void lodepng_color_mode_cleanup(LodePNGColorMode * info)
 {
     lodepng_palette_clear(info);
 }
 
+LV_FUNC_SECTION
 unsigned lodepng_color_mode_copy(LodePNGColorMode * dest, const LodePNGColorMode * source)
 {
     lodepng_color_mode_cleanup(dest);
@@ -3154,6 +3266,7 @@ unsigned lodepng_color_mode_copy(LodePNGColorMode * dest, const LodePNGColorMode
     return 0;
 }
 
+LV_FUNC_SECTION
 LodePNGColorMode lodepng_color_mode_make(LodePNGColorType colortype, unsigned bitdepth)
 {
     LodePNGColorMode result;
@@ -3163,6 +3276,7 @@ LodePNGColorMode lodepng_color_mode_make(LodePNGColorType colortype, unsigned bi
     return result;
 }
 
+LV_FUNC_SECTION
 static int lodepng_color_mode_equal(const LodePNGColorMode * a, const LodePNGColorMode * b)
 {
     size_t i;
@@ -3181,6 +3295,7 @@ static int lodepng_color_mode_equal(const LodePNGColorMode * a, const LodePNGCol
     return 1;
 }
 
+LV_FUNC_SECTION
 void lodepng_palette_clear(LodePNGColorMode * info)
 {
     if(info->palette) lodepng_free(info->palette);
@@ -3188,6 +3303,7 @@ void lodepng_palette_clear(LodePNGColorMode * info)
     info->palettesize = 0;
 }
 
+LV_FUNC_SECTION
 unsigned lodepng_palette_add(LodePNGColorMode * info,
                              unsigned char r, unsigned char g, unsigned char b, unsigned char a)
 {
@@ -3207,31 +3323,37 @@ unsigned lodepng_palette_add(LodePNGColorMode * info,
 }
 
 /*calculate bits per pixel out of colortype and bitdepth*/
+LV_FUNC_SECTION
 unsigned lodepng_get_bpp(const LodePNGColorMode * info)
 {
     return lodepng_get_bpp_lct(info->colortype, info->bitdepth);
 }
 
+LV_FUNC_SECTION
 unsigned lodepng_get_channels(const LodePNGColorMode * info)
 {
     return getNumColorChannels(info->colortype);
 }
 
+LV_FUNC_SECTION
 unsigned lodepng_is_greyscale_type(const LodePNGColorMode * info)
 {
     return info->colortype == LCT_GREY || info->colortype == LCT_GREY_ALPHA;
 }
 
+LV_FUNC_SECTION
 unsigned lodepng_is_alpha_type(const LodePNGColorMode * info)
 {
     return (info->colortype & 4) != 0; /*4 or 6*/
 }
 
+LV_FUNC_SECTION
 unsigned lodepng_is_palette_type(const LodePNGColorMode * info)
 {
     return info->colortype == LCT_PALETTE;
 }
 
+LV_FUNC_SECTION
 unsigned lodepng_has_palette_alpha(const LodePNGColorMode * info)
 {
     size_t i;
@@ -3241,6 +3363,7 @@ unsigned lodepng_has_palette_alpha(const LodePNGColorMode * info)
     return 0;
 }
 
+LV_FUNC_SECTION
 unsigned lodepng_can_have_alpha(const LodePNGColorMode * info)
 {
     return info->key_defined
@@ -3248,6 +3371,7 @@ unsigned lodepng_can_have_alpha(const LodePNGColorMode * info)
            || lodepng_has_palette_alpha(info);
 }
 
+LV_FUNC_SECTION
 static size_t lodepng_get_raw_size_lct(unsigned w, unsigned h, LodePNGColorType colortype, unsigned bitdepth)
 {
     size_t bpp = lodepng_get_bpp_lct(colortype, bitdepth);
@@ -3255,6 +3379,7 @@ static size_t lodepng_get_raw_size_lct(unsigned w, unsigned h, LodePNGColorType
     return ((n / 8u) * bpp) + ((n & 7u) * bpp + 7u) / 8u;
 }
 
+LV_FUNC_SECTION
 size_t lodepng_get_raw_size(unsigned w, unsigned h, const LodePNGColorMode * color)
 {
     return lodepng_get_raw_size_lct(w, h, color->colortype, color->bitdepth);
@@ -3266,6 +3391,7 @@ size_t lodepng_get_raw_size(unsigned w, unsigned h, const LodePNGColorMode * col
 /*in an idat chunk, each scanline is a multiple of 8 bits, unlike the lodepng output buffer,
 and in addition has one extra byte per line: the filter byte. So this gives a larger
 result than lodepng_get_raw_size. Set h to 1 to get the size of 1 row including filter byte. */
+LV_FUNC_SECTION
 static size_t lodepng_get_raw_size_idat(unsigned w, unsigned h, unsigned bpp)
 {
     /* + 1 for the filter byte, and possibly plus padding bits per line. */
@@ -3283,6 +3409,7 @@ you can safely compute in a size_t (but not an unsigned):
 -amount of bytes in raw color model
 Returns 1 if overflow possible, 0 if not.
 */
+LV_FUNC_SECTION
 static int lodepng_pixel_overflow(unsigned w, unsigned h,
                                   const LodePNGColorMode * pngcolor, const LodePNGColorMode * rawcolor)
 {
@@ -3307,6 +3434,7 @@ static int lodepng_pixel_overflow(unsigned w, unsigned h,
 
 #ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
 
+LV_FUNC_SECTION
 static void LodePNGUnknownChunks_init(LodePNGInfo * info)
 {
     unsigned i;
@@ -3314,12 +3442,14 @@ static void LodePNGUnknownChunks_init(LodePNGInfo * info)
     for(i = 0; i != 3; ++i) info->unknown_chunks_size[i] = 0;
 }
 
+LV_FUNC_SECTION
 static void LodePNGUnknownChunks_cleanup(LodePNGInfo * info)
 {
     unsigned i;
     for(i = 0; i != 3; ++i) lodepng_free(info->unknown_chunks_data[i]);
 }
 
+LV_FUNC_SECTION
 static unsigned LodePNGUnknownChunks_copy(LodePNGInfo * dest, const LodePNGInfo * src)
 {
     unsigned i;
@@ -3341,6 +3471,7 @@ static unsigned LodePNGUnknownChunks_copy(LodePNGInfo * dest, const LodePNGInfo
 
 /******************************************************************************/
 
+LV_FUNC_SECTION
 static void LodePNGText_init(LodePNGInfo * info)
 {
     info->text_num = 0;
@@ -3348,6 +3479,7 @@ static void LodePNGText_init(LodePNGInfo * info)
     info->text_strings = NULL;
 }
 
+LV_FUNC_SECTION
 static void LodePNGText_cleanup(LodePNGInfo * info)
 {
     size_t i;
@@ -3359,6 +3491,7 @@ static void LodePNGText_cleanup(LodePNGInfo * info)
     lodepng_free(info->text_strings);
 }
 
+LV_FUNC_SECTION
 static unsigned LodePNGText_copy(LodePNGInfo * dest, const LodePNGInfo * source)
 {
     size_t i = 0;
@@ -3371,6 +3504,7 @@ static unsigned LodePNGText_copy(LodePNGInfo * dest, const LodePNGInfo * source)
     return 0;
 }
 
+LV_FUNC_SECTION
 static unsigned lodepng_add_text_sized(LodePNGInfo * info, const char * key, const char * str, size_t size)
 {
     char ** new_keys = (char **)(lodepng_realloc(info->text_keys, sizeof(char *) * (info->text_num + 1)));
@@ -3389,11 +3523,13 @@ static unsigned lodepng_add_text_sized(LodePNGInfo * info, const char * key, con
     return 0;
 }
 
+LV_FUNC_SECTION
 unsigned lodepng_add_text(LodePNGInfo * info, const char * key, const char * str)
 {
     return lodepng_add_text_sized(info, key, str, lodepng_strlen(str));
 }
 
+LV_FUNC_SECTION
 void lodepng_clear_text(LodePNGInfo * info)
 {
     LodePNGText_cleanup(info);
@@ -3401,6 +3537,7 @@ void lodepng_clear_text(LodePNGInfo * info)
 
 /******************************************************************************/
 
+LV_FUNC_SECTION
 static void LodePNGIText_init(LodePNGInfo * info)
 {
     info->itext_num = 0;
@@ -3410,6 +3547,7 @@ static void LodePNGIText_init(LodePNGInfo * info)
     info->itext_strings = NULL;
 }
 
+LV_FUNC_SECTION
 static void LodePNGIText_cleanup(LodePNGInfo * info)
 {
     size_t i;
@@ -3425,6 +3563,7 @@ static void LodePNGIText_cleanup(LodePNGInfo * info)
     lodepng_free(info->itext_strings);
 }
 
+LV_FUNC_SECTION
 static unsigned LodePNGIText_copy(LodePNGInfo * dest, const LodePNGInfo * source)
 {
     size_t i = 0;
@@ -3440,11 +3579,13 @@ static unsigned LodePNGIText_copy(LodePNGInfo * dest, const LodePNGInfo * source
     return 0;
 }
 
+LV_FUNC_SECTION
 void lodepng_clear_itext(LodePNGInfo * info)
 {
     LodePNGIText_cleanup(info);
 }
 
+LV_FUNC_SECTION
 static unsigned lodepng_add_itext_sized(LodePNGInfo * info, const char * key, const char * langtag,
                                         const char * transkey, const char * str, size_t size)
 {
@@ -3470,6 +3611,7 @@ static unsigned lodepng_add_itext_sized(LodePNGInfo * info, const char * key, co
     return 0;
 }
 
+LV_FUNC_SECTION
 unsigned lodepng_add_itext(LodePNGInfo * info, const char * key, const char * langtag,
                            const char * transkey, const char * str)
 {
@@ -3477,6 +3619,7 @@ unsigned lodepng_add_itext(LodePNGInfo * info, const char * key, const char * la
 }
 
 /* same as set but does not delete */
+LV_FUNC_SECTION
 static unsigned lodepng_assign_icc(LodePNGInfo * info, const char * name, const unsigned char * profile,
                                    unsigned profile_size)
 {
@@ -3493,6 +3636,7 @@ static unsigned lodepng_assign_icc(LodePNGInfo * info, const char * name, const
     return 0; /*ok*/
 }
 
+LV_FUNC_SECTION
 unsigned lodepng_set_icc(LodePNGInfo * info, const char * name, const unsigned char * profile, unsigned profile_size)
 {
     if(info->iccp_name) lodepng_clear_icc(info);
@@ -3501,6 +3645,7 @@ unsigned lodepng_set_icc(LodePNGInfo * info, const char * name, const unsigned c
     return lodepng_assign_icc(info, name, profile, profile_size);
 }
 
+LV_FUNC_SECTION
 void lodepng_clear_icc(LodePNGInfo * info)
 {
     string_cleanup(&info->iccp_name);
@@ -3511,6 +3656,7 @@ void lodepng_clear_icc(LodePNGInfo * info)
 }
 #endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
 
+LV_FUNC_SECTION
 void lodepng_info_init(LodePNGInfo * info)
 {
     lodepng_color_mode_init(&info->color);
@@ -3541,6 +3687,7 @@ void lodepng_info_init(LodePNGInfo * info)
 #endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
 }
 
+LV_FUNC_SECTION
 void lodepng_info_cleanup(LodePNGInfo * info)
 {
     lodepng_color_mode_cleanup(&info->color);
@@ -3554,6 +3701,7 @@ void lodepng_info_cleanup(LodePNGInfo * info)
 #endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
 }
 
+LV_FUNC_SECTION
 unsigned lodepng_info_copy(LodePNGInfo * dest, const LodePNGInfo * source)
 {
     lodepng_info_cleanup(dest);
@@ -3577,6 +3725,7 @@ unsigned lodepng_info_copy(LodePNGInfo * dest, const LodePNGInfo * source)
 /* ////////////////////////////////////////////////////////////////////////// */
 
 /*index: bitgroup index, bits: bitgroup size(1, 2 or 4), in: bitgroup value, out: octet array to add bits to*/
+LV_FUNC_SECTION
 static void addColorBits(unsigned char * out, size_t index, unsigned bits, unsigned in)
 {
     unsigned m = bits == 1 ? 7 : bits == 2 ? 3 : 1; /*8 / bits - 1*/
@@ -3601,12 +3750,14 @@ struct ColorTree {
     int index; /*the payload. Only has a meaningful value if this is in the last level*/
 };
 
+LV_FUNC_SECTION
 static void color_tree_init(ColorTree * tree)
 {
     lodepng_memset(tree->children, 0, 16 * sizeof(*tree->children));
     tree->index = -1;
 }
 
+LV_FUNC_SECTION
 static void color_tree_cleanup(ColorTree * tree)
 {
     int i;
@@ -3619,6 +3770,7 @@ static void color_tree_cleanup(ColorTree * tree)
 }
 
 /*returns -1 if color not present, its index otherwise*/
+LV_FUNC_SECTION
 static int color_tree_get(ColorTree * tree, unsigned char r, unsigned char g, unsigned char b, unsigned char a)
 {
     int bit = 0;
@@ -3631,6 +3783,7 @@ static int color_tree_get(ColorTree * tree, unsigned char r, unsigned char g, un
 }
 
 #ifdef LODEPNG_COMPILE_ENCODER
+LV_FUNC_SECTION
 static int color_tree_has(ColorTree * tree, unsigned char r, unsigned char g, unsigned char b, unsigned char a)
 {
     return color_tree_get(tree, r, g, b, a) >= 0;
@@ -3640,6 +3793,7 @@ static int color_tree_has(ColorTree * tree, unsigned char r, unsigned char g, un
 /*color is not allowed to already exist.
 Index should be >= 0 (it's signed to be compatible with using -1 for "doesn't exist")
 Returns error code, or 0 if ok*/
+LV_FUNC_SECTION
 static unsigned color_tree_add(ColorTree * tree,
                                unsigned char r, unsigned char g, unsigned char b, unsigned char a, unsigned index)
 {
@@ -3658,6 +3812,7 @@ static unsigned color_tree_add(ColorTree * tree,
 }
 
 /*put a pixel, given its RGBA color, into image of any color type*/
+LV_FUNC_SECTION
 static unsigned rgba8ToPixel(unsigned char * out, size_t i,
                              const LodePNGColorMode * mode, ColorTree * tree /*for palette*/,
                              unsigned char r, unsigned char g, unsigned char b, unsigned char a)
@@ -3720,6 +3875,7 @@ static unsigned rgba8ToPixel(unsigned char * out, size_t i,
 }
 
 /*put a pixel, given its RGBA16 color, into image of any color 16-bitdepth type*/
+LV_FUNC_SECTION
 static void rgba16ToPixel(unsigned char * out, size_t i,
                           const LodePNGColorMode * mode,
                           unsigned short r, unsigned short g, unsigned short b, unsigned short a)
@@ -3757,6 +3913,7 @@ static void rgba16ToPixel(unsigned char * out, size_t i,
 }
 
 /*Get RGBA8 color of pixel with index i (y * width + x) from the raw image with given color type.*/
+LV_FUNC_SECTION
 static void getPixelColorRGBA8(unsigned char * r, unsigned char * g,
                                unsigned char * b, unsigned char * a,
                                const unsigned char * in, size_t i,
@@ -3843,6 +4000,7 @@ static void getPixelColorRGBA8(unsigned char * r, unsigned char * g,
 mode test cases, optimized to convert the colors much faster, when converting
 to the common case of RGBA with 8 bit per channel. buffer must be RGBA with
 enough memory.*/
+LV_FUNC_SECTION
 static void getPixelColorsRGBA8(unsigned char * LODEPNG_RESTRICT buffer, size_t numpixels,
                                 const unsigned char * LODEPNG_RESTRICT in,
                                 const LodePNGColorMode * mode)
@@ -3950,6 +4108,7 @@ static void getPixelColorsRGBA8(unsigned char * LODEPNG_RESTRICT buffer, size_t
 }
 
 /*Similar to getPixelColorsRGBA8, but with 3-channel RGB output.*/
+LV_FUNC_SECTION
 static void getPixelColorsRGB8(unsigned char * LODEPNG_RESTRICT buffer, size_t numpixels,
                                const unsigned char * LODEPNG_RESTRICT in,
                                const LodePNGColorMode * mode)
@@ -4035,6 +4194,7 @@ static void getPixelColorsRGB8(unsigned char * LODEPNG_RESTRICT buffer, size_t n
 
 /*Get RGBA16 color of pixel with index i (y * width + x) from the raw image with
 given color type, but the given color type must be 16-bit itself.*/
+LV_FUNC_SECTION
 static void getPixelColorRGBA16(unsigned short * r, unsigned short * g, unsigned short * b, unsigned short * a,
                                 const unsigned char * in, size_t i, const LodePNGColorMode * mode)
 {
@@ -4065,6 +4225,7 @@ static void getPixelColorRGBA16(unsigned short * r, unsigned short * g, unsigned
     }
 }
 
+LV_FUNC_SECTION
 unsigned lodepng_convert(unsigned char * out, const unsigned char * in,
                          const LodePNGColorMode * mode_out, const LodePNGColorMode * mode_in,
                          unsigned w, unsigned h)
@@ -4150,6 +4311,7 @@ function, do not use to process all pixels of an image. Alpha channel not suppor
 this is for bKGD, supporting alpha may prevent it from finding a color in the palette, from the
 specification it looks like bKGD should ignore the alpha values of the palette since it can use
 any palette index but doesn't have an alpha channel. Idem with ignoring color key. */
+LV_FUNC_SECTION
 static unsigned lodepng_convert_rgb(
     unsigned * r_out, unsigned * g_out, unsigned * b_out,
     unsigned r_in, unsigned g_in, unsigned b_in,
@@ -4209,6 +4371,7 @@ static unsigned lodepng_convert_rgb(
 
 #ifdef LODEPNG_COMPILE_ENCODER
 
+LV_FUNC_SECTION
 void lodepng_color_stats_init(LodePNGColorStats * stats)
 {
     /*stats*/
@@ -4237,6 +4400,7 @@ void lodepng_color_stats_init(LodePNGColorStats * stats)
 }*/
 
 /*Returns how many bits needed to represent given value (max 8 bit)*/
+LV_FUNC_SECTION
 static unsigned getValueRequiredBits(unsigned char value)
 {
     if(value == 0 || value == 255) return 1;
@@ -4246,6 +4410,7 @@ static unsigned getValueRequiredBits(unsigned char value)
 }
 
 /*stats must already have been inited. */
+LV_FUNC_SECTION
 unsigned lodepng_compute_color_stats(LodePNGColorStats * stats,
                                      const unsigned char * in, unsigned w, unsigned h,
                                      const LodePNGColorMode * mode_in)
@@ -4439,6 +4604,7 @@ cleanup:
 /*Adds a single color to the color stats. The stats must already have been inited. The color must be given as 16-bit
 (with 2 bytes repeating for 8-bit and 65535 for opaque alpha channel). This function is expensive, do not call it for
 all pixels of an image but only for a few additional values. */
+LV_FUNC_SECTION
 static unsigned lodepng_color_stats_add(LodePNGColorStats * stats,
                                         unsigned r, unsigned g, unsigned b, unsigned a)
 {
@@ -4469,6 +4635,7 @@ Minimal PNG color model means the color type and bit depth that gives smallest a
 e.g. gray if only grayscale pixels, palette if less than 256 colors, color key if only single transparent color, ...
 This is used if auto_convert is enabled (it is by default).
 */
+LV_FUNC_SECTION
 static unsigned auto_choose_color(LodePNGColorMode * mode_out,
                                   const LodePNGColorMode * mode_in,
                                   const LodePNGColorStats * stats)
@@ -4539,6 +4706,7 @@ static unsigned auto_choose_color(LodePNGColorMode * mode_out,
 #endif /* #ifdef LODEPNG_COMPILE_ENCODER */
 
 /*Paeth predictor, used by PNG filter type 4*/
+LV_FUNC_SECTION
 static unsigned char paethPredictor(unsigned char a, unsigned char b, unsigned char c)
 {
     /* the subtractions of unsigned char cast it to a signed type.
@@ -4577,6 +4745,7 @@ bpp: bits per pixel
 "padded" is only relevant if bpp is less than 8 and a scanline or image does not
  end at a full byte
 */
+LV_FUNC_SECTION
 static void Adam7_getpassvalues(unsigned passw[7], unsigned passh[7], size_t filter_passstart[8],
                                 size_t padded_passstart[8], size_t passstart[8], unsigned w, unsigned h, unsigned bpp)
 {
@@ -4610,6 +4779,7 @@ static void Adam7_getpassvalues(unsigned passw[7], unsigned passh[7], size_t fil
 /* ////////////////////////////////////////////////////////////////////////// */
 
 /*read the information from the header and store it in the LodePNGInfo. return value is error*/
+LV_FUNC_SECTION
 unsigned lodepng_inspect(unsigned * w, unsigned * h, LodePNGState * state,
                          const unsigned char * in, size_t insize)
 {
@@ -4675,6 +4845,7 @@ unsigned lodepng_inspect(unsigned * w, unsigned * h, LodePNGState * state,
     return state->error;
 }
 
+LV_FUNC_SECTION
 static unsigned unfilterScanline(unsigned char * recon, const unsigned char * scanline, const unsigned char * precon,
                                  size_t bytewidth, unsigned char filterType, size_t length)
 {
@@ -4941,6 +5112,7 @@ static unsigned unfilterScanline(unsigned char * recon, const unsigned char * sc
     return 0;
 }
 
+LV_FUNC_SECTION
 static unsigned unfilter(unsigned char * out, const unsigned char * in, unsigned w, unsigned h, unsigned bpp)
 {
     /*
@@ -4983,6 +5155,7 @@ out must be big enough AND must be 0 everywhere if bpp < 8 in the current implem
 (because that's likely a little bit faster)
 NOTE: comments about padding bits are only relevant if bpp < 8
 */
+LV_FUNC_SECTION
 static void Adam7_deinterlace(unsigned char * out, const unsigned char * in, unsigned w, unsigned h, unsigned bpp)
 {
     unsigned passw[7], passh[7];
@@ -5025,6 +5198,7 @@ static void Adam7_deinterlace(unsigned char * out, const unsigned char * in, uns
     }
 }
 
+LV_FUNC_SECTION
 static void removePaddingBits(unsigned char * out, const unsigned char * in,
                               size_t olinebits, size_t ilinebits, unsigned h)
 {
@@ -5053,6 +5227,7 @@ static void removePaddingBits(unsigned char * out, const unsigned char * in,
 /*out must be buffer big enough to contain full image, and in must contain the full decompressed data from
 the IDAT chunks (with filter index bytes and possible padding bits)
 return value is error*/
+LV_FUNC_SECTION
 static unsigned postProcessScanlines(unsigned char * out, unsigned char * in,
                                      unsigned w, unsigned h, const LodePNGInfo * info_png)
 {
@@ -5099,6 +5274,7 @@ static unsigned postProcessScanlines(unsigned char * out, unsigned char * in,
     return 0;
 }
 
+LV_FUNC_SECTION
 static unsigned readChunk_PLTE(LodePNGColorMode * color, const unsigned char * data, size_t chunkLength)
 {
     unsigned pos = 0, i;
@@ -5120,6 +5296,7 @@ static unsigned readChunk_PLTE(LodePNGColorMode * color, const unsigned char * d
     return 0; /* OK */
 }
 
+LV_FUNC_SECTION
 static unsigned readChunk_tRNS(LodePNGColorMode * color, const unsigned char * data, size_t chunkLength)
 {
     unsigned i;
@@ -5153,6 +5330,7 @@ static unsigned readChunk_tRNS(LodePNGColorMode * color, const unsigned char * d
 
 #ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
 /*background color chunk (bKGD)*/
+LV_FUNC_SECTION
 static unsigned readChunk_bKGD(LodePNGInfo * info, const unsigned char * data, size_t chunkLength)
 {
     if(info->color.colortype == LCT_PALETTE) {
@@ -5188,6 +5366,7 @@ static unsigned readChunk_bKGD(LodePNGInfo * info, const unsigned char * data, s
 }
 
 /*text chunk (tEXt)*/
+LV_FUNC_SECTION
 static unsigned readChunk_tEXt(LodePNGInfo * info, const unsigned char * data, size_t chunkLength)
 {
     unsigned error = 0;
@@ -5229,6 +5408,7 @@ static unsigned readChunk_tEXt(LodePNGInfo * info, const unsigned char * data, s
 }
 
 /*compressed text chunk (zTXt)*/
+LV_FUNC_SECTION
 static unsigned readChunk_zTXt(LodePNGInfo * info, const LodePNGDecoderSettings * decoder,
                                const unsigned char * data, size_t chunkLength)
 {
@@ -5277,6 +5457,7 @@ static unsigned readChunk_zTXt(LodePNGInfo * info, const LodePNGDecoderSettings
 }
 
 /*international text chunk (iTXt)*/
+LV_FUNC_SECTION
 static unsigned readChunk_iTXt(LodePNGInfo * info, const LodePNGDecoderSettings * decoder,
                                const unsigned char * data, size_t chunkLength)
 {
@@ -5365,6 +5546,7 @@ static unsigned readChunk_iTXt(LodePNGInfo * info, const LodePNGDecoderSettings
     return error;
 }
 
+LV_FUNC_SECTION
 static unsigned readChunk_tIME(LodePNGInfo * info, const unsigned char * data, size_t chunkLength)
 {
     if(chunkLength != 7) return 73; /*invalid tIME chunk size*/
@@ -5380,6 +5562,7 @@ static unsigned readChunk_tIME(LodePNGInfo * info, const unsigned char * data, s
     return 0; /* OK */
 }
 
+LV_FUNC_SECTION
 static unsigned readChunk_pHYs(LodePNGInfo * info, const unsigned char * data, size_t chunkLength)
 {
     if(chunkLength != 9) return 74; /*invalid pHYs chunk size*/
@@ -5392,6 +5575,7 @@ static unsigned readChunk_pHYs(LodePNGInfo * info, const unsigned char * data, s
     return 0; /* OK */
 }
 
+LV_FUNC_SECTION
 static unsigned readChunk_gAMA(LodePNGInfo * info, const unsigned char * data, size_t chunkLength)
 {
     if(chunkLength != 4) return 96; /*invalid gAMA chunk size*/
@@ -5402,6 +5586,7 @@ static unsigned readChunk_gAMA(LodePNGInfo * info, const unsigned char * data, s
     return 0; /* OK */
 }
 
+LV_FUNC_SECTION
 static unsigned readChunk_cHRM(LodePNGInfo * info, const unsigned char * data, size_t chunkLength)
 {
     if(chunkLength != 32) return 97; /*invalid cHRM chunk size*/
@@ -5419,6 +5604,7 @@ static unsigned readChunk_cHRM(LodePNGInfo * info, const unsigned char * data, s
     return 0; /* OK */
 }
 
+LV_FUNC_SECTION
 static unsigned readChunk_sRGB(LodePNGInfo * info, const unsigned char * data, size_t chunkLength)
 {
     if(chunkLength != 1) return 98; /*invalid sRGB chunk size (this one is never ignored)*/
@@ -5429,6 +5615,7 @@ static unsigned readChunk_sRGB(LodePNGInfo * info, const unsigned char * data, s
     return 0; /* OK */
 }
 
+LV_FUNC_SECTION
 static unsigned readChunk_iCCP(LodePNGInfo * info, const LodePNGDecoderSettings * decoder,
                                const unsigned char * data, size_t chunkLength)
 {
@@ -5471,6 +5658,7 @@ static unsigned readChunk_iCCP(LodePNGInfo * info, const LodePNGDecoderSettings
 }
 
 /*significant bits chunk (sBIT)*/
+LV_FUNC_SECTION
 static unsigned readChunk_sBIT(LodePNGInfo * info, const unsigned char * data, size_t chunkLength)
 {
     unsigned bitdepth = (info->color.colortype == LCT_PALETTE) ? 8 : info->color.bitdepth;
@@ -5516,6 +5704,7 @@ static unsigned readChunk_sBIT(LodePNGInfo * info, const unsigned char * data, s
 }
 #endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
 
+LV_FUNC_SECTION
 unsigned lodepng_inspect_chunk(LodePNGState * state, size_t pos,
                                const unsigned char * in, size_t insize)
 {
@@ -5585,6 +5774,7 @@ unsigned lodepng_inspect_chunk(LodePNGState * state, size_t pos,
 }
 
 /*read a PNG, the result will be in the same color type as the PNG (hence "generic")*/
+LV_FUNC_SECTION
 static void decodeGeneric(unsigned char ** out, unsigned * w, unsigned * h,
                           LodePNGState * state,
                           const unsigned char * in, size_t insize)
@@ -5805,6 +5995,7 @@ static void decodeGeneric(unsigned char ** out, unsigned * w, unsigned * h,
     lodepng_free(scanlines);
 }
 
+LV_FUNC_SECTION
 unsigned lodepng_decode(unsigned char ** out, unsigned * w, unsigned * h,
                         LodePNGState * state,
                         const unsigned char * in, size_t insize)
@@ -5851,6 +6042,7 @@ unsigned lodepng_decode(unsigned char ** out, unsigned * w, unsigned * h,
     return state->error;
 }
 
+LV_FUNC_SECTION
 unsigned lodepng_decode_memory(unsigned char ** out, unsigned * w, unsigned * h, const unsigned char * in,
                                size_t insize, LodePNGColorType colortype, unsigned bitdepth)
 {
@@ -5869,17 +6061,20 @@ unsigned lodepng_decode_memory(unsigned char ** out, unsigned * w, unsigned * h,
     return error;
 }
 
+LV_FUNC_SECTION
 unsigned lodepng_decode32(unsigned char ** out, unsigned * w, unsigned * h, const unsigned char * in, size_t insize)
 {
     return lodepng_decode_memory(out, w, h, in, insize, LCT_RGBA, 8);
 }
 
+LV_FUNC_SECTION
 unsigned lodepng_decode24(unsigned char ** out, unsigned * w, unsigned * h, const unsigned char * in, size_t insize)
 {
     return lodepng_decode_memory(out, w, h, in, insize, LCT_RGB, 8);
 }
 
 #ifdef LODEPNG_COMPILE_DISK
+LV_FUNC_SECTION
 unsigned lodepng_decode_file(unsigned char ** out, unsigned * w, unsigned * h, const char * filename,
                              LodePNGColorType colortype, unsigned bitdepth)
 {
@@ -5895,17 +6090,20 @@ unsigned lodepng_decode_file(unsigned char ** out, unsigned * w, unsigned * h, c
     return error;
 }
 
+LV_FUNC_SECTION
 unsigned lodepng_decode32_file(unsigned char ** out, unsigned * w, unsigned * h, const char * filename)
 {
     return lodepng_decode_file(out, w, h, filename, LCT_RGBA, 8);
 }
 
+LV_FUNC_SECTION
 unsigned lodepng_decode24_file(unsigned char ** out, unsigned * w, unsigned * h, const char * filename)
 {
     return lodepng_decode_file(out, w, h, filename, LCT_RGB, 8);
 }
 #endif /*LODEPNG_COMPILE_DISK*/
 
+LV_FUNC_SECTION
 void lodepng_decoder_settings_init(LodePNGDecoderSettings * settings)
 {
     settings->color_convert = 1;
@@ -5925,6 +6123,7 @@ void lodepng_decoder_settings_init(LodePNGDecoderSettings * settings)
 
 #if defined(LODEPNG_COMPILE_DECODER) || defined(LODEPNG_COMPILE_ENCODER)
 
+LV_FUNC_SECTION
 void lodepng_state_init(LodePNGState * state)
 {
 #ifdef LODEPNG_COMPILE_DECODER
@@ -5938,12 +6137,14 @@ void lodepng_state_init(LodePNGState * state)
     state->error = 1;
 }
 
+LV_FUNC_SECTION
 void lodepng_state_cleanup(LodePNGState * state)
 {
     lodepng_color_mode_cleanup(&state->info_raw);
     lodepng_info_cleanup(&state->info_png);
 }
 
+LV_FUNC_SECTION
 void lodepng_state_copy(LodePNGState * dest, const LodePNGState * source)
 {
     lodepng_state_cleanup(dest);
@@ -5965,6 +6166,7 @@ void lodepng_state_copy(LodePNGState * dest, const LodePNGState * source)
 /* ////////////////////////////////////////////////////////////////////////// */
 
 
+LV_FUNC_SECTION
 static unsigned writeSignature(ucvector * out)
 {
     size_t pos = out->size;
@@ -5975,6 +6177,7 @@ static unsigned writeSignature(ucvector * out)
     return 0;
 }
 
+LV_FUNC_SECTION
 static unsigned addChunk_IHDR(ucvector * out, unsigned w, unsigned h,
                               LodePNGColorType colortype, unsigned bitdepth, unsigned interlace_method)
 {
@@ -5995,6 +6198,7 @@ static unsigned addChunk_IHDR(ucvector * out, unsigned w, unsigned h,
 }
 
 /* only adds the chunk if needed (there is a key or palette with alpha) */
+LV_FUNC_SECTION
 static unsigned addChunk_PLTE(ucvector * out, const LodePNGColorMode * info)
 {
     unsigned char * chunk;
@@ -6017,6 +6221,7 @@ static unsigned addChunk_PLTE(ucvector * out, const LodePNGColorMode * info)
     return 0;
 }
 
+LV_FUNC_SECTION
 static unsigned addChunk_tRNS(ucvector * out, const LodePNGColorMode * info)
 {
     unsigned char * chunk = 0;
@@ -6057,6 +6262,7 @@ static unsigned addChunk_tRNS(ucvector * out, const LodePNGColorMode * info)
     return 0;
 }
 
+LV_FUNC_SECTION
 static unsigned addChunk_IDAT(ucvector * out, const unsigned char * data, size_t datasize,
                               LodePNGCompressSettings * zlibsettings)
 {
@@ -6072,6 +6278,7 @@ static unsigned addChunk_IDAT(ucvector * out, const unsigned char * data, size_t
     return error;
 }
 
+LV_FUNC_SECTION
 static unsigned addChunk_IEND(ucvector * out)
 {
     return lodepng_chunk_createv(out, 0, "IEND", 0);
@@ -6079,6 +6286,7 @@ static unsigned addChunk_IEND(ucvector * out)
 
 #ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
 
+LV_FUNC_SECTION
 static unsigned addChunk_tEXt(ucvector * out, const char * keyword, const char * textstring)
 {
     unsigned char * chunk = 0;
@@ -6093,6 +6301,7 @@ static unsigned addChunk_tEXt(ucvector * out, const char * keyword, const char *
     return 0;
 }
 
+LV_FUNC_SECTION
 static unsigned addChunk_zTXt(ucvector * out, const char * keyword, const char * textstring,
                               LodePNGCompressSettings * zlibsettings)
 {
@@ -6122,6 +6331,7 @@ static unsigned addChunk_zTXt(ucvector * out, const char * keyword, const char *
     return error;
 }
 
+LV_FUNC_SECTION
 static unsigned addChunk_iTXt(ucvector * out, unsigned compress, const char * keyword, const char * langtag,
                               const char * transkey, const char * textstring, LodePNGCompressSettings * zlibsettings)
 {
@@ -6168,6 +6378,7 @@ static unsigned addChunk_iTXt(ucvector * out, unsigned compress, const char * ke
     return error;
 }
 
+LV_FUNC_SECTION
 static unsigned addChunk_bKGD(ucvector * out, const LodePNGInfo * info)
 {
     unsigned char * chunk = 0;
@@ -6193,6 +6404,7 @@ static unsigned addChunk_bKGD(ucvector * out, const LodePNGInfo * info)
     return 0;
 }
 
+LV_FUNC_SECTION
 static unsigned addChunk_tIME(ucvector * out, const LodePNGTime * time)
 {
     unsigned char * chunk;
@@ -6208,6 +6420,7 @@ static unsigned addChunk_tIME(ucvector * out, const LodePNGTime * time)
     return 0;
 }
 
+LV_FUNC_SECTION
 static unsigned addChunk_pHYs(ucvector * out, const LodePNGInfo * info)
 {
     unsigned char * chunk;
@@ -6219,6 +6432,7 @@ static unsigned addChunk_pHYs(ucvector * out, const LodePNGInfo * info)
     return 0;
 }
 
+LV_FUNC_SECTION
 static unsigned addChunk_gAMA(ucvector * out, const LodePNGInfo * info)
 {
     unsigned char * chunk;
@@ -6228,6 +6442,7 @@ static unsigned addChunk_gAMA(ucvector * out, const LodePNGInfo * info)
     return 0;
 }
 
+LV_FUNC_SECTION
 static unsigned addChunk_cHRM(ucvector * out, const LodePNGInfo * info)
 {
     unsigned char * chunk;
@@ -6244,12 +6459,14 @@ static unsigned addChunk_cHRM(ucvector * out, const LodePNGInfo * info)
     return 0;
 }
 
+LV_FUNC_SECTION
 static unsigned addChunk_sRGB(ucvector * out, const LodePNGInfo * info)
 {
     unsigned char data = info->srgb_intent;
     return lodepng_chunk_createv(out, 1, "sRGB", &data);
 }
 
+LV_FUNC_SECTION
 static unsigned addChunk_iCCP(ucvector * out, const LodePNGInfo * info, LodePNGCompressSettings * zlibsettings)
 {
     unsigned error = 0;
@@ -6277,6 +6494,7 @@ static unsigned addChunk_iCCP(ucvector * out, const LodePNGInfo * info, LodePNGC
     return error;
 }
 
+LV_FUNC_SECTION
 static unsigned addChunk_sBIT(ucvector * out, const LodePNGInfo * info)
 {
     unsigned bitdepth = (info->color.colortype == LCT_PALETTE) ? 8 : info->color.bitdepth;
@@ -6319,6 +6537,7 @@ static unsigned addChunk_sBIT(ucvector * out, const LodePNGInfo * info)
 
 #endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
 
+LV_FUNC_SECTION
 static void filterScanline(unsigned char * out, const unsigned char * scanline, const unsigned char * prevline,
                            size_t length, size_t bytewidth, unsigned char filterType)
 {
@@ -6369,6 +6588,7 @@ static void filterScanline(unsigned char * out, const unsigned char * scanline,
 }
 
 /* integer binary logarithm, max return value is 31 */
+LV_FUNC_SECTION
 static size_t ilog2(size_t i)
 {
     size_t result = 0;
@@ -6395,6 +6615,7 @@ static size_t ilog2(size_t i)
 }
 
 /* integer approximation for i * log2(i), helper function for LFS_ENTROPY */
+LV_FUNC_SECTION
 static size_t ilog2i(size_t i)
 {
     size_t l;
@@ -6405,6 +6626,7 @@ static size_t ilog2i(size_t i)
     return i * l + ((i - (((size_t)1) << l)) << 1u);
 }
 
+LV_FUNC_SECTION
 static unsigned filter(unsigned char * out, const unsigned char * in, unsigned w, unsigned h,
                        const LodePNGColorMode * color, const LodePNGEncoderSettings * settings)
 {
@@ -6605,6 +6827,7 @@ static unsigned filter(unsigned char * out, const unsigned char * in, unsigned w
     return error;
 }
 
+LV_FUNC_SECTION
 static void addPaddingBits(unsigned char * out, const unsigned char * in,
                            size_t olinebits, size_t ilinebits, unsigned h)
 {
@@ -6636,6 +6859,7 @@ in has the following size in bits: w * h * bpp.
 out is possibly bigger due to padding bits between reduced images
 NOTE: comments about padding bits are only relevant if bpp < 8
 */
+LV_FUNC_SECTION
 static void Adam7_interlace(unsigned char * out, const unsigned char * in, unsigned w, unsigned h, unsigned bpp)
 {
     unsigned passw[7], passh[7];
@@ -6679,6 +6903,7 @@ static void Adam7_interlace(unsigned char * out, const unsigned char * in, unsig
 
 /*out must be buffer big enough to contain uncompressed IDAT chunk data, and in must contain the full image.
 return value is error**/
+LV_FUNC_SECTION
 static unsigned preProcessScanlines(unsigned char ** out, size_t * outsize, const unsigned char * in,
                                     unsigned w, unsigned h,
                                     const LodePNGInfo * info_png, const LodePNGEncoderSettings * settings)
@@ -6757,6 +6982,7 @@ static unsigned preProcessScanlines(unsigned char ** out, size_t * outsize, cons
 }
 
 #ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
+LV_FUNC_SECTION
 static unsigned addUnknownChunks(ucvector * out, unsigned char * data, size_t datasize)
 {
     unsigned char * inchunk = data;
@@ -6768,6 +6994,7 @@ static unsigned addUnknownChunks(ucvector * out, unsigned char * data, size_t da
     return 0;
 }
 
+LV_FUNC_SECTION
 static unsigned isGrayICCProfile(const unsigned char * profile, unsigned size)
 {
     /*
@@ -6783,6 +7010,7 @@ static unsigned isGrayICCProfile(const unsigned char * profile, unsigned size)
     return profile[16] == 'G' &&  profile[17] == 'R' &&  profile[18] == 'A' &&  profile[19] == 'Y';
 }
 
+LV_FUNC_SECTION
 static unsigned isRGBICCProfile(const unsigned char * profile, unsigned size)
 {
     /* See comment in isGrayICCProfile*/
@@ -6791,6 +7019,7 @@ static unsigned isRGBICCProfile(const unsigned char * profile, unsigned size)
 }
 #endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
 
+LV_FUNC_SECTION
 unsigned lodepng_encode(unsigned char ** out, size_t * outsize,
                         const unsigned char * image, unsigned w, unsigned h,
                         LodePNGState * state)
@@ -7129,6 +7358,7 @@ cleanup:
     return state->error;
 }
 
+LV_FUNC_SECTION
 unsigned lodepng_encode_memory(unsigned char ** out, size_t * outsize, const unsigned char * image,
                                unsigned w, unsigned h, LodePNGColorType colortype, unsigned bitdepth)
 {
@@ -7145,17 +7375,20 @@ unsigned lodepng_encode_memory(unsigned char ** out, size_t * outsize, const uns
     return error;
 }
 
+LV_FUNC_SECTION
 unsigned lodepng_encode32(unsigned char ** out, size_t * outsize, const unsigned char * image, unsigned w, unsigned h)
 {
     return lodepng_encode_memory(out, outsize, image, w, h, LCT_RGBA, 8);
 }
 
+LV_FUNC_SECTION
 unsigned lodepng_encode24(unsigned char ** out, size_t * outsize, const unsigned char * image, unsigned w, unsigned h)
 {
     return lodepng_encode_memory(out, outsize, image, w, h, LCT_RGB, 8);
 }
 
 #ifdef LODEPNG_COMPILE_DISK
+LV_FUNC_SECTION
 unsigned lodepng_encode_file(const char * filename, const unsigned char * image, unsigned w, unsigned h,
                              LodePNGColorType colortype, unsigned bitdepth)
 {
@@ -7167,17 +7400,20 @@ unsigned lodepng_encode_file(const char * filename, const unsigned char * image,
     return error;
 }
 
+LV_FUNC_SECTION
 unsigned lodepng_encode32_file(const char * filename, const unsigned char * image, unsigned w, unsigned h)
 {
     return lodepng_encode_file(filename, image, w, h, LCT_RGBA, 8);
 }
 
+LV_FUNC_SECTION
 unsigned lodepng_encode24_file(const char * filename, const unsigned char * image, unsigned w, unsigned h)
 {
     return lodepng_encode_file(filename, image, w, h, LCT_RGB, 8);
 }
 #endif /*LODEPNG_COMPILE_DISK*/
 
+LV_FUNC_SECTION
 void lodepng_encoder_settings_init(LodePNGEncoderSettings * settings)
 {
     lodepng_compress_settings_init(&settings->zlibsettings);
@@ -7200,6 +7436,7 @@ void lodepng_encoder_settings_init(LodePNGEncoderSettings * settings)
 This returns the description of a numerical error code in English. This is also
 the documentation of all the error codes.
 */
+LV_FUNC_SECTION
 const char * lodepng_error_text(unsigned code)
 {
     switch(code) {
@@ -7443,6 +7680,7 @@ namespace lodepng
 {
 
 #ifdef LODEPNG_COMPILE_DISK
+LV_FUNC_SECTION
 unsigned load_file(std::vector<unsigned char> & buffer, const std::string & filename)
 {
     long size = lodepng_filesize(filename.c_str());
@@ -7452,6 +7690,7 @@ unsigned load_file(std::vector<unsigned char> & buffer, const std::string & file
 }
 
 /*write given buffer to the file, overwriting the file, it doesn't append to it.*/
+LV_FUNC_SECTION
 unsigned save_file(const std::vector<unsigned char> & buffer, const std::string & filename)
 {
     return lodepng_save_file(buffer.empty() ? 0 : &buffer[0], buffer.size(), filename.c_str());
@@ -7460,6 +7699,7 @@ unsigned save_file(const std::vector<unsigned char> & buffer, const std::string
 
 #ifdef LODEPNG_COMPILE_ZLIB
 #ifdef LODEPNG_COMPILE_DECODER
+LV_FUNC_SECTION
 unsigned decompress(std::vector<unsigned char> & out, const unsigned char * in, size_t insize,
                     const LodePNGDecompressSettings & settings)
 {
@@ -7473,6 +7713,7 @@ unsigned decompress(std::vector<unsigned char> & out, const unsigned char * in,
     return error;
 }
 
+LV_FUNC_SECTION
 unsigned decompress(std::vector<unsigned char> & out, const std::vector<unsigned char> & in,
                     const LodePNGDecompressSettings & settings)
 {
@@ -7481,6 +7722,7 @@ unsigned decompress(std::vector<unsigned char> & out, const std::vector<unsigned
 #endif /* LODEPNG_COMPILE_DECODER */
 
 #ifdef LODEPNG_COMPILE_ENCODER
+LV_FUNC_SECTION
 unsigned compress(std::vector<unsigned char> & out, const unsigned char * in, size_t insize,
                   const LodePNGCompressSettings & settings)
 {
@@ -7494,6 +7736,7 @@ unsigned compress(std::vector<unsigned char> & out, const unsigned char * in, si
     return error;
 }
 
+LV_FUNC_SECTION
 unsigned compress(std::vector<unsigned char> & out, const std::vector<unsigned char> & in,
                   const LodePNGCompressSettings & settings)
 {
@@ -7505,17 +7748,20 @@ unsigned compress(std::vector<unsigned char> & out, const std::vector<unsigned c
 
 #ifdef LODEPNG_COMPILE_PNG
 
+LV_FUNC_SECTION
 State::State()
 {
     lodepng_state_init(this);
 }
 
+LV_FUNC_SECTION
 State::State(const State & other)
 {
     lodepng_state_init(this);
     lodepng_state_copy(this, &other);
 }
 
+LV_FUNC_SECTION
 State::~State()
 {
     lodepng_state_cleanup(this);
@@ -7529,6 +7775,7 @@ State & State::operator=(const State & other)
 
 #ifdef LODEPNG_COMPILE_DECODER
 
+LV_FUNC_SECTION
 unsigned decode(std::vector<unsigned char> & out, unsigned & w, unsigned & h, const unsigned char * in,
                 size_t insize, LodePNGColorType colortype, unsigned bitdepth)
 {
@@ -7545,12 +7792,14 @@ unsigned decode(std::vector<unsigned char> & out, unsigned & w, unsigned & h, co
     return error;
 }
 
+LV_FUNC_SECTION
 unsigned decode(std::vector<unsigned char> & out, unsigned & w, unsigned & h,
                 const std::vector<unsigned char> & in, LodePNGColorType colortype, unsigned bitdepth)
 {
     return decode(out, w, h, in.empty() ? 0 : &in[0], (unsigned)in.size(), colortype, bitdepth);
 }
 
+LV_FUNC_SECTION
 unsigned decode(std::vector<unsigned char> & out, unsigned & w, unsigned & h,
                 State & state,
                 const unsigned char * in, size_t insize)
@@ -7565,6 +7814,7 @@ unsigned decode(std::vector<unsigned char> & out, unsigned & w, unsigned & h,
     return error;
 }
 
+LV_FUNC_SECTION
 unsigned decode(std::vector<unsigned char> & out, unsigned & w, unsigned & h,
                 State & state,
                 const std::vector<unsigned char> & in)
@@ -7573,6 +7823,7 @@ unsigned decode(std::vector<unsigned char> & out, unsigned & w, unsigned & h,
 }
 
 #ifdef LODEPNG_COMPILE_DISK
+LV_FUNC_SECTION
 unsigned decode(std::vector<unsigned char> & out, unsigned & w, unsigned & h, const std::string & filename,
                 LodePNGColorType colortype, unsigned bitdepth)
 {
@@ -7587,6 +7838,7 @@ unsigned decode(std::vector<unsigned char> & out, unsigned & w, unsigned & h, co
 #endif /* LODEPNG_COMPILE_DISK */
 
 #ifdef LODEPNG_COMPILE_ENCODER
+LV_FUNC_SECTION
 unsigned encode(std::vector<unsigned char> & out, const unsigned char * in, unsigned w, unsigned h,
                 LodePNGColorType colortype, unsigned bitdepth)
 {
@@ -7600,6 +7852,7 @@ unsigned encode(std::vector<unsigned char> & out, const unsigned char * in, unsi
     return error;
 }
 
+LV_FUNC_SECTION
 unsigned encode(std::vector<unsigned char> & out,
                 const std::vector<unsigned char> & in, unsigned w, unsigned h,
                 LodePNGColorType colortype, unsigned bitdepth)
@@ -7608,6 +7861,7 @@ unsigned encode(std::vector<unsigned char> & out,
     return encode(out, in.empty() ? 0 : &in[0], w, h, colortype, bitdepth);
 }
 
+LV_FUNC_SECTION
 unsigned encode(std::vector<unsigned char> & out,
                 const unsigned char * in, unsigned w, unsigned h,
                 State & state)
@@ -7622,6 +7876,7 @@ unsigned encode(std::vector<unsigned char> & out,
     return error;
 }
 
+LV_FUNC_SECTION
 unsigned encode(std::vector<unsigned char> & out,
                 const std::vector<unsigned char> & in, unsigned w, unsigned h,
                 State & state)
@@ -7631,6 +7886,7 @@ unsigned encode(std::vector<unsigned char> & out,
 }
 
 #ifdef LODEPNG_COMPILE_DISK
+LV_FUNC_SECTION
 unsigned encode(const std::string & filename,
                 const unsigned char * in, unsigned w, unsigned h,
                 LodePNGColorType colortype, unsigned bitdepth)
@@ -7641,6 +7897,7 @@ unsigned encode(const std::string & filename,
     return error;
 }
 
+LV_FUNC_SECTION
 unsigned encode(const std::string & filename,
                 const std::vector<unsigned char> & in, unsigned w, unsigned h,
                 LodePNGColorType colortype, unsigned bitdepth)
diff --git a/src/libs/lodepng/lv_lodepng.c b/src/libs/lodepng/lv_lodepng.c
index e5b55de2b..72e62f960 100644
--- a/src/libs/lodepng/lv_lodepng.c
+++ b/src/libs/lodepng/lv_lodepng.c
@@ -50,6 +50,7 @@ static lv_draw_buf_t * decode_png_data(const void * png_data, size_t png_data_si
 /**
  * Register the PNG decoder functions in LVGL
  */
+LV_FUNC_SECTION
 void lv_lodepng_init(void)
 {
     lv_image_decoder_t * dec = lv_image_decoder_create();
@@ -60,6 +61,7 @@ void lv_lodepng_init(void)
     dec->name = DECODER_NAME;
 }
 
+LV_FUNC_SECTION
 void lv_lodepng_deinit(void)
 {
     lv_image_decoder_t * dec = NULL;
@@ -82,6 +84,7 @@ void lv_lodepng_deinit(void)
  * @param header    image information is set in header parameter
  * @return          LV_RESULT_OK: no error; LV_RESULT_INVALID: can't get the info
  */
+__attribute__(( fptrgroup("lv_image_deocder_info_cb") ))
 static lv_result_t decoder_info(lv_image_decoder_t * decoder, lv_image_decoder_dsc_t * dsc, lv_image_header_t * header)
 {
     LV_UNUSED(decoder); /*Unused*/
@@ -136,6 +139,7 @@ static lv_result_t decoder_info(lv_image_decoder_t * decoder, lv_image_decoder_d
  * @param dsc       decoded image descriptor
  * @return          LV_RESULT_OK: no error; LV_RESULT_INVALID: can't open the image
  */
+__attribute__(( fptrgroup("lv_image_deocder_open_cb") ))
 static lv_result_t decoder_open(lv_image_decoder_t * decoder, lv_image_decoder_dsc_t * dsc)
 {
     LV_UNUSED(decoder);
@@ -215,6 +219,7 @@ static lv_result_t decoder_open(lv_image_decoder_t * decoder, lv_image_decoder_d
  * @param dsc       decoded image descriptor
  * @return          LV_RESULT_OK: no error; LV_RESULT_INVALID: can't open the image
  */
+__attribute__(( fptrgroup("lv_image_deocder_close_cb") ))
 static void decoder_close(lv_image_decoder_t * decoder, lv_image_decoder_dsc_t * dsc)
 {
     LV_UNUSED(decoder);
@@ -223,6 +228,7 @@ static void decoder_close(lv_image_decoder_t * decoder, lv_image_decoder_dsc_t *
        !lv_image_cache_is_enabled()) lv_draw_buf_destroy((lv_draw_buf_t *)dsc->decoded);
 }
 
+LV_FUNC_SECTION
 static lv_draw_buf_t * decode_png_data(const void * png_data, size_t png_data_size)
 {
     unsigned png_width;             /*Not used, just required by the decoder*/
@@ -247,6 +253,7 @@ static lv_draw_buf_t * decode_png_data(const void * png_data, size_t png_data_si
  * @param img the ARGB888 image
  * @param px_cnt number of pixels in `img`
  */
+LV_FUNC_SECTION
 static void convert_color_depth(uint8_t * img_p, uint32_t px_cnt)
 {
     lv_color32_t * img_argb = (lv_color32_t *)img_p;
diff --git a/src/libs/lz4/lz4.c b/src/libs/lz4/lz4.c
index 145f5fbd5..338bef453 100644
--- a/src/libs/lz4/lz4.c
+++ b/src/libs/lz4/lz4.c
@@ -291,6 +291,7 @@ static const int LZ4_minLength = (MFLIMIT+1);
 #  define DEBUGLOG(l, ...) {}    /* disabled */
 #endif
 
+LV_FUNC_SECTION
 static int LZ4_isAligned(const void* ptr, size_t alignment)
 {
     return ((size_t)ptr & (alignment -1)) == 0;
@@ -362,6 +363,7 @@ typedef enum {
 #  endif
 #endif
 
+LV_FUNC_SECTION
 static unsigned LZ4_isLittleEndian(void)
 {
     const union { U32 u; BYTE c[4]; } one = { 1 };   /* don't use static : performance detrimental */
@@ -377,11 +379,16 @@ static unsigned LZ4_isLittleEndian(void)
 #if defined(LZ4_FORCE_MEMORY_ACCESS) && (LZ4_FORCE_MEMORY_ACCESS==2)
 /* lie to the compiler about data alignment; use with caution */
 
+LV_FUNC_SECTION
 static U16 LZ4_read16(const void* memPtr) { return *(const U16*) memPtr; }
+LV_FUNC_SECTION
 static U32 LZ4_read32(const void* memPtr) { return *(const U32*) memPtr; }
+LV_FUNC_SECTION
 static reg_t LZ4_read_ARCH(const void* memPtr) { return *(const reg_t*) memPtr; }
 
+LV_FUNC_SECTION
 static void LZ4_write16(void* memPtr, U16 value) { *(U16*)memPtr = value; }
+LV_FUNC_SECTION
 static void LZ4_write32(void* memPtr, U32 value) { *(U32*)memPtr = value; }
 
 #elif defined(LZ4_FORCE_MEMORY_ACCESS) && (LZ4_FORCE_MEMORY_ACCESS==1)
@@ -392,35 +399,45 @@ LZ4_PACK(typedef struct { U16 u16; }) LZ4_unalign16;
 LZ4_PACK(typedef struct { U32 u32; }) LZ4_unalign32;
 LZ4_PACK(typedef struct { reg_t uArch; }) LZ4_unalignST;
 
+LV_FUNC_SECTION
 static U16 LZ4_read16(const void* ptr) { return ((const LZ4_unalign16*)ptr)->u16; }
+LV_FUNC_SECTION
 static U32 LZ4_read32(const void* ptr) { return ((const LZ4_unalign32*)ptr)->u32; }
+LV_FUNC_SECTION
 static reg_t LZ4_read_ARCH(const void* ptr) { return ((const LZ4_unalignST*)ptr)->uArch; }
 
+LV_FUNC_SECTION
 static void LZ4_write16(void* memPtr, U16 value) { ((LZ4_unalign16*)memPtr)->u16 = value; }
+LV_FUNC_SECTION
 static void LZ4_write32(void* memPtr, U32 value) { ((LZ4_unalign32*)memPtr)->u32 = value; }
 
 #else  /* safe and portable access using memcpy() */
 
+LV_FUNC_SECTION
 static U16 LZ4_read16(const void* memPtr)
 {
     U16 val; LZ4_memcpy(&val, memPtr, sizeof(val)); return val;
 }
 
+LV_FUNC_SECTION
 static U32 LZ4_read32(const void* memPtr)
 {
     U32 val; LZ4_memcpy(&val, memPtr, sizeof(val)); return val;
 }
 
+LV_FUNC_SECTION
 static reg_t LZ4_read_ARCH(const void* memPtr)
 {
     reg_t val; LZ4_memcpy(&val, memPtr, sizeof(val)); return val;
 }
 
+LV_FUNC_SECTION
 static void LZ4_write16(void* memPtr, U16 value)
 {
     LZ4_memcpy(memPtr, &value, sizeof(value));
 }
 
+LV_FUNC_SECTION
 static void LZ4_write32(void* memPtr, U32 value)
 {
     LZ4_memcpy(memPtr, &value, sizeof(value));
@@ -429,6 +446,7 @@ static void LZ4_write32(void* memPtr, U32 value)
 #endif /* LZ4_FORCE_MEMORY_ACCESS */
 
 
+LV_FUNC_SECTION
 static U16 LZ4_readLE16(const void* memPtr)
 {
     if (LZ4_isLittleEndian()) {
@@ -439,6 +457,7 @@ static U16 LZ4_readLE16(const void* memPtr)
     }
 }
 
+LV_FUNC_SECTION
 static void LZ4_writeLE16(void* memPtr, U16 value)
 {
     if (LZ4_isLittleEndian()) {
@@ -452,6 +471,7 @@ static void LZ4_writeLE16(void* memPtr, U16 value)
 
 /* customized variant of memcpy, which can overwrite up to 8 bytes beyond dstEnd */
 LZ4_FORCE_INLINE
+LV_FUNC_SECTION
 void LZ4_wildCopy8(void* dstPtr, const void* srcPtr, void* dstEnd)
 {
     BYTE* d = (BYTE*)dstPtr;
@@ -483,6 +503,7 @@ static const int      dec64table[8] = {0, 0, 0, -1, -4,  1, 2, 3};
 #if LZ4_FAST_DEC_LOOP
 
 LZ4_FORCE_INLINE void
+LV_FUNC_SECTION
 LZ4_memcpy_using_offset_base(BYTE* dstPtr, const BYTE* srcPtr, BYTE* dstEnd, const size_t offset)
 {
     assert(srcPtr + offset == dstPtr);
@@ -509,6 +530,7 @@ LZ4_memcpy_using_offset_base(BYTE* dstPtr, const BYTE* srcPtr, BYTE* dstEnd, con
  * this version copies two times 16 bytes (instead of one time 32 bytes)
  * because it must be compatible with offsets >= 16. */
 LZ4_FORCE_INLINE void
+LV_FUNC_SECTION
 LZ4_wildCopy32(void* dstPtr, const void* srcPtr, void* dstEnd)
 {
     BYTE* d = (BYTE*)dstPtr;
@@ -522,6 +544,7 @@ LZ4_wildCopy32(void* dstPtr, const void* srcPtr, void* dstEnd)
  * - dstEnd >= dstPtr + MINMATCH
  * - there is at least 8 bytes available to write after dstEnd */
 LZ4_FORCE_INLINE void
+LV_FUNC_SECTION
 LZ4_memcpy_using_offset(BYTE* dstPtr, const BYTE* srcPtr, BYTE* dstEnd, const size_t offset)
 {
     BYTE v[8];
@@ -566,6 +589,7 @@ LZ4_memcpy_using_offset(BYTE* dstPtr, const BYTE* srcPtr, BYTE* dstEnd, const si
 /*-************************************
 *  Common functions
 **************************************/
+LV_FUNC_SECTION
 static unsigned LZ4_NbCommonBytes (reg_t val)
 {
     assert(val != 0);
@@ -667,6 +691,7 @@ static unsigned LZ4_NbCommonBytes (reg_t val)
 
 #define STEPSIZE sizeof(reg_t)
 LZ4_FORCE_INLINE
+LV_FUNC_SECTION
 unsigned LZ4_count(const BYTE* pIn, const BYTE* pMatch, const BYTE* pInLimit)
 {
     const BYTE* const pStart = pIn;
@@ -736,9 +761,13 @@ typedef enum { noDictIssue = 0, dictSmall } dictIssue_directive;
 /*-************************************
 *  Local Utils
 **************************************/
+LV_FUNC_SECTION
 int LZ4_versionNumber (void) { return LZ4_VERSION_NUMBER; }
+LV_FUNC_SECTION
 const char* LZ4_versionString(void) { return LZ4_VERSION_STRING; }
+LV_FUNC_SECTION
 int LZ4_compressBound(int isize)  { return LZ4_COMPRESSBOUND(isize); }
+LV_FUNC_SECTION
 int LZ4_sizeofState(void) { return sizeof(LZ4_stream_t); }
 
 
@@ -764,6 +793,7 @@ int LZ4_decompress_safe_partial_forceExtDict(const char* source, char* dest,
 /*-******************************
 *  Compression functions
 ********************************/
+LV_FUNC_SECTION
 LZ4_FORCE_INLINE U32 LZ4_hash4(U32 sequence, tableType_t const tableType)
 {
     if (tableType == byU16)
@@ -772,6 +802,7 @@ LZ4_FORCE_INLINE U32 LZ4_hash4(U32 sequence, tableType_t const tableType)
         return ((sequence * 2654435761U) >> ((MINMATCH*8)-LZ4_HASHLOG));
 }
 
+LV_FUNC_SECTION
 LZ4_FORCE_INLINE U32 LZ4_hash5(U64 sequence, tableType_t const tableType)
 {
     const U32 hashLog = (tableType == byU16) ? LZ4_HASHLOG+1 : LZ4_HASHLOG;
@@ -784,12 +815,14 @@ LZ4_FORCE_INLINE U32 LZ4_hash5(U64 sequence, tableType_t const tableType)
     }
 }
 
+LV_FUNC_SECTION
 LZ4_FORCE_INLINE U32 LZ4_hashPosition(const void* const p, tableType_t const tableType)
 {
     if ((sizeof(reg_t)==8) && (tableType != byU16)) return LZ4_hash5(LZ4_read_ARCH(p), tableType);
     return LZ4_hash4(LZ4_read32(p), tableType);
 }
 
+LV_FUNC_SECTION
 LZ4_FORCE_INLINE void LZ4_clearHash(U32 h, void* tableBase, tableType_t const tableType)
 {
     switch (tableType)
@@ -802,6 +835,7 @@ LZ4_FORCE_INLINE void LZ4_clearHash(U32 h, void* tableBase, tableType_t const ta
     }
 }
 
+LV_FUNC_SECTION
 LZ4_FORCE_INLINE void LZ4_putIndexOnHash(U32 idx, U32 h, void* tableBase, tableType_t const tableType)
 {
     switch (tableType)
@@ -815,6 +849,7 @@ LZ4_FORCE_INLINE void LZ4_putIndexOnHash(U32 idx, U32 h, void* tableBase, tableT
 }
 
 /* LZ4_putPosition*() : only used in byPtr mode */
+LV_FUNC_SECTION
 LZ4_FORCE_INLINE void LZ4_putPositionOnHash(const BYTE* p, U32 h,
                                   void* tableBase, tableType_t const tableType)
 {
@@ -823,6 +858,7 @@ LZ4_FORCE_INLINE void LZ4_putPositionOnHash(const BYTE* p, U32 h,
     hashTable[h] = p;
 }
 
+LV_FUNC_SECTION
 LZ4_FORCE_INLINE void LZ4_putPosition(const BYTE* p, void* tableBase, tableType_t tableType)
 {
     U32 const h = LZ4_hashPosition(p, tableType);
@@ -835,6 +871,7 @@ LZ4_FORCE_INLINE void LZ4_putPosition(const BYTE* p, void* tableBase, tableType_
  * Assumption 1 : only valid if tableType == byU32 or byU16.
  * Assumption 2 : h is presumed valid (within limits of hash table)
  */
+LV_FUNC_SECTION
 LZ4_FORCE_INLINE U32 LZ4_getIndexOnHash(U32 h, const void* tableBase, tableType_t tableType)
 {
     LZ4_STATIC_ASSERT(LZ4_MEMORY_USAGE > 2);
@@ -851,6 +888,7 @@ LZ4_FORCE_INLINE U32 LZ4_getIndexOnHash(U32 h, const void* tableBase, tableType_
     assert(0); return 0;  /* forbidden case */
 }
 
+LV_FUNC_SECTION
 static const BYTE* LZ4_getPositionOnHash(U32 h, const void* tableBase, tableType_t tableType)
 {
     assert(tableType == byPtr); (void)tableType;
@@ -858,6 +896,7 @@ static const BYTE* LZ4_getPositionOnHash(U32 h, const void* tableBase, tableType
 }
 
 LZ4_FORCE_INLINE const BYTE*
+LV_FUNC_SECTION
 LZ4_getPosition(const BYTE* p,
                 const void* tableBase, tableType_t tableType)
 {
@@ -866,6 +905,7 @@ LZ4_getPosition(const BYTE* p,
 }
 
 LZ4_FORCE_INLINE void
+LV_FUNC_SECTION
 LZ4_prepareTable(LZ4_stream_t_internal* const cctx,
            const int inputSize,
            const tableType_t tableType) {
@@ -912,6 +952,7 @@ LZ4_prepareTable(LZ4_stream_t_internal* const cctx,
  *  - source != NULL
  *  - inputSize > 0
  */
+LV_FUNC_SECTION
 LZ4_FORCE_INLINE int LZ4_compress_generic_validated(
                  LZ4_stream_t_internal* const cctx,
                  const char* const source,
@@ -1326,6 +1367,7 @@ _last_literals:
  *  inlined, to ensure branches are decided at compilation time;
  *  takes care of src == (NULL, 0)
  *  and forward the rest to LZ4_compress_generic_validated */
+LV_FUNC_SECTION
 LZ4_FORCE_INLINE int LZ4_compress_generic(
                  LZ4_stream_t_internal* const cctx,
                  const char* const src,
@@ -1364,6 +1406,7 @@ LZ4_FORCE_INLINE int LZ4_compress_generic(
 }
 
 
+LV_FUNC_SECTION
 int LZ4_compress_fast_extState(void* state, const char* source, char* dest, int inputSize, int maxOutputSize, int acceleration)
 {
     LZ4_stream_t_internal* const ctx = & LZ4_initStream(state, sizeof(LZ4_stream_t)) -> internal_donotuse;
@@ -1396,6 +1439,7 @@ int LZ4_compress_fast_extState(void* state, const char* source, char* dest, int
  * (see comment in lz4.h on LZ4_resetStream_fast() for a definition of
  * "correctly initialized").
  */
+LV_FUNC_SECTION
 int LZ4_compress_fast_extState_fastReset(void* state, const char* src, char* dst, int srcSize, int dstCapacity, int acceleration)
 {
     LZ4_stream_t_internal* const ctx = &((LZ4_stream_t*)state)->internal_donotuse;
@@ -1435,6 +1479,7 @@ int LZ4_compress_fast_extState_fastReset(void* state, const char* src, char* dst
 }
 
 
+LV_FUNC_SECTION
 int LZ4_compress_fast(const char* src, char* dest, int srcSize, int dstCapacity, int acceleration)
 {
     int result;
@@ -1454,6 +1499,7 @@ int LZ4_compress_fast(const char* src, char* dest, int srcSize, int dstCapacity,
 }
 
 
+LV_FUNC_SECTION
 int LZ4_compress_default(const char* src, char* dst, int srcSize, int dstCapacity)
 {
     return LZ4_compress_fast(src, dst, srcSize, dstCapacity, 1);
@@ -1463,6 +1509,7 @@ int LZ4_compress_default(const char* src, char* dst, int srcSize, int dstCapacit
 /* Note!: This function leaves the stream in an unclean/broken state!
  * It is not safe to subsequently use the same state with a _fastReset() or
  * _continue() call without resetting it. */
+LV_FUNC_SECTION
 static int LZ4_compress_destSize_extState (LZ4_stream_t* state, const char* src, char* dst, int* srcSizePtr, int targetDstSize)
 {
     void* const s = LZ4_initStream(state, sizeof (*state));
@@ -1480,6 +1527,7 @@ static int LZ4_compress_destSize_extState (LZ4_stream_t* state, const char* src,
 }
 
 
+LV_FUNC_SECTION
 int LZ4_compress_destSize(const char* src, char* dst, int* srcSizePtr, int targetDstSize)
 {
 #if (LZ4_HEAPMODE)
@@ -1505,6 +1553,7 @@ int LZ4_compress_destSize(const char* src, char* dst, int* srcSizePtr, int targe
 ********************************/
 
 #if !defined(LZ4_STATIC_LINKING_ONLY_DISABLE_MEMORY_ALLOCATION)
+LV_FUNC_SECTION
 LZ4_stream_t* LZ4_createStream(void)
 {
     LZ4_stream_t* const lz4s = (LZ4_stream_t*)ALLOC(sizeof(LZ4_stream_t));
@@ -1516,6 +1565,7 @@ LZ4_stream_t* LZ4_createStream(void)
 }
 #endif
 
+LV_FUNC_SECTION
 static size_t LZ4_stream_t_alignment(void)
 {
 #if LZ4_ALIGN_TEST
@@ -1526,6 +1576,7 @@ static size_t LZ4_stream_t_alignment(void)
 #endif
 }
 
+LV_FUNC_SECTION
 LZ4_stream_t* LZ4_initStream (void* buffer, size_t size)
 {
     DEBUGLOG(5, "LZ4_initStream");
@@ -1538,17 +1589,20 @@ LZ4_stream_t* LZ4_initStream (void* buffer, size_t size)
 
 /* resetStream is now deprecated,
  * prefer initStream() which is more general */
+LV_FUNC_SECTION
 void LZ4_resetStream (LZ4_stream_t* LZ4_stream)
 {
     DEBUGLOG(5, "LZ4_resetStream (ctx:%p)", LZ4_stream);
     MEM_INIT(LZ4_stream, 0, sizeof(LZ4_stream_t_internal));
 }
 
+LV_FUNC_SECTION
 void LZ4_resetStream_fast(LZ4_stream_t* ctx) {
     LZ4_prepareTable(&(ctx->internal_donotuse), 0, byU32);
 }
 
 #if !defined(LZ4_STATIC_LINKING_ONLY_DISABLE_MEMORY_ALLOCATION)
+LV_FUNC_SECTION
 int LZ4_freeStream (LZ4_stream_t* LZ4_stream)
 {
     if (!LZ4_stream) return 0;   /* support free on NULL */
@@ -1560,6 +1614,7 @@ int LZ4_freeStream (LZ4_stream_t* LZ4_stream)
 
 
 #define HASH_UNIT sizeof(reg_t)
+LV_FUNC_SECTION
 int LZ4_loadDict (LZ4_stream_t* LZ4_dict, const char* dictionary, int dictSize)
 {
     LZ4_stream_t_internal* const dict = &LZ4_dict->internal_donotuse;
@@ -1603,6 +1658,7 @@ int LZ4_loadDict (LZ4_stream_t* LZ4_dict, const char* dictionary, int dictSize)
     return (int)dict->dictSize;
 }
 
+LV_FUNC_SECTION
 void LZ4_attach_dictionary(LZ4_stream_t* workingStream, const LZ4_stream_t* dictionaryStream)
 {
     const LZ4_stream_t_internal* dictCtx = (dictionaryStream == NULL) ? NULL :
@@ -1632,6 +1688,7 @@ void LZ4_attach_dictionary(LZ4_stream_t* workingStream, const LZ4_stream_t* dict
 }
 
 
+LV_FUNC_SECTION
 static void LZ4_renormDictT(LZ4_stream_t_internal* LZ4_dict, int nextSize)
 {
     assert(nextSize >= 0);
@@ -1652,6 +1709,7 @@ static void LZ4_renormDictT(LZ4_stream_t_internal* LZ4_dict, int nextSize)
 }
 
 
+LV_FUNC_SECTION
 int LZ4_compress_fast_continue (LZ4_stream_t* LZ4_stream,
                                 const char* source, char* dest,
                                 int inputSize, int maxOutputSize,
@@ -1732,6 +1790,7 @@ int LZ4_compress_fast_continue (LZ4_stream_t* LZ4_stream,
 
 
 /* Hidden debug function, to force-test external dictionary mode */
+LV_FUNC_SECTION
 int LZ4_compress_forceExtDict (LZ4_stream_t* LZ4_dict, const char* source, char* dest, int srcSize)
 {
     LZ4_stream_t_internal* const streamPtr = &LZ4_dict->internal_donotuse;
@@ -1759,6 +1818,7 @@ int LZ4_compress_forceExtDict (LZ4_stream_t* LZ4_dict, const char* source, char*
  *         one can therefore call LZ4_compress_fast_continue() right after.
  * @return : saved dictionary size in bytes (necessarily <= dictSize), or 0 if error.
  */
+LV_FUNC_SECTION
 int LZ4_saveDict (LZ4_stream_t* LZ4_dict, char* safeBuffer, int dictSize)
 {
     LZ4_stream_t_internal* const dict = &LZ4_dict->internal_donotuse;
@@ -1797,6 +1857,7 @@ typedef enum { decode_full_block = 0, partial_decode = 1 } earlyEnd_directive;
  * does not know end of input
  * presumes input is well formed
  * note : will consume at least one byte */
+LV_FUNC_SECTION
 static size_t read_long_length_no_check(const BYTE** pp)
 {
     size_t b, l = 0;
@@ -1815,6 +1876,7 @@ static size_t read_long_length_no_check(const BYTE** pp)
  *        the goal is to remove support of decompress_fast*() variants by v2.0
 **/
 LZ4_FORCE_INLINE int
+LV_FUNC_SECTION
 LZ4_decompress_unsafe_generic(
                  const BYTE* const istart,
                  BYTE* const ostart,
@@ -1924,6 +1986,7 @@ LZ4_decompress_unsafe_generic(
 typedef size_t Rvl_t;
 static const Rvl_t rvl_error = (Rvl_t)(-1);
 LZ4_FORCE_INLINE Rvl_t
+LV_FUNC_SECTION
 read_variable_length(const BYTE** ip, const BYTE* ilimit,
                      int initial_check)
 {
@@ -1957,6 +2020,7 @@ read_variable_length(const BYTE** ip, const BYTE* ilimit,
  *  in order to remove useless branches during compilation optimization.
  */
 LZ4_FORCE_INLINE int
+LV_FUNC_SECTION
 LZ4_decompress_generic(
                  const char* const src,
                  char* const dst,
@@ -2377,6 +2441,7 @@ LZ4_decompress_generic(
 /*===== Instantiate the API decoding functions. =====*/
 
 LZ4_FORCE_O2
+LV_FUNC_SECTION
 int LZ4_decompress_safe(const char* source, char* dest, int compressedSize, int maxDecompressedSize)
 {
     return LZ4_decompress_generic(source, dest, compressedSize, maxDecompressedSize,
@@ -2385,6 +2450,7 @@ int LZ4_decompress_safe(const char* source, char* dest, int compressedSize, int
 }
 
 LZ4_FORCE_O2
+LV_FUNC_SECTION
 int LZ4_decompress_safe_partial(const char* src, char* dst, int compressedSize, int targetOutputSize, int dstCapacity)
 {
     dstCapacity = MIN(targetOutputSize, dstCapacity);
@@ -2394,6 +2460,7 @@ int LZ4_decompress_safe_partial(const char* src, char* dst, int compressedSize,
 }
 
 LZ4_FORCE_O2
+LV_FUNC_SECTION
 int LZ4_decompress_fast(const char* source, char* dest, int originalSize)
 {
     DEBUGLOG(5, "LZ4_decompress_fast");
@@ -2405,6 +2472,7 @@ int LZ4_decompress_fast(const char* source, char* dest, int originalSize)
 /*===== Instantiate a few more decoding cases, used more than once. =====*/
 
 LZ4_FORCE_O2 /* Exported, an obsolete API function. */
+LV_FUNC_SECTION
 int LZ4_decompress_safe_withPrefix64k(const char* source, char* dest, int compressedSize, int maxOutputSize)
 {
     return LZ4_decompress_generic(source, dest, compressedSize, maxOutputSize,
@@ -2413,6 +2481,7 @@ int LZ4_decompress_safe_withPrefix64k(const char* source, char* dest, int compre
 }
 
 LZ4_FORCE_O2
+LV_FUNC_SECTION
 static int LZ4_decompress_safe_partial_withPrefix64k(const char* source, char* dest, int compressedSize, int targetOutputSize, int dstCapacity)
 {
     dstCapacity = MIN(targetOutputSize, dstCapacity);
@@ -2422,6 +2491,7 @@ static int LZ4_decompress_safe_partial_withPrefix64k(const char* source, char* d
 }
 
 /* Another obsolete API function, paired with the previous one. */
+LV_FUNC_SECTION
 int LZ4_decompress_fast_withPrefix64k(const char* source, char* dest, int originalSize)
 {
     return LZ4_decompress_unsafe_generic(
@@ -2430,6 +2500,7 @@ int LZ4_decompress_fast_withPrefix64k(const char* source, char* dest, int origin
 }
 
 LZ4_FORCE_O2
+LV_FUNC_SECTION
 static int LZ4_decompress_safe_withSmallPrefix(const char* source, char* dest, int compressedSize, int maxOutputSize,
                                                size_t prefixSize)
 {
@@ -2439,6 +2510,7 @@ static int LZ4_decompress_safe_withSmallPrefix(const char* source, char* dest, i
 }
 
 LZ4_FORCE_O2
+LV_FUNC_SECTION
 static int LZ4_decompress_safe_partial_withSmallPrefix(const char* source, char* dest, int compressedSize, int targetOutputSize, int dstCapacity,
                                                size_t prefixSize)
 {
@@ -2449,6 +2521,7 @@ static int LZ4_decompress_safe_partial_withSmallPrefix(const char* source, char*
 }
 
 LZ4_FORCE_O2
+LV_FUNC_SECTION
 int LZ4_decompress_safe_forceExtDict(const char* source, char* dest,
                                      int compressedSize, int maxOutputSize,
                                      const void* dictStart, size_t dictSize)
@@ -2460,6 +2533,7 @@ int LZ4_decompress_safe_forceExtDict(const char* source, char* dest,
 }
 
 LZ4_FORCE_O2
+LV_FUNC_SECTION
 int LZ4_decompress_safe_partial_forceExtDict(const char* source, char* dest,
                                      int compressedSize, int targetOutputSize, int dstCapacity,
                                      const void* dictStart, size_t dictSize)
@@ -2471,6 +2545,7 @@ int LZ4_decompress_safe_partial_forceExtDict(const char* source, char* dest,
 }
 
 LZ4_FORCE_O2
+LV_FUNC_SECTION
 static int LZ4_decompress_fast_extDict(const char* source, char* dest, int originalSize,
                                        const void* dictStart, size_t dictSize)
 {
@@ -2484,6 +2559,7 @@ static int LZ4_decompress_fast_extDict(const char* source, char* dest, int origi
  * These routines are used only once, in LZ4_decompress_*_continue().
  */
 LZ4_FORCE_INLINE
+LV_FUNC_SECTION
 int LZ4_decompress_safe_doubleDict(const char* source, char* dest, int compressedSize, int maxOutputSize,
                                    size_t prefixSize, const void* dictStart, size_t dictSize)
 {
@@ -2495,12 +2571,14 @@ int LZ4_decompress_safe_doubleDict(const char* source, char* dest, int compresse
 /*===== streaming decompression functions =====*/
 
 #if !defined(LZ4_STATIC_LINKING_ONLY_DISABLE_MEMORY_ALLOCATION)
+LV_FUNC_SECTION
 LZ4_streamDecode_t* LZ4_createStreamDecode(void)
 {
     LZ4_STATIC_ASSERT(sizeof(LZ4_streamDecode_t) >= sizeof(LZ4_streamDecode_t_internal));
     return (LZ4_streamDecode_t*) ALLOC_AND_ZERO(sizeof(LZ4_streamDecode_t));
 }
 
+LV_FUNC_SECTION
 int LZ4_freeStreamDecode (LZ4_streamDecode_t* LZ4_stream)
 {
     if (LZ4_stream == NULL) { return 0; }  /* support free on NULL */
@@ -2515,6 +2593,7 @@ int LZ4_freeStreamDecode (LZ4_streamDecode_t* LZ4_stream)
  *  Loading a size of 0 is allowed (same effect as no dictionary).
  * @return : 1 if OK, 0 if error
  */
+LV_FUNC_SECTION
 int LZ4_setStreamDecode (LZ4_streamDecode_t* LZ4_streamDecode, const char* dictionary, int dictSize)
 {
     LZ4_streamDecode_t_internal* lz4sd = &LZ4_streamDecode->internal_donotuse;
@@ -2541,6 +2620,7 @@ int LZ4_setStreamDecode (LZ4_streamDecode_t* LZ4_streamDecode, const char* dicti
  * @return : minimum ring buffer size,
  *           or 0 if there is an error (invalid maxBlockSize).
  */
+LV_FUNC_SECTION
 int LZ4_decoderRingBufferSize(int maxBlockSize)
 {
     if (maxBlockSize < 0) return 0;
@@ -2557,6 +2637,7 @@ int LZ4_decoderRingBufferSize(int maxBlockSize)
     and indicate where it stands using LZ4_setStreamDecode()
 */
 LZ4_FORCE_O2
+LV_FUNC_SECTION
 int LZ4_decompress_safe_continue (LZ4_streamDecode_t* LZ4_streamDecode, const char* source, char* dest, int compressedSize, int maxOutputSize)
 {
     LZ4_streamDecode_t_internal* lz4sd = &LZ4_streamDecode->internal_donotuse;
@@ -2597,6 +2678,7 @@ int LZ4_decompress_safe_continue (LZ4_streamDecode_t* LZ4_streamDecode, const ch
 }
 
 LZ4_FORCE_O2 int
+LV_FUNC_SECTION
 LZ4_decompress_fast_continue (LZ4_streamDecode_t* LZ4_streamDecode,
                         const char* source, char* dest, int originalSize)
 {
@@ -2645,6 +2727,7 @@ Advanced decoding functions :
     the dictionary must be explicitly provided within parameters
 */
 
+LV_FUNC_SECTION
 int LZ4_decompress_safe_usingDict(const char* source, char* dest, int compressedSize, int maxOutputSize, const char* dictStart, int dictSize)
 {
     if (dictSize==0)
@@ -2660,6 +2743,7 @@ int LZ4_decompress_safe_usingDict(const char* source, char* dest, int compressed
     return LZ4_decompress_safe_forceExtDict(source, dest, compressedSize, maxOutputSize, dictStart, (size_t)dictSize);
 }
 
+LV_FUNC_SECTION
 int LZ4_decompress_safe_partial_usingDict(const char* source, char* dest, int compressedSize, int targetOutputSize, int dstCapacity, const char* dictStart, int dictSize)
 {
     if (dictSize==0)
@@ -2675,6 +2759,7 @@ int LZ4_decompress_safe_partial_usingDict(const char* source, char* dest, int co
     return LZ4_decompress_safe_partial_forceExtDict(source, dest, compressedSize, targetOutputSize, dstCapacity, dictStart, (size_t)dictSize);
 }
 
+LV_FUNC_SECTION
 int LZ4_decompress_fast_usingDict(const char* source, char* dest, int originalSize, const char* dictStart, int dictSize)
 {
     if (dictSize==0 || dictStart+dictSize == dest)
@@ -2690,26 +2775,32 @@ int LZ4_decompress_fast_usingDict(const char* source, char* dest, int originalSi
 *  Obsolete Functions
 ***************************************************/
 /* obsolete compression functions */
+LV_FUNC_SECTION
 int LZ4_compress_limitedOutput(const char* source, char* dest, int inputSize, int maxOutputSize)
 {
     return LZ4_compress_default(source, dest, inputSize, maxOutputSize);
 }
+LV_FUNC_SECTION
 int LZ4_compress(const char* src, char* dest, int srcSize)
 {
     return LZ4_compress_default(src, dest, srcSize, LZ4_compressBound(srcSize));
 }
+LV_FUNC_SECTION
 int LZ4_compress_limitedOutput_withState (void* state, const char* src, char* dst, int srcSize, int dstSize)
 {
     return LZ4_compress_fast_extState(state, src, dst, srcSize, dstSize, 1);
 }
+LV_FUNC_SECTION
 int LZ4_compress_withState (void* state, const char* src, char* dst, int srcSize)
 {
     return LZ4_compress_fast_extState(state, src, dst, srcSize, LZ4_compressBound(srcSize), 1);
 }
+LV_FUNC_SECTION
 int LZ4_compress_limitedOutput_continue (LZ4_stream_t* LZ4_stream, const char* src, char* dst, int srcSize, int dstCapacity)
 {
     return LZ4_compress_fast_continue(LZ4_stream, src, dst, srcSize, dstCapacity, 1);
 }
+LV_FUNC_SECTION
 int LZ4_compress_continue (LZ4_stream_t* LZ4_stream, const char* source, char* dest, int inputSize)
 {
     return LZ4_compress_fast_continue(LZ4_stream, source, dest, inputSize, LZ4_compressBound(inputSize), 1);
@@ -2721,10 +2812,12 @@ They are only provided here for compatibility with older user programs.
 - LZ4_uncompress is totally equivalent to LZ4_decompress_fast
 - LZ4_uncompress_unknownOutputSize is totally equivalent to LZ4_decompress_safe
 */
+LV_FUNC_SECTION
 int LZ4_uncompress (const char* source, char* dest, int outputSize)
 {
     return LZ4_decompress_fast(source, dest, outputSize);
 }
+LV_FUNC_SECTION
 int LZ4_uncompress_unknownOutputSize (const char* source, char* dest, int isize, int maxOutputSize)
 {
     return LZ4_decompress_safe(source, dest, isize, maxOutputSize);
@@ -2732,8 +2825,10 @@ int LZ4_uncompress_unknownOutputSize (const char* source, char* dest, int isize,
 
 /* Obsolete Streaming functions */
 
+LV_FUNC_SECTION
 int LZ4_sizeofStreamState(void) { return sizeof(LZ4_stream_t); }
 
+LV_FUNC_SECTION
 int LZ4_resetStreamState(void* state, char* inputBuffer)
 {
     (void)inputBuffer;
@@ -2742,6 +2837,7 @@ int LZ4_resetStreamState(void* state, char* inputBuffer)
 }
 
 #if !defined(LZ4_STATIC_LINKING_ONLY_DISABLE_MEMORY_ALLOCATION)
+LV_FUNC_SECTION
 void* LZ4_create (char* inputBuffer)
 {
     (void)inputBuffer;
@@ -2749,6 +2845,7 @@ void* LZ4_create (char* inputBuffer)
 }
 #endif
 
+LV_FUNC_SECTION
 char* LZ4_slideInputBuffer (void* state)
 {
     /* avoid const char * -> char * conversion warning */
diff --git a/src/libs/qrcode/lv_qrcode.c b/src/libs/qrcode/lv_qrcode.c
index f4b5b5456..bd3a466f3 100644
--- a/src/libs/qrcode/lv_qrcode.c
+++ b/src/libs/qrcode/lv_qrcode.c
@@ -48,6 +48,7 @@ const lv_obj_class_t lv_qrcode_class = {
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 lv_obj_t * lv_qrcode_create(lv_obj_t * parent)
 {
     LV_LOG_INFO("begin");
@@ -56,6 +57,7 @@ lv_obj_t * lv_qrcode_create(lv_obj_t * parent)
     return obj;
 }
 
+LV_FUNC_SECTION
 void lv_qrcode_set_size(lv_obj_t * obj, int32_t size)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -76,6 +78,7 @@ void lv_qrcode_set_size(lv_obj_t * obj, int32_t size)
     if(old_buf != NULL) lv_draw_buf_destroy(old_buf);
 }
 
+LV_FUNC_SECTION
 void lv_qrcode_set_dark_color(lv_obj_t * obj, lv_color_t color)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -83,6 +86,7 @@ void lv_qrcode_set_dark_color(lv_obj_t * obj, lv_color_t color)
     qrcode->dark_color = color;
 }
 
+LV_FUNC_SECTION
 void lv_qrcode_set_light_color(lv_obj_t * obj, lv_color_t color)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -90,6 +94,7 @@ void lv_qrcode_set_light_color(lv_obj_t * obj, lv_color_t color)
     qrcode->light_color = color;
 }
 
+LV_FUNC_SECTION
 lv_result_t lv_qrcode_update(lv_obj_t * obj, const void * data, uint32_t data_len)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -215,6 +220,7 @@ lv_result_t lv_qrcode_update(lv_obj_t * obj, const void * data, uint32_t data_le
  *   STATIC FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 static void lv_qrcode_constructor(const lv_obj_class_t * class_p, lv_obj_t * obj)
 {
     LV_UNUSED(class_p);
@@ -227,6 +233,7 @@ static void lv_qrcode_constructor(const lv_obj_class_t * class_p, lv_obj_t * obj
     lv_qrcode_set_light_color(obj, lv_color_white());
 }
 
+LV_FUNC_SECTION
 static void lv_qrcode_destructor(const lv_obj_class_t * class_p, lv_obj_t * obj)
 {
     LV_UNUSED(class_p);
diff --git a/src/libs/qrcode/qrcodegen.c b/src/libs/qrcode/qrcodegen.c
index f501a248f..9524a1b21 100644
--- a/src/libs/qrcode/qrcodegen.c
+++ b/src/libs/qrcode/qrcodegen.c
@@ -127,6 +127,7 @@ static const int PENALTY_N4 = 10;
 /*---- High-level QR Code encoding functions ----*/
 
 // Public function - see documentation comment in header file.
+LV_FUNC_SECTION
 bool qrcodegen_encodeText(const char * text, uint8_t tempBuffer[], uint8_t qrcode[],
                           enum qrcodegen_Ecc ecl, int minVersion, int maxVersion, enum qrcodegen_Mask mask, bool boostEcl)
 {
@@ -168,6 +169,7 @@ fail:
 
 
 // Public function - see documentation comment in header file.
+LV_FUNC_SECTION
 bool qrcodegen_encodeBinary(uint8_t dataAndTemp[], size_t dataLen, uint8_t qrcode[],
                             enum qrcodegen_Ecc ecl, int minVersion, int maxVersion, enum qrcodegen_Mask mask, bool boostEcl)
 {
@@ -187,6 +189,7 @@ bool qrcodegen_encodeBinary(uint8_t dataAndTemp[], size_t dataLen, uint8_t qrcod
 
 // Appends the given number of low-order bits of the given value to the given byte-based
 // bit buffer, increasing the bit length. Requires 0 <= numBits <= 16 and val < 2^numBits.
+LV_FUNC_SECTION
 testable void appendBitsToBuffer(unsigned int val, int numBits, uint8_t buffer[], int * bitLen)
 {
     LV_ASSERT(0 <= numBits && numBits <= 16 && (unsigned long)val >> numBits == 0);
@@ -199,6 +202,7 @@ testable void appendBitsToBuffer(unsigned int val, int numBits, uint8_t buffer[]
 /*---- Low-level QR Code encoding functions ----*/
 
 // Public function - see documentation comment in header file.
+LV_FUNC_SECTION
 bool qrcodegen_encodeSegments(const struct qrcodegen_Segment segs[], size_t len,
                               enum qrcodegen_Ecc ecl, uint8_t tempBuffer[], uint8_t qrcode[])
 {
@@ -208,6 +212,7 @@ bool qrcodegen_encodeSegments(const struct qrcodegen_Segment segs[], size_t len,
 
 
 // Public function - see documentation comment in header file.
+LV_FUNC_SECTION
 bool qrcodegen_encodeSegmentsAdvanced(const struct qrcodegen_Segment segs[], size_t len, enum qrcodegen_Ecc ecl,
                                       int minVersion, int maxVersion, int mask, bool boostEcl, uint8_t tempBuffer[], uint8_t qrcode[])
 {
@@ -297,6 +302,7 @@ bool qrcodegen_encodeSegmentsAdvanced(const struct qrcodegen_Segment segs[], siz
 // bytes from the blocks and stores them in the result array. data[0 : dataLen] contains
 // the input data. data[dataLen : rawCodewords] is used as a temporary work area and will
 // be clobbered by this function. The final answer is stored in result[0 : rawCodewords].
+LV_FUNC_SECTION
 testable void addEccAndInterleave(uint8_t data[], int version, enum qrcodegen_Ecc ecl, uint8_t result[])
 {
     // Calculate parameter numbers
@@ -331,6 +337,7 @@ testable void addEccAndInterleave(uint8_t data[], int version, enum qrcodegen_Ec
 
 // Returns the number of 8-bit codewords that can be used for storing data (not ECC),
 // for the given version number and error correction level. The result is in the range [9, 2956].
+LV_FUNC_SECTION
 testable int getNumDataCodewords(int version, enum qrcodegen_Ecc ecl)
 {
     int v = version, e = (int)ecl;
@@ -344,6 +351,7 @@ testable int getNumDataCodewords(int version, enum qrcodegen_Ecc ecl)
 // Returns the number of data bits that can be stored in a QR Code of the given version number, after
 // all function modules are excluded. This includes remainder bits, so it might not be a multiple of 8.
 // The result is in the range [208, 29648]. This could be implemented as a 40-entry lookup table.
+LV_FUNC_SECTION
 testable int getNumRawDataModules(int ver)
 {
     LV_ASSERT(qrcodegen_VERSION_MIN <= ver && ver <= qrcodegen_VERSION_MAX);
@@ -362,6 +370,7 @@ testable int getNumRawDataModules(int ver)
 /*---- Reed-Solomon ECC generator functions ----*/
 
 // Calculates the Reed-Solomon generator polynomial of the given degree, storing in result[0 : degree].
+LV_FUNC_SECTION
 testable void calcReedSolomonGenerator(int degree, uint8_t result[])
 {
     // Start with the monomial x^0
@@ -387,6 +396,7 @@ testable void calcReedSolomonGenerator(int degree, uint8_t result[])
 
 // Calculates the remainder of the polynomial data[0 : dataLen] when divided by the generator[0 : degree], where all
 // polynomials are in big endian and the generator has an implicit leading 1 term, storing the result in result[0 : degree].
+LV_FUNC_SECTION
 testable void calcReedSolomonRemainder(const uint8_t data[], int dataLen,
                                        const uint8_t generator[], int degree, uint8_t result[])
 {
@@ -408,6 +418,7 @@ testable void calcReedSolomonRemainder(const uint8_t data[], int dataLen,
 
 // Returns the product of the two given field elements modulo GF(2^8/0x11D).
 // All inputs are valid. This could be implemented as a 256*256 lookup table.
+LV_FUNC_SECTION
 testable uint8_t finiteFieldMultiply(uint8_t x, uint8_t y)
 {
     // Russian peasant multiplication
@@ -425,6 +436,7 @@ testable uint8_t finiteFieldMultiply(uint8_t x, uint8_t y)
 
 // Clears the given QR Code grid with white modules for the given
 // version's size, then marks every function module as black.
+LV_FUNC_SECTION
 testable void initializeFunctionModules(int version, uint8_t qrcode[])
 {
     // Initialize QR Code
@@ -463,6 +475,7 @@ testable void initializeFunctionModules(int version, uint8_t qrcode[])
 // Draws white function modules and possibly some black modules onto the given QR Code, without changing
 // non-function modules. This does not draw the format bits. This requires all function modules to be previously
 // marked black (namely by initializeFunctionModules()), because this may skip redrawing black function modules.
+LV_FUNC_SECTION
 static void drawWhiteFunctionModules(uint8_t qrcode[], int version)
 {
     // Draw horizontal and vertical timing patterns
@@ -525,6 +538,7 @@ static void drawWhiteFunctionModules(uint8_t qrcode[], int version)
 // Draws two copies of the format bits (with its own error correction code) based
 // on the given mask and error correction level. This always draws all modules of
 // the format bits, unlike drawWhiteFunctionModules() which might skip black modules.
+LV_FUNC_SECTION
 static void drawFormatBits(enum qrcodegen_Ecc ecl, enum qrcodegen_Mask mask, uint8_t qrcode[])
 {
     // Calculate error correction code and pack bits
@@ -560,6 +574,7 @@ static void drawFormatBits(enum qrcodegen_Ecc ecl, enum qrcodegen_Mask mask, uin
 // for this version number, returning the length of the list (in the range [0,7]).
 // Each position is in the range [0,177), and are used on both the x and y axes.
 // This could be implemented as lookup table of 40 variable-length lists of unsigned bytes.
+LV_FUNC_SECTION
 testable int getAlignmentPatternPositions(int version, uint8_t result[7])
 {
     if(version == 1)
@@ -575,6 +590,7 @@ testable int getAlignmentPatternPositions(int version, uint8_t result[7])
 
 
 // Sets every pixel in the range [left : left + width] * [top : top + height] to black.
+LV_FUNC_SECTION
 static void fillRectangle(int left, int top, int width, int height, uint8_t qrcode[])
 {
     for(int dy = 0; dy < height; dy++) {
@@ -589,6 +605,7 @@ static void fillRectangle(int left, int top, int width, int height, uint8_t qrco
 
 // Draws the raw codewords (including data and ECC) onto the given QR Code. This requires the initial state of
 // the QR Code to be black at function modules and white at codeword modules (including unused remainder bits).
+LV_FUNC_SECTION
 static void drawCodewords(const uint8_t data[], int dataLen, uint8_t qrcode[])
 {
     int qrsize = qrcodegen_getSize(qrcode);
@@ -621,6 +638,7 @@ static void drawCodewords(const uint8_t data[], int dataLen, uint8_t qrcode[])
 // before masking. Due to the arithmetic of XOR, calling applyMask() with
 // the same mask value a second time will undo the mask. A final well-formed
 // QR Code needs exactly one (not zero, two, etc.) mask applied.
+LV_FUNC_SECTION
 static void applyMask(const uint8_t functionModules[], uint8_t qrcode[], enum qrcodegen_Mask mask)
 {
     LV_ASSERT(0 <= (int)mask && (int)mask <= 7);  // Disallows qrcodegen_Mask_AUTO
@@ -668,6 +686,7 @@ static void applyMask(const uint8_t functionModules[], uint8_t qrcode[], enum qr
 
 // Calculates and returns the penalty score based on state of the given QR Code's current modules.
 // This is used by the automatic mask choice algorithm to find the mask pattern that yields the lowest score.
+LV_FUNC_SECTION
 static long getPenaltyScore(const uint8_t qrcode[])
 {
     int qrsize = qrcodegen_getSize(qrcode);
@@ -757,6 +776,7 @@ static long getPenaltyScore(const uint8_t qrcode[])
 
 // Inserts the given value to the front of the given array, which shifts over the
 // existing values and deletes the last value. A helper function for getPenaltyScore().
+LV_FUNC_SECTION
 static void addRunToHistory(unsigned char run, unsigned char history[7])
 {
     memmove(&history[1], &history[0], 6 * sizeof(history[0]));
@@ -767,6 +787,7 @@ static void addRunToHistory(unsigned char run, unsigned char history[7])
 // Tests whether the given run history has the pattern of ratio 1:1:3:1:1 in the middle, and
 // surrounded by at least 4 on either or both ends. A helper function for getPenaltyScore().
 // Must only be called immediately after a run of white modules has ended.
+LV_FUNC_SECTION
 static bool hasFinderLikePattern(const unsigned char runHistory[7])
 {
     unsigned char n = runHistory[1];
@@ -781,6 +802,7 @@ static bool hasFinderLikePattern(const unsigned char runHistory[7])
 /*---- Basic QR Code information ----*/
 
 // Public function - see documentation comment in header file.
+LV_FUNC_SECTION
 int qrcodegen_getSize(const uint8_t qrcode[])
 {
     LV_ASSERT(qrcode != NULL);
@@ -792,6 +814,7 @@ int qrcodegen_getSize(const uint8_t qrcode[])
 
 
 // Public function - see documentation comment in header file.
+LV_FUNC_SECTION
 bool qrcodegen_getModule(const uint8_t qrcode[], int x, int y)
 {
     LV_ASSERT(qrcode != NULL);
@@ -801,6 +824,7 @@ bool qrcodegen_getModule(const uint8_t qrcode[], int x, int y)
 
 
 // Gets the module at the given coordinates, which must be in bounds.
+LV_FUNC_SECTION
 testable bool getModule(const uint8_t qrcode[], int x, int y)
 {
     int qrsize = qrcode[0];
@@ -811,6 +835,7 @@ testable bool getModule(const uint8_t qrcode[], int x, int y)
 
 
 // Sets the module at the given coordinates, which must be in bounds.
+LV_FUNC_SECTION
 testable void setModule(uint8_t qrcode[], int x, int y, bool isBlack)
 {
     int qrsize = qrcode[0];
@@ -826,6 +851,7 @@ testable void setModule(uint8_t qrcode[], int x, int y, bool isBlack)
 
 
 // Sets the module at the given coordinates, doing nothing if out of bounds.
+LV_FUNC_SECTION
 testable void setModuleBounded(uint8_t qrcode[], int x, int y, bool isBlack)
 {
     int qrsize = qrcode[0];
@@ -835,6 +861,7 @@ testable void setModuleBounded(uint8_t qrcode[], int x, int y, bool isBlack)
 
 
 // Returns true iff the i'th bit of x is set to 1. Requires x >= 0 and 0 <= i <= 14.
+LV_FUNC_SECTION
 static bool getBit(int x, int i)
 {
     return ((x >> i) & 1) != 0;
@@ -845,6 +872,7 @@ static bool getBit(int x, int i)
 /*---- Segment handling ----*/
 
 // Public function - see documentation comment in header file.
+LV_FUNC_SECTION
 bool qrcodegen_isAlphanumeric(const char * text)
 {
     LV_ASSERT(text != NULL);
@@ -857,6 +885,7 @@ bool qrcodegen_isAlphanumeric(const char * text)
 
 
 // Public function - see documentation comment in header file.
+LV_FUNC_SECTION
 bool qrcodegen_isNumeric(const char * text)
 {
     LV_ASSERT(text != NULL);
@@ -869,6 +898,7 @@ bool qrcodegen_isNumeric(const char * text)
 
 
 // Public function - see documentation comment in header file.
+LV_FUNC_SECTION
 size_t qrcodegen_calcSegmentBufferSize(enum qrcodegen_Mode mode, size_t numChars)
 {
     int temp = calcSegmentBitLength(mode, numChars);
@@ -887,6 +917,7 @@ size_t qrcodegen_calcSegmentBufferSize(enum qrcodegen_Mode mode, size_t numChars
 // - For byte mode, numChars measures the number of bytes, not Unicode code points.
 // - For ECI mode, numChars must be 0, and the worst-case number of bits is returned.
 //   An actual ECI segment can have shorter data. For non-ECI modes, the result is exact.
+LV_FUNC_SECTION
 testable int calcSegmentBitLength(enum qrcodegen_Mode mode, size_t numChars)
 {
     // All calculations are designed to avoid overflow on all platforms
@@ -915,6 +946,7 @@ testable int calcSegmentBitLength(enum qrcodegen_Mode mode, size_t numChars)
 
 
 // Public function - see documentation comment in header file.
+LV_FUNC_SECTION
 struct qrcodegen_Segment qrcodegen_makeBytes(const uint8_t data[], size_t len, uint8_t buf[])
 {
     LV_ASSERT(data != NULL || len == 0);
@@ -931,6 +963,7 @@ struct qrcodegen_Segment qrcodegen_makeBytes(const uint8_t data[], size_t len, u
 
 
 // Public function - see documentation comment in header file.
+LV_FUNC_SECTION
 struct qrcodegen_Segment qrcodegen_makeNumeric(const char * digits, uint8_t buf[])
 {
     LV_ASSERT(digits != NULL);
@@ -966,6 +999,7 @@ struct qrcodegen_Segment qrcodegen_makeNumeric(const char * digits, uint8_t buf[
 
 
 // Public function - see documentation comment in header file.
+LV_FUNC_SECTION
 struct qrcodegen_Segment qrcodegen_makeAlphanumeric(const char * text, uint8_t buf[])
 {
     LV_ASSERT(text != NULL);
@@ -1001,6 +1035,7 @@ struct qrcodegen_Segment qrcodegen_makeAlphanumeric(const char * text, uint8_t b
 
 
 // Public function - see documentation comment in header file.
+LV_FUNC_SECTION
 struct qrcodegen_Segment qrcodegen_makeEci(long assignVal, uint8_t buf[])
 {
     struct qrcodegen_Segment result;
@@ -1036,6 +1071,7 @@ struct qrcodegen_Segment qrcodegen_makeEci(long assignVal, uint8_t buf[])
 // Calculates the number of bits needed to encode the given segments at the given version.
 // Returns a non-negative number if successful. Otherwise returns -1 if a segment has too
 // many characters to fit its length field, or the total bits exceeds INT16_MAX.
+LV_FUNC_SECTION
 testable int getTotalBits(const struct qrcodegen_Segment segs[], size_t len, int version)
 {
     LV_ASSERT(segs != NULL || len == 0);
@@ -1060,6 +1096,7 @@ testable int getTotalBits(const struct qrcodegen_Segment segs[], size_t len, int
 
 // Returns the bit width of the character count field for a segment in the given mode
 // in a QR Code at the given version number. The result is in the range [0, 16].
+LV_FUNC_SECTION
 static int numCharCountBits(enum qrcodegen_Mode mode, int version)
 {
     LV_ASSERT(qrcodegen_VERSION_MIN <= version && version <= qrcodegen_VERSION_MAX);
@@ -1089,6 +1126,7 @@ static int numCharCountBits(enum qrcodegen_Mode mode, int version)
     }
 }
 
+LV_FUNC_SECTION
 int qrcodegen_getMinFitVersion(enum qrcodegen_Ecc ecl, size_t dataLen)
 {
     struct qrcodegen_Segment seg;
@@ -1105,6 +1143,7 @@ int qrcodegen_getMinFitVersion(enum qrcodegen_Ecc ecl, size_t dataLen)
     return -1;
 }
 
+LV_FUNC_SECTION
 int qrcodegen_version2size(int version)
 {
     if(version < qrcodegen_VERSION_MIN || version > qrcodegen_VERSION_MAX) {
diff --git a/src/libs/rle/lv_rle.c b/src/libs/rle/lv_rle.c
index e715b7cc1..83e77db26 100644
--- a/src/libs/rle/lv_rle.c
+++ b/src/libs/rle/lv_rle.c
@@ -35,6 +35,7 @@
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 uint32_t lv_rle_decompress(const uint8_t * input,
                            uint32_t input_buff_len, uint8_t * output,
                            uint32_t output_buff_len, uint8_t blk_size)
diff --git a/src/libs/rlottie/lv_rlottie.c b/src/libs/rlottie/lv_rlottie.c
index 3c723ec0f..d86bfe127 100644
--- a/src/libs/rlottie/lv_rlottie.c
+++ b/src/libs/rlottie/lv_rlottie.c
@@ -62,6 +62,7 @@ static lv_rlottie_create_info_t create_info;
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 lv_obj_t * lv_rlottie_create_from_file(lv_obj_t * parent, int32_t width, int32_t height, const char * path)
 {
     create_info.width = width;
@@ -76,6 +77,7 @@ lv_obj_t * lv_rlottie_create_from_file(lv_obj_t * parent, int32_t width, int32_t
     return obj;
 }
 
+LV_FUNC_SECTION
 lv_obj_t * lv_rlottie_create_from_raw(lv_obj_t * parent, int32_t width, int32_t height, const char * rlottie_desc)
 {
     create_info.width = width;
@@ -90,6 +92,7 @@ lv_obj_t * lv_rlottie_create_from_raw(lv_obj_t * parent, int32_t width, int32_t
     return obj;
 }
 
+LV_FUNC_SECTION
 void lv_rlottie_set_play_mode(lv_obj_t * obj, const lv_rlottie_ctrl_t ctrl)
 {
     lv_rlottie_t * rlottie = (lv_rlottie_t *) obj;
@@ -101,6 +104,7 @@ void lv_rlottie_set_play_mode(lv_obj_t * obj, const lv_rlottie_ctrl_t ctrl)
     }
 }
 
+LV_FUNC_SECTION
 void lv_rlottie_set_current_frame(lv_obj_t * obj, const size_t goto_frame)
 {
     lv_rlottie_t * rlottie = (lv_rlottie_t *) obj;
@@ -111,6 +115,7 @@ void lv_rlottie_set_current_frame(lv_obj_t * obj, const size_t goto_frame)
  *   STATIC FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 static void lv_rlottie_constructor(const lv_obj_class_t * class_p, lv_obj_t * obj)
 {
     LV_UNUSED(class_p);
@@ -156,6 +161,7 @@ static void lv_rlottie_constructor(const lv_obj_class_t * class_p, lv_obj_t * ob
     lv_obj_update_layout(obj);
 }
 
+LV_FUNC_SECTION
 static void lv_rlottie_destructor(const lv_obj_class_t * class_p, lv_obj_t * obj)
 {
     LV_UNUSED(class_p);
@@ -187,6 +193,7 @@ static void lv_rlottie_destructor(const lv_obj_class_t * class_p, lv_obj_t * obj
 
 }
 
+LV_FUNC_SECTION
 static void next_frame_task_cb(lv_timer_t * t)
 {
     lv_obj_t * obj = lv_timer_get_user_data(t);
diff --git a/src/libs/tiny_ttf/lv_tiny_ttf.c b/src/libs/tiny_ttf/lv_tiny_ttf.c
index 899432707..3ad5a381e 100644
--- a/src/libs/tiny_ttf/lv_tiny_ttf.c
+++ b/src/libs/tiny_ttf/lv_tiny_ttf.c
@@ -120,6 +120,7 @@ static void lv_tiny_ttf_cache_create(ttf_font_desc_t * dsc);
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 void lv_tiny_ttf_set_size(lv_font_t * font, int32_t font_size)
 {
     if(font_size <= 0) {
@@ -148,6 +149,7 @@ void lv_tiny_ttf_set_size(lv_font_t * font, int32_t font_size)
     lv_tiny_ttf_cache_create(dsc);
 }
 
+LV_FUNC_SECTION
 void lv_tiny_ttf_destroy(lv_font_t * font)
 {
     LV_ASSERT_NULL(font);
@@ -173,6 +175,7 @@ void lv_tiny_ttf_destroy(lv_font_t * font)
  **********************/
 
 #if LV_TINY_TTF_FILE_SUPPORT != 0
+LV_FUNC_SECTION
 static void ttf_cb_stream_read(ttf_cb_stream_t * stream, void * data, size_t to_read)
 {
     if(stream->file != NULL) {
@@ -187,6 +190,7 @@ static void ttf_cb_stream_read(ttf_cb_stream_t * stream, void * data, size_t to_
         stream->position += to_read;
     }
 }
+LV_FUNC_SECTION
 static void ttf_cb_stream_seek(ttf_cb_stream_t * stream, size_t position)
 {
     if(stream->file != NULL) {
@@ -203,6 +207,7 @@ static void ttf_cb_stream_seek(ttf_cb_stream_t * stream, size_t position)
 }
 #endif
 
+LV_FUNC_SECTION
 static bool ttf_get_glyph_dsc_cb(const lv_font_t * font, lv_font_glyph_dsc_t * dsc_out, uint32_t unicode_letter,
                                  uint32_t unicode_letter_next)
 {
@@ -286,6 +291,7 @@ static bool ttf_get_glyph_dsc_cb(const lv_font_t * font, lv_font_glyph_dsc_t * d
     return true; /*true: glyph found; false: glyph was not found*/
 }
 
+LV_FUNC_SECTION
 static const void * ttf_get_glyph_bitmap_cb(lv_font_glyph_dsc_t * g_dsc, lv_draw_buf_t * draw_buf)
 {
     LV_UNUSED(draw_buf);
@@ -318,6 +324,7 @@ static const void * ttf_get_glyph_bitmap_cb(lv_font_glyph_dsc_t * g_dsc, lv_draw
     return cached_data->draw_buf;
 }
 
+LV_FUNC_SECTION
 static void ttf_release_glyph_cb(const lv_font_t * font, lv_font_glyph_dsc_t * g_dsc)
 {
     LV_ASSERT_NULL(font);
@@ -335,6 +342,7 @@ static void ttf_release_glyph_cb(const lv_font_t * font, lv_font_glyph_dsc_t * g
     g_dsc->entry = NULL;
 }
 
+LV_FUNC_SECTION
 static void lv_tiny_ttf_cache_create(ttf_font_desc_t * dsc)
 {
     /*Init cache*/
@@ -355,6 +363,7 @@ static void lv_tiny_ttf_cache_create(ttf_font_desc_t * dsc)
     lv_cache_set_name(dsc->draw_data_cache, "TINY_TTF_DRAW_DATA");
 }
 
+LV_FUNC_SECTION
 static lv_font_t * lv_tiny_ttf_create(const char * path, const void * data, size_t data_size, int32_t font_size,
                                       lv_font_kerning_t kerning, size_t cache_size)
 {
@@ -421,22 +430,26 @@ static lv_font_t * lv_tiny_ttf_create(const char * path, const void * data, size
     return out_font;
 }
 #if LV_TINY_TTF_FILE_SUPPORT != 0
+LV_FUNC_SECTION
 lv_font_t * lv_tiny_ttf_create_file_ex(const char * path, int32_t font_size, lv_font_kerning_t kerning,
                                        size_t cache_size)
 {
     return lv_tiny_ttf_create(path, NULL, 0, font_size, kerning, cache_size);
 }
+LV_FUNC_SECTION
 lv_font_t * lv_tiny_ttf_create_file(const char * path, int32_t font_size)
 {
     return lv_tiny_ttf_create(path, NULL, 0, font_size, LV_FONT_KERNING_NORMAL, LV_TINY_TTF_CACHE_GLYPH_CNT);
 }
 #endif
 
+LV_FUNC_SECTION
 lv_font_t * lv_tiny_ttf_create_data_ex(const void * data, size_t data_size, int32_t font_size,
                                        lv_font_kerning_t kerning, size_t cache_size)
 {
     return lv_tiny_ttf_create(NULL, data, data_size, font_size, kerning, cache_size);
 }
+LV_FUNC_SECTION
 lv_font_t * lv_tiny_ttf_create_data(const void * data, size_t data_size, int32_t font_size)
 {
     return lv_tiny_ttf_create(NULL, data, data_size, font_size, LV_FONT_KERNING_NORMAL, LV_TINY_TTF_CACHE_GLYPH_CNT);
@@ -445,7 +458,7 @@ lv_font_t * lv_tiny_ttf_create_data(const void * data, size_t data_size, int32_t
 /*-----------------
  * Cache Callbacks
  *----------------*/
-
+__attribute__(( fptrgroup("lv_cache_create_cb") ))
 static bool tiny_ttf_glyph_cache_create_cb(tiny_ttf_glyph_cache_data_t * node, void * user_data)
 {
     ttf_font_desc_t * dsc = (ttf_font_desc_t *)user_data;
@@ -486,12 +499,14 @@ static bool tiny_ttf_glyph_cache_create_cb(tiny_ttf_glyph_cache_data_t * node, v
     return true;
 }
 
+__attribute__(( fptrgroup("lv_cache_free_cb") ))
 static void tiny_ttf_glyph_cache_free_cb(tiny_ttf_glyph_cache_data_t * node, void * user_data)
 {
     LV_UNUSED(node);
     LV_UNUSED(user_data);
 }
 
+__attribute__(( fptrgroup("lv_cache_compare_cb") ))
 static lv_cache_compare_res_t tiny_ttf_glyph_cache_compare_cb(const tiny_ttf_glyph_cache_data_t * lhs,
                                                               const tiny_ttf_glyph_cache_data_t * rhs)
 {
@@ -502,6 +517,7 @@ static lv_cache_compare_res_t tiny_ttf_glyph_cache_compare_cb(const tiny_ttf_gly
     return 0;
 }
 
+__attribute__(( fptrgroup("lv_cache_create_cb") ))
 static bool tiny_ttf_draw_data_cache_create_cb(tiny_ttf_cache_data_t * node, void * user_data)
 {
     int g1 = (int)node->glyph_index;
@@ -534,6 +550,7 @@ static bool tiny_ttf_draw_data_cache_create_cb(tiny_ttf_cache_data_t * node, voi
     return true;
 }
 
+__attribute__(( fptrgroup("lv_cache_free_cb") ))
 static void tiny_ttf_draw_data_cache_free_cb(tiny_ttf_cache_data_t * node, void * user_data)
 {
     LV_UNUSED(user_data);
@@ -541,6 +558,7 @@ static void tiny_ttf_draw_data_cache_free_cb(tiny_ttf_cache_data_t * node, void
     lv_draw_buf_destroy(node->draw_buf);
 }
 
+__attribute__(( fptrgroup("lv_cache_compare_cb") ))
 static lv_cache_compare_res_t tiny_ttf_draw_data_cache_compare_cb(const tiny_ttf_cache_data_t * lhs,
                                                                   const tiny_ttf_cache_data_t * rhs)
 {
diff --git a/src/libs/tjpgd/lv_tjpgd.c b/src/libs/tjpgd/lv_tjpgd.c
index 650b36ad6..40a55f860 100644
--- a/src/libs/tjpgd/lv_tjpgd.c
+++ b/src/libs/tjpgd/lv_tjpgd.c
@@ -52,6 +52,7 @@ static int is_jpg(const uint8_t * raw_data, size_t len);
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 void lv_tjpgd_init(void)
 {
     lv_image_decoder_t * dec = lv_image_decoder_create();
@@ -63,6 +64,7 @@ void lv_tjpgd_init(void)
     dec->name = DECODER_NAME;
 }
 
+LV_FUNC_SECTION
 void lv_tjpgd_deinit(void)
 {
     lv_image_decoder_t * dec = NULL;
@@ -77,7 +79,7 @@ void lv_tjpgd_deinit(void)
 /**********************
  *   STATIC FUNCTIONS
  **********************/
-
+__attribute__(( fptrgroup("lv_image_deocder_info_cb") ))
 static lv_result_t decoder_info(lv_image_decoder_t * decoder, lv_image_decoder_dsc_t * dsc, lv_image_header_t * header)
 {
     LV_UNUSED(decoder);
@@ -125,6 +127,7 @@ static lv_result_t decoder_info(lv_image_decoder_t * decoder, lv_image_decoder_d
     return LV_RESULT_INVALID;
 }
 
+LV_FUNC_SECTION
 static size_t input_func(JDEC * jd, uint8_t * buff, size_t ndata)
 {
     lv_fs_file_t * f = jd->device;
@@ -150,6 +153,7 @@ static size_t input_func(JDEC * jd, uint8_t * buff, size_t ndata)
  * @param dsc     pointer to the decoder descriptor
  * @return LV_RESULT_OK: no error; LV_RESULT_INVALID: can't open the image
  */
+__attribute__(( fptrgroup("lv_image_deocder_open_cb") ))
 static lv_result_t decoder_open(lv_image_decoder_t * decoder, lv_image_decoder_dsc_t * dsc)
 {
     LV_UNUSED(decoder);
@@ -204,6 +208,7 @@ static lv_result_t decoder_open(lv_image_decoder_t * decoder, lv_image_decoder_d
     return LV_RESULT_OK;
 }
 
+__attribute__(( fptrgroup("lv_image_deocder_get_area_cb") ))
 static lv_result_t decoder_get_area(lv_image_decoder_t * decoder, lv_image_decoder_dsc_t * dsc,
                                     const lv_area_t * full_area, lv_area_t * decoded_area)
 {
@@ -280,6 +285,7 @@ static lv_result_t decoder_get_area(lv_image_decoder_t * decoder, lv_image_decod
  * @param decoder pointer to the decoder where this function belongs
  * @param dsc pointer to a descriptor which describes this decoding session
  */
+__attribute__(( fptrgroup("lv_image_deocder_close_cb") ))
 static void decoder_close(lv_image_decoder_t * decoder, lv_image_decoder_dsc_t * dsc)
 {
     LV_UNUSED(decoder);
@@ -291,6 +297,7 @@ static void decoder_close(lv_image_decoder_t * decoder, lv_image_decoder_dsc_t *
     lv_free((void *)dsc->decoded);
 }
 
+LV_FUNC_SECTION
 static int is_jpg(const uint8_t * raw_data, size_t len)
 {
     const uint8_t jpg_signature[] = {0xFF, 0xD8, 0xFF,  0xE0,  0x00,  0x10, 0x4A,  0x46, 0x49, 0x46};
diff --git a/src/libs/tjpgd/tjpgd.c b/src/libs/tjpgd/tjpgd.c
index 7152adf17..b4f43a80c 100644
--- a/src/libs/tjpgd/tjpgd.c
+++ b/src/libs/tjpgd/tjpgd.c
@@ -115,6 +115,7 @@ static const uint8_t Clip8[1024] = {
 
 #else   /* JD_TBLCLIP */
 
+LV_FUNC_SECTION
 static uint8_t BYTECLIP(int val)
 {
     if(val < 0) return 0;
@@ -130,6 +131,7 @@ static uint8_t BYTECLIP(int val)
 /* Allocate a memory block from memory pool                              */
 /*-----------------------------------------------------------------------*/
 
+LV_FUNC_SECTION
 static void * alloc_pool(   /* Pointer to allocated memory block (NULL:no memory available) */
     JDEC * jd,              /* Pointer to the decompressor object */
     size_t ndata            /* Number of bytes to allocate */
@@ -156,6 +158,7 @@ static void * alloc_pool(   /* Pointer to allocated memory block (NULL:no memory
 /* Create de-quantization and prescaling tables with a DQT segment       */
 /*-----------------------------------------------------------------------*/
 
+LV_FUNC_SECTION
 static JRESULT create_qt_tbl(   /* 0:OK, !0:Failed */
     JDEC * jd,              /* Pointer to the decompressor object */
     const uint8_t * data,   /* Pointer to the quantizer tables */
@@ -192,6 +195,7 @@ static JRESULT create_qt_tbl(   /* 0:OK, !0:Failed */
 /* Create huffman code tables with a DHT segment                         */
 /*-----------------------------------------------------------------------*/
 
+LV_FUNC_SECTION
 static JRESULT create_huffman_tbl(  /* 0:OK, !0:Failed */
     JDEC * jd,                  /* Pointer to the decompressor object */
     const uint8_t * data,       /* Pointer to the packed huffman tables */
@@ -283,6 +287,7 @@ static JRESULT create_huffman_tbl(  /* 0:OK, !0:Failed */
 /* Extract a huffman decoded data from input stream                      */
 /*-----------------------------------------------------------------------*/
 
+LV_FUNC_SECTION
 static int huffext(     /* >=0: decoded data, <0: error code */
     JDEC * jd,          /* Pointer to the decompressor object */
     unsigned int id,    /* Table ID (0:Y, 1:C) */
@@ -436,6 +441,7 @@ static int huffext(     /* >=0: decoded data, <0: error code */
 /* Extract N bits from input stream                                      */
 /*-----------------------------------------------------------------------*/
 
+LV_FUNC_SECTION
 static int bitext(  /* >=0: extracted data, <0: error code */
     JDEC * jd,          /* Pointer to the decompressor object */
     unsigned int nbit   /* Number of bits to extract (1 to 16) */
@@ -532,6 +538,7 @@ static int bitext(  /* >=0: extracted data, <0: error code */
 /* Process restart interval                                              */
 /*-----------------------------------------------------------------------*/
 
+LV_FUNC_SECTION
 JRESULT jd_restart(
     JDEC * jd,      /* Pointer to the decompressor object */
     uint16_t rstn   /* Expected restart sequence number */
@@ -608,6 +615,7 @@ JRESULT jd_restart(
 /* Apply Inverse-DCT in Arai Algorithm (see also aa_idct.png)            */
 /*-----------------------------------------------------------------------*/
 
+LV_FUNC_SECTION
 static void block_idct(
     int32_t * src,  /* Input block data (de-quantized and pre-scaled for Arai Algorithm) */
     jd_yuv_t * dst  /* Pointer to the destination to store the block as byte array */
@@ -733,6 +741,7 @@ static void block_idct(
 /* Load all blocks in an MCU into working buffer                         */
 /*-----------------------------------------------------------------------*/
 
+LV_FUNC_SECTION
 JRESULT jd_mcu_load(
     JDEC * jd       /* Pointer to the decompressor object */
 )
@@ -824,6 +833,7 @@ JRESULT jd_mcu_load(
 /* Output an MCU: Convert YCrCb to RGB and output it in RGB form         */
 /*-----------------------------------------------------------------------*/
 
+LV_FUNC_SECTION
 JRESULT jd_mcu_output(
     JDEC * jd,          /* Pointer to the decompressor object */
     int (*outfunc)(JDEC *, void *, JRECT *), /* RGB output function */
@@ -938,6 +948,7 @@ JRESULT jd_mcu_output(
 #define LDB_WORD(ptr)       (uint16_t)(((uint16_t)*((uint8_t*)(ptr))<<8)|(uint16_t)*(uint8_t*)((ptr)+1))
 
 
+LV_FUNC_SECTION
 JRESULT jd_prepare(
     JDEC * jd,              /* Blank decompressor object */
     size_t (*infunc)(JDEC *, uint8_t *, size_t), /* JPEG stream input function */
@@ -1099,6 +1110,7 @@ JRESULT jd_prepare(
 /* Start to decompress the JPEG picture                                  */
 /*-----------------------------------------------------------------------*/
 
+LV_FUNC_SECTION
 JRESULT jd_decomp(
     JDEC * jd,                              /* Initialized decompression object */
     int (*outfunc)(JDEC *, void *, JRECT *), /* RGB output function */
diff --git a/src/lv_init.c b/src/lv_init.c
index a019d6e57..25d84a0e7 100644
--- a/src/lv_init.c
+++ b/src/lv_init.c
@@ -93,6 +93,7 @@
 /**********************
  *   GLOBAL FUNCTIONS
  **********************/
+LV_FUNC_SECTION
 static inline void lv_global_init(lv_global_t * global)
 {
     LV_ASSERT_NULL(global);
@@ -125,6 +126,7 @@ static inline void lv_global_init(lv_global_t * global)
 #endif
 }
 
+LV_FUNC_SECTION
 static inline void lv_cleanup_devices(lv_global_t * global)
 {
     LV_ASSERT_NULL(global);
@@ -136,6 +138,7 @@ static inline void lv_cleanup_devices(lv_global_t * global)
     }
 }
 
+LV_FUNC_SECTION
 bool lv_is_initialized(void)
 {
 #if LV_ENABLE_GLOBAL_CUSTOM
@@ -146,6 +149,7 @@ bool lv_is_initialized(void)
 #endif
 }
 
+LV_FUNC_SECTION
 void lv_init(void)
 {
     /*First initialize Garbage Collection if needed*/
@@ -339,6 +343,7 @@ void lv_init(void)
     LV_LOG_TRACE("finished");
 }
 
+LV_FUNC_SECTION
 void lv_deinit(void)
 {
     /*Do nothing if already deinit*/
diff --git a/src/misc/cache/lv_cache.c b/src/misc/cache/lv_cache.c
index 0518ab5e1..5ad507235 100644
--- a/src/misc/cache/lv_cache.c
+++ b/src/misc/cache/lv_cache.c
@@ -41,6 +41,7 @@ static lv_cache_entry_t * cache_add_internal_no_lock(lv_cache_t * cache, const v
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 lv_cache_t * lv_cache_create(const lv_cache_class_t * cache_class,
                              size_t node_size, size_t max_size,
                              lv_cache_ops_t ops)
@@ -65,6 +66,7 @@ lv_cache_t * lv_cache_create(const lv_cache_class_t * cache_class,
     return cache;
 }
 
+LV_FUNC_SECTION
 void lv_cache_destroy(lv_cache_t * cache, void * user_data)
 {
     LV_ASSERT_NULL(cache);
@@ -76,6 +78,7 @@ void lv_cache_destroy(lv_cache_t * cache, void * user_data)
     lv_free(cache);
 }
 
+LV_FUNC_SECTION
 lv_cache_entry_t * lv_cache_acquire(lv_cache_t * cache, const void * key, void * user_data)
 {
     LV_ASSERT_NULL(cache);
@@ -101,6 +104,7 @@ lv_cache_entry_t * lv_cache_acquire(lv_cache_t * cache, const void * key, void *
     LV_PROFILER_END;
     return entry;
 }
+LV_FUNC_SECTION
 void lv_cache_release(lv_cache_t * cache, lv_cache_entry_t * entry, void * user_data)
 {
     LV_ASSERT_NULL(entry);
@@ -118,6 +122,7 @@ void lv_cache_release(lv_cache_t * cache, lv_cache_entry_t * entry, void * user_
 
     LV_PROFILER_END;
 }
+LV_FUNC_SECTION
 lv_cache_entry_t * lv_cache_add(lv_cache_t * cache, const void * key, void * user_data)
 {
     LV_ASSERT_NULL(cache);
@@ -142,6 +147,7 @@ lv_cache_entry_t * lv_cache_add(lv_cache_t * cache, const void * key, void * use
     LV_PROFILER_END;
     return entry;
 }
+LV_FUNC_SECTION
 lv_cache_entry_t * lv_cache_acquire_or_create(lv_cache_t * cache, const void * key, void * user_data)
 {
     LV_ASSERT_NULL(cache);
@@ -191,6 +197,7 @@ lv_cache_entry_t * lv_cache_acquire_or_create(lv_cache_t * cache, const void * k
     LV_PROFILER_END;
     return entry;
 }
+LV_FUNC_SECTION
 void lv_cache_reserve(lv_cache_t * cache, uint32_t reserved_size, void * user_data)
 {
     LV_ASSERT_NULL(cache);
@@ -204,6 +211,7 @@ void lv_cache_reserve(lv_cache_t * cache, uint32_t reserved_size, void * user_da
 
     LV_PROFILER_END;
 }
+LV_FUNC_SECTION
 void lv_cache_drop(lv_cache_t * cache, const void * key, void * user_data)
 {
     LV_ASSERT_NULL(cache);
@@ -217,6 +225,7 @@ void lv_cache_drop(lv_cache_t * cache, const void * key, void * user_data)
 
     LV_PROFILER_END;
 }
+LV_FUNC_SECTION
 bool lv_cache_evict_one(lv_cache_t * cache, void * user_data)
 {
     LV_ASSERT_NULL(cache);
@@ -230,6 +239,7 @@ bool lv_cache_evict_one(lv_cache_t * cache, void * user_data)
     LV_PROFILER_END;
     return res;
 }
+LV_FUNC_SECTION
 void lv_cache_drop_all(lv_cache_t * cache, void * user_data)
 {
     LV_ASSERT_NULL(cache);
@@ -243,50 +253,60 @@ void lv_cache_drop_all(lv_cache_t * cache, void * user_data)
     LV_PROFILER_END;
 }
 
+LV_FUNC_SECTION
 void lv_cache_set_max_size(lv_cache_t * cache, size_t max_size, void * user_data)
 {
     LV_UNUSED(user_data);
     cache->max_size = max_size;
 }
+LV_FUNC_SECTION
 size_t lv_cache_get_max_size(lv_cache_t * cache, void * user_data)
 {
     LV_UNUSED(user_data);
     return cache->max_size;
 }
+LV_FUNC_SECTION
 size_t lv_cache_get_size(lv_cache_t * cache, void * user_data)
 {
     LV_UNUSED(user_data);
     return cache->size;
 }
+LV_FUNC_SECTION
 size_t lv_cache_get_free_size(lv_cache_t * cache, void * user_data)
 {
     LV_UNUSED(user_data);
     return cache->max_size - cache->size;
 }
+LV_FUNC_SECTION
 bool lv_cache_is_enabled(lv_cache_t * cache)
 {
     return cache->max_size > 0;
 }
+LV_FUNC_SECTION
 void lv_cache_set_compare_cb(lv_cache_t * cache, lv_cache_compare_cb_t compare_cb, void * user_data)
 {
     LV_UNUSED(user_data);
     cache->ops.compare_cb = compare_cb;
 }
+LV_FUNC_SECTION
 void lv_cache_set_create_cb(lv_cache_t * cache, lv_cache_create_cb_t alloc_cb, void * user_data)
 {
     LV_UNUSED(user_data);
     cache->ops.create_cb = alloc_cb;
 }
+LV_FUNC_SECTION
 void lv_cache_set_free_cb(lv_cache_t * cache, lv_cache_free_cb_t free_cb, void * user_data)
 {
     LV_UNUSED(user_data);
     cache->ops.free_cb = free_cb;
 }
+LV_FUNC_SECTION
 void lv_cache_set_name(lv_cache_t * cache, const char * name)
 {
     if(cache == NULL) return;
     cache->name = name;
 }
+LV_FUNC_SECTION
 const char * lv_cache_get_name(lv_cache_t * cache)
 {
     return cache->name;
@@ -296,6 +316,7 @@ const char * lv_cache_get_name(lv_cache_t * cache)
  *   STATIC FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 static void cache_drop_internal_no_lock(lv_cache_t * cache, const void * key, void * user_data)
 {
     lv_cache_entry_t * entry = cache->clz->get_cb(cache, key, user_data);
@@ -314,6 +335,7 @@ static void cache_drop_internal_no_lock(lv_cache_t * cache, const void * key, vo
     }
 }
 
+LV_FUNC_SECTION
 static bool cache_evict_one_internal_no_lock(lv_cache_t * cache, void * user_data)
 {
     lv_cache_entry_t * victim = cache->clz->get_victim_cb(cache, user_data);
@@ -329,6 +351,7 @@ static bool cache_evict_one_internal_no_lock(lv_cache_t * cache, void * user_dat
     return true;
 }
 
+LV_FUNC_SECTION
 static lv_cache_entry_t * cache_add_internal_no_lock(lv_cache_t * cache, const void * key, void * user_data)
 {
     lv_cache_reserve_cond_res_t reserve_cond_res = cache->clz->reserve_cond_cb(cache, key, 0, user_data);
diff --git a/src/misc/cache/lv_cache_entry.c b/src/misc/cache/lv_cache_entry.c
index e0cc66434..4497822f2 100644
--- a/src/misc/cache/lv_cache_entry.c
+++ b/src/misc/cache/lv_cache_entry.c
@@ -46,16 +46,19 @@ struct lv_cache_entry_t {
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 void lv_cache_entry_reset_ref(lv_cache_entry_t * entry)
 {
     LV_ASSERT_NULL(entry);
     entry->ref_cnt = 0;
 }
+LV_FUNC_SECTION
 void lv_cache_entry_inc_ref(lv_cache_entry_t * entry)
 {
     LV_ASSERT_NULL(entry);
     entry->ref_cnt++;
 }
+LV_FUNC_SECTION
 void lv_cache_entry_dec_ref(lv_cache_entry_t * entry)
 {
     LV_ASSERT_NULL(entry);
@@ -65,35 +68,42 @@ void lv_cache_entry_dec_ref(lv_cache_entry_t * entry)
         entry->ref_cnt = 0;
     }
 }
+LV_FUNC_SECTION
 int32_t lv_cache_entry_get_ref(lv_cache_entry_t * entry)
 {
     LV_ASSERT_NULL(entry);
     return entry->ref_cnt;
 }
+LV_FUNC_SECTION
 uint32_t lv_cache_entry_get_node_size(lv_cache_entry_t * entry)
 {
     return entry->node_size;
 }
+LV_FUNC_SECTION
 void lv_cache_entry_set_node_size(lv_cache_entry_t * entry, uint32_t node_size)
 {
     LV_ASSERT_NULL(entry);
     entry->node_size = node_size;
 }
+LV_FUNC_SECTION
 void lv_cache_entry_set_invalid(lv_cache_entry_t * entry, bool is_invalid)
 {
     LV_ASSERT_NULL(entry);
     entry->is_invalid = is_invalid;
 }
+LV_FUNC_SECTION
 bool lv_cache_entry_is_invalid(lv_cache_entry_t * entry)
 {
     LV_ASSERT_NULL(entry);
     return entry->is_invalid;
 }
+LV_FUNC_SECTION
 void * lv_cache_entry_get_data(lv_cache_entry_t * entry)
 {
     LV_ASSERT_NULL(entry);
     return (uint8_t *)entry - entry->node_size;
 }
+LV_FUNC_SECTION
 void * lv_cache_entry_acquire_data(lv_cache_entry_t * entry)
 {
     LV_ASSERT_NULL(entry);
@@ -101,6 +111,7 @@ void * lv_cache_entry_acquire_data(lv_cache_entry_t * entry)
     lv_cache_entry_inc_ref(entry);
     return lv_cache_entry_get_data(entry);
 }
+LV_FUNC_SECTION
 void lv_cache_entry_release_data(lv_cache_entry_t * entry, void * user_data)
 {
     LV_UNUSED(user_data);
@@ -113,26 +124,31 @@ void lv_cache_entry_release_data(lv_cache_entry_t * entry, void * user_data)
 
     lv_cache_entry_dec_ref(entry);
 }
+LV_FUNC_SECTION
 lv_cache_entry_t * lv_cache_entry_get_entry(void * data, const uint32_t node_size)
 {
     LV_ASSERT_NULL(data);
     return (lv_cache_entry_t *)((uint8_t *)data + node_size);
 }
+LV_FUNC_SECTION
 void lv_cache_entry_set_cache(lv_cache_entry_t * entry, const lv_cache_t * cache)
 {
     LV_ASSERT_NULL(entry);
     entry->cache = cache;
 }
+LV_FUNC_SECTION
 const lv_cache_t * lv_cache_entry_get_cache(const lv_cache_entry_t * entry)
 {
     LV_ASSERT_NULL(entry);
     return entry->cache;
 }
 
+LV_FUNC_SECTION
 uint32_t lv_cache_entry_get_size(const uint32_t node_size)
 {
     return node_size + sizeof(lv_cache_entry_t);
 }
+LV_FUNC_SECTION
 lv_cache_entry_t * lv_cache_entry_alloc(const uint32_t node_size, const lv_cache_t * cache)
 {
     void * res = lv_malloc_zeroed(lv_cache_entry_get_size(node_size));
@@ -145,6 +161,7 @@ lv_cache_entry_t * lv_cache_entry_alloc(const uint32_t node_size, const lv_cache
     lv_cache_entry_init(entry, cache, node_size);
     return (lv_cache_entry_t *)((uint8_t *)entry + node_size);
 }
+LV_FUNC_SECTION
 void lv_cache_entry_init(lv_cache_entry_t * entry, const lv_cache_t * cache, const uint32_t node_size)
 {
     LV_ASSERT_NULL(entry);
@@ -155,6 +172,7 @@ void lv_cache_entry_init(lv_cache_entry_t * entry, const lv_cache_t * cache, con
     entry->ref_cnt = 0;
     entry->is_invalid = false;
 }
+LV_FUNC_SECTION
 void lv_cache_entry_delete(lv_cache_entry_t * entry)
 {
     LV_ASSERT_NULL(entry);
diff --git a/src/misc/cache/lv_cache_lru_rb.c b/src/misc/cache/lv_cache_lru_rb.c
index 0a73102d1..af6e2491a 100644
--- a/src/misc/cache/lv_cache_lru_rb.c
+++ b/src/misc/cache/lv_cache_lru_rb.c
@@ -64,6 +64,7 @@ struct lv_lru_rb_t {
     lv_rb_t rb;
     lv_ll_t ll;
 
+    __attribute__(( fptrgroup("lv_lru_get_data_size_cb_cb") ))
     get_data_size_cb_t * get_data_size_cb;
 };
 typedef struct lv_lru_rb_t lv_lru_rb_t_;
@@ -136,6 +137,7 @@ const lv_cache_class_t lv_cache_class_lru_rb_size = {
 /**********************
  *   STATIC FUNCTIONS
  **********************/
+LV_FUNC_SECTION
 static void * alloc_new_node(lv_lru_rb_t_ * lru, void * key, void * user_data)
 {
     LV_UNUSED(user_data);
@@ -172,11 +174,13 @@ FAILED_HANDLER2:
     return node;
 }
 
+LV_FUNC_SECTION
 inline static void ** get_lru_node(lv_lru_rb_t_ * lru, lv_rb_node_t * node)
 {
     return (void **)((char *)node->data + lru->rb.size - sizeof(void *));
 }
 
+__attribute__(( fptrgroup("lv_cache_alloc_cb") ))
 static void * alloc_cb(void)
 {
     void * res = lv_malloc(sizeof(lv_lru_rb_t_));
@@ -190,6 +194,7 @@ static void * alloc_cb(void)
     return res;
 }
 
+__attribute__(( fptrgroup("lv_cache_init_cb") ))
 static bool init_cnt_cb(lv_cache_t * cache)
 {
     lv_lru_rb_t_ * lru = (lv_lru_rb_t_ *)cache;
@@ -213,6 +218,7 @@ static bool init_cnt_cb(lv_cache_t * cache)
     return true;
 }
 
+__attribute__(( fptrgroup("lv_cache_init_cb") ))
 static bool init_size_cb(lv_cache_t * cache)
 {
     lv_lru_rb_t_ * lru = (lv_lru_rb_t_ *)cache;
@@ -236,6 +242,7 @@ static bool init_size_cb(lv_cache_t * cache)
     return true;
 }
 
+__attribute__(( fptrgroup("lv_cache_destroy_cb") ))
 static void destroy_cb(lv_cache_t * cache, void * user_data)
 {
     LV_UNUSED(user_data);
@@ -251,6 +258,7 @@ static void destroy_cb(lv_cache_t * cache, void * user_data)
     cache->clz->drop_all_cb(cache, user_data);
 }
 
+__attribute__(( fptrgroup("lv_cache_get_cb") ))
 static lv_cache_entry_t * get_cb(lv_cache_t * cache, const void * key, void * user_data)
 {
     LV_UNUSED(user_data);
@@ -288,6 +296,7 @@ static lv_cache_entry_t * get_cb(lv_cache_t * cache, const void * key, void * us
     return NULL;
 }
 
+__attribute__(( fptrgroup("lv_cache_add_cb") ))
 static lv_cache_entry_t * add_cb(lv_cache_t * cache, const void * key, void * user_data)
 {
     LV_UNUSED(user_data);
@@ -313,6 +322,7 @@ static lv_cache_entry_t * add_cb(lv_cache_t * cache, const void * key, void * us
     return entry;
 }
 
+__attribute__(( fptrgroup("lv_cache_remove_cb") ))
 static void remove_cb(lv_cache_t * cache, lv_cache_entry_t * entry, void * user_data)
 {
     LV_UNUSED(user_data);
@@ -340,6 +350,7 @@ static void remove_cb(lv_cache_t * cache, lv_cache_entry_t * entry, void * user_
     cache->size -= lru->get_data_size_cb(data);
 }
 
+__attribute__(( fptrgroup("lv_cache_drop_cb") ))
 static void drop_cb(lv_cache_t * cache, const void * key, void * user_data)
 {
     lv_lru_rb_t_ * lru = (lv_lru_rb_t_ *)cache;
@@ -371,6 +382,7 @@ static void drop_cb(lv_cache_t * cache, const void * key, void * user_data)
     lv_free(lru_node);
 }
 
+__attribute__(( fptrgroup("lv_cache_drop_all_cb") ))
 static void drop_all_cb(lv_cache_t * cache, void * user_data)
 {
     lv_lru_rb_t_ * lru = (lv_lru_rb_t_ *)cache;
@@ -405,6 +417,7 @@ static void drop_all_cb(lv_cache_t * cache, void * user_data)
     cache->size = 0;
 }
 
+__attribute__(( fptrgroup("lv_cache_get_victim_cb") ))
 static lv_cache_entry_t * get_victim_cb(lv_cache_t * cache, void * user_data)
 {
     LV_UNUSED(user_data);
@@ -425,6 +438,7 @@ static lv_cache_entry_t * get_victim_cb(lv_cache_t * cache, void * user_data)
     return NULL;
 }
 
+__attribute__(( fptrgroup("lv_cache_reserve_cond_cb") ))
 static lv_cache_reserve_cond_res_t reserve_cond_cb(lv_cache_t * cache, const void * key, size_t reserved_size,
                                                    void * user_data)
 {
@@ -449,12 +463,14 @@ static lv_cache_reserve_cond_res_t reserve_cond_cb(lv_cache_t * cache, const voi
            : LV_CACHE_RESERVE_COND_OK;
 }
 
+__attribute__(( fptrgroup("lv_lru_get_data_size_cb_cb") ))
 static uint32_t cnt_get_data_size_cb(const void * data)
 {
     LV_UNUSED(data);
     return 1;
 }
 
+__attribute__(( fptrgroup("lv_lru_get_data_size_cb_cb") ))
 static uint32_t size_get_data_size_cb(const void * data)
 {
     lv_cache_slot_size_t * slot = (lv_cache_slot_size_t *)data;
diff --git a/src/misc/cache/lv_cache_private.h b/src/misc/cache/lv_cache_private.h
index c8ac24993..e573c7ec6 100644
--- a/src/misc/cache/lv_cache_private.h
+++ b/src/misc/cache/lv_cache_private.h
@@ -111,8 +111,11 @@ typedef lv_cache_reserve_cond_res_t (*lv_cache_reserve_cond_cb)(lv_cache_t * cac
  * The cache operations struct
  */
 struct lv_cache_ops_t {
+    __attribute__(( fptrgroup("lv_cache_compare_cb") ))
     lv_cache_compare_cb_t compare_cb;    /**< Compare function for keys */
+    __attribute__(( fptrgroup("lv_cache_create_cb") ))
     lv_cache_create_cb_t create_cb;      /**< Create function for nodes */
+    __attribute__(( fptrgroup("lv_cache_free_cb") ))
     lv_cache_free_cb_t free_cb;          /**< Free function for nodes */
 };
 
@@ -144,16 +147,26 @@ struct lv_cache_t {
  * - lv_cache_class_lru_rb_size for LRU-based cache with size-based eviction policy.
  */
 struct lv_cache_class_t {
+    __attribute__(( fptrgroup("lv_cache_alloc_cb") ))
     lv_cache_alloc_cb_t alloc_cb;                 /**< The allocation function for cache entries */
+    __attribute__(( fptrgroup("lv_cache_init_cb") ))
     lv_cache_init_cb_t init_cb;                   /**< The initialization function for cache entries */
+    __attribute__(( fptrgroup("lv_cache_destroy_cb") ))
     lv_cache_destroy_cb_t destroy_cb;             /**< The destruction function for cache entries */
 
+    __attribute__(( fptrgroup("lv_cache_get_cb") ))
     lv_cache_get_cb_t get_cb;                     /**< The get function for cache entries */
+    __attribute__(( fptrgroup("lv_cache_add_cb") ))
     lv_cache_add_cb_t add_cb;                     /**< The add function for cache entries */
+    __attribute__(( fptrgroup("lv_cache_remove_cb") ))
     lv_cache_remove_cb_t remove_cb;               /**< The remove function for cache entries */
+    __attribute__(( fptrgroup("lv_cache_drop_cb") ))
     lv_cache_drop_cb_t drop_cb;                   /**< The drop function for cache entries */
+    __attribute__(( fptrgroup("lv_cache_drop_all_cb") ))
     lv_cache_drop_all_cb_t drop_all_cb;           /**< The drop all function for cache entries */
+    __attribute__(( fptrgroup("lv_cache_get_victim_cb") ))
     lv_cache_get_victim_cb get_victim_cb;         /**< The get victim function for cache entries */
+    __attribute__(( fptrgroup("lv_cache_reserve_cond_cb") ))
     lv_cache_reserve_cond_cb reserve_cond_cb;     /**< The reserve condition function for cache entries */
 };
 
diff --git a/src/misc/cache/lv_image_cache.c b/src/misc/cache/lv_image_cache.c
index c2ca4354e..4a162ef39 100644
--- a/src/misc/cache/lv_image_cache.c
+++ b/src/misc/cache/lv_image_cache.c
@@ -51,6 +51,7 @@ static void image_cache_free_cb(lv_image_cache_data_t * entry, void * user_data)
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 lv_result_t lv_image_cache_init(uint32_t size)
 {
     if(img_cache_p != NULL) {
@@ -68,6 +69,7 @@ lv_result_t lv_image_cache_init(uint32_t size)
     return img_cache_p != NULL ? LV_RESULT_OK : LV_RESULT_INVALID;
 }
 
+LV_FUNC_SECTION
 void lv_image_cache_resize(uint32_t new_size, bool evict_now)
 {
     lv_cache_set_max_size(img_cache_p, new_size, NULL);
@@ -76,6 +78,7 @@ void lv_image_cache_resize(uint32_t new_size, bool evict_now)
     }
 }
 
+LV_FUNC_SECTION
 void lv_image_cache_drop(const void * src)
 {
     /*If user invalidate image, the header cache should be invalidated too.*/
@@ -94,6 +97,7 @@ void lv_image_cache_drop(const void * src)
     lv_cache_drop(img_cache_p, &search_key, NULL);
 }
 
+LV_FUNC_SECTION
 bool lv_image_cache_is_enabled(void)
 {
     return lv_cache_is_enabled(img_cache_p);
@@ -103,6 +107,7 @@ bool lv_image_cache_is_enabled(void)
  *   STATIC FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 inline static lv_cache_compare_res_t image_cache_common_compare(const void * lhs_src, lv_image_src_t lhs_src_type,
                                                                 const void * rhs_src, lv_image_src_t rhs_src_type)
 {
@@ -123,6 +128,7 @@ inline static lv_cache_compare_res_t image_cache_common_compare(const void * lhs
     return lhs_src_type > rhs_src_type ? 1 : -1;
 }
 
+__attribute__(( fptrgroup("lv_cache_compare_cb") ))
 static lv_cache_compare_res_t image_cache_compare_cb(
     const lv_image_cache_data_t * lhs,
     const lv_image_cache_data_t * rhs)
@@ -130,6 +136,7 @@ static lv_cache_compare_res_t image_cache_compare_cb(
     return image_cache_common_compare(lhs->src, lhs->src_type, rhs->src, rhs->src_type);
 }
 
+__attribute__(( fptrgroup("lv_cache_free_cb") ))
 static void image_cache_free_cb(lv_image_cache_data_t * entry, void * user_data)
 {
     LV_UNUSED(user_data);
diff --git a/src/misc/cache/lv_image_header_cache.c b/src/misc/cache/lv_image_header_cache.c
index ef124fb0a..1ab374933 100644
--- a/src/misc/cache/lv_image_header_cache.c
+++ b/src/misc/cache/lv_image_header_cache.c
@@ -49,6 +49,7 @@ static void image_header_cache_free_cb(lv_image_header_cache_data_t * entry, voi
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 lv_result_t lv_image_header_cache_init(uint32_t count)
 {
     if(img_header_cache_p != NULL) {
@@ -66,6 +67,7 @@ lv_result_t lv_image_header_cache_init(uint32_t count)
     return img_header_cache_p != NULL ? LV_RESULT_OK : LV_RESULT_INVALID;
 }
 
+LV_FUNC_SECTION
 void lv_image_header_cache_resize(uint32_t count, bool evict_now)
 {
     lv_cache_set_max_size(img_header_cache_p, count, NULL);
@@ -74,6 +76,7 @@ void lv_image_header_cache_resize(uint32_t count, bool evict_now)
     }
 }
 
+LV_FUNC_SECTION
 void lv_image_header_cache_drop(const void * src)
 {
     if(src == NULL) {
@@ -89,6 +92,7 @@ void lv_image_header_cache_drop(const void * src)
     lv_cache_drop(img_header_cache_p, &search_key, NULL);
 }
 
+LV_FUNC_SECTION
 bool lv_image_header_cache_is_enabled(void)
 {
     return lv_cache_is_enabled(img_header_cache_p);
@@ -98,6 +102,7 @@ bool lv_image_header_cache_is_enabled(void)
  *   STATIC FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 inline static lv_cache_compare_res_t image_cache_common_compare(const void * lhs_src, lv_image_src_t lhs_src_type,
                                                                 const void * rhs_src, lv_image_src_t rhs_src_type)
 {
@@ -118,6 +123,7 @@ inline static lv_cache_compare_res_t image_cache_common_compare(const void * lhs
     return lhs_src_type > rhs_src_type ? 1 : -1;
 }
 
+__attribute__(( fptrgroup("lv_cache_compare_cb") ))
 static lv_cache_compare_res_t image_header_cache_compare_cb(
     const lv_image_header_cache_data_t * lhs,
     const lv_image_header_cache_data_t * rhs)
@@ -125,6 +131,7 @@ static lv_cache_compare_res_t image_header_cache_compare_cb(
     return image_cache_common_compare(lhs->src, lhs->src_type, rhs->src, rhs->src_type);
 }
 
+__attribute__(( fptrgroup("lv_cache_free_cb") ))
 static void image_header_cache_free_cb(lv_image_header_cache_data_t * entry, void * user_data)
 {
     LV_UNUSED(user_data); /*Unused*/
diff --git a/src/misc/lv_anim.c b/src/misc/lv_anim.c
index 8fc986764..6f0e9c266 100644
--- a/src/misc/lv_anim.c
+++ b/src/misc/lv_anim.c
@@ -58,6 +58,7 @@ static void remove_anim(void * a);
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 void lv_anim_core_init(void)
 {
     lv_ll_init(anim_ll_p, sizeof(lv_anim_t));
@@ -67,11 +68,13 @@ void lv_anim_core_init(void)
     state.anim_run_round = false;
 }
 
+LV_FUNC_SECTION
 void lv_anim_core_deinit(void)
 {
     lv_anim_delete_all();
 }
 
+LV_FUNC_SECTION
 void lv_anim_init(lv_anim_t * a)
 {
     lv_memzero(a, sizeof(lv_anim_t));
@@ -83,6 +86,7 @@ void lv_anim_init(lv_anim_t * a)
     a->early_apply = 1;
 }
 
+LV_FUNC_SECTION
 lv_anim_t * lv_anim_start(const lv_anim_t * a)
 {
     LV_TRACE_ANIM("begin");
@@ -128,6 +132,7 @@ lv_anim_t * lv_anim_start(const lv_anim_t * a)
     return new_anim;
 }
 
+LV_FUNC_SECTION
 uint32_t lv_anim_get_playtime(const lv_anim_t * a)
 {
     if(a->repeat_cnt == LV_ANIM_REPEAT_INFINITE) {
@@ -142,6 +147,7 @@ uint32_t lv_anim_get_playtime(const lv_anim_t * a)
     return playtime;
 }
 
+LV_FUNC_SECTION
 bool lv_anim_delete(void * var, lv_anim_exec_xcb_t exec_cb)
 {
     lv_anim_t * a;
@@ -165,12 +171,14 @@ bool lv_anim_delete(void * var, lv_anim_exec_xcb_t exec_cb)
     return del_any;
 }
 
+LV_FUNC_SECTION
 void lv_anim_delete_all(void)
 {
     lv_ll_clear_custom(anim_ll_p, remove_anim);
     anim_mark_list_change();
 }
 
+LV_FUNC_SECTION
 lv_anim_t * lv_anim_get(void * var, lv_anim_exec_xcb_t exec_cb)
 {
     lv_anim_t * a;
@@ -183,11 +191,13 @@ lv_anim_t * lv_anim_get(void * var, lv_anim_exec_xcb_t exec_cb)
     return NULL;
 }
 
+LV_FUNC_SECTION
 lv_timer_t * lv_anim_get_timer(void)
 {
     return state.timer;
 }
 
+LV_FUNC_SECTION
 uint16_t lv_anim_count_running(void)
 {
     uint16_t cnt = 0;
@@ -197,6 +207,7 @@ uint16_t lv_anim_count_running(void)
     return cnt;
 }
 
+LV_FUNC_SECTION
 uint32_t lv_anim_speed_clamped(uint32_t speed, uint32_t min_time, uint32_t max_time)
 {
 
@@ -222,11 +233,13 @@ uint32_t lv_anim_speed_clamped(uint32_t speed, uint32_t min_time, uint32_t max_t
 
 }
 
+LV_FUNC_SECTION
 uint32_t lv_anim_speed(uint32_t speed)
 {
     return lv_anim_speed_clamped(speed, 0, 10000);
 }
 
+LV_FUNC_SECTION
 uint32_t lv_anim_speed_to_time(uint32_t speed, int32_t start, int32_t end)
 {
     uint32_t d = LV_ABS(start - end);
@@ -237,11 +250,13 @@ uint32_t lv_anim_speed_to_time(uint32_t speed, int32_t start, int32_t end)
     return time;
 }
 
+LV_FUNC_SECTION
 void lv_anim_refr_now(void)
 {
     anim_timer(NULL);
 }
 
+__attribute__(( fptrgroup("lv_anim_path_cb") ))
 int32_t lv_anim_path_linear(const lv_anim_t * a)
 {
     /*Calculate the current step*/
@@ -257,29 +272,34 @@ int32_t lv_anim_path_linear(const lv_anim_t * a)
     return new_value;
 }
 
+__attribute__(( fptrgroup("lv_anim_path_cb") ))
 int32_t lv_anim_path_ease_in(const lv_anim_t * a)
 {
     return lv_anim_path_cubic_bezier(a, LV_BEZIER_VAL_FLOAT(0.42), LV_BEZIER_VAL_FLOAT(0),
                                      LV_BEZIER_VAL_FLOAT(1), LV_BEZIER_VAL_FLOAT(1));
 }
 
+__attribute__(( fptrgroup("lv_anim_path_cb") ))
 int32_t lv_anim_path_ease_out(const lv_anim_t * a)
 {
     return lv_anim_path_cubic_bezier(a, LV_BEZIER_VAL_FLOAT(0), LV_BEZIER_VAL_FLOAT(0),
                                      LV_BEZIER_VAL_FLOAT(0.58), LV_BEZIER_VAL_FLOAT(1));
 }
 
+__attribute__(( fptrgroup("lv_anim_path_cb") ))
 int32_t lv_anim_path_ease_in_out(const lv_anim_t * a)
 {
     return lv_anim_path_cubic_bezier(a, LV_BEZIER_VAL_FLOAT(0.42), LV_BEZIER_VAL_FLOAT(0),
                                      LV_BEZIER_VAL_FLOAT(0.58), LV_BEZIER_VAL_FLOAT(1));
 }
 
+__attribute__(( fptrgroup("lv_anim_path_cb") ))
 int32_t lv_anim_path_overshoot(const lv_anim_t * a)
 {
     return lv_anim_path_cubic_bezier(a, 341, 0, 683, 1300);
 }
 
+__attribute__(( fptrgroup("lv_anim_path_cb") ))
 int32_t lv_anim_path_bounce(const lv_anim_t * a)
 {
     /*Calculate the current step*/
@@ -332,6 +352,7 @@ int32_t lv_anim_path_bounce(const lv_anim_t * a)
     return new_value;
 }
 
+__attribute__(( fptrgroup("lv_anim_path_cb") ))
 int32_t lv_anim_path_step(const lv_anim_t * a)
 {
     if(a->act_time >= a->duration)
@@ -340,37 +361,44 @@ int32_t lv_anim_path_step(const lv_anim_t * a)
         return a->start_value;
 }
 
+__attribute__(( fptrgroup("lv_anim_path_cb") ))
 int32_t lv_anim_path_custom_bezier3(const lv_anim_t * a)
 {
     const lv_anim_bezier3_para_t * para = &a->parameter.bezier3;
     return lv_anim_path_cubic_bezier(a, para->x1, para->y1, para->x2, para->y2);
 }
 
+LV_FUNC_SECTION
 void lv_anim_set_var(lv_anim_t * a, void * var)
 {
     a->var = var;
 }
 
+LV_FUNC_SECTION
 void lv_anim_set_exec_cb(lv_anim_t * a, lv_anim_exec_xcb_t exec_cb)
 {
     a->exec_cb = exec_cb;
 }
 
+LV_FUNC_SECTION
 void lv_anim_set_duration(lv_anim_t * a, uint32_t duration)
 {
     a->duration = duration;
 }
 
+LV_FUNC_SECTION
 void lv_anim_set_time(lv_anim_t * a, uint32_t duration)
 {
     lv_anim_set_duration(a, duration);
 }
 
+LV_FUNC_SECTION
 void lv_anim_set_delay(lv_anim_t * a, uint32_t delay)
 {
     a->act_time = -(int32_t)(delay);
 }
 
+LV_FUNC_SECTION
 void lv_anim_set_values(lv_anim_t * a, int32_t start, int32_t end)
 {
     a->start_value = start;
@@ -378,71 +406,85 @@ void lv_anim_set_values(lv_anim_t * a, int32_t start, int32_t end)
     a->end_value = end;
 }
 
+LV_FUNC_SECTION
 void lv_anim_set_custom_exec_cb(lv_anim_t * a, lv_anim_custom_exec_cb_t exec_cb)
 {
     a->custom_exec_cb = exec_cb;
 }
 
+LV_FUNC_SECTION
 void lv_anim_set_path_cb(lv_anim_t * a, lv_anim_path_cb_t path_cb)
 {
     a->path_cb = path_cb;
 }
 
+LV_FUNC_SECTION
 void lv_anim_set_start_cb(lv_anim_t * a, lv_anim_start_cb_t start_cb)
 {
     a->start_cb = start_cb;
 }
 
+LV_FUNC_SECTION
 void lv_anim_set_get_value_cb(lv_anim_t * a, lv_anim_get_value_cb_t get_value_cb)
 {
     a->get_value_cb = get_value_cb;
 }
 
+LV_FUNC_SECTION
 void lv_anim_set_completed_cb(lv_anim_t * a, lv_anim_completed_cb_t completed_cb)
 {
     a->completed_cb = completed_cb;
 }
 
+LV_FUNC_SECTION
 void lv_anim_set_deleted_cb(lv_anim_t * a, lv_anim_deleted_cb_t deleted_cb)
 {
     a->deleted_cb = deleted_cb;
 }
 
+LV_FUNC_SECTION
 void lv_anim_set_playback_duration(lv_anim_t * a, uint32_t duration)
 {
     a->playback_duration = duration;
 }
 
+LV_FUNC_SECTION
 void lv_anim_set_playback_time(lv_anim_t * a, uint32_t duration)
 {
     lv_anim_set_playback_duration(a, duration);
 }
 
+LV_FUNC_SECTION
 void lv_anim_set_playback_delay(lv_anim_t * a, uint32_t delay)
 {
     a->playback_delay = delay;
 }
 
+LV_FUNC_SECTION
 void lv_anim_set_repeat_count(lv_anim_t * a, uint32_t cnt)
 {
     a->repeat_cnt = cnt;
 }
 
+LV_FUNC_SECTION
 void lv_anim_set_repeat_delay(lv_anim_t * a, uint32_t delay)
 {
     a->repeat_delay = delay;
 }
 
+LV_FUNC_SECTION
 void lv_anim_set_early_apply(lv_anim_t * a, bool en)
 {
     a->early_apply = en;
 }
 
+LV_FUNC_SECTION
 void lv_anim_set_user_data(lv_anim_t * a, void * user_data)
 {
     a->user_data = user_data;
 }
 
+LV_FUNC_SECTION
 void lv_anim_set_bezier3_param(lv_anim_t * a, int16_t x1, int16_t y1, int16_t x2, int16_t y2)
 {
     lv_anim_bezier3_para_t * para = &a->parameter.bezier3;
@@ -453,31 +495,37 @@ void lv_anim_set_bezier3_param(lv_anim_t * a, int16_t x1, int16_t y1, int16_t x2
     para->y2 = y2;
 }
 
+LV_FUNC_SECTION
 uint32_t lv_anim_get_delay(const lv_anim_t * a)
 {
     return -a->act_time;
 }
 
+LV_FUNC_SECTION
 uint32_t lv_anim_get_time(const lv_anim_t * a)
 {
     return a->duration;
 }
 
+LV_FUNC_SECTION
 uint32_t lv_anim_get_repeat_count(const lv_anim_t * a)
 {
     return a->repeat_cnt;
 }
 
+LV_FUNC_SECTION
 void * lv_anim_get_user_data(const lv_anim_t * a)
 {
     return a->user_data;
 }
 
+LV_FUNC_SECTION
 bool lv_anim_custom_delete(lv_anim_t * a, lv_anim_custom_exec_cb_t exec_cb)
 {
     return lv_anim_delete(a ? a->var : NULL, (lv_anim_exec_xcb_t)exec_cb);
 }
 
+LV_FUNC_SECTION
 lv_anim_t * lv_anim_custom_get(lv_anim_t * a, lv_anim_custom_exec_cb_t exec_cb)
 {
     return lv_anim_get(a ? a->var : NULL, (lv_anim_exec_xcb_t)exec_cb);
@@ -490,6 +538,7 @@ lv_anim_t * lv_anim_custom_get(lv_anim_t * a, lv_anim_custom_exec_cb_t exec_cb)
  * Periodically handle the animations.
  * @param param unused
  */
+LV_FUNC_SECTION
 static void anim_timer(lv_timer_t * param)
 {
     LV_UNUSED(param);
@@ -567,6 +616,7 @@ static void anim_timer(lv_timer_t * param)
  * e.g. repeat, play back, delete etc.
  * @param a pointer to an animation descriptor
  */
+LV_FUNC_SECTION
 static void anim_completed_handler(lv_anim_t * a)
 {
     /*In the end of a forward anim decrement repeat cnt.*/
@@ -612,6 +662,7 @@ static void anim_completed_handler(lv_anim_t * a)
     }
 }
 
+LV_FUNC_SECTION
 static void anim_mark_list_change(void)
 {
     state.anim_list_changed = true;
@@ -621,6 +672,7 @@ static void anim_mark_list_change(void)
         lv_timer_resume(state.timer);
 }
 
+LV_FUNC_SECTION
 static int32_t lv_anim_path_cubic_bezier(const lv_anim_t * a, int32_t x1, int32_t y1, int32_t x2, int32_t y2)
 {
     /*Calculate the current step*/
@@ -635,6 +687,7 @@ static int32_t lv_anim_path_cubic_bezier(const lv_anim_t * a, int32_t x1, int32_
     return new_value;
 }
 
+LV_FUNC_SECTION
 static uint32_t convert_speed_to_time(uint32_t speed_or_time, int32_t start, int32_t end)
 {
     /*It was a simple time*/
@@ -649,6 +702,7 @@ static uint32_t convert_speed_to_time(uint32_t speed_or_time, int32_t start, int
     return LV_CLAMP(min_time * 10, time, max_time * 10);
 }
 
+LV_FUNC_SECTION
 static void resolve_time(lv_anim_t * a)
 {
     a->duration = convert_speed_to_time(a->duration, a->start_value, a->end_value);
@@ -663,6 +717,7 @@ static void resolve_time(lv_anim_t * a)
  * @param a_current     the current animation, use its var and exec_cb as reference to know what to remove
  * @return              true: at least one animation was delete
  */
+LV_FUNC_SECTION
 static bool remove_concurrent_anims(lv_anim_t * a_current)
 {
     if(a_current->exec_cb == NULL && a_current->custom_exec_cb == NULL) return false;
@@ -698,6 +753,7 @@ static bool remove_concurrent_anims(lv_anim_t * a_current)
     return del_any;
 }
 
+__attribute__(( fptrgroup("lv_ll_cleanup") ))
 static void remove_anim(void * a)
 {
     lv_anim_t * anim = a;
diff --git a/src/misc/lv_anim.h b/src/misc/lv_anim.h
index 0d626c89b..e86c32231 100644
--- a/src/misc/lv_anim.h
+++ b/src/misc/lv_anim.h
@@ -123,14 +123,21 @@ typedef struct {
 /** Describes an animation*/
 struct lv_anim_t {
     void * var;                               /**< Variable to animate*/
+    __attribute__(( fptrgroup("lv_anim_exec_cb") ))
     lv_anim_exec_xcb_t exec_cb;               /**< Function to execute to animate*/
+    __attribute__(( fptrgroup("lv_anim_custom_exec_cb") ))
     lv_anim_custom_exec_cb_t custom_exec_cb;  /**< Function to execute to animate,
                                                * same purpose as exec_cb but different parameters*/
+    __attribute__(( fptrgroup("lv_anim_start_cb") ))
     lv_anim_start_cb_t start_cb;              /**< Call it when the animation is starts (considering `delay`)*/
+    __attribute__(( fptrgroup("lv_anim_completed_cb") ))
     lv_anim_completed_cb_t completed_cb;      /**< Call it when the animation is fully completed*/
+    __attribute__(( fptrgroup("lv_anim_deleted_cb") ))
     lv_anim_deleted_cb_t deleted_cb;          /**< Call it when the animation is deleted*/
+    __attribute__(( fptrgroup("lv_anim_get_value_cb") ))
     lv_anim_get_value_cb_t get_value_cb;      /**< Get the current value in relative mode*/
     void * user_data;                         /**< Custom user data*/
+    __attribute__(( fptrgroup("lv_anim_path_cb") ))
     lv_anim_path_cb_t path_cb;                /**< Describe the path (curve) of animations*/
     int32_t start_value;                      /**< Start value*/
     int32_t current_value;                    /**< Current value*/
diff --git a/src/misc/lv_anim_timeline.c b/src/misc/lv_anim_timeline.c
index f9cd53056..813d0aa7e 100644
--- a/src/misc/lv_anim_timeline.c
+++ b/src/misc/lv_anim_timeline.c
@@ -56,6 +56,7 @@ static int32_t anim_timeline_path_cb(const lv_anim_t * a);
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 lv_anim_timeline_t * lv_anim_timeline_create(void)
 {
     lv_anim_timeline_t * at = lv_malloc_zeroed(sizeof(lv_anim_timeline_t));
@@ -63,6 +64,7 @@ lv_anim_timeline_t * lv_anim_timeline_create(void)
     return at;
 }
 
+LV_FUNC_SECTION
 void lv_anim_timeline_delete(lv_anim_timeline_t * at)
 {
     LV_ASSERT_NULL(at);
@@ -73,6 +75,7 @@ void lv_anim_timeline_delete(lv_anim_timeline_t * at)
     lv_free(at);
 }
 
+LV_FUNC_SECTION
 void lv_anim_timeline_add(lv_anim_timeline_t * at, uint32_t start_time, const lv_anim_t * a)
 {
     LV_ASSERT_NULL(at);
@@ -86,6 +89,7 @@ void lv_anim_timeline_add(lv_anim_timeline_t * at, uint32_t start_time, const lv
     at->anim_dsc[at->anim_dsc_cnt - 1].start_time = start_time;
 }
 
+LV_FUNC_SECTION
 uint32_t lv_anim_timeline_start(lv_anim_timeline_t * at)
 {
     LV_ASSERT_NULL(at);
@@ -117,6 +121,7 @@ uint32_t lv_anim_timeline_start(lv_anim_timeline_t * at)
     return playtime;
 }
 
+LV_FUNC_SECTION
 void lv_anim_timeline_pause(lv_anim_timeline_t * at)
 {
     LV_ASSERT_NULL(at);
@@ -124,24 +129,28 @@ void lv_anim_timeline_pause(lv_anim_timeline_t * at)
     lv_anim_delete(at, anim_timeline_exec_cb);
 }
 
+LV_FUNC_SECTION
 void lv_anim_timeline_set_reverse(lv_anim_timeline_t * at, bool reverse)
 {
     LV_ASSERT_NULL(at);
     at->reverse = reverse;
 }
 
+LV_FUNC_SECTION
 void lv_anim_timeline_set_repeat_count(lv_anim_timeline_t * at, uint32_t cnt)
 {
     LV_ASSERT_NULL(at);
     at->repeat_count = cnt;
 }
 
+LV_FUNC_SECTION
 void lv_anim_timeline_set_repeat_delay(lv_anim_timeline_t * at, uint32_t delay)
 {
     LV_ASSERT_NULL(at);
     at->repeat_delay = delay;
 }
 
+LV_FUNC_SECTION
 void lv_anim_timeline_set_progress(lv_anim_timeline_t * at, uint16_t progress)
 {
     LV_ASSERT_NULL(at);
@@ -151,6 +160,7 @@ void lv_anim_timeline_set_progress(lv_anim_timeline_t * at, uint16_t progress)
     anim_timeline_set_act_time(at, act_time);
 }
 
+LV_FUNC_SECTION
 uint32_t lv_anim_timeline_get_playtime(lv_anim_timeline_t * at)
 {
     LV_ASSERT_NULL(at);
@@ -169,12 +179,14 @@ uint32_t lv_anim_timeline_get_playtime(lv_anim_timeline_t * at)
     return playtime;
 }
 
+LV_FUNC_SECTION
 bool lv_anim_timeline_get_reverse(lv_anim_timeline_t * at)
 {
     LV_ASSERT_NULL(at);
     return at->reverse;
 }
 
+LV_FUNC_SECTION
 uint16_t lv_anim_timeline_get_progress(lv_anim_timeline_t * at)
 {
     LV_ASSERT_NULL(at);
@@ -182,12 +194,14 @@ uint16_t lv_anim_timeline_get_progress(lv_anim_timeline_t * at)
     return lv_map(at->act_time, 0, playtime, 0, LV_ANIM_TIMELINE_PROGRESS_MAX);
 }
 
+LV_FUNC_SECTION
 uint32_t lv_anim_timeline_get_repeat_count(lv_anim_timeline_t * at)
 {
     LV_ASSERT_NULL(at);
     return  at->repeat_count;
 }
 
+LV_FUNC_SECTION
 uint32_t lv_anim_timeline_get_repeat_delay(lv_anim_timeline_t * at)
 {
     LV_ASSERT_NULL(at);
@@ -198,6 +212,7 @@ uint32_t lv_anim_timeline_get_repeat_delay(lv_anim_timeline_t * at)
  *   STATIC FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 static void anim_timeline_set_act_time(lv_anim_timeline_t * at, uint32_t act_time)
 {
     at->act_time = act_time;
@@ -298,12 +313,14 @@ static void anim_timeline_set_act_time(lv_anim_timeline_t * at, uint32_t act_tim
     }
 }
 
+__attribute__(( fptrgroup("lv_anim_path_cb") ))
 static int32_t anim_timeline_path_cb(const lv_anim_t * a)
 {
     /* Directly map original timestamps to avoid loss of accuracy */
     return lv_map(a->act_time, 0, a->duration, a->start_value, a->end_value);
 }
 
+__attribute__(( fptrgroup("lv_anim_exec_cb") ))
 static void anim_timeline_exec_cb(void * var, int32_t v)
 {
     lv_anim_timeline_t * at = var;
diff --git a/src/misc/lv_area.c b/src/misc/lv_area.c
index 4410076d6..b93542309 100644
--- a/src/misc/lv_area.c
+++ b/src/misc/lv_area.c
@@ -38,6 +38,7 @@ static bool lv_point_within_circle(const lv_area_t * area, const lv_point_t * p)
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 void lv_area_set(lv_area_t * area_p, int32_t x1, int32_t y1, int32_t x2, int32_t y2)
 {
     area_p->x1 = x1;
@@ -46,16 +47,19 @@ void lv_area_set(lv_area_t * area_p, int32_t x1, int32_t y1, int32_t x2, int32_t
     area_p->y2 = y2;
 }
 
+LV_FUNC_SECTION
 void lv_area_set_width(lv_area_t * area_p, int32_t w)
 {
     area_p->x2 = area_p->x1 + w - 1;
 }
 
+LV_FUNC_SECTION
 void lv_area_set_height(lv_area_t * area_p, int32_t h)
 {
     area_p->y2 = area_p->y1 + h - 1;
 }
 
+LV_FUNC_SECTION
 void lv_area_set_pos(lv_area_t * area_p, int32_t x, int32_t y)
 {
     int32_t w = lv_area_get_width(area_p);
@@ -66,6 +70,7 @@ void lv_area_set_pos(lv_area_t * area_p, int32_t x, int32_t y)
     lv_area_set_height(area_p, h);
 }
 
+LV_FUNC_SECTION
 uint32_t lv_area_get_size(const lv_area_t * area_p)
 {
     uint32_t size;
@@ -75,6 +80,7 @@ uint32_t lv_area_get_size(const lv_area_t * area_p)
     return size;
 }
 
+LV_FUNC_SECTION
 void lv_area_increase(lv_area_t * area, int32_t w_extra, int32_t h_extra)
 {
     area->x1 -= w_extra;
@@ -83,6 +89,7 @@ void lv_area_increase(lv_area_t * area, int32_t w_extra, int32_t h_extra)
     area->y2 += h_extra;
 }
 
+LV_FUNC_SECTION
 void lv_area_move(lv_area_t * area, int32_t x_ofs, int32_t y_ofs)
 {
     area->x1 += x_ofs;
@@ -91,6 +98,7 @@ void lv_area_move(lv_area_t * area, int32_t x_ofs, int32_t y_ofs)
     area->y2 += y_ofs;
 }
 
+LV_FUNC_SECTION
 bool lv_area_intersect(lv_area_t * res_p, const lv_area_t * a1_p, const lv_area_t * a2_p)
 {
     /*Get the smaller area from 'a1_p' and 'a2_p'*/
@@ -108,6 +116,7 @@ bool lv_area_intersect(lv_area_t * res_p, const lv_area_t * a1_p, const lv_area_
     return union_ok;
 }
 
+LV_FUNC_SECTION
 int8_t lv_area_diff(lv_area_t res_p[], const lv_area_t * a1_p, const lv_area_t * a2_p)
 {
     /*Areas have no common parts*/
@@ -173,6 +182,7 @@ int8_t lv_area_diff(lv_area_t res_p[], const lv_area_t * a1_p, const lv_area_t *
     return res_c;
 }
 
+LV_FUNC_SECTION
 void lv_area_join(lv_area_t * a_res_p, const lv_area_t * a1_p, const lv_area_t * a2_p)
 {
     a_res_p->x1 = LV_MIN(a1_p->x1, a2_p->x1);
@@ -181,6 +191,8 @@ void lv_area_join(lv_area_t * a_res_p, const lv_area_t * a1_p, const lv_area_t *
     a_res_p->y2 = LV_MAX(a1_p->y2, a2_p->y2);
 }
 
+#pragma stackfunction 2048
+LV_FUNC_SECTION
 bool lv_area_is_point_on(const lv_area_t * a_p, const lv_point_t * p_p, int32_t radius)
 {
     /*First check the basic area*/
@@ -241,6 +253,7 @@ bool lv_area_is_point_on(const lv_area_t * a_p, const lv_point_t * p_p, int32_t
     return true;
 }
 
+LV_FUNC_SECTION
 bool lv_area_is_on(const lv_area_t * a1_p, const lv_area_t * a2_p)
 {
     if((a1_p->x1 <= a2_p->x2) && (a1_p->x2 >= a2_p->x1) && (a1_p->y1 <= a2_p->y2) && (a1_p->y2 >= a2_p->y1)) {
@@ -251,6 +264,7 @@ bool lv_area_is_on(const lv_area_t * a1_p, const lv_area_t * a2_p)
     }
 }
 
+LV_FUNC_SECTION
 bool lv_area_is_in(const lv_area_t * ain_p, const lv_area_t * aholder_p, int32_t radius)
 {
     bool is_in = false;
@@ -281,6 +295,7 @@ bool lv_area_is_in(const lv_area_t * ain_p, const lv_area_t * aholder_p, int32_t
     return true;
 }
 
+LV_FUNC_SECTION
 bool lv_area_is_out(const lv_area_t * aout_p, const lv_area_t * aholder_p, int32_t radius)
 {
     if(aout_p->x2 < aholder_p->x1 || aout_p->y2 < aholder_p->y1 || aout_p->x1 > aholder_p->x2 ||
@@ -308,11 +323,13 @@ bool lv_area_is_out(const lv_area_t * aout_p, const lv_area_t * aholder_p, int32
     return true;
 }
 
+LV_FUNC_SECTION
 bool lv_area_is_equal(const lv_area_t * a, const lv_area_t * b)
 {
     return a->x1 == b->x1 && a->x2 == b->x2 && a->y1 == b->y1 && a->y2 == b->y2;
 }
 
+LV_FUNC_SECTION
 void lv_area_align(const lv_area_t * base, lv_area_t * to_align, lv_align_t align, int32_t ofs_x, int32_t ofs_y)
 {
 
@@ -440,12 +457,14 @@ void lv_area_align(const lv_area_t * base, lv_area_t * to_align, lv_align_t alig
 
 #define LV_TRANSFORM_TRIGO_SHIFT 10
 
+LV_FUNC_SECTION
 void lv_point_transform(lv_point_t * point, int32_t angle, int32_t scale_x, int32_t scale_y, const lv_point_t * pivot,
                         bool zoom_first)
 {
     lv_point_array_transform(point, 1, angle, scale_x, scale_y, pivot, zoom_first);
 }
 
+LV_FUNC_SECTION
 void lv_point_array_transform(lv_point_t * points, size_t count, int32_t angle, int32_t scale_x, int32_t scale_y,
                               const lv_point_t * pivot,
                               bool zoom_first)
@@ -509,16 +528,19 @@ void lv_point_array_transform(lv_point_t * points, size_t count, int32_t angle,
     }
 }
 
+LV_FUNC_SECTION
 int32_t lv_area_get_width(const lv_area_t * area_p)
 {
     return (int32_t)(area_p->x2 - area_p->x1 + 1);
 }
 
+LV_FUNC_SECTION
 int32_t lv_area_get_height(const lv_area_t * area_p)
 {
     return (int32_t)(area_p->y2 - area_p->y1 + 1);
 }
 
+LV_FUNC_SECTION
 lv_point_t lv_point_from_precise(const lv_point_precise_t * p)
 {
     lv_point_t point = {
@@ -528,6 +550,7 @@ lv_point_t lv_point_from_precise(const lv_point_precise_t * p)
     return point;
 }
 
+LV_FUNC_SECTION
 lv_point_precise_t lv_point_to_precise(const lv_point_t * p)
 {
     lv_point_precise_t point = {
@@ -537,18 +560,21 @@ lv_point_precise_t lv_point_to_precise(const lv_point_t * p)
     return point;
 }
 
+LV_FUNC_SECTION
 void lv_point_set(lv_point_t * p, int32_t x, int32_t y)
 {
     p->x = x;
     p->y = y;
 }
 
+LV_FUNC_SECTION
 void lv_point_precise_set(lv_point_precise_t * p, lv_value_precise_t x, lv_value_precise_t y)
 {
     p->x = x;
     p->y = y;
 }
 
+LV_FUNC_SECTION
 void lv_point_swap(lv_point_t * p1, lv_point_t * p2)
 {
     lv_point_t tmp = *p1;
@@ -556,6 +582,7 @@ void lv_point_swap(lv_point_t * p1, lv_point_t * p2)
     *p2 = tmp;
 }
 
+LV_FUNC_SECTION
 void lv_point_precise_swap(lv_point_precise_t * p1, lv_point_precise_t * p2)
 {
     lv_point_precise_t tmp = *p1;
@@ -563,11 +590,13 @@ void lv_point_precise_swap(lv_point_precise_t * p1, lv_point_precise_t * p2)
     *p2 = tmp;
 }
 
+LV_FUNC_SECTION
 int32_t lv_pct(int32_t x)
 {
     return LV_PCT(x);
 }
 
+LV_FUNC_SECTION
 int32_t lv_pct_to_px(int32_t v, int32_t base)
 {
     if(LV_COORD_IS_PCT(v)) {
@@ -581,6 +610,7 @@ int32_t lv_pct_to_px(int32_t v, int32_t base)
  *   STATIC FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 static bool lv_point_within_circle(const lv_area_t * area, const lv_point_t * p)
 {
     int32_t r = (area->x2 - area->x1) / 2;
diff --git a/src/misc/lv_array.c b/src/misc/lv_array.c
index 39382bcbf..966cbf1ee 100644
--- a/src/misc/lv_array.c
+++ b/src/misc/lv_array.c
@@ -35,6 +35,7 @@
 /**********************
  *   GLOBAL FUNCTIONS
  **********************/
+LV_FUNC_SECTION
 void lv_array_init(lv_array_t * array, uint32_t capacity, uint32_t element_size)
 {
     array->size = 0;
@@ -45,6 +46,7 @@ void lv_array_init(lv_array_t * array, uint32_t capacity, uint32_t element_size)
     LV_ASSERT_MALLOC(array->data);
 }
 
+LV_FUNC_SECTION
 void lv_array_deinit(lv_array_t * array)
 {
     if(array->data) {
@@ -56,6 +58,7 @@ void lv_array_deinit(lv_array_t * array)
     array->capacity = 0;
 }
 
+LV_FUNC_SECTION
 void lv_array_copy(lv_array_t * target, const lv_array_t * source)
 {
     if(lv_array_is_empty(source)) {
@@ -67,6 +70,7 @@ void lv_array_copy(lv_array_t * target, const lv_array_t * source)
     target->size = source->size;
 }
 
+LV_FUNC_SECTION
 void lv_array_shrink(lv_array_t * array)
 {
     if(array->size <= array->capacity / LV_ARRAY_DEFAULT_SHRINK_RATIO) {
@@ -74,6 +78,7 @@ void lv_array_shrink(lv_array_t * array)
     }
 }
 
+LV_FUNC_SECTION
 lv_result_t lv_array_remove(lv_array_t * array, uint32_t index)
 {
     if(index >= array->size) {
@@ -96,6 +101,7 @@ lv_result_t lv_array_remove(lv_array_t * array, uint32_t index)
     return LV_RESULT_OK;
 }
 
+LV_FUNC_SECTION
 lv_result_t lv_array_erase(lv_array_t * array, uint32_t start, uint32_t end)
 {
     if(end > array->size) {
@@ -122,6 +128,7 @@ lv_result_t lv_array_erase(lv_array_t * array, uint32_t start, uint32_t end)
     return LV_RESULT_OK;
 }
 
+LV_FUNC_SECTION
 void lv_array_resize(lv_array_t * array, uint32_t new_capacity)
 {
     uint8_t * data = lv_realloc(array->data, new_capacity * array->element_size);
@@ -133,6 +140,7 @@ void lv_array_resize(lv_array_t * array, uint32_t new_capacity)
     }
 }
 
+LV_FUNC_SECTION
 lv_result_t lv_array_concat(lv_array_t * array, const lv_array_t * other)
 {
     LV_ASSERT_NULL(array->data);
@@ -148,6 +156,7 @@ lv_result_t lv_array_concat(lv_array_t * array, const lv_array_t * other)
     return LV_RESULT_OK;
 }
 
+LV_FUNC_SECTION
 lv_result_t lv_array_push_back(lv_array_t * array, const void * element)
 {
     LV_ASSERT_NULL(array->data);
@@ -163,6 +172,7 @@ lv_result_t lv_array_push_back(lv_array_t * array, const void * element)
     return LV_RESULT_OK;
 }
 
+LV_FUNC_SECTION
 void * lv_array_at(const lv_array_t * array, uint32_t index)
 {
     if(index >= array->size) {
@@ -173,6 +183,7 @@ void * lv_array_at(const lv_array_t * array, uint32_t index)
     return array->data + index * array->element_size;
 }
 
+LV_FUNC_SECTION
 lv_result_t lv_array_assign(lv_array_t * array, uint32_t index, const void * value)
 {
     uint8_t * data = lv_array_at(array, index);
@@ -182,36 +193,43 @@ lv_result_t lv_array_assign(lv_array_t * array, uint32_t index, const void * val
     return LV_RESULT_OK;
 }
 
+LV_FUNC_SECTION
 uint32_t lv_array_size(const lv_array_t * array)
 {
     return array->size;
 }
 
+LV_FUNC_SECTION
 uint32_t lv_array_capacity(const lv_array_t * array)
 {
     return array->capacity;
 }
 
+LV_FUNC_SECTION
 bool lv_array_is_empty(const lv_array_t * array)
 {
     return array->size == 0;
 }
 
+LV_FUNC_SECTION
 bool lv_array_is_full(const lv_array_t * array)
 {
     return array->size == array->capacity;
 }
 
+LV_FUNC_SECTION
 void lv_array_clear(lv_array_t * array)
 {
     array->size = 0;
 }
 
+LV_FUNC_SECTION
 void * lv_array_front(const lv_array_t * array)
 {
     return lv_array_at(array, 0);
 }
 
+LV_FUNC_SECTION
 void * lv_array_back(const lv_array_t * array)
 {
     return lv_array_at(array, lv_array_size(array) - 1);
diff --git a/src/misc/lv_async.c b/src/misc/lv_async.c
index e1657aeb4..9fd0e5c39 100644
--- a/src/misc/lv_async.c
+++ b/src/misc/lv_async.c
@@ -20,6 +20,7 @@
  **********************/
 
 typedef struct lv_async_info_t {
+    __attribute__(( fptrgroup("lv_async_info_cb") ))
     lv_async_cb_t cb;
     void * user_data;
 } lv_async_info_t;
@@ -42,6 +43,7 @@ static void lv_async_timer_cb(lv_timer_t * timer);
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 lv_result_t lv_async_call(lv_async_cb_t async_xcb, void * user_data)
 {
     /*Allocate an info structure*/
@@ -65,6 +67,7 @@ lv_result_t lv_async_call(lv_async_cb_t async_xcb, void * user_data)
     return LV_RESULT_OK;
 }
 
+LV_FUNC_SECTION
 lv_result_t lv_async_call_cancel(lv_async_cb_t async_xcb, void * user_data)
 {
     lv_timer_t * timer = lv_timer_get_next(NULL);
@@ -96,6 +99,7 @@ lv_result_t lv_async_call_cancel(lv_async_cb_t async_xcb, void * user_data)
  *   STATIC FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 static void lv_async_timer_cb(lv_timer_t * timer)
 {
     /*Save the info because an lv_async_call_cancel might delete it in the callback*/
diff --git a/src/misc/lv_bidi.c b/src/misc/lv_bidi.c
index 44f014e28..a433658cc 100644
--- a/src/misc/lv_bidi.c
+++ b/src/misc/lv_bidi.c
@@ -74,6 +74,7 @@ static const char * custom_neutrals = NULL;
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 void lv_bidi_process(const char * str_in, char * str_out, lv_base_dir_t base_dir)
 {
     if(base_dir == LV_BASE_DIR_AUTO) base_dir = lv_bidi_detect_base_dir(str_in);
@@ -105,6 +106,7 @@ void lv_bidi_process(const char * str_in, char * str_out, lv_base_dir_t base_dir
  * @param txt the text to process
  * @return `LV_BASE_DIR_LTR` or `LV_BASE_DIR_RTL`
  */
+LV_FUNC_SECTION
 lv_base_dir_t lv_bidi_detect_base_dir(const char * txt)
 {
     uint32_t i = 0;
@@ -122,6 +124,7 @@ lv_base_dir_t lv_bidi_detect_base_dir(const char * txt)
     else return LV_BIDI_BASE_DIR_DEF;
 }
 
+LV_FUNC_SECTION
 uint16_t lv_bidi_get_logical_pos(const char * str_in, char ** bidi_txt, uint32_t len, lv_base_dir_t base_dir,
                                  uint32_t visual_pos, bool * is_rtl)
 {
@@ -147,6 +150,7 @@ uint16_t lv_bidi_get_logical_pos(const char * str_in, char ** bidi_txt, uint32_t
     return res;
 }
 
+LV_FUNC_SECTION
 uint16_t lv_bidi_get_visual_pos(const char * str_in, char ** bidi_txt, uint16_t len, lv_base_dir_t base_dir,
                                 uint32_t logical_pos, bool * is_rtl)
 {
@@ -179,6 +183,7 @@ uint16_t lv_bidi_get_visual_pos(const char * str_in, char ** bidi_txt, uint16_t
     return (uint16_t) -1;
 }
 
+LV_FUNC_SECTION
 void lv_bidi_process_paragraph(const char * str_in, char * str_out, uint32_t len, lv_base_dir_t base_dir,
                                uint16_t * pos_conv_out, uint16_t pos_conv_len)
 {
@@ -272,6 +277,7 @@ void lv_bidi_process_paragraph(const char * str_in, char * str_out, uint32_t len
     }
 }
 
+LV_FUNC_SECTION
 void lv_bidi_calculate_align(lv_text_align_t * align, lv_base_dir_t * base_dir, const char * txt)
 {
     if(*base_dir == LV_BASE_DIR_AUTO) *base_dir = lv_bidi_detect_base_dir(txt);
@@ -282,6 +288,7 @@ void lv_bidi_calculate_align(lv_text_align_t * align, lv_base_dir_t * base_dir,
     }
 }
 
+LV_FUNC_SECTION
 void lv_bidi_set_custom_neutrals_static(const char * neutrals)
 {
     custom_neutrals = neutrals;
@@ -296,6 +303,7 @@ void lv_bidi_set_custom_neutrals_static(const char * neutrals)
  * @param txt the text to process
  * @return the length of the current paragraph in byte count
  */
+LV_FUNC_SECTION
 static uint32_t lv_bidi_get_next_paragraph(const char * txt)
 {
     uint32_t i = 0;
@@ -314,6 +322,7 @@ static uint32_t lv_bidi_get_next_paragraph(const char * txt)
  * @param letter a Unicode character
  * @return `LV_BASE_DIR_RTL/LTR/WEAK/NEUTRAL`
  */
+LV_FUNC_SECTION
 static lv_base_dir_t lv_bidi_get_letter_dir(uint32_t letter)
 {
     if(lv_bidi_letter_is_rtl(letter)) return LV_BASE_DIR_RTL;
@@ -327,6 +336,7 @@ static lv_base_dir_t lv_bidi_get_letter_dir(uint32_t letter)
  * @param letter a Unicode character
  * @return true/false
  */
+LV_FUNC_SECTION
 static bool lv_bidi_letter_is_weak(uint32_t letter)
 {
     uint32_t i = 0;
@@ -346,6 +356,7 @@ static bool lv_bidi_letter_is_weak(uint32_t letter)
  * @param letter a Unicode character
  * @return true/false
  */
+LV_FUNC_SECTION
 static bool lv_bidi_letter_is_rtl(uint32_t letter)
 {
     if(letter == 0x202E) return true;               /*Unicode of LV_BIDI_RLO*/
@@ -367,6 +378,7 @@ static bool lv_bidi_letter_is_rtl(uint32_t letter)
  * @param letter a Unicode character
  * @return true/false
  */
+LV_FUNC_SECTION
 static bool lv_bidi_letter_is_neutral(uint32_t letter)
 {
     uint16_t i;
@@ -382,6 +394,7 @@ static bool lv_bidi_letter_is_neutral(uint32_t letter)
     return false;
 }
 
+LV_FUNC_SECTION
 static uint32_t get_txt_len(const char * txt, uint32_t max_len)
 {
     uint32_t len = 0;
@@ -395,6 +408,7 @@ static uint32_t get_txt_len(const char * txt, uint32_t max_len)
     return len;
 }
 
+LV_FUNC_SECTION
 static void fill_pos_conv(uint16_t * out, uint16_t len, uint16_t index)
 {
     uint16_t i;
@@ -404,6 +418,7 @@ static void fill_pos_conv(uint16_t * out, uint16_t len, uint16_t index)
     }
 }
 
+LV_FUNC_SECTION
 static lv_base_dir_t get_next_run(lv_bidi_ctx_t * ctx, const char * txt, lv_base_dir_t base_dir, uint32_t max_len,
                                   uint32_t * len,
                                   uint16_t  * pos_conv_len)
@@ -498,6 +513,7 @@ static lv_base_dir_t get_next_run(lv_bidi_ctx_t * ctx, const char * txt, lv_base
     return run_dir;
 }
 
+LV_FUNC_SECTION
 static void rtl_reverse(char * dest, const char * src, uint32_t len, uint16_t * pos_conv_out, uint16_t pos_conv_rd_base,
                         uint16_t pos_conv_len)
 {
@@ -566,6 +582,7 @@ static void rtl_reverse(char * dest, const char * src, uint32_t len, uint16_t *
     }
 }
 
+LV_FUNC_SECTION
 static uint32_t char_change_to_pair(uint32_t letter)
 {
 
@@ -581,6 +598,7 @@ static uint32_t char_change_to_pair(uint32_t letter)
     return letter;
 }
 
+LV_FUNC_SECTION
 static lv_base_dir_t bracket_process(lv_bidi_ctx_t * ctx, const char * txt, uint32_t next_pos, uint32_t len,
                                      uint32_t letter,
                                      lv_base_dir_t base_dir)
diff --git a/src/misc/lv_color.c b/src/misc/lv_color.c
index d62f280b1..f138279f1 100644
--- a/src/misc/lv_color.c
+++ b/src/misc/lv_color.c
@@ -40,6 +40,7 @@ const lv_color_filter_dsc_t lv_color_filter_shade = {.filter_cb = lv_color_filte
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 uint8_t lv_color_format_get_bpp(lv_color_format_t cf)
 {
     switch(cf) {
@@ -75,6 +76,7 @@ uint8_t lv_color_format_get_bpp(lv_color_format_t cf)
     }
 }
 
+LV_FUNC_SECTION
 bool lv_color_format_has_alpha(lv_color_format_t cf)
 {
     switch(cf) {
@@ -96,6 +98,7 @@ bool lv_color_format_has_alpha(lv_color_format_t cf)
     }
 }
 
+LV_FUNC_SECTION
 lv_color32_t lv_color_to_32(lv_color_t color, lv_opa_t opa)
 {
     lv_color32_t c32;
@@ -106,27 +109,32 @@ lv_color32_t lv_color_to_32(lv_color_t color, lv_opa_t opa)
     return c32;
 }
 
+LV_FUNC_SECTION
 uint16_t lv_color_to_u16(lv_color_t color)
 {
     return ((color.red & 0xF8) << 8) + ((color.green & 0xFC) << 3) + ((color.blue & 0xF8) >> 3);
 }
 
+LV_FUNC_SECTION
 uint32_t lv_color_to_u32(lv_color_t color)
 {
     return (uint32_t)((uint32_t)0xff << 24) + (color.red << 16) + (color.green << 8) + (color.blue);
 }
 
+LV_FUNC_SECTION
 lv_color_t lv_color_lighten(lv_color_t c, lv_opa_t lvl)
 {
 
     return lv_color_mix(lv_color_white(), c, lvl);
 }
 
+LV_FUNC_SECTION
 lv_color_t lv_color_darken(lv_color_t c, lv_opa_t lvl)
 {
     return lv_color_mix(lv_color_black(), c, lvl);
 }
 
+LV_FUNC_SECTION
 lv_color_t lv_color_hsv_to_rgb(uint16_t h, uint8_t s, uint8_t v)
 {
     h = (uint32_t)((uint32_t)h * 255) / 360;
@@ -185,6 +193,7 @@ lv_color_t lv_color_hsv_to_rgb(uint16_t h, uint8_t s, uint8_t v)
     return result;
 }
 
+LV_FUNC_SECTION
 lv_color_hsv_t lv_color_rgb_to_hsv(uint8_t r8, uint8_t g8, uint8_t b8)
 {
     uint16_t r = ((uint32_t)r8 << 10) / 255;
@@ -236,32 +245,38 @@ lv_color_hsv_t lv_color_rgb_to_hsv(uint8_t r8, uint8_t g8, uint8_t b8)
  * @param color color
  * @return the given color in HSV
  */
+LV_FUNC_SECTION
 lv_color_hsv_t lv_color_to_hsv(lv_color_t c)
 {
     return lv_color_rgb_to_hsv(c.red, c.green, c.blue);
 }
 
+LV_FUNC_SECTION
 uint8_t lv_color_format_get_size(lv_color_format_t cf)
 {
     return (lv_color_format_get_bpp(cf) + 7) >> 3;
 }
 
+LV_FUNC_SECTION
 uint32_t lv_color_to_int(lv_color_t c)
 {
     uint8_t * tmp = (uint8_t *) &c;
     return tmp[0] + (tmp[1] << 8) + (tmp[2] << 16);
 }
 
+LV_FUNC_SECTION
 bool lv_color_eq(lv_color_t c1, lv_color_t c2)
 {
     return lv_color_to_int(c1) == lv_color_to_int(c2);
 }
 
+LV_FUNC_SECTION
 bool lv_color32_eq(lv_color32_t c1, lv_color32_t c2)
 {
     return *((uint32_t *)&c1) == *((uint32_t *)&c2);
 }
 
+LV_FUNC_SECTION
 lv_color_t lv_color_hex(uint32_t c)
 {
     lv_color_t ret;
@@ -271,6 +286,7 @@ lv_color_t lv_color_hex(uint32_t c)
     return ret;
 }
 
+LV_FUNC_SECTION
 lv_color_t lv_color_make(uint8_t r, uint8_t g, uint8_t b)
 {
     lv_color_t ret;
@@ -280,6 +296,7 @@ lv_color_t lv_color_make(uint8_t r, uint8_t g, uint8_t b)
     return ret;
 }
 
+LV_FUNC_SECTION
 lv_color32_t lv_color32_make(uint8_t r, uint8_t g, uint8_t b, uint8_t a)
 {
     lv_color32_t ret;
@@ -290,6 +307,7 @@ lv_color32_t lv_color32_make(uint8_t r, uint8_t g, uint8_t b, uint8_t a)
     return ret;
 }
 
+LV_FUNC_SECTION
 lv_color_t lv_color_hex3(uint32_t c)
 {
     return lv_color_make((uint8_t)(((c >> 4) & 0xF0) | ((c >> 8) & 0xF)), (uint8_t)((c & 0xF0) | ((c & 0xF0) >> 4)),
@@ -316,16 +334,19 @@ uint16_t LV_ATTRIBUTE_FAST_MEM lv_color_16_16_mix(uint16_t c1, uint16_t c2, uint
     return ret;
 }
 
+LV_FUNC_SECTION
 lv_color_t lv_color_white(void)
 {
     return lv_color_make(0xff, 0xff, 0xff);
 }
 
+LV_FUNC_SECTION
 lv_color_t lv_color_black(void)
 {
     return lv_color_make(0x00, 0x00, 0x00);
 }
 
+LV_FUNC_SECTION
 void lv_color_premultiply(lv_color32_t * c)
 {
     if(c->alpha == LV_OPA_COVER) {
@@ -342,6 +363,7 @@ void lv_color_premultiply(lv_color32_t * c)
     c->blue = LV_OPA_MIX2(c->blue, c->alpha);
 }
 
+LV_FUNC_SECTION
 void lv_color16_premultiply(lv_color16_t * c, lv_opa_t a)
 {
     if(a == LV_OPA_COVER) {
@@ -358,21 +380,25 @@ void lv_color16_premultiply(lv_color16_t * c, lv_opa_t a)
     c->blue = LV_OPA_MIX2(c->blue, a);
 }
 
+LV_FUNC_SECTION
 uint8_t lv_color_luminance(lv_color_t c)
 {
     return (uint8_t)((uint16_t)(77u * c.red + 151u * c.green + 28u * c.blue) >> 8);
 }
 
+LV_FUNC_SECTION
 uint8_t lv_color16_luminance(const lv_color16_t c)
 {
     return (uint8_t)((uint16_t)(635u * c.red + 613u * c.green + 231u * c.blue) >> 8);
 }
 
+LV_FUNC_SECTION
 uint8_t lv_color24_luminance(const uint8_t * c)
 {
     return (uint8_t)((uint16_t)(77u * c[2] + 151u * c[1] + 28u * c[0]) >> 8);
 }
 
+LV_FUNC_SECTION
 uint8_t lv_color32_luminance(lv_color32_t c)
 {
     return (uint8_t)((uint16_t)(77u * c.red + 151u * c.green + 28u * c.blue) >> 8);
@@ -394,6 +420,7 @@ uint8_t lv_color32_luminance(lv_color32_t c)
  *                      - LV_OPA_100:   fully white
  * @return          the modified color
  */
+LV_FUNC_SECTION
 static lv_color_t lv_color_filter_shade_cb(const lv_color_filter_dsc_t * dsc, lv_color_t c, lv_opa_t opa)
 {
     LV_UNUSED(dsc);
diff --git a/src/misc/lv_color.h b/src/misc/lv_color.h
index 6328c0d2c..a234dcd2e 100644
--- a/src/misc/lv_color.h
+++ b/src/misc/lv_color.h
@@ -98,7 +98,7 @@ typedef struct {
     uint8_t blue;
     uint8_t green;
     uint8_t red;
-} lv_color_t;
+} __attribute__ ((aligned (2))) lv_color_t;
 
 typedef struct {
     uint16_t blue : 5;
diff --git a/src/misc/lv_color_op.c b/src/misc/lv_color_op.c
index a26f2b453..9996a4480 100644
--- a/src/misc/lv_color_op.c
+++ b/src/misc/lv_color_op.c
@@ -43,6 +43,7 @@ lv_color_t LV_ATTRIBUTE_FAST_MEM lv_color_mix(lv_color_t c1, lv_color_t c2, uint
     return ret;
 }
 
+LV_FUNC_SECTION
 lv_color32_t lv_color_mix32(lv_color32_t fg, lv_color32_t bg)
 {
     if(fg.alpha >= LV_OPA_MAX) {
@@ -58,12 +59,14 @@ lv_color32_t lv_color_mix32(lv_color32_t fg, lv_color32_t bg)
     return bg;
 }
 
+LV_FUNC_SECTION
 uint8_t lv_color_brightness(lv_color_t c)
 {
     uint16_t bright = (uint16_t)(3u * c.red + c.green + 4u * c.blue);
     return (uint8_t)(bright >> 3);
 }
 
+LV_FUNC_SECTION
 void lv_color_filter_dsc_init(lv_color_filter_dsc_t * dsc, lv_color_filter_cb_t cb)
 {
     dsc->filter_cb = cb;
diff --git a/src/misc/lv_event.c b/src/misc/lv_event.c
index ec985ed25..fb3e2d9bf 100644
--- a/src/misc/lv_event.c
+++ b/src/misc/lv_event.c
@@ -45,6 +45,7 @@
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 void lv_event_push(lv_event_t * e)
 {
     /*Build a simple linked list from the objects used in the events
@@ -55,11 +56,13 @@ void lv_event_push(lv_event_t * e)
 
 }
 
+LV_FUNC_SECTION
 void lv_event_pop(lv_event_t * e)
 {
     event_head = e->prev;
 }
 
+LV_FUNC_SECTION
 lv_result_t lv_event_send(lv_event_list_t * list, lv_event_t * e, bool preprocess)
 {
     if(list == NULL) return LV_RESULT_OK;
@@ -85,6 +88,7 @@ lv_result_t lv_event_send(lv_event_list_t * list, lv_event_t * e, bool preproces
     return LV_RESULT_OK;
 }
 
+LV_FUNC_SECTION
 lv_event_dsc_t * lv_event_add(lv_event_list_t * list, lv_event_cb_t cb, lv_event_code_t filter,
                               void * user_data)
 {
@@ -104,6 +108,7 @@ lv_event_dsc_t * lv_event_add(lv_event_list_t * list, lv_event_cb_t cb, lv_event
     return dsc;
 }
 
+LV_FUNC_SECTION
 bool lv_event_remove_dsc(lv_event_list_t * list, lv_event_dsc_t * dsc)
 {
     LV_ASSERT_NULL(list);
@@ -122,12 +127,14 @@ bool lv_event_remove_dsc(lv_event_list_t * list, lv_event_dsc_t * dsc)
     return false;
 }
 
+LV_FUNC_SECTION
 uint32_t lv_event_get_count(lv_event_list_t * list)
 {
     LV_ASSERT_NULL(list);
     return lv_array_size(list);
 }
 
+LV_FUNC_SECTION
 lv_event_dsc_t * lv_event_get_dsc(lv_event_list_t * list, uint32_t index)
 {
     LV_ASSERT_NULL(list);
@@ -136,12 +143,14 @@ lv_event_dsc_t * lv_event_get_dsc(lv_event_list_t * list, uint32_t index)
     return dsc ? *dsc : NULL;
 }
 
+LV_FUNC_SECTION
 lv_event_cb_t lv_event_dsc_get_cb(lv_event_dsc_t * dsc)
 {
     LV_ASSERT_NULL(dsc);
     return dsc->cb;
 }
 
+LV_FUNC_SECTION
 void * lv_event_dsc_get_user_data(lv_event_dsc_t * dsc)
 {
     LV_ASSERT_NULL(dsc);
@@ -149,6 +158,7 @@ void * lv_event_dsc_get_user_data(lv_event_dsc_t * dsc)
 
 }
 
+LV_FUNC_SECTION
 bool lv_event_remove(lv_event_list_t * list, uint32_t index)
 {
     LV_ASSERT_NULL(list);
@@ -157,6 +167,7 @@ bool lv_event_remove(lv_event_list_t * list, uint32_t index)
     return lv_array_remove(list, index);
 }
 
+LV_FUNC_SECTION
 void lv_event_remove_all(lv_event_list_t * list)
 {
     LV_ASSERT_NULL(list);
@@ -168,47 +179,56 @@ void lv_event_remove_all(lv_event_list_t * list)
     lv_array_deinit(list);
 }
 
+LV_FUNC_SECTION
 void * lv_event_get_current_target(lv_event_t * e)
 {
     return e->current_target;
 }
 
+LV_FUNC_SECTION
 void * lv_event_get_target(lv_event_t * e)
 {
     return e->original_target;
 }
 
+LV_FUNC_SECTION
 lv_event_code_t lv_event_get_code(lv_event_t * e)
 {
     return e->code & ~LV_EVENT_PREPROCESS;
 }
 
+LV_FUNC_SECTION
 void * lv_event_get_param(lv_event_t * e)
 {
     return e->param;
 }
 
+LV_FUNC_SECTION
 void * lv_event_get_user_data(lv_event_t * e)
 {
     return e->user_data;
 }
 
+LV_FUNC_SECTION
 void lv_event_stop_bubbling(lv_event_t * e)
 {
     e->stop_bubbling = 1;
 }
 
+LV_FUNC_SECTION
 void lv_event_stop_processing(lv_event_t * e)
 {
     e->stop_processing = 1;
 }
 
+LV_FUNC_SECTION
 uint32_t lv_event_register_id(void)
 {
     event_last_id ++;
     return event_last_id;
 }
 
+LV_FUNC_SECTION
 void lv_event_mark_deleted(void * target)
 {
     lv_event_t * e = event_head;
diff --git a/src/misc/lv_event_private.h b/src/misc/lv_event_private.h
index b31ca81b8..037526e2c 100644
--- a/src/misc/lv_event_private.h
+++ b/src/misc/lv_event_private.h
@@ -25,6 +25,7 @@ extern "C" {
  **********************/
 
 struct lv_event_dsc_t {
+    __attribute__(( fptrgroup("lv_event_cb") ))
     lv_event_cb_t cb;
     void * user_data;
     uint32_t filter;
diff --git a/src/misc/lv_fs.c b/src/misc/lv_fs.c
index f71369880..2752f68ca 100644
--- a/src/misc/lv_fs.c
+++ b/src/misc/lv_fs.c
@@ -52,16 +52,19 @@ static lv_fs_res_t lv_fs_seek_cached(lv_fs_file_t * file_p, uint32_t pos, lv_fs_
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 void lv_fs_init(void)
 {
     lv_ll_init(fsdrv_ll_p, sizeof(lv_fs_drv_t *));
 }
 
+LV_FUNC_SECTION
 void lv_fs_deinit(void)
 {
     lv_ll_clear(fsdrv_ll_p);
 }
 
+LV_FUNC_SECTION
 bool lv_fs_is_ready(char letter)
 {
     lv_fs_drv_t * drv = lv_fs_get_drv(letter);
@@ -73,6 +76,7 @@ bool lv_fs_is_ready(char letter)
     return drv->ready_cb(drv);
 }
 
+LV_FUNC_SECTION
 lv_fs_res_t lv_fs_open(lv_fs_file_t * file_p, const char * path, lv_fs_mode_t mode)
 {
     if(path == NULL) {
@@ -142,6 +146,7 @@ lv_fs_res_t lv_fs_open(lv_fs_file_t * file_p, const char * path, lv_fs_mode_t mo
     return LV_FS_RES_OK;
 }
 
+LV_FUNC_SECTION
 void lv_fs_make_path_from_buffer(lv_fs_path_ex_t * path, char letter, const void * buf, uint32_t size)
 {
     path->path[0] = letter;
@@ -151,6 +156,7 @@ void lv_fs_make_path_from_buffer(lv_fs_path_ex_t * path, char letter, const void
     path->size = size;
 }
 
+LV_FUNC_SECTION
 lv_fs_res_t lv_fs_close(lv_fs_file_t * file_p)
 {
     if(file_p->drv == NULL) {
@@ -183,6 +189,7 @@ lv_fs_res_t lv_fs_close(lv_fs_file_t * file_p)
     return res;
 }
 
+LV_FUNC_SECTION
 lv_fs_res_t lv_fs_read(lv_fs_file_t * file_p, void * buf, uint32_t btr, uint32_t * br)
 {
     if(br != NULL) *br = 0;
@@ -214,6 +221,7 @@ lv_fs_res_t lv_fs_read(lv_fs_file_t * file_p, void * buf, uint32_t btr, uint32_t
     return res;
 }
 
+LV_FUNC_SECTION
 lv_fs_res_t lv_fs_write(lv_fs_file_t * file_p, const void * buf, uint32_t btw, uint32_t * bw)
 {
     if(bw != NULL) *bw = 0;
@@ -246,6 +254,7 @@ lv_fs_res_t lv_fs_write(lv_fs_file_t * file_p, const void * buf, uint32_t btw, u
     return res;
 }
 
+LV_FUNC_SECTION
 lv_fs_res_t lv_fs_seek(lv_fs_file_t * file_p, uint32_t pos, lv_fs_whence_t whence)
 {
     if(file_p->drv == NULL) {
@@ -274,6 +283,7 @@ lv_fs_res_t lv_fs_seek(lv_fs_file_t * file_p, uint32_t pos, lv_fs_whence_t whenc
     return res;
 }
 
+LV_FUNC_SECTION
 lv_fs_res_t lv_fs_tell(lv_fs_file_t * file_p, uint32_t * pos)
 {
     if(file_p->drv == NULL) {
@@ -302,6 +312,7 @@ lv_fs_res_t lv_fs_tell(lv_fs_file_t * file_p, uint32_t * pos)
     return res;
 }
 
+LV_FUNC_SECTION
 lv_fs_res_t lv_fs_dir_open(lv_fs_dir_t * rddir_p, const char * path)
 {
     if(path == NULL) return LV_FS_RES_INV_PARAM;
@@ -341,6 +352,7 @@ lv_fs_res_t lv_fs_dir_open(lv_fs_dir_t * rddir_p, const char * path)
     return LV_FS_RES_OK;
 }
 
+LV_FUNC_SECTION
 lv_fs_res_t lv_fs_dir_read(lv_fs_dir_t * rddir_p, char * fn, uint32_t fn_len)
 {
     if(fn_len == 0) {
@@ -366,6 +378,7 @@ lv_fs_res_t lv_fs_dir_read(lv_fs_dir_t * rddir_p, char * fn, uint32_t fn_len)
     return res;
 }
 
+LV_FUNC_SECTION
 lv_fs_res_t lv_fs_dir_close(lv_fs_dir_t * rddir_p)
 {
     if(rddir_p->drv == NULL || rddir_p->dir_d == NULL) {
@@ -388,11 +401,13 @@ lv_fs_res_t lv_fs_dir_close(lv_fs_dir_t * rddir_p)
     return res;
 }
 
+LV_FUNC_SECTION
 void lv_fs_drv_init(lv_fs_drv_t * drv)
 {
     lv_memzero(drv, sizeof(lv_fs_drv_t));
 }
 
+LV_FUNC_SECTION
 void lv_fs_drv_register(lv_fs_drv_t * drv_p)
 {
     /*Save the new driver*/
@@ -404,6 +419,7 @@ void lv_fs_drv_register(lv_fs_drv_t * drv_p)
     *new_drv = drv_p;
 }
 
+LV_FUNC_SECTION
 lv_fs_drv_t * lv_fs_get_drv(char letter)
 {
     lv_fs_drv_t ** drv;
@@ -417,6 +433,7 @@ lv_fs_drv_t * lv_fs_get_drv(char letter)
     return NULL;
 }
 
+LV_FUNC_SECTION
 char * lv_fs_get_letters(char * buf)
 {
     lv_fs_drv_t ** drv;
@@ -432,6 +449,7 @@ char * lv_fs_get_letters(char * buf)
     return buf;
 }
 
+LV_FUNC_SECTION
 const char * lv_fs_get_ext(const char * fn)
 {
     size_t i;
@@ -447,6 +465,7 @@ const char * lv_fs_get_ext(const char * fn)
     return ""; /*Empty string if no '.' in the file name.*/
 }
 
+LV_FUNC_SECTION
 char * lv_fs_up(char * path)
 {
     size_t len = lv_strlen(path);
@@ -473,6 +492,7 @@ char * lv_fs_up(char * path)
     return path;
 }
 
+LV_FUNC_SECTION
 const char * lv_fs_get_last(const char * path)
 {
     size_t len = lv_strlen(path);
@@ -506,6 +526,7 @@ const char * lv_fs_get_last(const char * path)
  * Extract the drive letter and the real path from LVGL's "abstracted file system" path string
  * @param path path string (E.g. S:/folder/file.txt)
  */
+LV_FUNC_SECTION
 static resolved_path_t lv_fs_resolve_path(const char * path)
 {
     resolved_path_t resolved;
@@ -535,6 +556,7 @@ static resolved_path_t lv_fs_resolve_path(const char * path)
     return resolved;
 }
 
+LV_FUNC_SECTION
 static lv_fs_res_t lv_fs_read_cached(lv_fs_file_t * file_p, void * buf, uint32_t btr, uint32_t * br)
 {
     lv_fs_res_t res = LV_FS_RES_OK;
@@ -620,6 +642,7 @@ static lv_fs_res_t lv_fs_read_cached(lv_fs_file_t * file_p, void * buf, uint32_t
     return res;
 }
 
+LV_FUNC_SECTION
 static lv_fs_res_t lv_fs_write_cached(lv_fs_file_t * file_p, const void * buf, uint32_t btw, uint32_t * bw)
 {
     lv_fs_res_t res = LV_FS_RES_OK;
@@ -664,6 +687,7 @@ static lv_fs_res_t lv_fs_write_cached(lv_fs_file_t * file_p, const void * buf, u
     return res;
 }
 
+LV_FUNC_SECTION
 static lv_fs_res_t lv_fs_seek_cached(lv_fs_file_t * file_p, uint32_t pos, lv_fs_whence_t whence)
 {
     lv_fs_res_t res = LV_FS_RES_OK;
diff --git a/src/misc/lv_fs.h b/src/misc/lv_fs.h
index c6f938b7d..5dfa339b8 100644
--- a/src/misc/lv_fs.h
+++ b/src/misc/lv_fs.h
@@ -69,17 +69,27 @@ typedef struct lv_fs_drv_t lv_fs_drv_t;
 struct lv_fs_drv_t {
     char letter;
     uint32_t cache_size;
+    __attribute__(( fptrgroup("lv_fs_ready_cb") ))
     bool (*ready_cb)(lv_fs_drv_t * drv);
 
+    __attribute__(( fptrgroup("lv_fs_open_cb") ))
     void * (*open_cb)(lv_fs_drv_t * drv, const char * path, lv_fs_mode_t mode);
+    __attribute__(( fptrgroup("lv_fs_close_cb") ))
     lv_fs_res_t (*close_cb)(lv_fs_drv_t * drv, void * file_p);
+    __attribute__(( fptrgroup("lv_fs_read_cb") ))
     lv_fs_res_t (*read_cb)(lv_fs_drv_t * drv, void * file_p, void * buf, uint32_t btr, uint32_t * br);
+    __attribute__(( fptrgroup("lv_fs_write_cb") ))
     lv_fs_res_t (*write_cb)(lv_fs_drv_t * drv, void * file_p, const void * buf, uint32_t btw, uint32_t * bw);
+    __attribute__(( fptrgroup("lv_fs_seek_cb") ))
     lv_fs_res_t (*seek_cb)(lv_fs_drv_t * drv, void * file_p, uint32_t pos, lv_fs_whence_t whence);
+    __attribute__(( fptrgroup("lv_fs_tell_cb") ))
     lv_fs_res_t (*tell_cb)(lv_fs_drv_t * drv, void * file_p, uint32_t * pos_p);
 
+    __attribute__(( fptrgroup("lv_fs_dir_open_cb") ))
     void * (*dir_open_cb)(lv_fs_drv_t * drv, const char * path);
+    __attribute__(( fptrgroup("lv_fs_dir_read_cb") ))
     lv_fs_res_t (*dir_read_cb)(lv_fs_drv_t * drv, void * rddir_p, char * fn, uint32_t fn_len);
+    __attribute__(( fptrgroup("lv_fs_dir_close_cb") ))
     lv_fs_res_t (*dir_close_cb)(lv_fs_drv_t * drv, void * rddir_p);
 
     void * user_data; /**< Custom file user data*/
diff --git a/src/misc/lv_ll.c b/src/misc/lv_ll.c
index ca1339ec5..a1c4c5f8a 100644
--- a/src/misc/lv_ll.c
+++ b/src/misc/lv_ll.c
@@ -39,6 +39,7 @@ static void node_set_next(lv_ll_t * ll_p, lv_ll_node_t * act, lv_ll_node_t * nex
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 void lv_ll_init(lv_ll_t * ll_p, uint32_t node_size)
 {
     ll_p->head = NULL;
@@ -54,6 +55,7 @@ void lv_ll_init(lv_ll_t * ll_p, uint32_t node_size)
     ll_p->n_size = node_size;
 }
 
+LV_FUNC_SECTION
 void * lv_ll_ins_head(lv_ll_t * ll_p)
 {
     lv_ll_node_t * n_new;
@@ -77,6 +79,7 @@ void * lv_ll_ins_head(lv_ll_t * ll_p)
     return n_new;
 }
 
+LV_FUNC_SECTION
 void * lv_ll_ins_prev(lv_ll_t * ll_p, void * n_act)
 {
     lv_ll_node_t * n_new;
@@ -102,6 +105,7 @@ void * lv_ll_ins_prev(lv_ll_t * ll_p, void * n_act)
     return n_new;
 }
 
+LV_FUNC_SECTION
 void * lv_ll_ins_tail(lv_ll_t * ll_p)
 {
     lv_ll_node_t * n_new;
@@ -124,6 +128,7 @@ void * lv_ll_ins_tail(lv_ll_t * ll_p)
     return n_new;
 }
 
+LV_FUNC_SECTION
 void lv_ll_remove(lv_ll_t * ll_p, void * node_p)
 {
     if(ll_p == NULL) return;
@@ -157,7 +162,7 @@ void lv_ll_remove(lv_ll_t * ll_p, void * node_p)
     }
 }
 
-void lv_ll_clear_custom(lv_ll_t * ll_p, void(*cleanup)(void *))
+void lv_ll_clear_custom(lv_ll_t * ll_p, __attribute__(( fptrgroup("lv_ll_cleanup") )) void(*cleanup)(void *))
 {
     void * i;
     void * i_next;
@@ -178,6 +183,7 @@ void lv_ll_clear_custom(lv_ll_t * ll_p, void(*cleanup)(void *))
     }
 }
 
+LV_FUNC_SECTION
 void lv_ll_chg_list(lv_ll_t * ll_ori_p, lv_ll_t * ll_new_p, void * node, bool head)
 {
     lv_ll_remove(ll_ori_p, node);
@@ -212,18 +218,21 @@ void lv_ll_chg_list(lv_ll_t * ll_ori_p, lv_ll_t * ll_new_p, void * node, bool he
     }
 }
 
+__attribute__(( fptrgroup("lv_ll_get") ))
 void * lv_ll_get_head(const lv_ll_t * ll_p)
 {
     if(ll_p == NULL) return NULL;
     return ll_p->head;
 }
 
+__attribute__(( fptrgroup("lv_ll_get") ))
 void * lv_ll_get_tail(const lv_ll_t * ll_p)
 {
     if(ll_p == NULL) return NULL;
     return ll_p->tail;
 }
 
+__attribute__(( fptrgroup("lv_ll_get") ))
 void * lv_ll_get_next(const lv_ll_t * ll_p, const void * n_act)
 {
     /*Pointer to the next node is stored in the end of this node.
@@ -233,6 +242,7 @@ void * lv_ll_get_next(const lv_ll_t * ll_p, const void * n_act)
     return *((lv_ll_node_t **)n_act_d);
 }
 
+__attribute__(( fptrgroup("lv_ll_get") ))
 void * lv_ll_get_prev(const lv_ll_t * ll_p, const void * n_act)
 {
     /*Pointer to the prev. node is stored in the end of this node.
@@ -242,6 +252,7 @@ void * lv_ll_get_prev(const lv_ll_t * ll_p, const void * n_act)
     return *((lv_ll_node_t **)n_act_d);
 }
 
+LV_FUNC_SECTION
 uint32_t lv_ll_get_len(const lv_ll_t * ll_p)
 {
     uint32_t len = 0;
@@ -254,6 +265,7 @@ uint32_t lv_ll_get_len(const lv_ll_t * ll_p)
     return len;
 }
 
+LV_FUNC_SECTION
 void lv_ll_move_before(lv_ll_t * ll_p, void * n_act, void * n_after)
 {
     if(n_act == n_after) return; /*Can't move before itself*/
@@ -282,6 +294,7 @@ void lv_ll_move_before(lv_ll_t * ll_p, void * n_act, void * n_after)
     if(n_before == NULL) ll_p->head = n_act;
 }
 
+LV_FUNC_SECTION
 bool lv_ll_is_empty(lv_ll_t * ll_p)
 {
     if(ll_p == NULL) return true;
@@ -291,6 +304,7 @@ bool lv_ll_is_empty(lv_ll_t * ll_p)
     return false;
 }
 
+LV_FUNC_SECTION
 void lv_ll_clear(lv_ll_t * ll_p)
 {
     lv_ll_clear_custom(ll_p, NULL);
@@ -306,6 +320,7 @@ void lv_ll_clear(lv_ll_t * ll_p)
  * @param act pointer to a node which prev. node pointer should be set
  * @param prev pointer to a node which should be the previous node before 'act'
  */
+LV_FUNC_SECTION
 static void node_set_prev(lv_ll_t * ll_p, lv_ll_node_t * act, lv_ll_node_t * prev)
 {
     if(act == NULL) return; /*Can't set the prev node of `NULL`*/
@@ -326,6 +341,7 @@ static void node_set_prev(lv_ll_t * ll_p, lv_ll_node_t * act, lv_ll_node_t * pre
  * @param act pointer to a node which next node pointer should be set
  * @param next pointer to a node which should be the next node before 'act'
  */
+LV_FUNC_SECTION
 static void node_set_next(lv_ll_t * ll_p, lv_ll_node_t * act, lv_ll_node_t * next)
 {
     if(act == NULL) return; /*Can't set the next node of `NULL`*/
diff --git a/src/misc/lv_log.c b/src/misc/lv_log.c
index 3f3caec8d..c5e552251 100644
--- a/src/misc/lv_log.c
+++ b/src/misc/lv_log.c
@@ -64,11 +64,13 @@
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 void lv_log_register_print_cb(lv_log_print_g_cb_t print_cb)
 {
     custom_print_cb = print_cb;
 }
 
+LV_FUNC_SECTION
 void lv_log_add(lv_log_level_t level, const char * file, int line, const char * func, const char * format, ...)
 {
     if(level >= LV_LOG_LEVEL_NUM) return; /*Invalid level*/
@@ -119,6 +121,7 @@ void lv_log_add(lv_log_level_t level, const char * file, int line, const char *
     }
 }
 
+LV_FUNC_SECTION
 void lv_log(const char * format, ...)
 {
     if(LV_LOG_LEVEL >= LV_LOG_LEVEL_NONE) return; /* disable log */
diff --git a/src/misc/lv_lru.c b/src/misc/lv_lru.c
index f8d4c0682..8367455c2 100755
--- a/src/misc/lv_lru.c
+++ b/src/misc/lv_lru.c
@@ -71,6 +71,7 @@ static lv_lru_item_t * lv_lru_pop_or_create_item(lv_lru_t * cache);
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 lv_lru_t * lv_lru_create(size_t cache_size, size_t average_length, lv_lru_free_cb_t value_free,
                          lv_lru_free_cb_t key_free)
 {
@@ -98,6 +99,7 @@ lv_lru_t * lv_lru_create(size_t cache_size, size_t average_length, lv_lru_free_c
     return cache;
 }
 
+LV_FUNC_SECTION
 void lv_lru_delete(lv_lru_t * cache)
 {
     LV_ASSERT_NULL(cache);
@@ -133,6 +135,7 @@ void lv_lru_delete(lv_lru_t * cache)
     lv_free(cache);
 }
 
+LV_FUNC_SECTION
 lv_lru_res_t lv_lru_set(lv_lru_t * cache, const void * key, size_t key_length, void * value, size_t value_length)
 {
     test_for_missing_cache();
@@ -185,6 +188,7 @@ lv_lru_res_t lv_lru_set(lv_lru_t * cache, const void * key, size_t key_length, v
     return LV_LRU_OK;
 }
 
+LV_FUNC_SECTION
 lv_lru_res_t lv_lru_get(lv_lru_t * cache, const void * key, size_t key_size, void ** value)
 {
     test_for_missing_cache();
@@ -208,6 +212,7 @@ lv_lru_res_t lv_lru_get(lv_lru_t * cache, const void * key, size_t key_size, voi
     return LV_LRU_OK;
 }
 
+LV_FUNC_SECTION
 lv_lru_res_t lv_lru_remove(lv_lru_t * cache, const void * key, size_t key_size)
 {
     test_for_missing_cache();
@@ -230,6 +235,7 @@ lv_lru_res_t lv_lru_remove(lv_lru_t * cache, const void * key, size_t key_size)
     return LV_LRU_OK;
 }
 
+LV_FUNC_SECTION
 void lv_lru_remove_lru_item(lv_lru_t * cache)
 {
     lv_lru_item_t * min_item = NULL, * min_prev = NULL;
@@ -262,6 +268,7 @@ void lv_lru_remove_lru_item(lv_lru_t * cache)
  *   STATIC FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 static uint32_t lv_lru_hash(lv_lru_t * cache, const void * key, uint32_t key_length)
 {
     uint32_t m = 0x5bd1e995;
@@ -297,6 +304,7 @@ static uint32_t lv_lru_hash(lv_lru_t * cache, const void * key, uint32_t key_len
     return h % cache->hash_table_size;
 }
 
+LV_FUNC_SECTION
 static int lv_lru_cmp_keys(lv_lru_item_t * item, const void * key, uint32_t key_length)
 {
     if(key_length != item->key_length) {
@@ -307,6 +315,7 @@ static int lv_lru_cmp_keys(lv_lru_item_t * item, const void * key, uint32_t key_
     }
 }
 
+LV_FUNC_SECTION
 static void lv_lru_remove_item(lv_lru_t * cache, lv_lru_item_t * prev, lv_lru_item_t * item, uint32_t hash_index)
 {
     if(prev) {
@@ -327,6 +336,7 @@ static void lv_lru_remove_item(lv_lru_t * cache, lv_lru_item_t * prev, lv_lru_it
     cache->free_items = item;
 }
 
+LV_FUNC_SECTION
 static lv_lru_item_t * lv_lru_pop_or_create_item(lv_lru_t * cache)
 {
     lv_lru_item_t * item = NULL;
diff --git a/src/misc/lv_math.c b/src/misc/lv_math.c
index bd728fbcf..5b21561a6 100644
--- a/src/misc/lv_math.c
+++ b/src/misc/lv_math.c
@@ -107,6 +107,7 @@ int32_t LV_ATTRIBUTE_FAST_MEM lv_trigo_sin(int16_t angle)
  *
  */
 
+LV_FUNC_SECTION
 static int32_t do_cubic_bezier(int32_t t, int32_t a, int32_t b, int32_t c)
 {
     /*a * t^3 + b * t^2 + c * t*/
@@ -123,6 +124,7 @@ static int32_t do_cubic_bezier(int32_t t, int32_t a, int32_t b, int32_t c)
     return ret;
 }
 
+LV_FUNC_SECTION
 int32_t lv_cubic_bezier(int32_t x, int32_t x1, int32_t y1, int32_t x2, int32_t y2)
 {
     int32_t ax, bx, cx, ay, by, cy;
@@ -311,6 +313,7 @@ adj:
     return xn;
 }
 
+LV_FUNC_SECTION
 uint16_t lv_atan2(int x, int y)
 {
     /**
@@ -388,6 +391,7 @@ uint16_t lv_atan2(int x, int y)
     return degree;
 }
 
+LV_FUNC_SECTION
 int64_t lv_pow(int64_t base, int8_t exp)
 {
     int64_t result = 1;
@@ -401,6 +405,7 @@ int64_t lv_pow(int64_t base, int8_t exp)
     return result;
 }
 
+LV_FUNC_SECTION
 int32_t lv_map(int32_t x, int32_t min_in, int32_t max_in, int32_t min_out, int32_t max_out)
 {
     if(max_in >= min_in && x >= max_in) return max_out;
@@ -422,11 +427,13 @@ int32_t lv_map(int32_t x, int32_t min_in, int32_t max_in, int32_t min_out, int32
     return ((x - min_in) * delta_out) / delta_in + min_out;
 }
 
+LV_FUNC_SECTION
 void lv_rand_set_seed(uint32_t seed)
 {
     rand_seed = seed;
 }
 
+LV_FUNC_SECTION
 uint32_t lv_rand(uint32_t min, uint32_t max)
 {
     /*Algorithm "xor" from p. 4 of Marsaglia, "Xorshift RNGs"*/
@@ -444,6 +451,7 @@ int32_t LV_ATTRIBUTE_FAST_MEM lv_trigo_cos(int16_t angle)
     return lv_trigo_sin(angle + 90);
 }
 
+LV_FUNC_SECTION
 int32_t lv_bezier3(int32_t t, int32_t u0, uint32_t u1, int32_t u2, int32_t u3)
 {
     LV_UNUSED(u0);
diff --git a/src/misc/lv_matrix.c b/src/misc/lv_matrix.c
index 4a6bb6374..8f345e3d3 100644
--- a/src/misc/lv_matrix.c
+++ b/src/misc/lv_matrix.c
@@ -41,6 +41,7 @@
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 void lv_matrix_identity(lv_matrix_t * matrix)
 {
     matrix->m[0][0] = 1.0f;
@@ -54,6 +55,7 @@ void lv_matrix_identity(lv_matrix_t * matrix)
     matrix->m[2][2] = 1.0f;
 }
 
+LV_FUNC_SECTION
 void lv_matrix_translate(lv_matrix_t * matrix, float dx, float dy)
 {
     if(lv_matrix_is_identity_or_translation(matrix)) {
@@ -73,6 +75,7 @@ void lv_matrix_translate(lv_matrix_t * matrix, float dx, float dy)
     lv_matrix_multiply(matrix, &tlm);
 }
 
+LV_FUNC_SECTION
 void lv_matrix_scale(lv_matrix_t * matrix, float scale_x, float scale_y)
 {
     lv_matrix_t scm = {{
@@ -85,6 +88,7 @@ void lv_matrix_scale(lv_matrix_t * matrix, float scale_x, float scale_y)
     lv_matrix_multiply(matrix, &scm);
 }
 
+LV_FUNC_SECTION
 void lv_matrix_rotate(lv_matrix_t * matrix, float degree)
 {
     float radian = degree / 180.0f * (float)M_PI;
@@ -101,6 +105,7 @@ void lv_matrix_rotate(lv_matrix_t * matrix, float degree)
     lv_matrix_multiply(matrix, &rtm);
 }
 
+LV_FUNC_SECTION
 void lv_matrix_skew(lv_matrix_t * matrix, float skew_x, float skew_y)
 {
     float rskew_x = skew_x / 180.0f * (float)M_PI;
@@ -118,6 +123,7 @@ void lv_matrix_skew(lv_matrix_t * matrix, float skew_x, float skew_y)
     lv_matrix_multiply(matrix, &skm);
 }
 
+LV_FUNC_SECTION
 void lv_matrix_multiply(lv_matrix_t * matrix, const lv_matrix_t * mul)
 {
     /*TODO: use NEON to optimize this function on ARM architecture.*/
@@ -134,6 +140,7 @@ void lv_matrix_multiply(lv_matrix_t * matrix, const lv_matrix_t * mul)
     lv_memcpy(matrix, &tmp, sizeof(lv_matrix_t));
 }
 
+LV_FUNC_SECTION
 bool lv_matrix_inverse(lv_matrix_t * matrix, const lv_matrix_t * m)
 {
     float det00, det01, det02;
@@ -177,6 +184,7 @@ bool lv_matrix_inverse(lv_matrix_t * matrix, const lv_matrix_t * m)
     return true;
 }
 
+LV_FUNC_SECTION
 lv_point_precise_t lv_matrix_transform_precise_point(const lv_matrix_t * matrix, const lv_point_precise_t * point)
 {
     lv_point_precise_t p;
@@ -185,6 +193,7 @@ lv_point_precise_t lv_matrix_transform_precise_point(const lv_matrix_t * matrix,
     return p;
 }
 
+LV_FUNC_SECTION
 lv_area_t lv_matrix_transform_area(const lv_matrix_t * matrix, const lv_area_t * area)
 {
     lv_area_t res;
@@ -207,6 +216,7 @@ lv_area_t lv_matrix_transform_area(const lv_matrix_t * matrix, const lv_area_t *
     return res;
 }
 
+LV_FUNC_SECTION
 bool lv_matrix_is_identity_or_translation(const lv_matrix_t * matrix)
 {
     return (matrix->m[0][0] == 1.0f &&
diff --git a/src/misc/lv_palette.c b/src/misc/lv_palette.c
index cbcdf4e64..bc1cbb251 100644
--- a/src/misc/lv_palette.c
+++ b/src/misc/lv_palette.c
@@ -32,6 +32,7 @@
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 lv_color_t lv_palette_main(lv_palette_t p)
 {
     static const lv_color_t colors[] = {
@@ -51,6 +52,7 @@ lv_color_t lv_palette_main(lv_palette_t p)
 
 }
 
+LV_FUNC_SECTION
 lv_color_t lv_palette_lighten(lv_palette_t p, uint8_t lvl)
 {
     static const lv_color_t colors[][5] = {
@@ -90,6 +92,7 @@ lv_color_t lv_palette_lighten(lv_palette_t p, uint8_t lvl)
     return colors[p][lvl];
 }
 
+LV_FUNC_SECTION
 lv_color_t lv_palette_darken(lv_palette_t p, uint8_t lvl)
 {
     static const lv_color_t colors[][4] = {
diff --git a/src/misc/lv_profiler_builtin.c b/src/misc/lv_profiler_builtin.c
index b6b6fd435..7ebc72ea2 100644
--- a/src/misc/lv_profiler_builtin.c
+++ b/src/misc/lv_profiler_builtin.c
@@ -86,6 +86,7 @@ static void flush_no_lock(void);
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 void lv_profiler_builtin_config_init(lv_profiler_builtin_config_t * config)
 {
     LV_ASSERT_NULL(config);
@@ -98,6 +99,7 @@ void lv_profiler_builtin_config_init(lv_profiler_builtin_config_t * config)
     config->cpu_get_cb = default_cpu_get_cb;
 }
 
+LV_FUNC_SECTION
 void lv_profiler_builtin_init(const lv_profiler_builtin_config_t * config)
 {
     LV_ASSERT_NULL(config);
@@ -146,6 +148,7 @@ void lv_profiler_builtin_init(const lv_profiler_builtin_config_t * config)
     LV_LOG_INFO("init OK, item_num = %d", (int)num);
 }
 
+LV_FUNC_SECTION
 void lv_profiler_builtin_uninit(void)
 {
     LV_ASSERT_NULL(profiler_ctx);
@@ -155,6 +158,7 @@ void lv_profiler_builtin_uninit(void)
     profiler_ctx = NULL;
 }
 
+LV_FUNC_SECTION
 void lv_profiler_builtin_set_enable(bool enable)
 {
     if(!profiler_ctx) {
@@ -164,6 +168,7 @@ void lv_profiler_builtin_set_enable(bool enable)
     profiler_ctx->enable = enable;
 }
 
+LV_FUNC_SECTION
 void lv_profiler_builtin_flush(void)
 {
     LV_ASSERT_NULL(profiler_ctx);
@@ -173,6 +178,7 @@ void lv_profiler_builtin_flush(void)
     LV_PROFILER_MULTEX_UNLOCK;
 }
 
+LV_FUNC_SECTION
 void lv_profiler_builtin_write(const char * func, char tag)
 {
     LV_ASSERT_NULL(profiler_ctx);
@@ -208,21 +214,25 @@ void lv_profiler_builtin_write(const char * func, char tag)
  *   STATIC FUNCTIONS
  **********************/
 
+__attribute__(( fptrgroup("lv_profiler_flush_cb") ))
 static void default_flush_cb(const char * buf)
 {
     LV_LOG("%s", buf);
 }
 
+__attribute__(( fptrgroup("lv_profiler_tid_get_cb") ))
 static int default_tid_get_cb(void)
 {
     return 1;
 }
 
+__attribute__(( fptrgroup("lv_profiler_cpu_get_cb") ))
 static int default_cpu_get_cb(void)
 {
     return 0;
 }
 
+LV_FUNC_SECTION
 static void flush_no_lock(void)
 {
     if(!profiler_ctx->config.flush_cb) {
diff --git a/src/misc/lv_profiler_builtin_private.h b/src/misc/lv_profiler_builtin_private.h
index 3fb9938a2..519a13226 100644
--- a/src/misc/lv_profiler_builtin_private.h
+++ b/src/misc/lv_profiler_builtin_private.h
@@ -32,9 +32,13 @@ extern "C" {
 struct lv_profiler_builtin_config_t {
     size_t buf_size;                    /**< The size of the buffer used for profiling data */
     uint32_t tick_per_sec;              /**< The number of ticks per second */
+    __attribute__(( fptrgroup("lv_profiler_tick_get_cb") ))
     uint32_t (*tick_get_cb)(void);      /**< Callback function to get the current tick count */
+    __attribute__(( fptrgroup("lv_profiler_flush_cb") ))
     void (*flush_cb)(const char * buf); /**< Callback function to flush the profiling data */
+    __attribute__(( fptrgroup("lv_profiler_tid_get_cb") ))
     int (*tid_get_cb)(void);            /**< Callback function to get the current thread ID */
+    __attribute__(( fptrgroup("lv_profiler_cpu_get_cb") ))
     int (*cpu_get_cb)(void);            /**< Callback function to get the current CPU */
 };
 
diff --git a/src/misc/lv_rb.c b/src/misc/lv_rb.c
index 8a7328caa..16005a5ed 100755
--- a/src/misc/lv_rb.c
+++ b/src/misc/lv_rb.c
@@ -44,6 +44,7 @@ static void rb_delete_color(lv_rb_t * tree, lv_rb_node_t * node1, lv_rb_node_t *
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 bool lv_rb_init(lv_rb_t * tree, lv_rb_compare_t compare, size_t node_size)
 {
     LV_ASSERT_NULL(tree);
@@ -63,6 +64,7 @@ bool lv_rb_init(lv_rb_t * tree, lv_rb_compare_t compare, size_t node_size)
     return true;
 }
 
+LV_FUNC_SECTION
 lv_rb_node_t * lv_rb_insert(lv_rb_t * tree, void * key)
 {
     LV_ASSERT_NULL(tree);
@@ -100,6 +102,7 @@ lv_rb_node_t * lv_rb_insert(lv_rb_t * tree, void * key)
     return node;
 }
 
+LV_FUNC_SECTION
 lv_rb_node_t * lv_rb_find(lv_rb_t * tree, const void * key)
 {
     LV_ASSERT_NULL(tree);
@@ -126,6 +129,7 @@ lv_rb_node_t * lv_rb_find(lv_rb_t * tree, const void * key)
     return NULL;
 }
 
+LV_FUNC_SECTION
 void * lv_rb_remove_node(lv_rb_t * tree, lv_rb_node_t * node)
 {
     lv_rb_node_t * child = NULL;
@@ -207,6 +211,7 @@ void * lv_rb_remove_node(lv_rb_t * tree, lv_rb_node_t * node)
     return data;
 }
 
+LV_FUNC_SECTION
 void * lv_rb_remove(lv_rb_t * tree, const void * key)
 {
     LV_ASSERT_NULL(tree);
@@ -224,6 +229,7 @@ void * lv_rb_remove(lv_rb_t * tree, const void * key)
     return lv_rb_remove_node(tree, node);
 }
 
+LV_FUNC_SECTION
 bool lv_rb_drop_node(lv_rb_t * tree, lv_rb_node_t * node)
 {
     LV_ASSERT_NULL(tree);
@@ -239,6 +245,7 @@ bool lv_rb_drop_node(lv_rb_t * tree, lv_rb_node_t * node)
     return false;
 }
 
+LV_FUNC_SECTION
 bool lv_rb_drop(lv_rb_t * tree, const void * key)
 {
     LV_ASSERT_NULL(tree);
@@ -254,6 +261,7 @@ bool lv_rb_drop(lv_rb_t * tree, const void * key)
     return false;
 }
 
+LV_FUNC_SECTION
 void lv_rb_destroy(lv_rb_t * tree)
 {
     LV_ASSERT_NULL(tree);
@@ -290,6 +298,7 @@ void lv_rb_destroy(lv_rb_t * tree)
     tree->root = NULL;
 }
 
+LV_FUNC_SECTION
 lv_rb_node_t * lv_rb_minimum(lv_rb_t * tree)
 {
     LV_ASSERT_NULL(tree);
@@ -299,6 +308,7 @@ lv_rb_node_t * lv_rb_minimum(lv_rb_t * tree)
     return lv_rb_minimum_from(tree->root);
 }
 
+LV_FUNC_SECTION
 lv_rb_node_t * lv_rb_maximum(lv_rb_t * tree)
 {
     LV_ASSERT_NULL(tree);
@@ -308,6 +318,7 @@ lv_rb_node_t * lv_rb_maximum(lv_rb_t * tree)
     return lv_rb_maximum_from(tree->root);
 }
 
+LV_FUNC_SECTION
 lv_rb_node_t * lv_rb_minimum_from(lv_rb_node_t * node)
 {
     while(node->left != NULL) {
@@ -317,6 +328,7 @@ lv_rb_node_t * lv_rb_minimum_from(lv_rb_node_t * node)
     return node;
 }
 
+LV_FUNC_SECTION
 lv_rb_node_t * lv_rb_maximum_from(lv_rb_node_t * node)
 {
     while(node->right != NULL) {
@@ -330,6 +342,7 @@ lv_rb_node_t * lv_rb_maximum_from(lv_rb_node_t * node)
  *   STATIC FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 static lv_rb_node_t * rb_create_node(lv_rb_t * tree)
 {
     lv_rb_node_t * node = lv_malloc_zeroed(sizeof(lv_rb_node_t));
@@ -352,6 +365,7 @@ static lv_rb_node_t * rb_create_node(lv_rb_t * tree)
     return node;
 }
 
+LV_FUNC_SECTION
 static lv_rb_node_t * rb_find_leaf_parent(lv_rb_t * tree, lv_rb_node_t * node)
 {
     lv_rb_node_t * current = tree->root;
@@ -371,6 +385,7 @@ static lv_rb_node_t * rb_find_leaf_parent(lv_rb_t * tree, lv_rb_node_t * node)
     return parent;
 }
 
+LV_FUNC_SECTION
 static void rb_right_rotate(lv_rb_t * tree, lv_rb_node_t * node)
 {
     lv_rb_node_t * left = node->left;
@@ -396,6 +411,7 @@ static void rb_right_rotate(lv_rb_t * tree, lv_rb_node_t * node)
     node->parent = left;
 }
 
+LV_FUNC_SECTION
 static void rb_left_rotate(lv_rb_t * tree, lv_rb_node_t * node)
 {
     lv_rb_node_t * right = node->right;
@@ -421,6 +437,7 @@ static void rb_left_rotate(lv_rb_t * tree, lv_rb_node_t * node)
     node->parent = right;
 }
 
+LV_FUNC_SECTION
 static void rb_insert_color(lv_rb_t * tree, lv_rb_node_t * node)
 {
     lv_rb_node_t * parent = NULL;
@@ -482,6 +499,7 @@ static void rb_insert_color(lv_rb_t * tree, lv_rb_node_t * node)
     tree->root->color = LV_RB_COLOR_BLACK;
 }
 
+LV_FUNC_SECTION
 static void rb_delete_color(lv_rb_t * tree, lv_rb_node_t * node1, lv_rb_node_t * node2)
 {
     LV_ASSERT_NULL(tree);
diff --git a/src/misc/lv_rb_private.h b/src/misc/lv_rb_private.h
index 327b7b0be..86c7cae8c 100644
--- a/src/misc/lv_rb_private.h
+++ b/src/misc/lv_rb_private.h
@@ -34,6 +34,7 @@ struct lv_rb_node_t {
 
 struct lv_rb_t {
     lv_rb_node_t * root;
+    __attribute__(( fptrgroup("lv_cache_compare_cb") ))
     lv_rb_compare_t compare;
     size_t size;
 };
diff --git a/src/misc/lv_style.c b/src/misc/lv_style.c
index d137d67eb..7d9c6bf03 100644
--- a/src/misc/lv_style.c
+++ b/src/misc/lv_style.c
@@ -173,6 +173,7 @@ const uint8_t lv_style_builtin_prop_flag_lookup_table[LV_STYLE_NUM_BUILT_IN_PROP
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 void lv_style_init(lv_style_t * style)
 {
 #if LV_USE_ASSERT_STYLE
@@ -187,6 +188,7 @@ void lv_style_init(lv_style_t * style)
 #endif
 }
 
+LV_FUNC_SECTION
 void lv_style_reset(lv_style_t * style)
 {
     LV_ASSERT_STYLE(style);
@@ -198,6 +200,7 @@ void lv_style_reset(lv_style_t * style)
 #endif
 }
 
+LV_FUNC_SECTION
 lv_style_prop_t lv_style_register_prop(uint8_t flag)
 {
     if(lv_style_custom_prop_flag_lookup_table == NULL) {
@@ -234,11 +237,13 @@ lv_style_prop_t lv_style_register_prop(uint8_t flag)
     return last_custom_prop_id;
 }
 
+LV_FUNC_SECTION
 lv_style_prop_t lv_style_get_num_custom_props(void)
 {
     return last_custom_prop_id - LV_STYLE_LAST_BUILT_IN_PROP;
 }
 
+LV_FUNC_SECTION
 bool lv_style_remove_prop(lv_style_t * style, lv_style_prop_t prop)
 {
     LV_ASSERT_STYLE(style);
@@ -284,6 +289,7 @@ bool lv_style_remove_prop(lv_style_t * style, lv_style_prop_t prop)
     return false;
 }
 
+LV_FUNC_SECTION
 void lv_style_set_prop(lv_style_t * style, lv_style_prop_t prop, lv_style_value_t value)
 {
     LV_ASSERT_STYLE(style);
@@ -333,11 +339,13 @@ void lv_style_set_prop(lv_style_t * style, lv_style_prop_t prop, lv_style_value_
     style->has_group |= (uint32_t)1 << group;
 }
 
+LV_FUNC_SECTION
 lv_style_res_t lv_style_get_prop(const lv_style_t * style, lv_style_prop_t prop, lv_style_value_t * value)
 {
     return lv_style_get_prop_inlined(style, prop, value);
 }
 
+LV_FUNC_SECTION
 void lv_style_transition_dsc_init(lv_style_transition_dsc_t * tr, const lv_style_prop_t props[],
                                   lv_anim_path_cb_t path_cb, uint32_t time, uint32_t delay, void * user_data)
 {
@@ -349,6 +357,7 @@ void lv_style_transition_dsc_init(lv_style_transition_dsc_t * tr, const lv_style
     tr->user_data = user_data;
 }
 
+LV_FUNC_SECTION
 lv_style_value_t lv_style_prop_get_default(lv_style_prop_t prop)
 {
     const lv_color_t black = LV_COLOR_MAKE(0x00, 0x00, 0x00);
@@ -417,6 +426,7 @@ lv_style_value_t lv_style_prop_get_default(lv_style_prop_t prop)
     }
 }
 
+LV_FUNC_SECTION
 bool lv_style_is_empty(const lv_style_t * style)
 {
     LV_ASSERT_STYLE(style);
@@ -424,6 +434,7 @@ bool lv_style_is_empty(const lv_style_t * style)
     return style->prop_cnt == 0;
 }
 
+LV_FUNC_SECTION
 uint8_t lv_style_prop_lookup_flags(lv_style_prop_t prop)
 {
     if(prop == LV_STYLE_PROP_ANY) return LV_STYLE_PROP_FLAG_ALL; /*Any prop can have any flags*/
diff --git a/src/misc/lv_style.h b/src/misc/lv_style.h
index dcce7dcd6..a671c76ec 100644
--- a/src/misc/lv_style.h
+++ b/src/misc/lv_style.h
@@ -348,6 +348,7 @@ typedef enum {
 typedef struct {
     const lv_style_prop_t * props; /**< An array with the properties to animate.*/
     void * user_data;              /**< A custom user data that will be passed to the animation's user_data */
+    __attribute__(( fptrgroup("lv_anim_path_cb") ))
     lv_anim_path_cb_t path_xcb;    /**< A path for the animation.*/
     uint32_t time;                 /**< Duration of the transition in [ms]*/
     uint32_t delay;                /**< Delay before the transition in [ms]*/
diff --git a/src/misc/lv_style_gen.c b/src/misc/lv_style_gen.c
index 233cf7b94..7635a7fa3 100644
--- a/src/misc/lv_style_gen.c
+++ b/src/misc/lv_style_gen.c
@@ -10,6 +10,7 @@
 #include "lv_style.h"
 
 
+LV_FUNC_SECTION
 void lv_style_set_width(lv_style_t * style, int32_t value)
 {
     lv_style_value_t v = {
@@ -18,6 +19,7 @@ void lv_style_set_width(lv_style_t * style, int32_t value)
     lv_style_set_prop(style, LV_STYLE_WIDTH, v);
 }
 
+LV_FUNC_SECTION
 void lv_style_set_min_width(lv_style_t * style, int32_t value)
 {
     lv_style_value_t v = {
@@ -26,6 +28,7 @@ void lv_style_set_min_width(lv_style_t * style, int32_t value)
     lv_style_set_prop(style, LV_STYLE_MIN_WIDTH, v);
 }
 
+LV_FUNC_SECTION
 void lv_style_set_max_width(lv_style_t * style, int32_t value)
 {
     lv_style_value_t v = {
@@ -34,6 +37,7 @@ void lv_style_set_max_width(lv_style_t * style, int32_t value)
     lv_style_set_prop(style, LV_STYLE_MAX_WIDTH, v);
 }
 
+LV_FUNC_SECTION
 void lv_style_set_height(lv_style_t * style, int32_t value)
 {
     lv_style_value_t v = {
@@ -42,6 +46,7 @@ void lv_style_set_height(lv_style_t * style, int32_t value)
     lv_style_set_prop(style, LV_STYLE_HEIGHT, v);
 }
 
+LV_FUNC_SECTION
 void lv_style_set_min_height(lv_style_t * style, int32_t value)
 {
     lv_style_value_t v = {
@@ -50,6 +55,7 @@ void lv_style_set_min_height(lv_style_t * style, int32_t value)
     lv_style_set_prop(style, LV_STYLE_MIN_HEIGHT, v);
 }
 
+LV_FUNC_SECTION
 void lv_style_set_max_height(lv_style_t * style, int32_t value)
 {
     lv_style_value_t v = {
@@ -58,6 +64,7 @@ void lv_style_set_max_height(lv_style_t * style, int32_t value)
     lv_style_set_prop(style, LV_STYLE_MAX_HEIGHT, v);
 }
 
+LV_FUNC_SECTION
 void lv_style_set_length(lv_style_t * style, int32_t value)
 {
     lv_style_value_t v = {
@@ -66,6 +73,7 @@ void lv_style_set_length(lv_style_t * style, int32_t value)
     lv_style_set_prop(style, LV_STYLE_LENGTH, v);
 }
 
+LV_FUNC_SECTION
 void lv_style_set_x(lv_style_t * style, int32_t value)
 {
     lv_style_value_t v = {
@@ -74,6 +82,7 @@ void lv_style_set_x(lv_style_t * style, int32_t value)
     lv_style_set_prop(style, LV_STYLE_X, v);
 }
 
+LV_FUNC_SECTION
 void lv_style_set_y(lv_style_t * style, int32_t value)
 {
     lv_style_value_t v = {
@@ -82,6 +91,7 @@ void lv_style_set_y(lv_style_t * style, int32_t value)
     lv_style_set_prop(style, LV_STYLE_Y, v);
 }
 
+LV_FUNC_SECTION
 void lv_style_set_align(lv_style_t * style, lv_align_t value)
 {
     lv_style_value_t v = {
@@ -90,6 +100,7 @@ void lv_style_set_align(lv_style_t * style, lv_align_t value)
     lv_style_set_prop(style, LV_STYLE_ALIGN, v);
 }
 
+LV_FUNC_SECTION
 void lv_style_set_transform_width(lv_style_t * style, int32_t value)
 {
     lv_style_value_t v = {
@@ -98,6 +109,7 @@ void lv_style_set_transform_width(lv_style_t * style, int32_t value)
     lv_style_set_prop(style, LV_STYLE_TRANSFORM_WIDTH, v);
 }
 
+LV_FUNC_SECTION
 void lv_style_set_transform_height(lv_style_t * style, int32_t value)
 {
     lv_style_value_t v = {
@@ -106,6 +118,7 @@ void lv_style_set_transform_height(lv_style_t * style, int32_t value)
     lv_style_set_prop(style, LV_STYLE_TRANSFORM_HEIGHT, v);
 }
 
+LV_FUNC_SECTION
 void lv_style_set_translate_x(lv_style_t * style, int32_t value)
 {
     lv_style_value_t v = {
@@ -114,6 +127,7 @@ void lv_style_set_translate_x(lv_style_t * style, int32_t value)
     lv_style_set_prop(style, LV_STYLE_TRANSLATE_X, v);
 }
 
+LV_FUNC_SECTION
 void lv_style_set_translate_y(lv_style_t * style, int32_t value)
 {
     lv_style_value_t v = {
@@ -122,6 +136,7 @@ void lv_style_set_translate_y(lv_style_t * style, int32_t value)
     lv_style_set_prop(style, LV_STYLE_TRANSLATE_Y, v);
 }
 
+LV_FUNC_SECTION
 void lv_style_set_transform_scale_x(lv_style_t * style, int32_t value)
 {
     lv_style_value_t v = {
@@ -130,6 +145,7 @@ void lv_style_set_transform_scale_x(lv_style_t * style, int32_t value)
     lv_style_set_prop(style, LV_STYLE_TRANSFORM_SCALE_X, v);
 }
 
+LV_FUNC_SECTION
 void lv_style_set_transform_scale_y(lv_style_t * style, int32_t value)
 {
     lv_style_value_t v = {
@@ -138,6 +154,7 @@ void lv_style_set_transform_scale_y(lv_style_t * style, int32_t value)
     lv_style_set_prop(style, LV_STYLE_TRANSFORM_SCALE_Y, v);
 }
 
+LV_FUNC_SECTION
 void lv_style_set_transform_rotation(lv_style_t * style, int32_t value)
 {
     lv_style_value_t v = {
@@ -146,6 +163,7 @@ void lv_style_set_transform_rotation(lv_style_t * style, int32_t value)
     lv_style_set_prop(style, LV_STYLE_TRANSFORM_ROTATION, v);
 }
 
+LV_FUNC_SECTION
 void lv_style_set_transform_pivot_x(lv_style_t * style, int32_t value)
 {
     lv_style_value_t v = {
@@ -154,6 +172,7 @@ void lv_style_set_transform_pivot_x(lv_style_t * style, int32_t value)
     lv_style_set_prop(style, LV_STYLE_TRANSFORM_PIVOT_X, v);
 }
 
+LV_FUNC_SECTION
 void lv_style_set_transform_pivot_y(lv_style_t * style, int32_t value)
 {
     lv_style_value_t v = {
@@ -162,6 +181,7 @@ void lv_style_set_transform_pivot_y(lv_style_t * style, int32_t value)
     lv_style_set_prop(style, LV_STYLE_TRANSFORM_PIVOT_Y, v);
 }
 
+LV_FUNC_SECTION
 void lv_style_set_transform_skew_x(lv_style_t * style, int32_t value)
 {
     lv_style_value_t v = {
@@ -170,6 +190,7 @@ void lv_style_set_transform_skew_x(lv_style_t * style, int32_t value)
     lv_style_set_prop(style, LV_STYLE_TRANSFORM_SKEW_X, v);
 }
 
+LV_FUNC_SECTION
 void lv_style_set_transform_skew_y(lv_style_t * style, int32_t value)
 {
     lv_style_value_t v = {
@@ -178,6 +199,7 @@ void lv_style_set_transform_skew_y(lv_style_t * style, int32_t value)
     lv_style_set_prop(style, LV_STYLE_TRANSFORM_SKEW_Y, v);
 }
 
+LV_FUNC_SECTION
 void lv_style_set_pad_top(lv_style_t * style, int32_t value)
 {
     lv_style_value_t v = {
@@ -186,6 +208,7 @@ void lv_style_set_pad_top(lv_style_t * style, int32_t value)
     lv_style_set_prop(style, LV_STYLE_PAD_TOP, v);
 }
 
+LV_FUNC_SECTION
 void lv_style_set_pad_bottom(lv_style_t * style, int32_t value)
 {
     lv_style_value_t v = {
@@ -194,6 +217,7 @@ void lv_style_set_pad_bottom(lv_style_t * style, int32_t value)
     lv_style_set_prop(style, LV_STYLE_PAD_BOTTOM, v);
 }
 
+LV_FUNC_SECTION
 void lv_style_set_pad_left(lv_style_t * style, int32_t value)
 {
     lv_style_value_t v = {
@@ -202,6 +226,7 @@ void lv_style_set_pad_left(lv_style_t * style, int32_t value)
     lv_style_set_prop(style, LV_STYLE_PAD_LEFT, v);
 }
 
+LV_FUNC_SECTION
 void lv_style_set_pad_right(lv_style_t * style, int32_t value)
 {
     lv_style_value_t v = {
@@ -210,6 +235,7 @@ void lv_style_set_pad_right(lv_style_t * style, int32_t value)
     lv_style_set_prop(style, LV_STYLE_PAD_RIGHT, v);
 }
 
+LV_FUNC_SECTION
 void lv_style_set_pad_row(lv_style_t * style, int32_t value)
 {
     lv_style_value_t v = {
@@ -218,6 +244,7 @@ void lv_style_set_pad_row(lv_style_t * style, int32_t value)
     lv_style_set_prop(style, LV_STYLE_PAD_ROW, v);
 }
 
+LV_FUNC_SECTION
 void lv_style_set_pad_column(lv_style_t * style, int32_t value)
 {
     lv_style_value_t v = {
@@ -226,6 +253,7 @@ void lv_style_set_pad_column(lv_style_t * style, int32_t value)
     lv_style_set_prop(style, LV_STYLE_PAD_COLUMN, v);
 }
 
+LV_FUNC_SECTION
 void lv_style_set_margin_top(lv_style_t * style, int32_t value)
 {
     lv_style_value_t v = {
@@ -234,6 +262,7 @@ void lv_style_set_margin_top(lv_style_t * style, int32_t value)
     lv_style_set_prop(style, LV_STYLE_MARGIN_TOP, v);
 }
 
+LV_FUNC_SECTION
 void lv_style_set_margin_bottom(lv_style_t * style, int32_t value)
 {
     lv_style_value_t v = {
@@ -242,6 +271,7 @@ void lv_style_set_margin_bottom(lv_style_t * style, int32_t value)
     lv_style_set_prop(style, LV_STYLE_MARGIN_BOTTOM, v);
 }
 
+LV_FUNC_SECTION
 void lv_style_set_margin_left(lv_style_t * style, int32_t value)
 {
     lv_style_value_t v = {
@@ -250,6 +280,7 @@ void lv_style_set_margin_left(lv_style_t * style, int32_t value)
     lv_style_set_prop(style, LV_STYLE_MARGIN_LEFT, v);
 }
 
+LV_FUNC_SECTION
 void lv_style_set_margin_right(lv_style_t * style, int32_t value)
 {
     lv_style_value_t v = {
@@ -258,6 +289,7 @@ void lv_style_set_margin_right(lv_style_t * style, int32_t value)
     lv_style_set_prop(style, LV_STYLE_MARGIN_RIGHT, v);
 }
 
+LV_FUNC_SECTION
 void lv_style_set_bg_color(lv_style_t * style, lv_color_t value)
 {
     lv_style_value_t v = {
@@ -266,6 +298,7 @@ void lv_style_set_bg_color(lv_style_t * style, lv_color_t value)
     lv_style_set_prop(style, LV_STYLE_BG_COLOR, v);
 }
 
+LV_FUNC_SECTION
 void lv_style_set_bg_opa(lv_style_t * style, lv_opa_t value)
 {
     lv_style_value_t v = {
@@ -274,6 +307,7 @@ void lv_style_set_bg_opa(lv_style_t * style, lv_opa_t value)
     lv_style_set_prop(style, LV_STYLE_BG_OPA, v);
 }
 
+LV_FUNC_SECTION
 void lv_style_set_bg_grad_color(lv_style_t * style, lv_color_t value)
 {
     lv_style_value_t v = {
@@ -282,6 +316,7 @@ void lv_style_set_bg_grad_color(lv_style_t * style, lv_color_t value)
     lv_style_set_prop(style, LV_STYLE_BG_GRAD_COLOR, v);
 }
 
+LV_FUNC_SECTION
 void lv_style_set_bg_grad_dir(lv_style_t * style, lv_grad_dir_t value)
 {
     lv_style_value_t v = {
@@ -290,6 +325,7 @@ void lv_style_set_bg_grad_dir(lv_style_t * style, lv_grad_dir_t value)
     lv_style_set_prop(style, LV_STYLE_BG_GRAD_DIR, v);
 }
 
+LV_FUNC_SECTION
 void lv_style_set_bg_main_stop(lv_style_t * style, int32_t value)
 {
     lv_style_value_t v = {
@@ -298,6 +334,7 @@ void lv_style_set_bg_main_stop(lv_style_t * style, int32_t value)
     lv_style_set_prop(style, LV_STYLE_BG_MAIN_STOP, v);
 }
 
+LV_FUNC_SECTION
 void lv_style_set_bg_grad_stop(lv_style_t * style, int32_t value)
 {
     lv_style_value_t v = {
@@ -306,6 +343,7 @@ void lv_style_set_bg_grad_stop(lv_style_t * style, int32_t value)
     lv_style_set_prop(style, LV_STYLE_BG_GRAD_STOP, v);
 }
 
+LV_FUNC_SECTION
 void lv_style_set_bg_main_opa(lv_style_t * style, lv_opa_t value)
 {
     lv_style_value_t v = {
@@ -314,6 +352,7 @@ void lv_style_set_bg_main_opa(lv_style_t * style, lv_opa_t value)
     lv_style_set_prop(style, LV_STYLE_BG_MAIN_OPA, v);
 }
 
+LV_FUNC_SECTION
 void lv_style_set_bg_grad_opa(lv_style_t * style, lv_opa_t value)
 {
     lv_style_value_t v = {
@@ -322,6 +361,7 @@ void lv_style_set_bg_grad_opa(lv_style_t * style, lv_opa_t value)
     lv_style_set_prop(style, LV_STYLE_BG_GRAD_OPA, v);
 }
 
+LV_FUNC_SECTION
 void lv_style_set_bg_grad(lv_style_t * style, const lv_grad_dsc_t * value)
 {
     lv_style_value_t v = {
@@ -330,6 +370,7 @@ void lv_style_set_bg_grad(lv_style_t * style, const lv_grad_dsc_t * value)
     lv_style_set_prop(style, LV_STYLE_BG_GRAD, v);
 }
 
+LV_FUNC_SECTION
 void lv_style_set_bg_image_src(lv_style_t * style, const void * value)
 {
     lv_style_value_t v = {
@@ -338,6 +379,7 @@ void lv_style_set_bg_image_src(lv_style_t * style, const void * value)
     lv_style_set_prop(style, LV_STYLE_BG_IMAGE_SRC, v);
 }
 
+LV_FUNC_SECTION
 void lv_style_set_bg_image_opa(lv_style_t * style, lv_opa_t value)
 {
     lv_style_value_t v = {
@@ -346,6 +388,7 @@ void lv_style_set_bg_image_opa(lv_style_t * style, lv_opa_t value)
     lv_style_set_prop(style, LV_STYLE_BG_IMAGE_OPA, v);
 }
 
+LV_FUNC_SECTION
 void lv_style_set_bg_image_recolor(lv_style_t * style, lv_color_t value)
 {
     lv_style_value_t v = {
@@ -354,6 +397,7 @@ void lv_style_set_bg_image_recolor(lv_style_t * style, lv_color_t value)
     lv_style_set_prop(style, LV_STYLE_BG_IMAGE_RECOLOR, v);
 }
 
+LV_FUNC_SECTION
 void lv_style_set_bg_image_recolor_opa(lv_style_t * style, lv_opa_t value)
 {
     lv_style_value_t v = {
@@ -362,6 +406,7 @@ void lv_style_set_bg_image_recolor_opa(lv_style_t * style, lv_opa_t value)
     lv_style_set_prop(style, LV_STYLE_BG_IMAGE_RECOLOR_OPA, v);
 }
 
+LV_FUNC_SECTION
 void lv_style_set_bg_image_tiled(lv_style_t * style, bool value)
 {
     lv_style_value_t v = {
@@ -370,6 +415,7 @@ void lv_style_set_bg_image_tiled(lv_style_t * style, bool value)
     lv_style_set_prop(style, LV_STYLE_BG_IMAGE_TILED, v);
 }
 
+LV_FUNC_SECTION
 void lv_style_set_border_color(lv_style_t * style, lv_color_t value)
 {
     lv_style_value_t v = {
@@ -378,6 +424,7 @@ void lv_style_set_border_color(lv_style_t * style, lv_color_t value)
     lv_style_set_prop(style, LV_STYLE_BORDER_COLOR, v);
 }
 
+LV_FUNC_SECTION
 void lv_style_set_border_opa(lv_style_t * style, lv_opa_t value)
 {
     lv_style_value_t v = {
@@ -386,6 +433,7 @@ void lv_style_set_border_opa(lv_style_t * style, lv_opa_t value)
     lv_style_set_prop(style, LV_STYLE_BORDER_OPA, v);
 }
 
+LV_FUNC_SECTION
 void lv_style_set_border_width(lv_style_t * style, int32_t value)
 {
     lv_style_value_t v = {
@@ -394,6 +442,7 @@ void lv_style_set_border_width(lv_style_t * style, int32_t value)
     lv_style_set_prop(style, LV_STYLE_BORDER_WIDTH, v);
 }
 
+LV_FUNC_SECTION
 void lv_style_set_border_side(lv_style_t * style, lv_border_side_t value)
 {
     lv_style_value_t v = {
@@ -402,6 +451,7 @@ void lv_style_set_border_side(lv_style_t * style, lv_border_side_t value)
     lv_style_set_prop(style, LV_STYLE_BORDER_SIDE, v);
 }
 
+LV_FUNC_SECTION
 void lv_style_set_border_post(lv_style_t * style, bool value)
 {
     lv_style_value_t v = {
@@ -410,6 +460,7 @@ void lv_style_set_border_post(lv_style_t * style, bool value)
     lv_style_set_prop(style, LV_STYLE_BORDER_POST, v);
 }
 
+LV_FUNC_SECTION
 void lv_style_set_outline_width(lv_style_t * style, int32_t value)
 {
     lv_style_value_t v = {
@@ -418,6 +469,7 @@ void lv_style_set_outline_width(lv_style_t * style, int32_t value)
     lv_style_set_prop(style, LV_STYLE_OUTLINE_WIDTH, v);
 }
 
+LV_FUNC_SECTION
 void lv_style_set_outline_color(lv_style_t * style, lv_color_t value)
 {
     lv_style_value_t v = {
@@ -426,6 +478,7 @@ void lv_style_set_outline_color(lv_style_t * style, lv_color_t value)
     lv_style_set_prop(style, LV_STYLE_OUTLINE_COLOR, v);
 }
 
+LV_FUNC_SECTION
 void lv_style_set_outline_opa(lv_style_t * style, lv_opa_t value)
 {
     lv_style_value_t v = {
@@ -434,6 +487,7 @@ void lv_style_set_outline_opa(lv_style_t * style, lv_opa_t value)
     lv_style_set_prop(style, LV_STYLE_OUTLINE_OPA, v);
 }
 
+LV_FUNC_SECTION
 void lv_style_set_outline_pad(lv_style_t * style, int32_t value)
 {
     lv_style_value_t v = {
@@ -442,6 +496,7 @@ void lv_style_set_outline_pad(lv_style_t * style, int32_t value)
     lv_style_set_prop(style, LV_STYLE_OUTLINE_PAD, v);
 }
 
+LV_FUNC_SECTION
 void lv_style_set_shadow_width(lv_style_t * style, int32_t value)
 {
     lv_style_value_t v = {
@@ -450,6 +505,7 @@ void lv_style_set_shadow_width(lv_style_t * style, int32_t value)
     lv_style_set_prop(style, LV_STYLE_SHADOW_WIDTH, v);
 }
 
+LV_FUNC_SECTION
 void lv_style_set_shadow_offset_x(lv_style_t * style, int32_t value)
 {
     lv_style_value_t v = {
@@ -458,6 +514,7 @@ void lv_style_set_shadow_offset_x(lv_style_t * style, int32_t value)
     lv_style_set_prop(style, LV_STYLE_SHADOW_OFFSET_X, v);
 }
 
+LV_FUNC_SECTION
 void lv_style_set_shadow_offset_y(lv_style_t * style, int32_t value)
 {
     lv_style_value_t v = {
@@ -466,6 +523,7 @@ void lv_style_set_shadow_offset_y(lv_style_t * style, int32_t value)
     lv_style_set_prop(style, LV_STYLE_SHADOW_OFFSET_Y, v);
 }
 
+LV_FUNC_SECTION
 void lv_style_set_shadow_spread(lv_style_t * style, int32_t value)
 {
     lv_style_value_t v = {
@@ -474,6 +532,7 @@ void lv_style_set_shadow_spread(lv_style_t * style, int32_t value)
     lv_style_set_prop(style, LV_STYLE_SHADOW_SPREAD, v);
 }
 
+LV_FUNC_SECTION
 void lv_style_set_shadow_color(lv_style_t * style, lv_color_t value)
 {
     lv_style_value_t v = {
@@ -482,6 +541,7 @@ void lv_style_set_shadow_color(lv_style_t * style, lv_color_t value)
     lv_style_set_prop(style, LV_STYLE_SHADOW_COLOR, v);
 }
 
+LV_FUNC_SECTION
 void lv_style_set_shadow_opa(lv_style_t * style, lv_opa_t value)
 {
     lv_style_value_t v = {
@@ -490,6 +550,7 @@ void lv_style_set_shadow_opa(lv_style_t * style, lv_opa_t value)
     lv_style_set_prop(style, LV_STYLE_SHADOW_OPA, v);
 }
 
+LV_FUNC_SECTION
 void lv_style_set_image_opa(lv_style_t * style, lv_opa_t value)
 {
     lv_style_value_t v = {
@@ -498,6 +559,7 @@ void lv_style_set_image_opa(lv_style_t * style, lv_opa_t value)
     lv_style_set_prop(style, LV_STYLE_IMAGE_OPA, v);
 }
 
+LV_FUNC_SECTION
 void lv_style_set_image_recolor(lv_style_t * style, lv_color_t value)
 {
     lv_style_value_t v = {
@@ -506,6 +568,7 @@ void lv_style_set_image_recolor(lv_style_t * style, lv_color_t value)
     lv_style_set_prop(style, LV_STYLE_IMAGE_RECOLOR, v);
 }
 
+LV_FUNC_SECTION
 void lv_style_set_image_recolor_opa(lv_style_t * style, lv_opa_t value)
 {
     lv_style_value_t v = {
@@ -514,6 +577,7 @@ void lv_style_set_image_recolor_opa(lv_style_t * style, lv_opa_t value)
     lv_style_set_prop(style, LV_STYLE_IMAGE_RECOLOR_OPA, v);
 }
 
+LV_FUNC_SECTION
 void lv_style_set_line_width(lv_style_t * style, int32_t value)
 {
     lv_style_value_t v = {
@@ -522,6 +586,7 @@ void lv_style_set_line_width(lv_style_t * style, int32_t value)
     lv_style_set_prop(style, LV_STYLE_LINE_WIDTH, v);
 }
 
+LV_FUNC_SECTION
 void lv_style_set_line_dash_width(lv_style_t * style, int32_t value)
 {
     lv_style_value_t v = {
@@ -530,6 +595,7 @@ void lv_style_set_line_dash_width(lv_style_t * style, int32_t value)
     lv_style_set_prop(style, LV_STYLE_LINE_DASH_WIDTH, v);
 }
 
+LV_FUNC_SECTION
 void lv_style_set_line_dash_gap(lv_style_t * style, int32_t value)
 {
     lv_style_value_t v = {
@@ -538,6 +604,7 @@ void lv_style_set_line_dash_gap(lv_style_t * style, int32_t value)
     lv_style_set_prop(style, LV_STYLE_LINE_DASH_GAP, v);
 }
 
+LV_FUNC_SECTION
 void lv_style_set_line_rounded(lv_style_t * style, bool value)
 {
     lv_style_value_t v = {
@@ -546,6 +613,7 @@ void lv_style_set_line_rounded(lv_style_t * style, bool value)
     lv_style_set_prop(style, LV_STYLE_LINE_ROUNDED, v);
 }
 
+LV_FUNC_SECTION
 void lv_style_set_line_color(lv_style_t * style, lv_color_t value)
 {
     lv_style_value_t v = {
@@ -554,6 +622,7 @@ void lv_style_set_line_color(lv_style_t * style, lv_color_t value)
     lv_style_set_prop(style, LV_STYLE_LINE_COLOR, v);
 }
 
+LV_FUNC_SECTION
 void lv_style_set_line_opa(lv_style_t * style, lv_opa_t value)
 {
     lv_style_value_t v = {
@@ -562,6 +631,7 @@ void lv_style_set_line_opa(lv_style_t * style, lv_opa_t value)
     lv_style_set_prop(style, LV_STYLE_LINE_OPA, v);
 }
 
+LV_FUNC_SECTION
 void lv_style_set_arc_width(lv_style_t * style, int32_t value)
 {
     lv_style_value_t v = {
@@ -570,6 +640,7 @@ void lv_style_set_arc_width(lv_style_t * style, int32_t value)
     lv_style_set_prop(style, LV_STYLE_ARC_WIDTH, v);
 }
 
+LV_FUNC_SECTION
 void lv_style_set_arc_rounded(lv_style_t * style, bool value)
 {
     lv_style_value_t v = {
@@ -578,6 +649,7 @@ void lv_style_set_arc_rounded(lv_style_t * style, bool value)
     lv_style_set_prop(style, LV_STYLE_ARC_ROUNDED, v);
 }
 
+LV_FUNC_SECTION
 void lv_style_set_arc_color(lv_style_t * style, lv_color_t value)
 {
     lv_style_value_t v = {
@@ -586,6 +658,7 @@ void lv_style_set_arc_color(lv_style_t * style, lv_color_t value)
     lv_style_set_prop(style, LV_STYLE_ARC_COLOR, v);
 }
 
+LV_FUNC_SECTION
 void lv_style_set_arc_opa(lv_style_t * style, lv_opa_t value)
 {
     lv_style_value_t v = {
@@ -594,6 +667,7 @@ void lv_style_set_arc_opa(lv_style_t * style, lv_opa_t value)
     lv_style_set_prop(style, LV_STYLE_ARC_OPA, v);
 }
 
+LV_FUNC_SECTION
 void lv_style_set_arc_image_src(lv_style_t * style, const void * value)
 {
     lv_style_value_t v = {
@@ -602,6 +676,7 @@ void lv_style_set_arc_image_src(lv_style_t * style, const void * value)
     lv_style_set_prop(style, LV_STYLE_ARC_IMAGE_SRC, v);
 }
 
+LV_FUNC_SECTION
 void lv_style_set_text_color(lv_style_t * style, lv_color_t value)
 {
     lv_style_value_t v = {
@@ -610,6 +685,7 @@ void lv_style_set_text_color(lv_style_t * style, lv_color_t value)
     lv_style_set_prop(style, LV_STYLE_TEXT_COLOR, v);
 }
 
+LV_FUNC_SECTION
 void lv_style_set_text_opa(lv_style_t * style, lv_opa_t value)
 {
     lv_style_value_t v = {
@@ -618,6 +694,7 @@ void lv_style_set_text_opa(lv_style_t * style, lv_opa_t value)
     lv_style_set_prop(style, LV_STYLE_TEXT_OPA, v);
 }
 
+LV_FUNC_SECTION
 void lv_style_set_text_font(lv_style_t * style, const lv_font_t * value)
 {
     lv_style_value_t v = {
@@ -626,6 +703,7 @@ void lv_style_set_text_font(lv_style_t * style, const lv_font_t * value)
     lv_style_set_prop(style, LV_STYLE_TEXT_FONT, v);
 }
 
+LV_FUNC_SECTION
 void lv_style_set_text_letter_space(lv_style_t * style, int32_t value)
 {
     lv_style_value_t v = {
@@ -634,6 +712,7 @@ void lv_style_set_text_letter_space(lv_style_t * style, int32_t value)
     lv_style_set_prop(style, LV_STYLE_TEXT_LETTER_SPACE, v);
 }
 
+LV_FUNC_SECTION
 void lv_style_set_text_line_space(lv_style_t * style, int32_t value)
 {
     lv_style_value_t v = {
@@ -642,6 +721,7 @@ void lv_style_set_text_line_space(lv_style_t * style, int32_t value)
     lv_style_set_prop(style, LV_STYLE_TEXT_LINE_SPACE, v);
 }
 
+LV_FUNC_SECTION
 void lv_style_set_text_decor(lv_style_t * style, lv_text_decor_t value)
 {
     lv_style_value_t v = {
@@ -650,6 +730,7 @@ void lv_style_set_text_decor(lv_style_t * style, lv_text_decor_t value)
     lv_style_set_prop(style, LV_STYLE_TEXT_DECOR, v);
 }
 
+LV_FUNC_SECTION
 void lv_style_set_text_align(lv_style_t * style, lv_text_align_t value)
 {
     lv_style_value_t v = {
@@ -658,6 +739,7 @@ void lv_style_set_text_align(lv_style_t * style, lv_text_align_t value)
     lv_style_set_prop(style, LV_STYLE_TEXT_ALIGN, v);
 }
 
+LV_FUNC_SECTION
 void lv_style_set_radius(lv_style_t * style, int32_t value)
 {
     lv_style_value_t v = {
@@ -666,6 +748,7 @@ void lv_style_set_radius(lv_style_t * style, int32_t value)
     lv_style_set_prop(style, LV_STYLE_RADIUS, v);
 }
 
+LV_FUNC_SECTION
 void lv_style_set_clip_corner(lv_style_t * style, bool value)
 {
     lv_style_value_t v = {
@@ -674,6 +757,7 @@ void lv_style_set_clip_corner(lv_style_t * style, bool value)
     lv_style_set_prop(style, LV_STYLE_CLIP_CORNER, v);
 }
 
+LV_FUNC_SECTION
 void lv_style_set_opa(lv_style_t * style, lv_opa_t value)
 {
     lv_style_value_t v = {
@@ -682,6 +766,7 @@ void lv_style_set_opa(lv_style_t * style, lv_opa_t value)
     lv_style_set_prop(style, LV_STYLE_OPA, v);
 }
 
+LV_FUNC_SECTION
 void lv_style_set_opa_layered(lv_style_t * style, lv_opa_t value)
 {
     lv_style_value_t v = {
@@ -690,6 +775,7 @@ void lv_style_set_opa_layered(lv_style_t * style, lv_opa_t value)
     lv_style_set_prop(style, LV_STYLE_OPA_LAYERED, v);
 }
 
+LV_FUNC_SECTION
 void lv_style_set_color_filter_dsc(lv_style_t * style, const lv_color_filter_dsc_t * value)
 {
     lv_style_value_t v = {
@@ -698,6 +784,7 @@ void lv_style_set_color_filter_dsc(lv_style_t * style, const lv_color_filter_dsc
     lv_style_set_prop(style, LV_STYLE_COLOR_FILTER_DSC, v);
 }
 
+LV_FUNC_SECTION
 void lv_style_set_color_filter_opa(lv_style_t * style, lv_opa_t value)
 {
     lv_style_value_t v = {
@@ -706,6 +793,7 @@ void lv_style_set_color_filter_opa(lv_style_t * style, lv_opa_t value)
     lv_style_set_prop(style, LV_STYLE_COLOR_FILTER_OPA, v);
 }
 
+LV_FUNC_SECTION
 void lv_style_set_anim(lv_style_t * style, const lv_anim_t * value)
 {
     lv_style_value_t v = {
@@ -714,6 +802,7 @@ void lv_style_set_anim(lv_style_t * style, const lv_anim_t * value)
     lv_style_set_prop(style, LV_STYLE_ANIM, v);
 }
 
+LV_FUNC_SECTION
 void lv_style_set_anim_duration(lv_style_t * style, uint32_t value)
 {
     lv_style_value_t v = {
@@ -722,6 +811,7 @@ void lv_style_set_anim_duration(lv_style_t * style, uint32_t value)
     lv_style_set_prop(style, LV_STYLE_ANIM_DURATION, v);
 }
 
+LV_FUNC_SECTION
 void lv_style_set_transition(lv_style_t * style, const lv_style_transition_dsc_t * value)
 {
     lv_style_value_t v = {
@@ -730,6 +820,7 @@ void lv_style_set_transition(lv_style_t * style, const lv_style_transition_dsc_t
     lv_style_set_prop(style, LV_STYLE_TRANSITION, v);
 }
 
+LV_FUNC_SECTION
 void lv_style_set_blend_mode(lv_style_t * style, lv_blend_mode_t value)
 {
     lv_style_value_t v = {
@@ -738,6 +829,7 @@ void lv_style_set_blend_mode(lv_style_t * style, lv_blend_mode_t value)
     lv_style_set_prop(style, LV_STYLE_BLEND_MODE, v);
 }
 
+LV_FUNC_SECTION
 void lv_style_set_layout(lv_style_t * style, uint16_t value)
 {
     lv_style_value_t v = {
@@ -746,6 +838,7 @@ void lv_style_set_layout(lv_style_t * style, uint16_t value)
     lv_style_set_prop(style, LV_STYLE_LAYOUT, v);
 }
 
+LV_FUNC_SECTION
 void lv_style_set_base_dir(lv_style_t * style, lv_base_dir_t value)
 {
     lv_style_value_t v = {
@@ -754,6 +847,7 @@ void lv_style_set_base_dir(lv_style_t * style, lv_base_dir_t value)
     lv_style_set_prop(style, LV_STYLE_BASE_DIR, v);
 }
 
+LV_FUNC_SECTION
 void lv_style_set_bitmap_mask_src(lv_style_t * style, const void * value)
 {
     lv_style_value_t v = {
@@ -762,6 +856,7 @@ void lv_style_set_bitmap_mask_src(lv_style_t * style, const void * value)
     lv_style_set_prop(style, LV_STYLE_BITMAP_MASK_SRC, v);
 }
 
+LV_FUNC_SECTION
 void lv_style_set_rotary_sensitivity(lv_style_t * style, uint32_t value)
 {
     lv_style_value_t v = {
@@ -771,6 +866,7 @@ void lv_style_set_rotary_sensitivity(lv_style_t * style, uint32_t value)
 }
 #if LV_USE_FLEX
 
+LV_FUNC_SECTION
 void lv_style_set_flex_flow(lv_style_t * style, lv_flex_flow_t value)
 {
     lv_style_value_t v = {
@@ -779,6 +875,7 @@ void lv_style_set_flex_flow(lv_style_t * style, lv_flex_flow_t value)
     lv_style_set_prop(style, LV_STYLE_FLEX_FLOW, v);
 }
 
+LV_FUNC_SECTION
 void lv_style_set_flex_main_place(lv_style_t * style, lv_flex_align_t value)
 {
     lv_style_value_t v = {
@@ -787,6 +884,7 @@ void lv_style_set_flex_main_place(lv_style_t * style, lv_flex_align_t value)
     lv_style_set_prop(style, LV_STYLE_FLEX_MAIN_PLACE, v);
 }
 
+LV_FUNC_SECTION
 void lv_style_set_flex_cross_place(lv_style_t * style, lv_flex_align_t value)
 {
     lv_style_value_t v = {
@@ -795,6 +893,7 @@ void lv_style_set_flex_cross_place(lv_style_t * style, lv_flex_align_t value)
     lv_style_set_prop(style, LV_STYLE_FLEX_CROSS_PLACE, v);
 }
 
+LV_FUNC_SECTION
 void lv_style_set_flex_track_place(lv_style_t * style, lv_flex_align_t value)
 {
     lv_style_value_t v = {
@@ -803,6 +902,7 @@ void lv_style_set_flex_track_place(lv_style_t * style, lv_flex_align_t value)
     lv_style_set_prop(style, LV_STYLE_FLEX_TRACK_PLACE, v);
 }
 
+LV_FUNC_SECTION
 void lv_style_set_flex_grow(lv_style_t * style, uint8_t value)
 {
     lv_style_value_t v = {
@@ -814,6 +914,7 @@ void lv_style_set_flex_grow(lv_style_t * style, uint8_t value)
 
 #if LV_USE_GRID
 
+LV_FUNC_SECTION
 void lv_style_set_grid_column_dsc_array(lv_style_t * style, const int32_t * value)
 {
     lv_style_value_t v = {
@@ -822,6 +923,7 @@ void lv_style_set_grid_column_dsc_array(lv_style_t * style, const int32_t * valu
     lv_style_set_prop(style, LV_STYLE_GRID_COLUMN_DSC_ARRAY, v);
 }
 
+LV_FUNC_SECTION
 void lv_style_set_grid_column_align(lv_style_t * style, lv_grid_align_t value)
 {
     lv_style_value_t v = {
@@ -830,6 +932,7 @@ void lv_style_set_grid_column_align(lv_style_t * style, lv_grid_align_t value)
     lv_style_set_prop(style, LV_STYLE_GRID_COLUMN_ALIGN, v);
 }
 
+LV_FUNC_SECTION
 void lv_style_set_grid_row_dsc_array(lv_style_t * style, const int32_t * value)
 {
     lv_style_value_t v = {
@@ -838,6 +941,7 @@ void lv_style_set_grid_row_dsc_array(lv_style_t * style, const int32_t * value)
     lv_style_set_prop(style, LV_STYLE_GRID_ROW_DSC_ARRAY, v);
 }
 
+LV_FUNC_SECTION
 void lv_style_set_grid_row_align(lv_style_t * style, lv_grid_align_t value)
 {
     lv_style_value_t v = {
@@ -846,6 +950,7 @@ void lv_style_set_grid_row_align(lv_style_t * style, lv_grid_align_t value)
     lv_style_set_prop(style, LV_STYLE_GRID_ROW_ALIGN, v);
 }
 
+LV_FUNC_SECTION
 void lv_style_set_grid_cell_column_pos(lv_style_t * style, int32_t value)
 {
     lv_style_value_t v = {
@@ -854,6 +959,7 @@ void lv_style_set_grid_cell_column_pos(lv_style_t * style, int32_t value)
     lv_style_set_prop(style, LV_STYLE_GRID_CELL_COLUMN_POS, v);
 }
 
+LV_FUNC_SECTION
 void lv_style_set_grid_cell_x_align(lv_style_t * style, lv_grid_align_t value)
 {
     lv_style_value_t v = {
@@ -862,6 +968,7 @@ void lv_style_set_grid_cell_x_align(lv_style_t * style, lv_grid_align_t value)
     lv_style_set_prop(style, LV_STYLE_GRID_CELL_X_ALIGN, v);
 }
 
+LV_FUNC_SECTION
 void lv_style_set_grid_cell_column_span(lv_style_t * style, int32_t value)
 {
     lv_style_value_t v = {
@@ -870,6 +977,7 @@ void lv_style_set_grid_cell_column_span(lv_style_t * style, int32_t value)
     lv_style_set_prop(style, LV_STYLE_GRID_CELL_COLUMN_SPAN, v);
 }
 
+LV_FUNC_SECTION
 void lv_style_set_grid_cell_row_pos(lv_style_t * style, int32_t value)
 {
     lv_style_value_t v = {
@@ -878,6 +986,7 @@ void lv_style_set_grid_cell_row_pos(lv_style_t * style, int32_t value)
     lv_style_set_prop(style, LV_STYLE_GRID_CELL_ROW_POS, v);
 }
 
+LV_FUNC_SECTION
 void lv_style_set_grid_cell_y_align(lv_style_t * style, lv_grid_align_t value)
 {
     lv_style_value_t v = {
@@ -886,6 +995,7 @@ void lv_style_set_grid_cell_y_align(lv_style_t * style, lv_grid_align_t value)
     lv_style_set_prop(style, LV_STYLE_GRID_CELL_Y_ALIGN, v);
 }
 
+LV_FUNC_SECTION
 void lv_style_set_grid_cell_row_span(lv_style_t * style, int32_t value)
 {
     lv_style_value_t v = {
diff --git a/src/misc/lv_text.c b/src/misc/lv_text.c
index 11081f959..1c4177e2d 100644
--- a/src/misc/lv_text.c
+++ b/src/misc/lv_text.c
@@ -89,6 +89,7 @@
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 void lv_text_get_size(lv_point_t * size_res, const char * text, const lv_font_t * font, int32_t letter_space,
                       int32_t line_space, int32_t max_width, lv_text_flag_t flag)
 {
@@ -166,6 +167,7 @@ void lv_text_get_size(lv_point_t * size_res, const char * text, const lv_font_t
  * @param[out] word_w_ptr width (in pixels) of the parsed word. May be NULL.
  * @return the index of the first char of the next word (in byte index not letter index. With UTF-8 they are different)
  */
+LV_FUNC_SECTION
 static uint32_t lv_text_get_next_word(const char * txt, const lv_font_t * font,
                                       int32_t letter_space, int32_t max_width,
                                       lv_text_flag_t flag, uint32_t * word_w_ptr)
@@ -272,6 +274,7 @@ static uint32_t lv_text_get_next_word(const char * txt, const lv_font_t * font,
 #endif
 }
 
+LV_FUNC_SECTION
 uint32_t lv_text_get_next_line(const char * txt, const lv_font_t * font,
                                int32_t letter_space, int32_t max_width,
                                int32_t * used_width, lv_text_flag_t flag)
@@ -338,6 +341,7 @@ uint32_t lv_text_get_next_line(const char * txt, const lv_font_t * font,
     return i;
 }
 
+LV_FUNC_SECTION
 int32_t lv_text_get_width(const char * txt, uint32_t length, const lv_font_t * font, int32_t letter_space)
 {
     if(txt == NULL) return 0;
@@ -369,6 +373,7 @@ int32_t lv_text_get_width(const char * txt, uint32_t length, const lv_font_t * f
     return width;
 }
 
+LV_FUNC_SECTION
 void lv_text_ins(char * txt_buf, uint32_t pos, const char * ins_txt)
 {
     if(txt_buf == NULL || ins_txt == NULL) return;
@@ -390,6 +395,7 @@ void lv_text_ins(char * txt_buf, uint32_t pos, const char * ins_txt)
     lv_memcpy(txt_buf + pos, ins_txt, ins_len);
 }
 
+LV_FUNC_SECTION
 void lv_text_cut(char * txt, uint32_t pos, uint32_t len)
 {
     if(txt == NULL) return;
@@ -406,6 +412,7 @@ void lv_text_cut(char * txt, uint32_t pos, uint32_t len)
     }
 }
 
+LV_FUNC_SECTION
 char * lv_text_set_text_vfmt(const char * fmt, va_list ap)
 {
     /*Allocate space for the new text by using trick from C99 standard section 7.19.6.12*/
@@ -448,6 +455,7 @@ char * lv_text_set_text_vfmt(const char * fmt, va_list ap)
     return text;
 }
 
+LV_FUNC_SECTION
 void lv_text_encoded_letter_next_2(const char * txt, uint32_t * letter, uint32_t * letter_next, uint32_t * ofs)
 {
     *letter = lv_text_encoded_next(txt, ofs);
@@ -464,6 +472,7 @@ void lv_text_encoded_letter_next_2(const char * txt, uint32_t * letter, uint32_t
  * @param str pointer to a character in a string
  * @return length of the UTF-8 character (1,2,3 or 4), 0 on invalid code.
  */
+__attribute__(( fptrgroup("lv_text_encoded_size_cb") ))
 static uint8_t lv_text_utf8_size(const char * str)
 {
     if(LV_IS_ASCII(str[0]))
@@ -482,6 +491,7 @@ static uint8_t lv_text_utf8_size(const char * str)
  * @param letter_uni a Unicode letter
  * @return UTF-8 coded character in Little Endian to be compatible with C chars (e.g. 'Á', 'Ű')
  */
+__attribute__(( fptrgroup("lv_text_unicode_to_encoded") ))
 static uint32_t lv_text_unicode_to_utf8(uint32_t letter_uni)
 {
     if(letter_uni < 128) return letter_uni;
@@ -518,6 +528,7 @@ static uint32_t lv_text_unicode_to_utf8(uint32_t letter_uni)
  * @param c a wide character or a  Little endian number
  * @return `c` in big endian
  */
+__attribute__(( fptrgroup("lv_text_encoded_conv_wc") ))
 static uint32_t lv_text_utf8_conv_wc(uint32_t c)
 {
 #if LV_BIG_ENDIAN_SYSTEM == 0
@@ -546,6 +557,7 @@ static uint32_t lv_text_utf8_conv_wc(uint32_t c)
  *          NULL to use txt[0] as index
  * @return the decoded Unicode character or 0 on invalid UTF-8 code
  */
+__attribute__(( fptrgroup("lv_text_encoded_next") ))
 static uint32_t lv_text_utf8_next(const char * txt, uint32_t * i)
 {
     /**
@@ -621,6 +633,7 @@ static uint32_t lv_text_utf8_next(const char * txt, uint32_t * i)
  * UTF-8 char in 'txt'.
  * @return the decoded Unicode character or 0 on invalid UTF-8 code
  */
+__attribute__(( fptrgroup("lv_text_encoded_prev") ))
 static uint32_t lv_text_utf8_prev(const char * txt, uint32_t * i)
 {
     uint8_t c_size;
@@ -654,6 +667,7 @@ static uint32_t lv_text_utf8_prev(const char * txt, uint32_t * i)
  * @param utf8_id character index
  * @return byte index of the 'utf8_id'th letter
  */
+__attribute__(( fptrgroup("lv_text_encoded_get_byte_id") ))
 static uint32_t lv_text_utf8_get_byte_id(const char * txt, uint32_t utf8_id)
 {
     uint32_t i;
@@ -674,6 +688,7 @@ static uint32_t lv_text_utf8_get_byte_id(const char * txt, uint32_t utf8_id)
  * @param byte_id byte index
  * @return character index of the letter at 'byte_id'th position
  */
+__attribute__(( fptrgroup("lv_text_encoded_get_char_id") ))
 static uint32_t lv_text_utf8_get_char_id(const char * txt, uint32_t byte_id)
 {
     uint32_t i        = 0;
@@ -693,6 +708,7 @@ static uint32_t lv_text_utf8_get_char_id(const char * txt, uint32_t byte_id)
  * @param txt a '\0' terminated char string
  * @return number of characters
  */
+__attribute__(( fptrgroup("lv_text_get_encoded_length") ))
 static uint32_t lv_text_utf8_get_length(const char * txt)
 {
     uint32_t len = 0;
@@ -716,6 +732,7 @@ static uint32_t lv_text_utf8_get_length(const char * txt)
  * @param str pointer to a character in a string
  * @return length of the ISO8859-1 coded character, will be always 1.
  */
+__attribute__(( fptrgroup("lv_text_encoded_size") ))
 static uint8_t lv_text_iso8859_1_size(const char * str)
 {
     LV_UNUSED(str); /*Unused*/
@@ -727,6 +744,7 @@ static uint8_t lv_text_iso8859_1_size(const char * str)
  * @param letter_uni a Unicode letter
  * @return ISO8859-1 coded character in Little Endian to be compatible with C chars (e.g. 'Á', 'Ű')
  */
+__attribute__(( fptrgroup("lv_text_unicode_to_encoded") ))
 static uint32_t lv_text_unicode_to_iso8859_1(uint32_t letter_uni)
 {
     if(letter_uni < 256)
@@ -741,6 +759,7 @@ static uint32_t lv_text_unicode_to_iso8859_1(uint32_t letter_uni)
  * @param c a character, e.g. 'A'
  * @return same as `c`
  */
+__attribute__(( fptrgroup("lv_text_encoded_conv_wc") ))
 static uint32_t lv_text_iso8859_1_conv_wc(uint32_t c)
 {
     return c;
@@ -754,6 +773,7 @@ static uint32_t lv_text_iso8859_1_conv_wc(uint32_t c)
  *          NULL to use txt[0] as index
  * @return the decoded ISO8859-1 character.
  */
+__attribute__(( fptrgroup("lv_text_encoded_next") ))
 static uint32_t lv_text_iso8859_1_next(const char * txt, uint32_t * i)
 {
     if(i == NULL) return txt[0]; /*Get the next char*/
@@ -769,6 +789,7 @@ static uint32_t lv_text_iso8859_1_next(const char * txt, uint32_t * i)
  * @param i start byte index in 'txt' where to start. After the call it will point to the previous ISO8859-1 coded char in 'txt'.
  * @return the decoded ISO8859-1 character.
  */
+__attribute__(( fptrgroup("lv_text_encoded_prev") ))
 static uint32_t lv_text_iso8859_1_prev(const char * txt, uint32_t * i)
 {
     if(i == NULL) return *(txt - 1); /*Get the prev. char*/
@@ -786,6 +807,7 @@ static uint32_t lv_text_iso8859_1_prev(const char * txt, uint32_t * i)
  * @param utf8_id character index
  * @return byte index of the 'utf8_id'th letter
  */
+__attribute__(( fptrgroup("lv_text_encoded_get_byte_id") ))
 static uint32_t lv_text_iso8859_1_get_byte_id(const char * txt, uint32_t utf8_id)
 {
     LV_UNUSED(txt); /*Unused*/
@@ -799,6 +821,7 @@ static uint32_t lv_text_iso8859_1_get_byte_id(const char * txt, uint32_t utf8_id
  * @param byte_id byte index
  * @return character index of the letter at 'byte_id'th position
  */
+__attribute__(( fptrgroup("lv_text_encoded_get_char_id") ))
 static uint32_t lv_text_iso8859_1_get_char_id(const char * txt, uint32_t byte_id)
 {
     LV_UNUSED(txt); /*Unused*/
@@ -811,6 +834,7 @@ static uint32_t lv_text_iso8859_1_get_char_id(const char * txt, uint32_t byte_id
  * @param txt a '\0' terminated char string
  * @return number of characters
  */
+__attribute__(( fptrgroup("lv_text_get_encoded_length") ))
 static uint32_t lv_text_iso8859_1_get_length(const char * txt)
 {
     return lv_strlen(txt);
diff --git a/src/misc/lv_text_ap.c b/src/misc/lv_text_ap.c
index 320debd0f..92482ce47 100644
--- a/src/misc/lv_text_ap.c
+++ b/src/misc/lv_text_ap.c
@@ -106,6 +106,7 @@ const ap_chars_map_t ap_chars_map[] = {
 /**********************
 *   GLOBAL FUNCTIONS
 **********************/
+LV_FUNC_SECTION
 uint32_t lv_text_ap_calc_bytes_count(const char * txt)
 {
     uint32_t txt_length = 0;
@@ -140,6 +141,7 @@ uint32_t lv_text_ap_calc_bytes_count(const char * txt)
     return chars_cnt + 1;
 }
 
+LV_FUNC_SECTION
 void lv_text_ap_proc(const char * txt, char * txt_out)
 {
     uint32_t txt_length = 0;
@@ -253,6 +255,7 @@ void lv_text_ap_proc(const char * txt, char * txt_out)
 *   STATIC FUNCTIONS
 **********************/
 
+LV_FUNC_SECTION
 static uint32_t lv_ap_get_char_index(uint16_t c)
 {
     for(uint8_t i = 0; ap_chars_map[i].char_end_form; i++) {
@@ -268,6 +271,7 @@ static uint32_t lv_ap_get_char_index(uint16_t c)
     return LV_UNDEF_ARABIC_PERSIAN_CHARS;
 }
 
+LV_FUNC_SECTION
 static uint32_t lv_text_lam_alef(uint32_t ch_curr, uint32_t ch_next)
 {
     uint32_t ch_code = 0;
@@ -293,6 +297,7 @@ static uint32_t lv_text_lam_alef(uint32_t ch_curr, uint32_t ch_next)
     return 0;
 }
 
+LV_FUNC_SECTION
 static bool lv_text_is_arabic_vowel(uint16_t c)
 {
     return (c >= 0x064B) && (c <= 0x0652);
diff --git a/src/misc/lv_text_private.h b/src/misc/lv_text_private.h
index 858f59383..5f72f1096 100644
--- a/src/misc/lv_text_private.h
+++ b/src/misc/lv_text_private.h
@@ -199,6 +199,7 @@ static inline bool lv_text_is_marker(uint32_t letter)
  * @param txt  pointer to a character in a string
  * @return length of the encoded character (1,2,3 ...). O in invalid
  */
+__attribute__(( fptrgroup("lv_text_encoded_size") ))
 extern uint8_t (*const lv_text_encoded_size)(const char * txt);
 
 /**
@@ -206,6 +207,7 @@ extern uint8_t (*const lv_text_encoded_size)(const char * txt);
  * @param letter_uni a Unicode letter
  * @return Encoded character in Little Endian to be compatible with C chars (e.g. 'Á', 'Ü')
  */
+__attribute__(( fptrgroup("lv_text_unicode_to_encoded") ))
 extern uint32_t (*const lv_text_unicode_to_encoded)(uint32_t letter_uni);
 
 /**
@@ -213,6 +215,7 @@ extern uint32_t (*const lv_text_unicode_to_encoded)(uint32_t letter_uni);
  * @param c a wide character
  * @return `c` in the encoded format
  */
+__attribute__(( fptrgroup("lv_text_encoded_conv_wc") ))
 extern uint32_t (*const lv_text_encoded_conv_wc)(uint32_t c);
 
 /**
@@ -223,6 +226,7 @@ extern uint32_t (*const lv_text_encoded_conv_wc)(uint32_t c);
  *                 NULL to use txt[0] as index
  * @return the decoded Unicode character or 0 on invalid data code
  */
+__attribute__(( fptrgroup("lv_text_encoded_next") ))
 extern uint32_t (*const lv_text_encoded_next)(const char * txt, uint32_t * i_start);
 
 /**
@@ -234,6 +238,7 @@ extern uint32_t (*const lv_text_encoded_next)(const char * txt, uint32_t * i_sta
  *
  * @return the decoded Unicode character or 0 on invalid data
  */
+__attribute__(( fptrgroup("lv_text_encoded_prev") ))
 extern uint32_t (*const lv_text_encoded_prev)(const char * txt, uint32_t * i_start);
 
 /**
@@ -243,6 +248,7 @@ extern uint32_t (*const lv_text_encoded_prev)(const char * txt, uint32_t * i_sta
  * @param utf8_id character index
  * @return byte index of the 'enc_id'th letter
  */
+__attribute__(( fptrgroup("lv_text_encoded_get_byte_id") ))
 extern uint32_t (*const lv_text_encoded_get_byte_id)(const char * txt, uint32_t utf8_id);
 
 /**
@@ -252,6 +258,7 @@ extern uint32_t (*const lv_text_encoded_get_byte_id)(const char * txt, uint32_t
  * @param byte_id byte index
  * @return character index of the letter at 'byte_id'th position
  */
+__attribute__(( fptrgroup("lv_text_encoded_get_char_id") ))
 extern uint32_t (*const lv_text_encoded_get_char_id)(const char * txt, uint32_t byte_id);
 
 /**
@@ -260,6 +267,7 @@ extern uint32_t (*const lv_text_encoded_get_char_id)(const char * txt, uint32_t
  * @param txt a '\0' terminated char string
  * @return number of characters
  */
+__attribute__(( fptrgroup("lv_text_get_encoded_length") ))
 extern uint32_t (*const lv_text_get_encoded_length)(const char * txt);
 
 /**********************
diff --git a/src/misc/lv_timer.c b/src/misc/lv_timer.c
index 959ce53b9..d4f8a5448 100644
--- a/src/misc/lv_timer.c
+++ b/src/misc/lv_timer.c
@@ -52,6 +52,7 @@ static void lv_timer_handler_resume(void);
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 void lv_timer_core_init(void)
 {
     lv_ll_init(timer_ll_p, sizeof(lv_timer_t));
@@ -60,6 +61,8 @@ void lv_timer_core_init(void)
     lv_timer_enable(true);
 }
 
+#pragma stackfunction 1024
+LV_FUNC_SECTION
 LV_ATTRIBUTE_TIMER_HANDLER uint32_t lv_timer_handler(void)
 {
     LV_TRACE_TIMER("begin");
@@ -148,6 +151,7 @@ LV_ATTRIBUTE_TIMER_HANDLER uint32_t lv_timer_handler(void)
     return time_until_next;
 }
 
+LV_FUNC_SECTION
 LV_ATTRIBUTE_TIMER_HANDLER void lv_timer_periodic_handler(void)
 {
     lv_timer_state_t * state_p = &state;
@@ -158,11 +162,13 @@ LV_ATTRIBUTE_TIMER_HANDLER void lv_timer_periodic_handler(void)
     }
 }
 
+LV_FUNC_SECTION
 lv_timer_t * lv_timer_create_basic(void)
 {
     return lv_timer_create(NULL, DEF_PERIOD, NULL);
 }
 
+LV_FUNC_SECTION
 lv_timer_t * lv_timer_create(lv_timer_cb_t timer_xcb, uint32_t period, void * user_data)
 {
     lv_timer_t * new_timer = NULL;
@@ -186,12 +192,14 @@ lv_timer_t * lv_timer_create(lv_timer_cb_t timer_xcb, uint32_t period, void * us
     return new_timer;
 }
 
+LV_FUNC_SECTION
 void lv_timer_set_cb(lv_timer_t * timer, lv_timer_cb_t timer_cb)
 {
     LV_ASSERT_NULL(timer);
     timer->timer_cb = timer_cb;
 }
 
+LV_FUNC_SECTION
 void lv_timer_delete(lv_timer_t * timer)
 {
     lv_ll_remove(timer_ll_p, timer);
@@ -200,12 +208,14 @@ void lv_timer_delete(lv_timer_t * timer)
     lv_free(timer);
 }
 
+LV_FUNC_SECTION
 void lv_timer_pause(lv_timer_t * timer)
 {
     LV_ASSERT_NULL(timer);
     timer->paused = true;
 }
 
+LV_FUNC_SECTION
 void lv_timer_resume(lv_timer_t * timer)
 {
     LV_ASSERT_NULL(timer);
@@ -213,36 +223,42 @@ void lv_timer_resume(lv_timer_t * timer)
     lv_timer_handler_resume();
 }
 
+LV_FUNC_SECTION
 void lv_timer_set_period(lv_timer_t * timer, uint32_t period)
 {
     LV_ASSERT_NULL(timer);
     timer->period = period;
 }
 
+LV_FUNC_SECTION
 void lv_timer_ready(lv_timer_t * timer)
 {
     LV_ASSERT_NULL(timer);
     timer->last_run = lv_tick_get() - timer->period - 1;
 }
 
+LV_FUNC_SECTION
 void lv_timer_set_repeat_count(lv_timer_t * timer, int32_t repeat_count)
 {
     LV_ASSERT_NULL(timer);
     timer->repeat_count = repeat_count;
 }
 
+LV_FUNC_SECTION
 void lv_timer_set_auto_delete(lv_timer_t * timer, bool auto_delete)
 {
     LV_ASSERT_NULL(timer);
     timer->auto_delete = auto_delete;
 }
 
+LV_FUNC_SECTION
 void lv_timer_set_user_data(lv_timer_t * timer, void * user_data)
 {
     LV_ASSERT_NULL(timer);
     timer->user_data = user_data;
 }
 
+LV_FUNC_SECTION
 void lv_timer_reset(lv_timer_t * timer)
 {
     LV_ASSERT_NULL(timer);
@@ -250,12 +266,14 @@ void lv_timer_reset(lv_timer_t * timer)
     lv_timer_handler_resume();
 }
 
+LV_FUNC_SECTION
 void lv_timer_enable(bool en)
 {
     state.lv_timer_run = en;
     if(en) lv_timer_handler_resume();
 }
 
+LV_FUNC_SECTION
 void lv_timer_core_deinit(void)
 {
     lv_timer_enable(false);
@@ -263,22 +281,26 @@ void lv_timer_core_deinit(void)
     lv_ll_clear(timer_ll_p);
 }
 
+LV_FUNC_SECTION
 uint32_t lv_timer_get_idle(void)
 {
     return state.idle_last;
 }
 
+LV_FUNC_SECTION
 uint32_t lv_timer_get_time_until_next(void)
 {
     return state.timer_time_until_next;
 }
 
+LV_FUNC_SECTION
 lv_timer_t * lv_timer_get_next(lv_timer_t * timer)
 {
     if(timer == NULL) return lv_ll_get_head(timer_ll_p);
     else return lv_ll_get_next(timer_ll_p, timer);
 }
 
+LV_FUNC_SECTION
 LV_ATTRIBUTE_TIMER_HANDLER uint32_t lv_timer_handler_run_in_period(uint32_t period)
 {
     static uint32_t last_tick = 0;
@@ -290,11 +312,13 @@ LV_ATTRIBUTE_TIMER_HANDLER uint32_t lv_timer_handler_run_in_period(uint32_t peri
     return 1;
 }
 
+LV_FUNC_SECTION
 void * lv_timer_get_user_data(lv_timer_t * timer)
 {
     return timer->user_data;
 }
 
+LV_FUNC_SECTION
 bool lv_timer_get_paused(lv_timer_t * timer)
 {
     return timer->paused;
@@ -309,6 +333,7 @@ bool lv_timer_get_paused(lv_timer_t * timer)
  * @param timer pointer to lv_timer
  * @return true: execute, false: not executed
  */
+LV_FUNC_SECTION
 static bool lv_timer_exec(lv_timer_t * timer)
 {
     if(timer->paused) return false;
@@ -357,6 +382,7 @@ static bool lv_timer_exec(lv_timer_t * timer)
  * @param timer pointer to lv_timer
  * @return the time remaining, or 0 if it needs to be run again
  */
+LV_FUNC_SECTION
 static uint32_t lv_timer_time_remaining(lv_timer_t * timer)
 {
     /*Check if at least 'period' time elapsed*/
@@ -369,6 +395,7 @@ static uint32_t lv_timer_time_remaining(lv_timer_t * timer)
 /**
  * Call the ready lv_timer
  */
+LV_FUNC_SECTION
 static void lv_timer_handler_resume(void)
 {
     /*If there is a timer which is ready to run then resume the timer loop*/
@@ -378,6 +405,7 @@ static void lv_timer_handler_resume(void)
     }
 }
 
+LV_FUNC_SECTION
 void lv_timer_handler_set_resume_cb(lv_timer_handler_resume_cb_t cb, void * data)
 {
     state.resume_cb = cb;
diff --git a/src/misc/lv_timer_private.h b/src/misc/lv_timer_private.h
index b7f42b0a1..fd1833b42 100644
--- a/src/misc/lv_timer_private.h
+++ b/src/misc/lv_timer_private.h
@@ -30,6 +30,7 @@ extern "C" {
 struct lv_timer_t {
     uint32_t period;           /**< How often the timer should run */
     uint32_t last_run;         /**< Last time the timer ran */
+    __attribute__(( fptrgroup("lv_timer_cb") ))
     lv_timer_cb_t timer_cb;    /**< Timer function */
     void * user_data;          /**< Custom user data */
     int32_t repeat_count;      /**< 1: One time;  -1 : infinity;  n>0: residual times */
@@ -52,6 +53,7 @@ typedef struct {
     uint32_t idle_period_start;
     uint32_t run_cnt;
 
+    __attribute__(( fptrgroup("lv_timer_resume_cb") ))
     lv_timer_handler_resume_cb_t resume_cb;
     void * resume_data;
 } lv_timer_state_t;
diff --git a/src/misc/lv_utils.c b/src/misc/lv_utils.c
index 868692170..80b335c41 100644
--- a/src/misc/lv_utils.c
+++ b/src/misc/lv_utils.c
@@ -35,8 +35,9 @@
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 void * lv_utils_bsearch(const void * key, const void * base, size_t n, size_t size,
-                        int (*cmp)(const void * pRef, const void * pElement))
+    __attribute__(( fptrgroup("lv_utils_cmp") ))int (*cmp)(const void * pRef, const void * pElement))
 {
     const char * middle;
     int32_t c;
@@ -58,6 +59,7 @@ void * lv_utils_bsearch(const void * key, const void * base, size_t n, size_t si
     return NULL;
 }
 
+LV_FUNC_SECTION
 lv_result_t lv_draw_buf_save_to_file(const lv_draw_buf_t * draw_buf, const char * path)
 {
     lv_fs_file_t file;
diff --git a/src/osal/lv_cmsis_rtos2.c b/src/osal/lv_cmsis_rtos2.c
index ed414c8da..2b028a863 100644
--- a/src/osal/lv_cmsis_rtos2.c
+++ b/src/osal/lv_cmsis_rtos2.c
@@ -42,6 +42,7 @@
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 lv_result_t lv_thread_init(lv_thread_t * thread, lv_thread_prio_t prio, void (*callback)(void *), size_t stack_size,
                            void * user_data)
 {
@@ -69,6 +70,7 @@ lv_result_t lv_thread_init(lv_thread_t * thread, lv_thread_prio_t prio, void (*c
 
 }
 
+LV_FUNC_SECTION
 lv_result_t lv_thread_delete(lv_thread_t * thread)
 {
     osThreadDetach(*thread);
@@ -79,6 +81,7 @@ lv_result_t lv_thread_delete(lv_thread_t * thread)
     return LV_RESULT_INVALID;
 }
 
+LV_FUNC_SECTION
 lv_result_t lv_mutex_init(lv_mutex_t * mutex)
 {
     const osMutexAttr_t Thread_Mutex_attr = {
@@ -96,6 +99,7 @@ lv_result_t lv_mutex_init(lv_mutex_t * mutex)
 
 }
 
+LV_FUNC_SECTION
 lv_result_t lv_mutex_lock(lv_mutex_t * mutex)
 {
     osStatus_t status = osMutexAcquire(*mutex, 0U);
@@ -107,6 +111,7 @@ lv_result_t lv_mutex_lock(lv_mutex_t * mutex)
     return LV_RESULT_OK;
 }
 
+LV_FUNC_SECTION
 lv_result_t lv_mutex_lock_isr(lv_mutex_t * mutex)
 {
     osStatus_t status = osMutexAcquire(*mutex, 0U);
@@ -118,6 +123,7 @@ lv_result_t lv_mutex_lock_isr(lv_mutex_t * mutex)
     return LV_RESULT_OK;
 }
 
+LV_FUNC_SECTION
 lv_result_t lv_mutex_unlock(lv_mutex_t * mutex)
 {
     osStatus_t status = osMutexRelease(*mutex);
@@ -129,6 +135,7 @@ lv_result_t lv_mutex_unlock(lv_mutex_t * mutex)
     return LV_RESULT_OK;
 }
 
+LV_FUNC_SECTION
 lv_result_t lv_mutex_delete(lv_mutex_t * mutex)
 {
     osStatus_t status = osMutexDelete(*mutex);
@@ -140,6 +147,7 @@ lv_result_t lv_mutex_delete(lv_mutex_t * mutex)
     return LV_RESULT_OK;
 }
 
+LV_FUNC_SECTION
 lv_result_t lv_thread_sync_init(lv_thread_sync_t * sync)
 {
     *sync = osEventFlagsNew(NULL);
@@ -150,6 +158,7 @@ lv_result_t lv_thread_sync_init(lv_thread_sync_t * sync)
     return LV_RESULT_OK;
 }
 
+LV_FUNC_SECTION
 lv_result_t lv_thread_sync_wait(lv_thread_sync_t * sync)
 {
     uint32_t ret = osEventFlagsWait(*sync, 0x01, osFlagsWaitAny, osWaitForever);
@@ -161,6 +170,7 @@ lv_result_t lv_thread_sync_wait(lv_thread_sync_t * sync)
     return LV_RESULT_OK;
 }
 
+LV_FUNC_SECTION
 lv_result_t lv_thread_sync_signal(lv_thread_sync_t * sync)
 {
     uint32_t ret = osEventFlagsSet(*sync, 0x01);
@@ -172,11 +182,13 @@ lv_result_t lv_thread_sync_signal(lv_thread_sync_t * sync)
     return LV_RESULT_OK;
 }
 
+LV_FUNC_SECTION
 lv_result_t lv_thread_sync_signal_isr(lv_thread_sync_t * sync)
 {
     return lv_thread_sync_signal(sync);
 }
 
+LV_FUNC_SECTION
 lv_result_t lv_thread_sync_delete(lv_thread_sync_t * sync)
 {
     osStatus_t status = osEventFlagsDelete(*sync);
diff --git a/src/osal/lv_freertos.c b/src/osal/lv_freertos.c
index f65a299aa..e5aad03ee 100644
--- a/src/osal/lv_freertos.c
+++ b/src/osal/lv_freertos.c
@@ -85,6 +85,7 @@ static void prvTestAndDecrement(lv_thread_sync_t * pxCond,
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 lv_result_t lv_thread_init(lv_thread_t * pxThread, lv_thread_prio_t xSchedPriority,
                            void (*pvStartRoutine)(void *), size_t usStackSize,
                            void * xAttr)
@@ -109,6 +110,7 @@ lv_result_t lv_thread_init(lv_thread_t * pxThread, lv_thread_prio_t xSchedPriori
     return LV_RESULT_OK;
 }
 
+LV_FUNC_SECTION
 lv_result_t lv_thread_delete(lv_thread_t * pxThread)
 {
     vTaskDelete(pxThread->xTaskHandle);
@@ -116,6 +118,7 @@ lv_result_t lv_thread_delete(lv_thread_t * pxThread)
     return LV_RESULT_OK;
 }
 
+LV_FUNC_SECTION
 lv_result_t lv_mutex_init(lv_mutex_t * pxMutex)
 {
     /* If mutex in uninitialized, perform initialization. */
@@ -124,6 +127,7 @@ lv_result_t lv_mutex_init(lv_mutex_t * pxMutex)
     return LV_RESULT_OK;
 }
 
+LV_FUNC_SECTION
 lv_result_t lv_mutex_lock(lv_mutex_t * pxMutex)
 {
     /* If mutex in uninitialized, perform initialization. */
@@ -138,6 +142,7 @@ lv_result_t lv_mutex_lock(lv_mutex_t * pxMutex)
     return LV_RESULT_OK;
 }
 
+LV_FUNC_SECTION
 lv_result_t lv_mutex_lock_isr(lv_mutex_t * pxMutex)
 {
     /* If mutex in uninitialized, perform initialization. */
@@ -160,6 +165,7 @@ lv_result_t lv_mutex_lock_isr(lv_mutex_t * pxMutex)
     return LV_RESULT_OK;
 }
 
+LV_FUNC_SECTION
 lv_result_t lv_mutex_unlock(lv_mutex_t * pxMutex)
 {
     /* If mutex in uninitialized, perform initialization. */
@@ -174,6 +180,7 @@ lv_result_t lv_mutex_unlock(lv_mutex_t * pxMutex)
     return LV_RESULT_OK;
 }
 
+LV_FUNC_SECTION
 lv_result_t lv_mutex_delete(lv_mutex_t * pxMutex)
 {
     vSemaphoreDelete(pxMutex->xMutex);
@@ -182,6 +189,7 @@ lv_result_t lv_mutex_delete(lv_mutex_t * pxMutex)
     return LV_RESULT_OK;
 }
 
+LV_FUNC_SECTION
 lv_result_t lv_thread_sync_init(lv_thread_sync_t * pxCond)
 {
     /* If the cond is uninitialized, perform initialization. */
@@ -190,6 +198,7 @@ lv_result_t lv_thread_sync_init(lv_thread_sync_t * pxCond)
     return LV_RESULT_OK;
 }
 
+LV_FUNC_SECTION
 lv_result_t lv_thread_sync_wait(lv_thread_sync_t * pxCond)
 {
     lv_result_t lvRes = LV_RESULT_OK;
@@ -272,6 +281,7 @@ lv_result_t lv_thread_sync_wait(lv_thread_sync_t * pxCond)
     return lvRes;
 }
 
+LV_FUNC_SECTION
 lv_result_t lv_thread_sync_signal(lv_thread_sync_t * pxCond)
 {
     /* If the cond is uninitialized, perform initialization. */
@@ -329,6 +339,7 @@ lv_result_t lv_thread_sync_signal(lv_thread_sync_t * pxCond)
     return LV_RESULT_OK;
 }
 
+LV_FUNC_SECTION
 lv_result_t lv_thread_sync_delete(lv_thread_sync_t * pxCond)
 {
 #if !LV_USE_FREERTOS_TASK_NOTIFY
@@ -343,6 +354,7 @@ lv_result_t lv_thread_sync_delete(lv_thread_sync_t * pxCond)
     return LV_RESULT_OK;
 }
 
+LV_FUNC_SECTION
 lv_result_t lv_thread_sync_signal_isr(lv_thread_sync_t * pxCond)
 {
     BaseType_t xHigherPriorityTaskWoken = pdFALSE;
@@ -388,6 +400,7 @@ lv_result_t lv_thread_sync_signal_isr(lv_thread_sync_t * pxCond)
 }
 
 
+LV_FUNC_SECTION
 void lv_freertos_task_switch_in(const char * name)
 {
     if(lv_strcmp(name, "IDLE")) globals->freertos_idle_task_running = false;
@@ -396,6 +409,7 @@ void lv_freertos_task_switch_in(const char * name)
     globals->freertos_task_switch_timestamp = lv_tick_get();
 }
 
+LV_FUNC_SECTION
 void lv_freertos_task_switch_out(void)
 {
     uint32_t elaps = lv_tick_elaps(globals->freertos_task_switch_timestamp);
@@ -403,6 +417,7 @@ void lv_freertos_task_switch_out(void)
     else globals->freertos_non_idle_time_sum += elaps;
 }
 
+LV_FUNC_SECTION
 uint32_t lv_os_get_idle_percent(void)
 {
     if(globals->freertos_non_idle_time_sum + globals->freertos_idle_time_sum == 0) {
@@ -423,6 +438,7 @@ uint32_t lv_os_get_idle_percent(void)
  *   STATIC FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 static void prvRunThread(void * pxArg)
 {
     lv_thread_t * pxThread = (lv_thread_t *)pxArg;
@@ -433,6 +449,7 @@ static void prvRunThread(void * pxArg)
     vTaskDelete(NULL);
 }
 
+LV_FUNC_SECTION
 static void prvMutexInit(lv_mutex_t * pxMutex)
 {
     pxMutex->xMutex = xSemaphoreCreateRecursiveMutex();
@@ -447,6 +464,7 @@ static void prvMutexInit(lv_mutex_t * pxMutex)
     pxMutex->xIsInitialized = pdTRUE;
 }
 
+LV_FUNC_SECTION
 static void prvCheckMutexInit(lv_mutex_t * pxMutex)
 {
     /* Check if the mutex needs to be initialized. */
@@ -467,6 +485,7 @@ static void prvCheckMutexInit(lv_mutex_t * pxMutex)
     }
 }
 
+LV_FUNC_SECTION
 static void prvCondInit(lv_thread_sync_t * pxCond)
 {
     pxCond->xIsInitialized = pdTRUE;
@@ -498,6 +517,7 @@ static void prvCondInit(lv_thread_sync_t * pxCond)
 #endif
 }
 
+LV_FUNC_SECTION
 static void prvCheckCondInit(lv_thread_sync_t * pxCond)
 {
     /* Check if the condition variable needs to be initialized. */
@@ -518,6 +538,7 @@ static void prvCheckCondInit(lv_thread_sync_t * pxCond)
     }
 }
 
+LV_FUNC_SECTION
 static void prvCheckCondInitIsr(lv_thread_sync_t * pxCond)
 {
     /* Check if the condition variable needs to be initialized. */
@@ -539,6 +560,7 @@ static void prvCheckCondInitIsr(lv_thread_sync_t * pxCond)
 }
 
 #if !LV_USE_FREERTOS_TASK_NOTIFY
+LV_FUNC_SECTION
 static void prvTestAndDecrement(lv_thread_sync_t * pxCond,
                                 uint32_t ulLocalWaitingThreads)
 {
diff --git a/src/osal/lv_mqx.c b/src/osal/lv_mqx.c
index fed82f428..4fb0decbc 100644
--- a/src/osal/lv_mqx.c
+++ b/src/osal/lv_mqx.c
@@ -37,6 +37,7 @@
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 lv_result_t lv_thread_init(lv_thread_t * thread, lv_thread_prio_t prio, void (*callback)(void *), size_t stack_size,
                            void * user_data)
 {
@@ -58,6 +59,7 @@ lv_result_t lv_thread_init(lv_thread_t * thread, lv_thread_prio_t prio, void (*c
     return LV_RESULT_OK;
 }
 
+LV_FUNC_SECTION
 lv_result_t lv_thread_delete(lv_thread_t * thread)
 {
     _mqx_uint ret = _task_destroy(*thread);
@@ -68,6 +70,7 @@ lv_result_t lv_thread_delete(lv_thread_t * thread)
     return LV_RESULT_OK;
 }
 
+LV_FUNC_SECTION
 lv_result_t lv_mutex_init(lv_mutex_t * mutex)
 {
     if(MQX_OK != _mutex_init(mutex, NULL)) {
@@ -77,6 +80,7 @@ lv_result_t lv_mutex_init(lv_mutex_t * mutex)
     return LV_RESULT_OK;
 }
 
+LV_FUNC_SECTION
 lv_result_t lv_mutex_lock(lv_mutex_t * mutex)
 {
     _mqx_uint ret = _mutex_lock(mutex);
@@ -87,6 +91,7 @@ lv_result_t lv_mutex_lock(lv_mutex_t * mutex)
     return LV_RESULT_OK;
 }
 
+LV_FUNC_SECTION
 lv_result_t lv_mutex_lock_isr(lv_mutex_t * mutex)
 {
     _mqx_uint ret = _mutex_lock(mutex);
@@ -97,6 +102,7 @@ lv_result_t lv_mutex_lock_isr(lv_mutex_t * mutex)
     return LV_RESULT_OK;
 }
 
+LV_FUNC_SECTION
 lv_result_t lv_mutex_unlock(lv_mutex_t * mutex)
 {
     _mqx_uint ret = _mutex_unlock(mutex);
@@ -107,6 +113,7 @@ lv_result_t lv_mutex_unlock(lv_mutex_t * mutex)
     return LV_RESULT_OK;
 }
 
+LV_FUNC_SECTION
 lv_result_t lv_mutex_delete(lv_mutex_t * mutex)
 {
     _mqx_uint ret = _mutex_destroy(mutex);
@@ -117,6 +124,7 @@ lv_result_t lv_mutex_delete(lv_mutex_t * mutex)
     return LV_RESULT_OK;
 }
 
+LV_FUNC_SECTION
 lv_result_t lv_thread_sync_init(lv_thread_sync_t * sync)
 {
     if(MQX_OK != _lwsem_create(sync, 0)) {
@@ -126,6 +134,7 @@ lv_result_t lv_thread_sync_init(lv_thread_sync_t * sync)
     return LV_RESULT_OK;
 }
 
+LV_FUNC_SECTION
 lv_result_t lv_thread_sync_wait(lv_thread_sync_t * sync)
 {
     _mqx_uint ret = _lwsem_wait(sync);
@@ -136,6 +145,7 @@ lv_result_t lv_thread_sync_wait(lv_thread_sync_t * sync)
     return LV_RESULT_OK;
 }
 
+LV_FUNC_SECTION
 lv_result_t lv_thread_sync_signal(lv_thread_sync_t * sync)
 {
     _mqx_uint ret = _lwsem_post(sync);
@@ -146,6 +156,7 @@ lv_result_t lv_thread_sync_signal(lv_thread_sync_t * sync)
     return LV_RESULT_OK;
 }
 
+LV_FUNC_SECTION
 lv_result_t lv_thread_sync_delete(lv_thread_sync_t * sync)
 {
     _mqx_uint ret = _lwsem_destroy(sync);
@@ -156,6 +167,7 @@ lv_result_t lv_thread_sync_delete(lv_thread_sync_t * sync)
     return LV_RESULT_OK;
 }
 
+LV_FUNC_SECTION
 lv_result_t lv_thread_sync_signal_isr(lv_thread_sync_t * sync)
 {
     LV_UNUSED(sync);
diff --git a/src/osal/lv_os.c b/src/osal/lv_os.c
index 7b775f034..3bd65afa2 100644
--- a/src/osal/lv_os.c
+++ b/src/osal/lv_os.c
@@ -35,6 +35,7 @@
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 void lv_os_init(void)
 {
 #if LV_USE_OS != LV_OS_NONE
@@ -42,6 +43,7 @@ void lv_os_init(void)
 #endif /*LV_USE_OS != LV_OS_NONE*/
 }
 
+LV_FUNC_SECTION
 void lv_lock(void)
 {
 #if LV_USE_OS != LV_OS_NONE
@@ -49,6 +51,7 @@ void lv_lock(void)
 #endif /*LV_USE_OS != LV_OS_NONE*/
 }
 
+LV_FUNC_SECTION
 lv_result_t lv_lock_isr(void)
 {
 #if LV_USE_OS != LV_OS_NONE
@@ -58,6 +61,7 @@ lv_result_t lv_lock_isr(void)
 #endif /*LV_USE_OS != LV_OS_NONE*/
 }
 
+LV_FUNC_SECTION
 void lv_unlock(void)
 {
 #if LV_USE_OS != LV_OS_NONE
diff --git a/src/osal/lv_os_none.c b/src/osal/lv_os_none.c
index 547810db7..af4d37146 100644
--- a/src/osal/lv_os_none.c
+++ b/src/osal/lv_os_none.c
@@ -36,6 +36,7 @@
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 lv_result_t lv_thread_init(lv_thread_t * thread, lv_thread_prio_t prio, void (*callback)(void *), size_t stack_size,
                            void * user_data)
 {
@@ -48,6 +49,7 @@ lv_result_t lv_thread_init(lv_thread_t * thread, lv_thread_prio_t prio, void (*c
     return LV_RESULT_INVALID;
 }
 
+LV_FUNC_SECTION
 lv_result_t lv_thread_delete(lv_thread_t * thread)
 {
     LV_UNUSED(thread);
@@ -55,36 +57,42 @@ lv_result_t lv_thread_delete(lv_thread_t * thread)
     return LV_RESULT_INVALID;
 }
 
+LV_FUNC_SECTION
 lv_result_t lv_mutex_init(lv_mutex_t * mutex)
 {
     LV_UNUSED(mutex);
     return LV_RESULT_OK;
 }
 
+LV_FUNC_SECTION
 lv_result_t lv_mutex_lock(lv_mutex_t * mutex)
 {
     LV_UNUSED(mutex);
     return LV_RESULT_OK;
 }
 
+LV_FUNC_SECTION
 lv_result_t lv_mutex_lock_isr(lv_mutex_t * mutex)
 {
     LV_UNUSED(mutex);
     return LV_RESULT_OK;
 }
 
+LV_FUNC_SECTION
 lv_result_t lv_mutex_unlock(lv_mutex_t * mutex)
 {
     LV_UNUSED(mutex);
     return LV_RESULT_OK;
 }
 
+LV_FUNC_SECTION
 lv_result_t lv_mutex_delete(lv_mutex_t * mutex)
 {
     LV_UNUSED(mutex);
     return LV_RESULT_OK;
 }
 
+LV_FUNC_SECTION
 lv_result_t lv_thread_sync_init(lv_thread_sync_t * sync)
 {
     LV_UNUSED(sync);
@@ -92,6 +100,7 @@ lv_result_t lv_thread_sync_init(lv_thread_sync_t * sync)
     return LV_RESULT_INVALID;
 }
 
+LV_FUNC_SECTION
 lv_result_t lv_thread_sync_wait(lv_thread_sync_t * sync)
 {
     LV_UNUSED(sync);
@@ -99,6 +108,7 @@ lv_result_t lv_thread_sync_wait(lv_thread_sync_t * sync)
     return LV_RESULT_INVALID;
 }
 
+LV_FUNC_SECTION
 lv_result_t lv_thread_sync_signal(lv_thread_sync_t * sync)
 {
     LV_UNUSED(sync);
@@ -106,6 +116,7 @@ lv_result_t lv_thread_sync_signal(lv_thread_sync_t * sync)
     return LV_RESULT_INVALID;
 }
 
+LV_FUNC_SECTION
 lv_result_t lv_thread_sync_signal_isr(lv_thread_sync_t * sync)
 {
     LV_UNUSED(sync);
@@ -113,6 +124,7 @@ lv_result_t lv_thread_sync_signal_isr(lv_thread_sync_t * sync)
     return LV_RESULT_INVALID;
 }
 
+LV_FUNC_SECTION
 lv_result_t lv_thread_sync_delete(lv_thread_sync_t * sync)
 {
     LV_UNUSED(sync);
diff --git a/src/osal/lv_pthread.c b/src/osal/lv_pthread.c
index 268f055c2..cadc26bd4 100644
--- a/src/osal/lv_pthread.c
+++ b/src/osal/lv_pthread.c
@@ -38,6 +38,7 @@ static void * generic_callback(void * user_data);
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 lv_result_t lv_thread_init(lv_thread_t * thread, lv_thread_prio_t prio, void (*callback)(void *), size_t stack_size,
                            void * user_data)
 {
@@ -51,6 +52,7 @@ lv_result_t lv_thread_init(lv_thread_t * thread, lv_thread_prio_t prio, void (*c
     return LV_RESULT_OK;
 }
 
+LV_FUNC_SECTION
 lv_result_t lv_thread_delete(lv_thread_t * thread)
 {
     int ret = pthread_join(thread->thread, NULL);
@@ -62,6 +64,7 @@ lv_result_t lv_thread_delete(lv_thread_t * thread)
     return LV_RESULT_OK;
 }
 
+LV_FUNC_SECTION
 lv_result_t lv_mutex_init(lv_mutex_t * mutex)
 {
     pthread_mutexattr_t attr;
@@ -80,6 +83,7 @@ lv_result_t lv_mutex_init(lv_mutex_t * mutex)
     }
 }
 
+LV_FUNC_SECTION
 lv_result_t lv_mutex_lock(lv_mutex_t * mutex)
 {
     int ret = pthread_mutex_lock(mutex);
@@ -92,6 +96,7 @@ lv_result_t lv_mutex_lock(lv_mutex_t * mutex)
     }
 }
 
+LV_FUNC_SECTION
 lv_result_t lv_mutex_lock_isr(lv_mutex_t * mutex)
 {
     int ret = pthread_mutex_lock(mutex);
@@ -104,6 +109,7 @@ lv_result_t lv_mutex_lock_isr(lv_mutex_t * mutex)
     }
 }
 
+LV_FUNC_SECTION
 lv_result_t lv_mutex_unlock(lv_mutex_t * mutex)
 {
     int ret = pthread_mutex_unlock(mutex);
@@ -116,12 +122,14 @@ lv_result_t lv_mutex_unlock(lv_mutex_t * mutex)
     }
 }
 
+LV_FUNC_SECTION
 lv_result_t lv_mutex_delete(lv_mutex_t * mutex)
 {
     pthread_mutex_destroy(mutex);
     return LV_RESULT_OK;
 }
 
+LV_FUNC_SECTION
 lv_result_t lv_thread_sync_init(lv_thread_sync_t * sync)
 {
     pthread_mutex_init(&sync->mutex, 0);
@@ -130,6 +138,7 @@ lv_result_t lv_thread_sync_init(lv_thread_sync_t * sync)
     return LV_RESULT_OK;
 }
 
+LV_FUNC_SECTION
 lv_result_t lv_thread_sync_wait(lv_thread_sync_t * sync)
 {
     pthread_mutex_lock(&sync->mutex);
@@ -141,6 +150,7 @@ lv_result_t lv_thread_sync_wait(lv_thread_sync_t * sync)
     return LV_RESULT_OK;
 }
 
+LV_FUNC_SECTION
 lv_result_t lv_thread_sync_signal(lv_thread_sync_t * sync)
 {
     pthread_mutex_lock(&sync->mutex);
@@ -151,6 +161,7 @@ lv_result_t lv_thread_sync_signal(lv_thread_sync_t * sync)
     return LV_RESULT_OK;
 }
 
+LV_FUNC_SECTION
 lv_result_t lv_thread_sync_delete(lv_thread_sync_t * sync)
 {
     pthread_mutex_destroy(&sync->mutex);
@@ -158,6 +169,7 @@ lv_result_t lv_thread_sync_delete(lv_thread_sync_t * sync)
     return LV_RESULT_OK;
 }
 
+LV_FUNC_SECTION
 lv_result_t lv_thread_sync_signal_isr(lv_thread_sync_t * sync)
 {
     LV_UNUSED(sync);
@@ -168,6 +180,7 @@ lv_result_t lv_thread_sync_signal_isr(lv_thread_sync_t * sync)
  *   STATIC FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 static void * generic_callback(void * user_data)
 {
     lv_thread_t * thread = user_data;
diff --git a/src/osal/lv_rtthread.c b/src/osal/lv_rtthread.c
index e781634e1..e4c257889 100644
--- a/src/osal/lv_rtthread.c
+++ b/src/osal/lv_rtthread.c
@@ -38,6 +38,7 @@
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 lv_result_t lv_thread_init(lv_thread_t * thread, lv_thread_prio_t prio, void (*callback)(void *), size_t stack_size,
                            void * user_data)
 {
@@ -57,6 +58,7 @@ lv_result_t lv_thread_init(lv_thread_t * thread, lv_thread_prio_t prio, void (*c
     }
 }
 
+LV_FUNC_SECTION
 lv_result_t lv_thread_delete(lv_thread_t * thread)
 {
     rt_err_t ret = rt_thread_delete(thread->thread);
@@ -69,6 +71,7 @@ lv_result_t lv_thread_delete(lv_thread_t * thread)
     }
 }
 
+LV_FUNC_SECTION
 lv_result_t lv_mutex_init(lv_mutex_t * mutex)
 {
     mutex->mutex = rt_mutex_create("mutex", RT_IPC_FLAG_PRIO);
@@ -81,6 +84,7 @@ lv_result_t lv_mutex_init(lv_mutex_t * mutex)
     }
 }
 
+LV_FUNC_SECTION
 lv_result_t lv_mutex_lock(lv_mutex_t * mutex)
 {
     rt_err_t ret = rt_mutex_take(mutex->mutex, RT_WAITING_FOREVER);
@@ -93,6 +97,7 @@ lv_result_t lv_mutex_lock(lv_mutex_t * mutex)
     }
 }
 
+LV_FUNC_SECTION
 lv_result_t lv_mutex_lock_isr(lv_mutex_t * mutex)
 {
     rt_err_t ret = rt_mutex_take(mutex->mutex, RT_WAITING_FOREVER);
@@ -105,6 +110,7 @@ lv_result_t lv_mutex_lock_isr(lv_mutex_t * mutex)
     }
 }
 
+LV_FUNC_SECTION
 lv_result_t lv_mutex_unlock(lv_mutex_t * mutex)
 {
     rt_err_t ret = rt_mutex_release(mutex->mutex);
@@ -117,6 +123,7 @@ lv_result_t lv_mutex_unlock(lv_mutex_t * mutex)
     }
 }
 
+LV_FUNC_SECTION
 lv_result_t lv_mutex_delete(lv_mutex_t * mutex)
 {
     rt_err_t ret = rt_mutex_delete(mutex->mutex);
@@ -129,6 +136,7 @@ lv_result_t lv_mutex_delete(lv_mutex_t * mutex)
     }
 }
 
+LV_FUNC_SECTION
 lv_result_t lv_thread_sync_init(lv_thread_sync_t * sync)
 {
     sync->sem = rt_sem_create("sem", 0, RT_IPC_FLAG_PRIO);
@@ -141,6 +149,7 @@ lv_result_t lv_thread_sync_init(lv_thread_sync_t * sync)
     }
 }
 
+LV_FUNC_SECTION
 lv_result_t lv_thread_sync_wait(lv_thread_sync_t * sync)
 {
     rt_err_t ret = rt_sem_take(sync->sem, RT_WAITING_FOREVER);
@@ -153,6 +162,7 @@ lv_result_t lv_thread_sync_wait(lv_thread_sync_t * sync)
     }
 }
 
+LV_FUNC_SECTION
 lv_result_t lv_thread_sync_signal(lv_thread_sync_t * sync)
 {
     rt_err_t ret = rt_sem_release(sync->sem);
@@ -165,6 +175,7 @@ lv_result_t lv_thread_sync_signal(lv_thread_sync_t * sync)
     }
 }
 
+LV_FUNC_SECTION
 lv_result_t lv_thread_sync_delete(lv_thread_sync_t * sync)
 {
     rt_err_t ret = rt_sem_delete(sync->sem);
@@ -177,6 +188,7 @@ lv_result_t lv_thread_sync_delete(lv_thread_sync_t * sync)
     }
 }
 
+LV_FUNC_SECTION
 lv_result_t lv_thread_sync_signal_isr(lv_thread_sync_t * sync)
 {
     LV_UNUSED(sync);
diff --git a/src/osal/lv_windows.c b/src/osal/lv_windows.c
index 78ac29353..0ad335d3b 100644
--- a/src/osal/lv_windows.c
+++ b/src/osal/lv_windows.c
@@ -44,6 +44,7 @@ static unsigned __stdcall thread_start_routine(void * parameter);
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 lv_result_t lv_thread_init(
     lv_thread_t * thread,
     lv_thread_prio_t prio,
@@ -101,6 +102,7 @@ lv_result_t lv_thread_init(
     return LV_RESULT_OK;
 }
 
+LV_FUNC_SECTION
 lv_result_t lv_thread_delete(lv_thread_t * thread)
 {
     lv_result_t result = LV_RESULT_OK;
@@ -114,36 +116,42 @@ lv_result_t lv_thread_delete(lv_thread_t * thread)
     return result;
 }
 
+LV_FUNC_SECTION
 lv_result_t lv_mutex_init(lv_mutex_t * mutex)
 {
     InitializeCriticalSection(mutex);
     return LV_RESULT_OK;
 }
 
+LV_FUNC_SECTION
 lv_result_t lv_mutex_lock(lv_mutex_t * mutex)
 {
     EnterCriticalSection(mutex);
     return LV_RESULT_OK;
 }
 
+LV_FUNC_SECTION
 lv_result_t lv_mutex_lock_isr(lv_mutex_t * mutex)
 {
     EnterCriticalSection(mutex);
     return LV_RESULT_OK;
 }
 
+LV_FUNC_SECTION
 lv_result_t lv_mutex_unlock(lv_mutex_t * mutex)
 {
     LeaveCriticalSection(mutex);
     return LV_RESULT_OK;
 }
 
+LV_FUNC_SECTION
 lv_result_t lv_mutex_delete(lv_mutex_t * mutex)
 {
     DeleteCriticalSection(mutex);
     return LV_RESULT_OK;
 }
 
+LV_FUNC_SECTION
 lv_result_t lv_thread_sync_init(lv_thread_sync_t * sync)
 {
     if(!sync) {
@@ -157,6 +165,7 @@ lv_result_t lv_thread_sync_init(lv_thread_sync_t * sync)
     return LV_RESULT_OK;
 }
 
+LV_FUNC_SECTION
 lv_result_t lv_thread_sync_wait(lv_thread_sync_t * sync)
 {
     if(!sync) {
@@ -173,6 +182,7 @@ lv_result_t lv_thread_sync_wait(lv_thread_sync_t * sync)
     return LV_RESULT_OK;
 }
 
+LV_FUNC_SECTION
 lv_result_t lv_thread_sync_signal(lv_thread_sync_t * sync)
 {
     if(!sync) {
@@ -187,6 +197,7 @@ lv_result_t lv_thread_sync_signal(lv_thread_sync_t * sync)
     return LV_RESULT_OK;
 }
 
+LV_FUNC_SECTION
 lv_result_t lv_thread_sync_delete(lv_thread_sync_t * sync)
 {
     if(!sync) {
@@ -198,6 +209,7 @@ lv_result_t lv_thread_sync_delete(lv_thread_sync_t * sync)
     return LV_RESULT_OK;
 }
 
+LV_FUNC_SECTION
 lv_result_t lv_thread_sync_signal_isr(lv_thread_sync_t * sync)
 {
     LV_UNUSED(sync);
@@ -208,6 +220,7 @@ lv_result_t lv_thread_sync_signal_isr(lv_thread_sync_t * sync)
  *   STATIC FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 static unsigned __stdcall thread_start_routine(void * parameter)
 {
     lv_thread_init_data_t * init_data = (lv_thread_init_data_t *)(parameter);
diff --git a/src/others/file_explorer/lv_file_explorer.c b/src/others/file_explorer/lv_file_explorer.c
index bb0220c89..9fd41fc17 100644
--- a/src/others/file_explorer/lv_file_explorer.c
+++ b/src/others/file_explorer/lv_file_explorer.c
@@ -68,6 +68,7 @@ const lv_obj_class_t lv_file_explorer_class = {
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 lv_obj_t * lv_file_explorer_create(lv_obj_t * parent)
 {
     LV_LOG_INFO("begin");
@@ -80,6 +81,7 @@ lv_obj_t * lv_file_explorer_create(lv_obj_t * parent)
  * Setter functions
  *====================*/
 #if LV_FILE_EXPLORER_QUICK_ACCESS
+LV_FUNC_SECTION
 void lv_file_explorer_set_quick_access_path(lv_obj_t * obj, lv_file_explorer_dir_t dir, const char * path)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -127,6 +129,7 @@ void lv_file_explorer_set_quick_access_path(lv_obj_t * obj, lv_file_explorer_dir
 
 #endif
 
+LV_FUNC_SECTION
 void lv_file_explorer_set_sort(lv_obj_t * obj, lv_file_explorer_sort_t sort)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -141,6 +144,7 @@ void lv_file_explorer_set_sort(lv_obj_t * obj, lv_file_explorer_sort_t sort)
 /*=====================
  * Getter functions
  *====================*/
+LV_FUNC_SECTION
 const char * lv_file_explorer_get_selected_file_name(const lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -150,6 +154,7 @@ const char * lv_file_explorer_get_selected_file_name(const lv_obj_t * obj)
     return explorer->sel_fn;
 }
 
+LV_FUNC_SECTION
 const char * lv_file_explorer_get_current_path(const lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -159,6 +164,7 @@ const char * lv_file_explorer_get_current_path(const lv_obj_t * obj)
     return explorer->current_path;
 }
 
+LV_FUNC_SECTION
 lv_obj_t * lv_file_explorer_get_file_table(lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -168,6 +174,7 @@ lv_obj_t * lv_file_explorer_get_file_table(lv_obj_t * obj)
     return explorer->file_table;
 }
 
+LV_FUNC_SECTION
 lv_obj_t * lv_file_explorer_get_header(lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -177,6 +184,7 @@ lv_obj_t * lv_file_explorer_get_header(lv_obj_t * obj)
     return explorer->head_area;
 }
 
+LV_FUNC_SECTION
 lv_obj_t * lv_file_explorer_get_path_label(lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -187,6 +195,7 @@ lv_obj_t * lv_file_explorer_get_path_label(lv_obj_t * obj)
 }
 
 #if LV_FILE_EXPLORER_QUICK_ACCESS
+LV_FUNC_SECTION
 lv_obj_t * lv_file_explorer_get_quick_access_area(lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -196,6 +205,7 @@ lv_obj_t * lv_file_explorer_get_quick_access_area(lv_obj_t * obj)
     return explorer->quick_access_area;
 }
 
+LV_FUNC_SECTION
 lv_obj_t * lv_file_explorer_get_places_list(lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -205,6 +215,7 @@ lv_obj_t * lv_file_explorer_get_places_list(lv_obj_t * obj)
     return explorer->list_places;
 }
 
+LV_FUNC_SECTION
 lv_obj_t * lv_file_explorer_get_device_list(lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -216,6 +227,7 @@ lv_obj_t * lv_file_explorer_get_device_list(lv_obj_t * obj)
 
 #endif
 
+LV_FUNC_SECTION
 lv_file_explorer_sort_t lv_file_explorer_get_sort(const lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -228,6 +240,7 @@ lv_file_explorer_sort_t lv_file_explorer_get_sort(const lv_obj_t * obj)
 /*=====================
  * Other functions
  *====================*/
+LV_FUNC_SECTION
 void lv_file_explorer_open_dir(lv_obj_t * obj, const char * dir)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -238,6 +251,7 @@ void lv_file_explorer_open_dir(lv_obj_t * obj, const char * dir)
 /**********************
  *   STATIC FUNCTIONS
  **********************/
+LV_FUNC_SECTION
 static void lv_file_explorer_constructor(const lv_obj_class_t * class_p, lv_obj_t * obj)
 {
     LV_UNUSED(class_p);
@@ -337,6 +351,7 @@ static void lv_file_explorer_constructor(const lv_obj_class_t * class_p, lv_obj_
     LV_TRACE_OBJ_CREATE("finished");
 }
 
+LV_FUNC_SECTION
 static void init_style(lv_obj_t * obj)
 {
     lv_file_explorer_t * explorer = (lv_file_explorer_t *)obj;
@@ -420,6 +435,7 @@ static void init_style(lv_obj_t * obj)
 }
 
 #if LV_FILE_EXPLORER_QUICK_ACCESS
+__attribute__(( fptrgroup("lv_event_cb") ))
 static void quick_access_event_handler(lv_event_t * e)
 {
     lv_event_code_t code = lv_event_get_code(e);
@@ -457,6 +473,7 @@ static void quick_access_event_handler(lv_event_t * e)
     }
 }
 
+__attribute__(( fptrgroup("lv_event_cb") ))
 static void quick_access_area_event_handler(lv_event_t * e)
 {
     lv_event_code_t code = lv_event_get_code(e);
@@ -474,6 +491,7 @@ static void quick_access_area_event_handler(lv_event_t * e)
 }
 #endif
 
+__attribute__(( fptrgroup("lv_event_cb") ))
 static void browser_file_event_handler(lv_event_t * e)
 {
     lv_event_code_t code = lv_event_get_code(e);
@@ -526,6 +544,7 @@ static void browser_file_event_handler(lv_event_t * e)
     }
 }
 
+LV_FUNC_SECTION
 static void show_dir(lv_obj_t * obj, const char * path)
 {
     lv_file_explorer_t * explorer = (lv_file_explorer_t *)obj;
@@ -610,6 +629,7 @@ static void show_dir(lv_obj_t * obj, const char * path)
 }
 
 /*Remove the specified suffix*/
+LV_FUNC_SECTION
 static void strip_ext(char * dir)
 {
     char * end = dir + lv_strlen(dir);
@@ -626,6 +646,7 @@ static void strip_ext(char * dir)
     }
 }
 
+LV_FUNC_SECTION
 static void exch_table_item(lv_obj_t * tb, int16_t i, int16_t j)
 {
     const char * tmp;
@@ -640,6 +661,7 @@ static void exch_table_item(lv_obj_t * tb, int16_t i, int16_t j)
     lv_table_set_cell_value(tb, j, 1, lv_table_get_cell_value(tb, 0, 2));
 }
 
+LV_FUNC_SECTION
 static void file_explorer_sort(lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -662,6 +684,7 @@ static void file_explorer_sort(lv_obj_t * obj)
 }
 
 /*Quick sort 3 way*/
+LV_FUNC_SECTION
 static void sort_by_file_kind(lv_obj_t * tb, int16_t lo, int16_t hi)
 {
     if(lo >= hi) return;
@@ -683,6 +706,7 @@ static void sort_by_file_kind(lv_obj_t * tb, int16_t lo, int16_t hi)
     sort_by_file_kind(tb, gt + 1, hi);
 }
 
+LV_FUNC_SECTION
 static bool is_end_with(const char * str1, const char * str2)
 {
     if(str1 == NULL || str2 == NULL)
diff --git a/src/others/fragment/lv_fragment.c b/src/others/fragment/lv_fragment.c
index 6deb4e785..6b762c738 100644
--- a/src/others/fragment/lv_fragment.c
+++ b/src/others/fragment/lv_fragment.c
@@ -22,6 +22,7 @@ static void cb_delete_assertion(lv_event_t * event);
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 lv_fragment_t * lv_fragment_create(const lv_fragment_class_t * cls, void * args)
 {
     LV_ASSERT_NULL(cls);
@@ -36,6 +37,7 @@ lv_fragment_t * lv_fragment_create(const lv_fragment_class_t * cls, void * args)
     return instance;
 }
 
+LV_FUNC_SECTION
 void lv_fragment_delete(lv_fragment_t * fragment)
 {
     LV_ASSERT_NULL(fragment);
@@ -55,6 +57,7 @@ void lv_fragment_delete(lv_fragment_t * fragment)
     lv_free(fragment);
 }
 
+LV_FUNC_SECTION
 lv_fragment_manager_t * lv_fragment_get_manager(lv_fragment_t * fragment)
 {
     LV_ASSERT_NULL(fragment);
@@ -62,6 +65,7 @@ lv_fragment_manager_t * lv_fragment_get_manager(lv_fragment_t * fragment)
     return fragment->managed->manager;
 }
 
+LV_FUNC_SECTION
 lv_obj_t * const * lv_fragment_get_container(lv_fragment_t * fragment)
 {
     LV_ASSERT_NULL(fragment);
@@ -69,6 +73,7 @@ lv_obj_t * const * lv_fragment_get_container(lv_fragment_t * fragment)
     return fragment->managed->container;
 }
 
+LV_FUNC_SECTION
 lv_fragment_t * lv_fragment_get_parent(lv_fragment_t * fragment)
 {
     LV_ASSERT_NULL(fragment);
@@ -76,6 +81,7 @@ lv_fragment_t * lv_fragment_get_parent(lv_fragment_t * fragment)
     return lv_fragment_manager_get_parent_fragment(fragment->managed->manager);
 }
 
+LV_FUNC_SECTION
 lv_obj_t * lv_fragment_create_obj(lv_fragment_t * fragment, lv_obj_t * container)
 {
     lv_fragment_managed_states_t * states = fragment->managed;
@@ -97,6 +103,7 @@ lv_obj_t * lv_fragment_create_obj(lv_fragment_t * fragment, lv_obj_t * container
     return obj;
 }
 
+LV_FUNC_SECTION
 void lv_fragment_delete_obj(lv_fragment_t * fragment)
 {
     LV_ASSERT_NULL(fragment);
@@ -134,6 +141,7 @@ void lv_fragment_delete_obj(lv_fragment_t * fragment)
     fragment->obj = NULL;
 }
 
+LV_FUNC_SECTION
 void lv_fragment_recreate_obj(lv_fragment_t * fragment)
 {
     LV_ASSERT_NULL(fragment);
@@ -145,7 +153,7 @@ void lv_fragment_recreate_obj(lv_fragment_t * fragment)
 /**********************
  *   STATIC FUNCTIONS
  **********************/
-
+__attribute__(( fptrgroup("lv_event_cb") ))
 static void cb_delete_assertion(lv_event_t * event)
 {
     LV_UNUSED(event);
diff --git a/src/others/fragment/lv_fragment.h b/src/others/fragment/lv_fragment.h
index f93473757..468d53264 100644
--- a/src/others/fragment/lv_fragment.h
+++ b/src/others/fragment/lv_fragment.h
@@ -55,24 +55,28 @@ struct lv_fragment_class_t {
      * @param self Fragment instance
      * @param args Arguments assigned by fragment manager
      */
+    __attribute__(( fptrgroup("lv_fragment_constructor_cb") ))
     void (*constructor_cb)(lv_fragment_t * self, void * args);
 
     /**
      * Destructor function for fragment class
      * @param self Fragment instance, will be freed after this call
      */
+    __attribute__(( fptrgroup("lv_fragment_destructor_cb") ))
     void (*destructor_cb)(lv_fragment_t * self);
 
     /**
      * Fragment attached to manager
      * @param self Fragment instance
      */
+    __attribute__(( fptrgroup("lv_fragment_attached_cb") ))
     void (*attached_cb)(lv_fragment_t * self);
 
     /**
      * Fragment detached from manager
      * @param self Fragment instance
      */
+    __attribute__(( fptrgroup("lv_event_cb") ))
     void (*detached_cb)(lv_fragment_t * self);
 
     /**
@@ -81,6 +85,7 @@ struct lv_fragment_class_t {
      * @param container Container of the objects should be created upon
      * @return Created object, NULL if multiple objects has been created
      */
+    __attribute__(( fptrgroup("lv_fragment_create_obj_cb") ))
     lv_obj_t * (*create_obj_cb)(lv_fragment_t * self, lv_obj_t * container);
 
     /**
@@ -88,6 +93,7 @@ struct lv_fragment_class_t {
      * @param self Fragment instance
      * @param obj lv_obj returned by create_obj_cb
      */
+    __attribute__(( fptrgroup("lv_fragment_obj_created_cb") ))
     void (*obj_created_cb)(lv_fragment_t * self, lv_obj_t * obj);
 
     /**
@@ -96,6 +102,7 @@ struct lv_fragment_class_t {
      * @param self Fragment instance
      * @param obj object with this fragment
      */
+    __attribute__(( fptrgroup("lv_fragment_obj_will_delete_cb") ))
     void (*obj_will_delete_cb)(lv_fragment_t * self, lv_obj_t * obj);
 
     /**
@@ -103,6 +110,7 @@ struct lv_fragment_class_t {
      * @param self Fragment instance
      * @param obj object with this fragment
      */
+    __attribute__(( fptrgroup("lv_fragment_obj_deleted_cb") ))
     void (*obj_deleted_cb)(lv_fragment_t * self, lv_obj_t * obj);
 
     /**
@@ -112,6 +120,7 @@ struct lv_fragment_class_t {
      * @param data1 User-defined data
      * @param data2 User-defined data
      */
+    __attribute__(( fptrgroup("lv_fragment_event_cb") ))
     bool (*event_cb)(lv_fragment_t * self, int code, void * userdata);
 
     /**
diff --git a/src/others/fragment/lv_fragment_manager.c b/src/others/fragment/lv_fragment_manager.c
index a8565185b..7577f3f55 100644
--- a/src/others/fragment/lv_fragment_manager.c
+++ b/src/others/fragment/lv_fragment_manager.c
@@ -62,6 +62,7 @@ static lv_fragment_managed_states_t * fragment_attach(lv_fragment_manager_t * ma
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 lv_fragment_manager_t * lv_fragment_manager_create(lv_fragment_t * parent)
 {
     lv_fragment_manager_t * instance = lv_malloc_zeroed(sizeof(lv_fragment_manager_t));
@@ -71,6 +72,7 @@ lv_fragment_manager_t * lv_fragment_manager_create(lv_fragment_t * parent)
     return instance;
 }
 
+LV_FUNC_SECTION
 void lv_fragment_manager_delete(lv_fragment_manager_t * manager)
 {
     LV_ASSERT_NULL(manager);
@@ -84,6 +86,7 @@ void lv_fragment_manager_delete(lv_fragment_manager_t * manager)
     lv_free(manager);
 }
 
+LV_FUNC_SECTION
 void lv_fragment_manager_create_obj(lv_fragment_manager_t * manager)
 {
     LV_ASSERT_NULL(manager);
@@ -98,6 +101,7 @@ void lv_fragment_manager_create_obj(lv_fragment_manager_t * manager)
     }
 }
 
+LV_FUNC_SECTION
 void lv_fragment_manager_delete_obj(lv_fragment_manager_t * manager)
 {
     LV_ASSERT_NULL(manager);
@@ -107,6 +111,7 @@ void lv_fragment_manager_delete_obj(lv_fragment_manager_t * manager)
     }
 }
 
+LV_FUNC_SECTION
 void lv_fragment_manager_add(lv_fragment_manager_t * manager, lv_fragment_t * fragment, lv_obj_t * const * container)
 {
     lv_fragment_managed_states_t * states = fragment_attach(manager, fragment, container);
@@ -115,6 +120,7 @@ void lv_fragment_manager_add(lv_fragment_manager_t * manager, lv_fragment_t * fr
     }
 }
 
+LV_FUNC_SECTION
 void lv_fragment_manager_remove(lv_fragment_manager_t * manager, lv_fragment_t * fragment)
 {
     LV_ASSERT_NULL(manager);
@@ -150,6 +156,7 @@ void lv_fragment_manager_remove(lv_fragment_manager_t * manager, lv_fragment_t *
     }
 }
 
+LV_FUNC_SECTION
 void lv_fragment_manager_push(lv_fragment_manager_t * manager, lv_fragment_t * fragment, lv_obj_t * const * container)
 {
     lv_fragment_stack_item_t * top = lv_ll_get_tail(&manager->stack);
@@ -165,6 +172,7 @@ void lv_fragment_manager_push(lv_fragment_manager_t * manager, lv_fragment_t * f
     item_create_obj(states);
 }
 
+LV_FUNC_SECTION
 bool lv_fragment_manager_pop(lv_fragment_manager_t * manager)
 {
     lv_fragment_t * top = lv_fragment_manager_get_top(manager);
@@ -173,6 +181,7 @@ bool lv_fragment_manager_pop(lv_fragment_manager_t * manager)
     return true;
 }
 
+LV_FUNC_SECTION
 void lv_fragment_manager_replace(lv_fragment_manager_t * manager, lv_fragment_t * fragment,
                                  lv_obj_t * const * container)
 {
@@ -183,6 +192,7 @@ void lv_fragment_manager_replace(lv_fragment_manager_t * manager, lv_fragment_t
     lv_fragment_manager_add(manager, fragment, container);
 }
 
+LV_FUNC_SECTION
 bool lv_fragment_manager_send_event(lv_fragment_manager_t * manager, int code, void * userdata)
 {
     LV_ASSERT_NULL(manager);
@@ -197,12 +207,14 @@ bool lv_fragment_manager_send_event(lv_fragment_manager_t * manager, int code, v
     return false;
 }
 
+LV_FUNC_SECTION
 size_t lv_fragment_manager_get_stack_size(lv_fragment_manager_t * manager)
 {
     LV_ASSERT_NULL(manager);
     return lv_ll_get_len(&manager->stack);
 }
 
+LV_FUNC_SECTION
 lv_fragment_t * lv_fragment_manager_get_top(lv_fragment_manager_t * manager)
 {
     LV_ASSERT(manager);
@@ -211,6 +223,7 @@ lv_fragment_t * lv_fragment_manager_get_top(lv_fragment_manager_t * manager)
     return top->states->instance;
 }
 
+LV_FUNC_SECTION
 lv_fragment_t * lv_fragment_manager_find_by_container(lv_fragment_manager_t * manager, const lv_obj_t * container)
 {
     LV_ASSERT(manager);
@@ -221,6 +234,7 @@ lv_fragment_t * lv_fragment_manager_find_by_container(lv_fragment_manager_t * ma
     return NULL;
 }
 
+LV_FUNC_SECTION
 lv_fragment_t * lv_fragment_manager_get_parent_fragment(lv_fragment_manager_t * manager)
 {
     LV_ASSERT_NULL(manager);
@@ -231,12 +245,14 @@ lv_fragment_t * lv_fragment_manager_get_parent_fragment(lv_fragment_manager_t *
  *   STATIC FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 static void item_create_obj(lv_fragment_managed_states_t * item)
 {
     LV_ASSERT(item->instance);
     lv_fragment_create_obj(item->instance, item->container ? *item->container : NULL);
 }
 
+LV_FUNC_SECTION
 static void item_delete_obj(lv_fragment_managed_states_t * item)
 {
     lv_fragment_delete_obj(item->instance);
@@ -246,6 +262,7 @@ static void item_delete_obj(lv_fragment_managed_states_t * item)
  * Detach, then destroy fragment
  * @param item fragment states
  */
+LV_FUNC_SECTION
 static void item_delete_fragment(lv_fragment_managed_states_t * item)
 {
     lv_fragment_t * instance = item->instance;
@@ -257,6 +274,7 @@ static void item_delete_fragment(lv_fragment_managed_states_t * item)
     item->instance = NULL;
 }
 
+LV_FUNC_SECTION
 static lv_fragment_managed_states_t * fragment_attach(lv_fragment_manager_t * manager, lv_fragment_t * fragment,
                                                       lv_obj_t * const * container)
 {
diff --git a/src/others/gridnav/lv_gridnav.c b/src/others/gridnav/lv_gridnav.c
index 5f348af58..b30c5f3d3 100644
--- a/src/others/gridnav/lv_gridnav.c
+++ b/src/others/gridnav/lv_gridnav.c
@@ -60,6 +60,7 @@ static int32_t get_y_center(lv_obj_t * obj);
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 void lv_gridnav_add(lv_obj_t * obj, lv_gridnav_ctrl_t ctrl)
 {
     lv_gridnav_remove(obj); /*Be sure to not add gridnav twice*/
@@ -73,6 +74,7 @@ void lv_gridnav_add(lv_obj_t * obj, lv_gridnav_ctrl_t ctrl)
     lv_obj_remove_flag(obj, LV_OBJ_FLAG_SCROLL_WITH_ARROW);
 }
 
+LV_FUNC_SECTION
 void lv_gridnav_remove(lv_obj_t * obj)
 {
     lv_event_dsc_t * event_dsc = NULL;
@@ -89,6 +91,7 @@ void lv_gridnav_remove(lv_obj_t * obj)
 
 }
 
+LV_FUNC_SECTION
 void lv_gridnav_set_focused(lv_obj_t * cont, lv_obj_t * to_focus, lv_anim_enable_t anim_en)
 {
     LV_ASSERT_NULL(to_focus);
@@ -127,7 +130,7 @@ void lv_gridnav_set_focused(lv_obj_t * cont, lv_obj_t * to_focus, lv_anim_enable
 /**********************
  *   STATIC FUNCTIONS
  **********************/
-
+__attribute__(( fptrgroup("lv_event_cb") ))
 static void gridnav_event_cb(lv_event_t * e)
 {
     lv_obj_t * obj = lv_event_get_current_target(e);
@@ -287,6 +290,7 @@ static void gridnav_event_cb(lv_event_t * e)
     }
 }
 
+LV_FUNC_SECTION
 static lv_obj_t * find_chid(lv_obj_t * obj, lv_obj_t * start_child, find_mode_t mode)
 {
     int32_t x_start = get_x_center(start_child);
@@ -357,6 +361,7 @@ static lv_obj_t * find_chid(lv_obj_t * obj, lv_obj_t * start_child, find_mode_t
     return guess;
 }
 
+LV_FUNC_SECTION
 static lv_obj_t * find_first_focusable(lv_obj_t * obj)
 {
     uint32_t child_cnt = lv_obj_get_child_count(obj);
@@ -369,6 +374,7 @@ static lv_obj_t * find_first_focusable(lv_obj_t * obj)
     return NULL;
 }
 
+LV_FUNC_SECTION
 static lv_obj_t * find_last_focusable(lv_obj_t * obj)
 {
     uint32_t child_cnt = lv_obj_get_child_count(obj);
@@ -380,6 +386,7 @@ static lv_obj_t * find_last_focusable(lv_obj_t * obj)
     return NULL;
 }
 
+LV_FUNC_SECTION
 static bool obj_is_focusable(lv_obj_t * obj)
 {
     if(lv_obj_has_flag(obj, LV_OBJ_FLAG_HIDDEN)) return false;
@@ -387,11 +394,13 @@ static bool obj_is_focusable(lv_obj_t * obj)
     else return false;
 }
 
+LV_FUNC_SECTION
 static int32_t get_x_center(lv_obj_t * obj)
 {
     return obj->coords.x1 + lv_area_get_width(&obj->coords) / 2;
 }
 
+LV_FUNC_SECTION
 static int32_t get_y_center(lv_obj_t * obj)
 {
     return obj->coords.y1 + lv_area_get_height(&obj->coords) / 2;
diff --git a/src/others/ime/lv_ime_pinyin.c b/src/others/ime/lv_ime_pinyin.c
index 8382269b7..053721390 100644
--- a/src/others/ime/lv_ime_pinyin.c
+++ b/src/others/ime/lv_ime_pinyin.c
@@ -410,6 +410,7 @@ static const lv_pinyin_dict_t lv_ime_pinyin_def_dict[] = {
 /**********************
  *   GLOBAL FUNCTIONS
  **********************/
+LV_FUNC_SECTION
 lv_obj_t * lv_ime_pinyin_create(lv_obj_t * parent)
 {
     LV_LOG_INFO("begin");
@@ -422,6 +423,7 @@ lv_obj_t * lv_ime_pinyin_create(lv_obj_t * parent)
  * Setter functions
  *====================*/
 
+LV_FUNC_SECTION
 void lv_ime_pinyin_set_keyboard(lv_obj_t * obj, lv_obj_t * kb)
 {
     if(kb) {
@@ -438,6 +440,7 @@ void lv_ime_pinyin_set_keyboard(lv_obj_t * obj, lv_obj_t * kb)
     lv_obj_align_to(pinyin_ime->cand_panel, pinyin_ime->kb, LV_ALIGN_OUT_TOP_MID, 0, 0);
 }
 
+LV_FUNC_SECTION
 void lv_ime_pinyin_set_dict(lv_obj_t * obj, lv_pinyin_dict_t * dict)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -445,6 +448,7 @@ void lv_ime_pinyin_set_dict(lv_obj_t * obj, lv_pinyin_dict_t * dict)
     init_pinyin_dict(obj, dict);
 }
 
+LV_FUNC_SECTION
 void lv_ime_pinyin_set_mode(lv_obj_t * obj, lv_ime_pinyin_mode_t mode)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -468,6 +472,7 @@ void lv_ime_pinyin_set_mode(lv_obj_t * obj, lv_ime_pinyin_mode_t mode)
  * Getter functions
  *====================*/
 
+LV_FUNC_SECTION
 lv_obj_t * lv_ime_pinyin_get_kb(lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -477,6 +482,7 @@ lv_obj_t * lv_ime_pinyin_get_kb(lv_obj_t * obj)
     return pinyin_ime->kb;
 }
 
+LV_FUNC_SECTION
 lv_obj_t * lv_ime_pinyin_get_cand_panel(lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -486,6 +492,7 @@ lv_obj_t * lv_ime_pinyin_get_cand_panel(lv_obj_t * obj)
     return pinyin_ime->cand_panel;
 }
 
+LV_FUNC_SECTION
 const lv_pinyin_dict_t * lv_ime_pinyin_get_dict(lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -503,6 +510,7 @@ const lv_pinyin_dict_t * lv_ime_pinyin_get_dict(lv_obj_t * obj)
  *   STATIC FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 static void lv_ime_pinyin_constructor(const lv_obj_class_t * class_p, lv_obj_t * obj)
 {
     LV_UNUSED(class_p);
@@ -588,6 +596,7 @@ static void lv_ime_pinyin_constructor(const lv_obj_class_t * class_p, lv_obj_t *
 #endif
 }
 
+LV_FUNC_SECTION
 static void lv_ime_pinyin_destructor(const lv_obj_class_t * class_p, lv_obj_t * obj)
 {
     LV_UNUSED(class_p);
@@ -601,6 +610,7 @@ static void lv_ime_pinyin_destructor(const lv_obj_class_t * class_p, lv_obj_t *
         lv_obj_delete(pinyin_ime->cand_panel);
 }
 
+__attribute__(( fptrgroup("lv_event_cb") ))
 static void lv_ime_pinyin_kb_event(lv_event_t * e)
 {
     lv_event_code_t code = lv_event_get_code(e);
@@ -738,6 +748,7 @@ static void lv_ime_pinyin_kb_event(lv_event_t * e)
     }
 }
 
+__attribute__(( fptrgroup("lv_event_cb") ))
 static void lv_ime_pinyin_cand_panel_event(lv_event_t * e)
 {
     lv_event_code_t code = lv_event_get_code(e);
@@ -774,6 +785,7 @@ static void lv_ime_pinyin_cand_panel_event(lv_event_t * e)
     }
 }
 
+LV_FUNC_SECTION
 static void pinyin_input_proc(lv_obj_t * obj)
 {
     lv_ime_pinyin_t * pinyin_ime = (lv_ime_pinyin_t *)obj;
@@ -800,6 +812,7 @@ static void pinyin_input_proc(lv_obj_t * obj)
     lv_obj_remove_flag(pinyin_ime->cand_panel, LV_OBJ_FLAG_HIDDEN);
 }
 
+LV_FUNC_SECTION
 static void pinyin_page_proc(lv_obj_t * obj, uint16_t dir)
 {
     lv_ime_pinyin_t * pinyin_ime = (lv_ime_pinyin_t *)obj;
@@ -841,6 +854,7 @@ static void pinyin_page_proc(lv_obj_t * obj, uint16_t dir)
     }
 }
 
+__attribute__(( fptrgroup("lv_event_cb") ))
 static void lv_ime_pinyin_style_change_event(lv_event_t * e)
 {
     lv_event_code_t code = lv_event_get_code(e);
@@ -854,6 +868,7 @@ static void lv_ime_pinyin_style_change_event(lv_event_t * e)
     }
 }
 
+LV_FUNC_SECTION
 static void init_pinyin_dict(lv_obj_t * obj, const lv_pinyin_dict_t * dict)
 {
     lv_ime_pinyin_t * pinyin_ime = (lv_ime_pinyin_t *)obj;
@@ -888,6 +903,7 @@ static void init_pinyin_dict(lv_obj_t * obj, const lv_pinyin_dict_t * dict)
     }
 }
 
+LV_FUNC_SECTION
 static char * pinyin_search_matching(lv_obj_t * obj, char * py_str, uint16_t * cand_num)
 {
     lv_ime_pinyin_t * pinyin_ime = (lv_ime_pinyin_t *)obj;
@@ -926,6 +942,7 @@ static char * pinyin_search_matching(lv_obj_t * obj, char * py_str, uint16_t * c
     return NULL;
 }
 
+LV_FUNC_SECTION
 static void pinyin_ime_clear_data(lv_obj_t * obj)
 {
     lv_ime_pinyin_t * pinyin_ime = (lv_ime_pinyin_t *)obj;
@@ -957,6 +974,7 @@ static void pinyin_ime_clear_data(lv_obj_t * obj)
 }
 
 #if LV_IME_PINYIN_USE_K9_MODE
+LV_FUNC_SECTION
 static void pinyin_k9_init_data(lv_obj_t * obj)
 {
     LV_UNUSED(obj);
@@ -989,6 +1007,7 @@ static void pinyin_k9_init_data(lv_obj_t * obj)
     default_kb_ctrl_k9_map[LV_IME_PINYIN_K9_CAND_TEXT_NUM + 16] = LV_BUTTONMATRIX_CTRL_CHECKED | 1;
 }
 
+LV_FUNC_SECTION
 static void pinyin_k9_get_legal_py(lv_obj_t * obj, char * k9_input, const char * py9_map[])
 {
     lv_ime_pinyin_t * pinyin_ime = (lv_ime_pinyin_t *)obj;
@@ -1047,6 +1066,7 @@ static void pinyin_k9_get_legal_py(lv_obj_t * obj, char * k9_input, const char *
 }
 
 /*true: visible; false: not visible*/
+LV_FUNC_SECTION
 static bool pinyin_k9_is_valid_py(lv_obj_t * obj, char * py_str)
 {
     lv_ime_pinyin_t * pinyin_ime = (lv_ime_pinyin_t *)obj;
@@ -1082,6 +1102,7 @@ static bool pinyin_k9_is_valid_py(lv_obj_t * obj, char * py_str)
     return false;
 }
 
+LV_FUNC_SECTION
 static void pinyin_k9_fill_cand(lv_obj_t * obj)
 {
     uint16_t index = 0, tmp_len = 0;
@@ -1126,6 +1147,7 @@ static void pinyin_k9_fill_cand(lv_obj_t * obj)
     lv_textarea_add_text(ta, pinyin_ime->input_char);
 }
 
+LV_FUNC_SECTION
 static void pinyin_k9_cand_page_proc(lv_obj_t * obj, uint16_t dir)
 {
     lv_ime_pinyin_t * pinyin_ime = (lv_ime_pinyin_t *)obj;
diff --git a/src/others/imgfont/lv_imgfont.c b/src/others/imgfont/lv_imgfont.c
index edc69907d..00c614b23 100644
--- a/src/others/imgfont/lv_imgfont.c
+++ b/src/others/imgfont/lv_imgfont.c
@@ -45,6 +45,7 @@ static bool imgfont_get_glyph_dsc(const lv_font_t * font, lv_font_glyph_dsc_t *
 /**********************
  *   GLOBAL FUNCTIONS
  **********************/
+LV_FUNC_SECTION
 lv_font_t * lv_imgfont_create(uint16_t height, lv_imgfont_get_path_cb_t path_cb, void * user_data)
 {
     imgfont_dsc_t * dsc = lv_malloc_zeroed(sizeof(imgfont_dsc_t));
@@ -67,6 +68,7 @@ lv_font_t * lv_imgfont_create(uint16_t height, lv_imgfont_get_path_cb_t path_cb,
     return font;
 }
 
+LV_FUNC_SECTION
 void lv_imgfont_destroy(lv_font_t * font)
 {
     LV_ASSERT_NULL(font);
@@ -79,6 +81,7 @@ void lv_imgfont_destroy(lv_font_t * font)
  *   STATIC FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 static const void * imgfont_get_glyph_bitmap(lv_font_glyph_dsc_t * g_dsc, lv_draw_buf_t * draw_buf)
 {
     LV_UNUSED(draw_buf);
@@ -87,6 +90,7 @@ static const void * imgfont_get_glyph_bitmap(lv_font_glyph_dsc_t * g_dsc, lv_dra
     return img_src;
 }
 
+LV_FUNC_SECTION
 static bool imgfont_get_glyph_dsc(const lv_font_t * font, lv_font_glyph_dsc_t * dsc_out,
                                   uint32_t unicode, uint32_t unicode_next)
 {
diff --git a/src/others/monkey/lv_monkey.c b/src/others/monkey/lv_monkey.c
index 97ba10a51..c6dac55a7 100644
--- a/src/others/monkey/lv_monkey.c
+++ b/src/others/monkey/lv_monkey.c
@@ -59,6 +59,7 @@ static void lv_monkey_timer_cb(lv_timer_t * timer);
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 void lv_monkey_config_init(lv_monkey_config_t * config)
 {
     lv_memzero(config, sizeof(lv_monkey_config_t));
@@ -67,6 +68,7 @@ void lv_monkey_config_init(lv_monkey_config_t * config)
     config->period_range.max = MONKEY_PERIOD_RANGE_MAX_DEF;
 }
 
+LV_FUNC_SECTION
 lv_monkey_t * lv_monkey_create(const lv_monkey_config_t * config)
 {
     lv_monkey_t * monkey = lv_malloc_zeroed(sizeof(lv_monkey_t));
@@ -83,36 +85,42 @@ lv_monkey_t * lv_monkey_create(const lv_monkey_config_t * config)
     return monkey;
 }
 
+LV_FUNC_SECTION
 lv_indev_t * lv_monkey_get_indev(lv_monkey_t * monkey)
 {
     LV_ASSERT_NULL(monkey);
     return monkey->indev;
 }
 
+LV_FUNC_SECTION
 void lv_monkey_set_enable(lv_monkey_t * monkey, bool en)
 {
     LV_ASSERT_NULL(monkey);
     en ? lv_timer_resume(monkey->timer) : lv_timer_pause(monkey->timer);
 }
 
+LV_FUNC_SECTION
 bool lv_monkey_get_enable(lv_monkey_t * monkey)
 {
     LV_ASSERT_NULL(monkey);
     return !lv_timer_get_paused(monkey->timer);
 }
 
+LV_FUNC_SECTION
 void lv_monkey_set_user_data(lv_monkey_t * monkey, void * user_data)
 {
     LV_ASSERT_NULL(monkey);
     monkey->user_data = user_data;
 }
 
+LV_FUNC_SECTION
 void * lv_monkey_get_user_data(lv_monkey_t * monkey)
 {
     LV_ASSERT_NULL(monkey);
     return monkey->user_data;
 }
 
+LV_FUNC_SECTION
 void lv_monkey_delete(lv_monkey_t * monkey)
 {
     LV_ASSERT_NULL(monkey);
@@ -126,6 +134,7 @@ void lv_monkey_delete(lv_monkey_t * monkey)
  *   STATIC FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 static void lv_monkey_read_cb(lv_indev_t * indev, lv_indev_data_t * data)
 {
     lv_monkey_t * monkey = lv_indev_get_user_data(indev);
@@ -136,6 +145,7 @@ static void lv_monkey_read_cb(lv_indev_t * indev, lv_indev_data_t * data)
     data->state = monkey->indev_data.state;
 }
 
+LV_FUNC_SECTION
 static int32_t lv_monkey_random(int32_t howsmall, int32_t howbig)
 {
     if(howsmall >= howbig) {
@@ -145,6 +155,7 @@ static int32_t lv_monkey_random(int32_t howsmall, int32_t howbig)
     return (int32_t)lv_rand(0, diff) + howsmall;
 }
 
+LV_FUNC_SECTION
 static void lv_monkey_timer_cb(lv_timer_t * timer)
 {
     lv_monkey_t * monkey = lv_timer_get_user_data(timer);
diff --git a/src/others/observer/lv_observer.c b/src/others/observer/lv_observer.c
index 8d43f52de..8660d7e1d 100644
--- a/src/others/observer/lv_observer.c
+++ b/src/others/observer/lv_observer.c
@@ -74,6 +74,7 @@ static void obj_value_changed_event_cb(lv_event_t * e);
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 void lv_subject_init_int(lv_subject_t * subject, int32_t value)
 {
     lv_memzero(subject, sizeof(lv_subject_t));
@@ -83,6 +84,7 @@ void lv_subject_init_int(lv_subject_t * subject, int32_t value)
     lv_ll_init(&(subject->subs_ll), sizeof(lv_observer_t));
 }
 
+LV_FUNC_SECTION
 void lv_subject_set_int(lv_subject_t * subject, int32_t value)
 {
     if(subject->type != LV_SUBJECT_TYPE_INT) {
@@ -95,6 +97,7 @@ void lv_subject_set_int(lv_subject_t * subject, int32_t value)
     lv_subject_notify(subject);
 }
 
+LV_FUNC_SECTION
 int32_t lv_subject_get_int(lv_subject_t * subject)
 {
     if(subject->type != LV_SUBJECT_TYPE_INT) {
@@ -105,6 +108,7 @@ int32_t lv_subject_get_int(lv_subject_t * subject)
     return subject->value.num;
 }
 
+LV_FUNC_SECTION
 int32_t lv_subject_get_previous_int(lv_subject_t * subject)
 {
     if(subject->type != LV_SUBJECT_TYPE_INT) {
@@ -115,6 +119,7 @@ int32_t lv_subject_get_previous_int(lv_subject_t * subject)
     return subject->prev_value.num;
 }
 
+LV_FUNC_SECTION
 void lv_subject_init_string(lv_subject_t * subject, char * buf, char * prev_buf, size_t size, const char * value)
 {
     lv_memzero(subject, sizeof(lv_subject_t));
@@ -129,6 +134,7 @@ void lv_subject_init_string(lv_subject_t * subject, char * buf, char * prev_buf,
     lv_ll_init(&(subject->subs_ll), sizeof(lv_observer_t));
 }
 
+LV_FUNC_SECTION
 void lv_subject_copy_string(lv_subject_t * subject, const char * buf)
 {
     if(subject->type != LV_SUBJECT_TYPE_STRING) {
@@ -147,6 +153,7 @@ void lv_subject_copy_string(lv_subject_t * subject, const char * buf)
 
 }
 
+LV_FUNC_SECTION
 const char * lv_subject_get_string(lv_subject_t * subject)
 {
     if(subject->type != LV_SUBJECT_TYPE_STRING) {
@@ -157,6 +164,7 @@ const char * lv_subject_get_string(lv_subject_t * subject)
     return subject->value.pointer;
 }
 
+LV_FUNC_SECTION
 const char * lv_subject_get_previous_string(lv_subject_t * subject)
 {
     if(subject->type != LV_SUBJECT_TYPE_STRING) {
@@ -167,6 +175,7 @@ const char * lv_subject_get_previous_string(lv_subject_t * subject)
     return subject->prev_value.pointer;
 }
 
+LV_FUNC_SECTION
 void lv_subject_init_pointer(lv_subject_t * subject, void * value)
 {
     lv_memzero(subject, sizeof(lv_subject_t));
@@ -176,6 +185,7 @@ void lv_subject_init_pointer(lv_subject_t * subject, void * value)
     lv_ll_init(&(subject->subs_ll), sizeof(lv_observer_t));
 }
 
+LV_FUNC_SECTION
 void lv_subject_set_pointer(lv_subject_t * subject, void * ptr)
 {
     if(subject->type != LV_SUBJECT_TYPE_POINTER) {
@@ -188,6 +198,7 @@ void lv_subject_set_pointer(lv_subject_t * subject, void * ptr)
     lv_subject_notify(subject);
 }
 
+LV_FUNC_SECTION
 const void * lv_subject_get_pointer(lv_subject_t * subject)
 {
     if(subject->type != LV_SUBJECT_TYPE_POINTER) {
@@ -198,6 +209,7 @@ const void * lv_subject_get_pointer(lv_subject_t * subject)
     return subject->value.pointer;
 }
 
+LV_FUNC_SECTION
 const void * lv_subject_get_previous_pointer(lv_subject_t * subject)
 {
     if(subject->type != LV_SUBJECT_TYPE_POINTER) {
@@ -208,6 +220,7 @@ const void * lv_subject_get_previous_pointer(lv_subject_t * subject)
     return subject->prev_value.pointer;
 }
 
+LV_FUNC_SECTION
 void lv_subject_init_color(lv_subject_t * subject, lv_color_t color)
 {
     lv_memzero(subject, sizeof(lv_subject_t));
@@ -217,6 +230,7 @@ void lv_subject_init_color(lv_subject_t * subject, lv_color_t color)
     lv_ll_init(&(subject->subs_ll), sizeof(lv_observer_t));
 }
 
+LV_FUNC_SECTION
 void lv_subject_set_color(lv_subject_t * subject, lv_color_t color)
 {
     if(subject->type != LV_SUBJECT_TYPE_COLOR) {
@@ -229,6 +243,7 @@ void lv_subject_set_color(lv_subject_t * subject, lv_color_t color)
     lv_subject_notify(subject);
 }
 
+LV_FUNC_SECTION
 lv_color_t lv_subject_get_color(lv_subject_t * subject)
 {
     if(subject->type != LV_SUBJECT_TYPE_COLOR) {
@@ -239,6 +254,7 @@ lv_color_t lv_subject_get_color(lv_subject_t * subject)
     return subject->value.color;
 }
 
+LV_FUNC_SECTION
 lv_color_t lv_subject_get_previous_color(lv_subject_t * subject)
 {
     if(subject->type != LV_SUBJECT_TYPE_COLOR) {
@@ -249,6 +265,7 @@ lv_color_t lv_subject_get_previous_color(lv_subject_t * subject)
     return subject->prev_value.color;
 }
 
+LV_FUNC_SECTION
 void lv_subject_init_group(lv_subject_t * subject, lv_subject_t * list[], uint32_t list_len)
 {
     subject->type = LV_SUBJECT_TYPE_GROUP;
@@ -264,6 +281,7 @@ void lv_subject_init_group(lv_subject_t * subject, lv_subject_t * list[], uint32
     }
 }
 
+LV_FUNC_SECTION
 void lv_subject_deinit(lv_subject_t * subject)
 {
     lv_observer_t * observer = lv_ll_get_head(&subject->subs_ll);
@@ -282,6 +300,7 @@ void lv_subject_deinit(lv_subject_t * subject)
     lv_ll_clear(&subject->subs_ll);
 }
 
+LV_FUNC_SECTION
 lv_subject_t * lv_subject_get_group_element(lv_subject_t * subject, int32_t index)
 {
     if(subject->type != LV_SUBJECT_TYPE_GROUP) {
@@ -294,6 +313,7 @@ lv_subject_t * lv_subject_get_group_element(lv_subject_t * subject, int32_t inde
     return ((lv_subject_t **)(subject->value.pointer))[index];
 }
 
+LV_FUNC_SECTION
 lv_observer_t * lv_subject_add_observer(lv_subject_t * subject, lv_observer_cb_t cb, void * user_data)
 {
     lv_observer_t * observer = lv_subject_add_observer_obj(subject, cb, NULL, user_data);
@@ -303,6 +323,7 @@ lv_observer_t * lv_subject_add_observer(lv_subject_t * subject, lv_observer_cb_t
     return observer;
 }
 
+LV_FUNC_SECTION
 lv_observer_t * lv_subject_add_observer_obj(lv_subject_t * subject, lv_observer_cb_t cb, lv_obj_t * obj,
                                             void * user_data)
 {
@@ -333,6 +354,7 @@ lv_observer_t * lv_subject_add_observer_obj(lv_subject_t * subject, lv_observer_
     return observer;
 }
 
+LV_FUNC_SECTION
 lv_observer_t * lv_subject_add_observer_with_target(lv_subject_t * subject, lv_observer_cb_t cb, void * target,
                                                     void * user_data)
 {
@@ -359,6 +381,7 @@ lv_observer_t * lv_subject_add_observer_with_target(lv_subject_t * subject, lv_o
 }
 
 
+LV_FUNC_SECTION
 void lv_observer_remove(lv_observer_t * observer)
 {
     LV_ASSERT_NULL(observer);
@@ -373,6 +396,7 @@ void lv_observer_remove(lv_observer_t * observer)
     lv_free(observer);
 }
 
+LV_FUNC_SECTION
 void lv_obj_remove_from_subject(lv_obj_t * obj, lv_subject_t * subject)
 {
     int32_t i;
@@ -389,6 +413,7 @@ void lv_obj_remove_from_subject(lv_obj_t * obj, lv_subject_t * subject)
     }
 }
 
+LV_FUNC_SECTION
 void * lv_observer_get_target(lv_observer_t * observer)
 {
     LV_ASSERT_NULL(observer);
@@ -396,6 +421,7 @@ void * lv_observer_get_target(lv_observer_t * observer)
     return observer->target;
 }
 
+LV_FUNC_SECTION
 void lv_subject_notify(lv_subject_t * subject)
 {
     LV_ASSERT_NULL(subject);
@@ -417,12 +443,14 @@ void lv_subject_notify(lv_subject_t * subject)
     } while(subject->notify_restart_query);
 }
 
+LV_FUNC_SECTION
 lv_observer_t * lv_obj_bind_flag_if_eq(lv_obj_t * obj, lv_subject_t * subject, lv_obj_flag_t flag, int32_t ref_value)
 {
     lv_observer_t * observable = bind_to_bitfield(subject, obj, obj_flag_observer_cb, flag, ref_value, false);
     return observable;
 }
 
+LV_FUNC_SECTION
 lv_observer_t * lv_obj_bind_flag_if_not_eq(lv_obj_t * obj, lv_subject_t * subject, lv_obj_flag_t flag,
                                            int32_t ref_value)
 {
@@ -430,18 +458,21 @@ lv_observer_t * lv_obj_bind_flag_if_not_eq(lv_obj_t * obj, lv_subject_t * subjec
     return observable;
 }
 
+LV_FUNC_SECTION
 lv_observer_t * lv_obj_bind_state_if_eq(lv_obj_t * obj, lv_subject_t * subject, lv_state_t state, int32_t ref_value)
 {
     lv_observer_t * observable = bind_to_bitfield(subject, obj, obj_state_observer_cb, state, ref_value, false);
     return observable;
 }
 
+LV_FUNC_SECTION
 lv_observer_t * lv_obj_bind_state_if_not_eq(lv_obj_t * obj, lv_subject_t * subject, lv_state_t state, int32_t ref_value)
 {
     lv_observer_t * observable = bind_to_bitfield(subject, obj, obj_state_observer_cb, state, ref_value, true);
     return observable;
 }
 
+LV_FUNC_SECTION
 lv_observer_t * lv_obj_bind_checked(lv_obj_t * obj, lv_subject_t * subject)
 {
     lv_observer_t * observable = bind_to_bitfield(subject, obj, obj_state_observer_cb, LV_STATE_CHECKED, 1, false);
@@ -450,6 +481,7 @@ lv_observer_t * lv_obj_bind_checked(lv_obj_t * obj, lv_subject_t * subject)
 }
 
 #if LV_USE_LABEL
+LV_FUNC_SECTION
 lv_observer_t * lv_label_bind_text(lv_obj_t * obj, lv_subject_t * subject, const char * fmt)
 {
     if(fmt == NULL) {
@@ -472,6 +504,7 @@ lv_observer_t * lv_label_bind_text(lv_obj_t * obj, lv_subject_t * subject, const
 #endif /*LV_USE_LABEL*/
 
 #if LV_USE_ARC
+LV_FUNC_SECTION
 lv_observer_t * lv_arc_bind_value(lv_obj_t * obj, lv_subject_t * subject)
 {
     if(subject->type != LV_SUBJECT_TYPE_INT) {
@@ -487,6 +520,7 @@ lv_observer_t * lv_arc_bind_value(lv_obj_t * obj, lv_subject_t * subject)
 #endif /*LV_USE_ARC*/
 
 #if LV_USE_SLIDER
+LV_FUNC_SECTION
 lv_observer_t * lv_slider_bind_value(lv_obj_t * obj, lv_subject_t * subject)
 {
     if(subject->type != LV_SUBJECT_TYPE_INT) {
@@ -503,6 +537,7 @@ lv_observer_t * lv_slider_bind_value(lv_obj_t * obj, lv_subject_t * subject)
 
 #if LV_USE_ROLLER
 
+LV_FUNC_SECTION
 lv_observer_t * lv_roller_bind_value(lv_obj_t * obj, lv_subject_t * subject)
 {
     if(subject->type != LV_SUBJECT_TYPE_INT) {
@@ -520,6 +555,7 @@ lv_observer_t * lv_roller_bind_value(lv_obj_t * obj, lv_subject_t * subject)
 
 #if LV_USE_DROPDOWN
 
+LV_FUNC_SECTION
 lv_observer_t * lv_dropdown_bind_value(lv_obj_t * obj, lv_subject_t * subject)
 {
     if(subject->type != LV_SUBJECT_TYPE_INT) {
@@ -536,11 +572,13 @@ lv_observer_t * lv_dropdown_bind_value(lv_obj_t * obj, lv_subject_t * subject)
 
 #endif /*LV_USE_DROPDOWN*/
 
+LV_FUNC_SECTION
 lv_obj_t * lv_observer_get_target_obj(lv_observer_t * observer)
 {
     return (lv_obj_t *)lv_observer_get_target(observer);
 }
 
+LV_FUNC_SECTION
 void * lv_observer_get_user_data(const lv_observer_t * observer)
 {
     LV_ASSERT_NULL(observer);
@@ -552,6 +590,7 @@ void * lv_observer_get_user_data(const lv_observer_t * observer)
  *   STATIC FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 static void group_notify_cb(lv_observer_t * observer, lv_subject_t * subject)
 {
     LV_UNUSED(subject);
@@ -559,12 +598,14 @@ static void group_notify_cb(lv_observer_t * observer, lv_subject_t * subject)
     lv_subject_notify(subject_group);
 }
 
+__attribute__(( fptrgroup("lv_event_cb") ))
 static void unsubscribe_on_delete_cb(lv_event_t * e)
 {
     lv_observer_t * observer = lv_event_get_user_data(e);
     lv_observer_remove(observer);
 }
 
+LV_FUNC_SECTION
 static lv_observer_t * bind_to_bitfield(lv_subject_t * subject, lv_obj_t * obj, lv_observer_cb_t cb, uint32_t flag,
                                         int32_t ref_value, bool inv)
 {
@@ -588,6 +629,7 @@ static lv_observer_t * bind_to_bitfield(lv_subject_t * subject, lv_obj_t * obj,
     return observable;
 }
 
+LV_FUNC_SECTION
 static void obj_flag_observer_cb(lv_observer_t * observer, lv_subject_t * subject)
 {
     flag_and_cond_t * p = observer->user_data;
@@ -603,6 +645,7 @@ static void obj_flag_observer_cb(lv_observer_t * observer, lv_subject_t * subjec
     }
 }
 
+LV_FUNC_SECTION
 static void obj_state_observer_cb(lv_observer_t * observer, lv_subject_t * subject)
 {
     flag_and_cond_t * p = observer->user_data;
@@ -618,6 +661,7 @@ static void obj_state_observer_cb(lv_observer_t * observer, lv_subject_t * subje
     }
 }
 
+__attribute__(( fptrgroup("lv_event_cb") ))
 static void obj_value_changed_event_cb(lv_event_t * e)
 {
     lv_obj_t * obj = lv_event_get_current_target(e);
@@ -628,6 +672,7 @@ static void obj_value_changed_event_cb(lv_event_t * e)
 
 #if LV_USE_LABEL
 
+LV_FUNC_SECTION
 static void label_text_observer_cb(lv_observer_t * observer, lv_subject_t * subject)
 {
     const char * fmt = observer->user_data;
@@ -654,6 +699,7 @@ static void label_text_observer_cb(lv_observer_t * observer, lv_subject_t * subj
 
 #if LV_USE_ARC
 
+__attribute__(( fptrgroup("lv_event_cb") ))
 static void arc_value_changed_event_cb(lv_event_t * e)
 {
     lv_obj_t * arc = lv_event_get_current_target(e);
@@ -662,6 +708,7 @@ static void arc_value_changed_event_cb(lv_event_t * e)
     lv_subject_set_int(subject, lv_arc_get_value(arc));
 }
 
+LV_FUNC_SECTION
 static void arc_value_observer_cb(lv_observer_t * observer, lv_subject_t * subject)
 {
     lv_arc_set_value(observer->target, subject->value.num);
@@ -671,6 +718,7 @@ static void arc_value_observer_cb(lv_observer_t * observer, lv_subject_t * subje
 
 #if LV_USE_SLIDER
 
+__attribute__(( fptrgroup("lv_event_cb") ))
 static void slider_value_changed_event_cb(lv_event_t * e)
 {
     lv_obj_t * slider = lv_event_get_current_target(e);
@@ -679,6 +727,7 @@ static void slider_value_changed_event_cb(lv_event_t * e)
     lv_subject_set_int(subject, lv_slider_get_value(slider));
 }
 
+LV_FUNC_SECTION
 static void slider_value_observer_cb(lv_observer_t * observer, lv_subject_t * subject)
 {
     lv_slider_set_value(observer->target, subject->value.num, LV_ANIM_OFF);
@@ -688,6 +737,7 @@ static void slider_value_observer_cb(lv_observer_t * observer, lv_subject_t * su
 
 #if LV_USE_ROLLER
 
+__attribute__(( fptrgroup("lv_event_cb") ))
 static void roller_value_changed_event_cb(lv_event_t * e)
 {
     lv_obj_t * roller = lv_event_get_current_target(e);
@@ -696,6 +746,7 @@ static void roller_value_changed_event_cb(lv_event_t * e)
     lv_subject_set_int(subject, lv_roller_get_selected(roller));
 }
 
+LV_FUNC_SECTION
 static void roller_value_observer_cb(lv_observer_t * observer, lv_subject_t * subject)
 {
     if((int32_t)lv_roller_get_selected(observer->target) != subject->value.num) {
@@ -707,6 +758,7 @@ static void roller_value_observer_cb(lv_observer_t * observer, lv_subject_t * su
 
 #if LV_USE_DROPDOWN
 
+__attribute__(( fptrgroup("lv_event_cb") ))
 static void dropdown_value_changed_event_cb(lv_event_t * e)
 {
     lv_obj_t * dropdown = lv_event_get_current_target(e);
@@ -715,6 +767,7 @@ static void dropdown_value_changed_event_cb(lv_event_t * e)
     lv_subject_set_int(subject, lv_dropdown_get_selected(dropdown));
 }
 
+LV_FUNC_SECTION
 static void dropdown_value_observer_cb(lv_observer_t * observer, lv_subject_t * subject)
 {
     lv_dropdown_set_selected(observer->target, subject->value.num);
diff --git a/src/others/observer/lv_observer_private.h b/src/others/observer/lv_observer_private.h
index 04a7992eb..1ab153387 100644
--- a/src/others/observer/lv_observer_private.h
+++ b/src/others/observer/lv_observer_private.h
@@ -31,6 +31,7 @@ extern "C" {
  */
 struct lv_observer_t {
     lv_subject_t * subject;             /**< The observed value */
+    __attribute__(( fptrgroup("lv_observer_cb") ))
     lv_observer_cb_t cb;                /**< Callback that should be called when the value changes*/
     void * target;                      /**< A target for the observer, e.g. a widget or style*/
     void * user_data;                   /**< Additional parameter supplied when subscribing*/
diff --git a/src/others/snapshot/lv_snapshot.c b/src/others/snapshot/lv_snapshot.c
index f3f182b8d..4b3a36e2b 100644
--- a/src/others/snapshot/lv_snapshot.c
+++ b/src/others/snapshot/lv_snapshot.c
@@ -44,6 +44,7 @@
 /**
  * Create a draw buffer for object to store the snapshot image.
  */
+LV_FUNC_SECTION
 lv_draw_buf_t * lv_snapshot_create_draw_buf(lv_obj_t * obj, lv_color_format_t cf)
 {
     lv_obj_update_layout(obj);
@@ -57,6 +58,7 @@ lv_draw_buf_t * lv_snapshot_create_draw_buf(lv_obj_t * obj, lv_color_format_t cf
     return lv_draw_buf_create(w, h, cf, LV_STRIDE_AUTO);
 }
 
+LV_FUNC_SECTION
 lv_result_t lv_snapshot_reshape_draw_buf(lv_obj_t * obj, lv_draw_buf_t * draw_buf)
 {
     lv_obj_update_layout(obj);
@@ -71,6 +73,7 @@ lv_result_t lv_snapshot_reshape_draw_buf(lv_obj_t * obj, lv_draw_buf_t * draw_bu
     return draw_buf == NULL ? LV_RESULT_INVALID : LV_RESULT_OK;
 }
 
+LV_FUNC_SECTION
 lv_result_t lv_snapshot_take_to_draw_buf(lv_obj_t * obj, lv_color_format_t cf, lv_draw_buf_t * draw_buf)
 {
     LV_ASSERT_NULL(obj);
@@ -137,6 +140,7 @@ lv_result_t lv_snapshot_take_to_draw_buf(lv_obj_t * obj, lv_color_format_t cf, l
     return LV_RESULT_OK;
 }
 
+LV_FUNC_SECTION
 lv_draw_buf_t * lv_snapshot_take(lv_obj_t * obj, lv_color_format_t cf)
 {
     LV_ASSERT_NULL(obj);
@@ -151,12 +155,14 @@ lv_draw_buf_t * lv_snapshot_take(lv_obj_t * obj, lv_color_format_t cf)
     return draw_buf;
 }
 
+LV_FUNC_SECTION
 void lv_snapshot_free(lv_image_dsc_t * dsc)
 {
     LV_LOG_WARN("Deprecated API, use lv_draw_buf_destroy directly.");
     lv_draw_buf_destroy((lv_draw_buf_t *)dsc);
 }
 
+LV_FUNC_SECTION
 lv_result_t lv_snapshot_take_to_buf(lv_obj_t * obj, lv_color_format_t cf, lv_image_dsc_t * dsc,
                                     void * buf,
                                     uint32_t buf_size)
diff --git a/src/others/sysmon/lv_sysmon.c b/src/others/sysmon/lv_sysmon.c
index 803ce8c5e..27849ab40 100644
--- a/src/others/sysmon/lv_sysmon.c
+++ b/src/others/sysmon/lv_sysmon.c
@@ -60,6 +60,7 @@
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 void lv_sysmon_builtin_init(void)
 {
 
@@ -70,6 +71,7 @@ void lv_sysmon_builtin_init(void)
 #endif
 }
 
+LV_FUNC_SECTION
 void lv_sysmon_builtin_deinit(void)
 {
 #if LV_USE_MEM_MONITOR
@@ -77,6 +79,7 @@ void lv_sysmon_builtin_deinit(void)
 #endif
 }
 
+LV_FUNC_SECTION
 lv_obj_t * lv_sysmon_create(lv_display_t * disp)
 {
     LV_LOG_INFO("begin");
@@ -97,6 +100,7 @@ lv_obj_t * lv_sysmon_create(lv_display_t * disp)
 
 #if LV_USE_PERF_MONITOR
 
+LV_FUNC_SECTION
 void lv_sysmon_show_performance(lv_display_t * disp)
 {
     if(disp == NULL) disp = lv_display_get_default();
@@ -124,6 +128,7 @@ void lv_sysmon_show_performance(lv_display_t * disp)
 #endif
 }
 
+LV_FUNC_SECTION
 void lv_sysmon_hide_performance(lv_display_t * disp)
 {
     if(disp == NULL) disp = lv_display_get_default();
@@ -139,6 +144,7 @@ void lv_sysmon_hide_performance(lv_display_t * disp)
 
 #if LV_USE_MEM_MONITOR
 
+LV_FUNC_SECTION
 void lv_sysmon_show_memory(lv_display_t * disp)
 {
     if(disp == NULL) disp = lv_display_get_default();
@@ -159,6 +165,7 @@ void lv_sysmon_show_memory(lv_display_t * disp)
     lv_obj_remove_flag(disp->mem_label, LV_OBJ_FLAG_HIDDEN);
 }
 
+LV_FUNC_SECTION
 void lv_sysmon_hide_memory(lv_display_t * disp)
 {
     if(disp == NULL) disp = lv_display_get_default();
@@ -178,6 +185,7 @@ void lv_sysmon_hide_memory(lv_display_t * disp)
 
 #if LV_USE_PERF_MONITOR
 
+__attribute__(( fptrgroup("lv_event_cb") ))
 static void perf_monitor_disp_event_cb(lv_event_t * e)
 {
     lv_display_t * disp = lv_event_get_target(e);
@@ -229,6 +237,7 @@ static void perf_monitor_disp_event_cb(lv_event_t * e)
     }
 }
 
+LV_FUNC_SECTION
 static void perf_update_timer_cb(lv_timer_t * t)
 {
     lv_display_t * disp = lv_timer_get_user_data(t);
@@ -275,6 +284,7 @@ static void perf_update_timer_cb(lv_timer_t * t)
     info->measured.last_report_timestamp = lv_tick_get();
 }
 
+LV_FUNC_SECTION
 static void perf_observer_cb(lv_observer_t * observer, lv_subject_t * subject)
 {
     const lv_sysmon_perf_info_t * perf = lv_subject_get_pointer(subject);
@@ -305,6 +315,7 @@ static void perf_observer_cb(lv_observer_t * observer, lv_subject_t * subject)
 
 #if LV_USE_MEM_MONITOR
 
+LV_FUNC_SECTION
 static void mem_update_timer_cb(lv_timer_t * t)
 {
     lv_mem_monitor_t * mem_mon = lv_timer_get_user_data(t);
@@ -312,6 +323,7 @@ static void mem_update_timer_cb(lv_timer_t * t)
     lv_subject_set_pointer(&sysmon_mem.subject, mem_mon);
 }
 
+LV_FUNC_SECTION
 static void mem_observer_cb(lv_observer_t * observer, lv_subject_t * subject)
 {
     lv_obj_t * label = lv_observer_get_target(observer);
diff --git a/src/others/vg_lite_tvg/vg_lite_matrix.c b/src/others/vg_lite_tvg/vg_lite_matrix.c
index 42f8ce38b..33edd6b48 100644
--- a/src/others/vg_lite_tvg/vg_lite_matrix.c
+++ b/src/others/vg_lite_tvg/vg_lite_matrix.c
@@ -41,6 +41,7 @@
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 vg_lite_error_t vg_lite_identity(vg_lite_matrix_t * matrix)
 {
     /* Set identify matrix. */
@@ -63,6 +64,7 @@ vg_lite_error_t vg_lite_identity(vg_lite_matrix_t * matrix)
     return VG_LITE_SUCCESS;
 }
 
+LV_FUNC_SECTION
 static void multiply(vg_lite_matrix_t * matrix, vg_lite_matrix_t * mult)
 {
     vg_lite_matrix_t temp;
@@ -87,6 +89,7 @@ static void multiply(vg_lite_matrix_t * matrix, vg_lite_matrix_t * mult)
 #endif /* VG_SW_BLIT_PRECISION_OPT */
 }
 
+LV_FUNC_SECTION
 vg_lite_error_t vg_lite_translate(vg_lite_float_t x, vg_lite_float_t y, vg_lite_matrix_t * matrix)
 {
     /* Set translation matrix. */
@@ -103,6 +106,7 @@ vg_lite_error_t vg_lite_translate(vg_lite_float_t x, vg_lite_float_t y, vg_lite_
     return VG_LITE_SUCCESS;
 }
 
+LV_FUNC_SECTION
 vg_lite_error_t vg_lite_scale(vg_lite_float_t scale_x, vg_lite_float_t scale_y, vg_lite_matrix_t * matrix)
 {
     /* Set scale matrix. */
@@ -124,6 +128,7 @@ vg_lite_error_t vg_lite_scale(vg_lite_float_t scale_x, vg_lite_float_t scale_y,
     return VG_LITE_SUCCESS;
 }
 
+LV_FUNC_SECTION
 vg_lite_error_t vg_lite_rotate(vg_lite_float_t degrees, vg_lite_matrix_t * matrix)
 {
     /* Convert degrees into radians. */
diff --git a/src/stdlib/builtin/lv_mem_core_builtin.c b/src/stdlib/builtin/lv_mem_core_builtin.c
index 23a218154..a2398ffc0 100644
--- a/src/stdlib/builtin/lv_mem_core_builtin.c
+++ b/src/stdlib/builtin/lv_mem_core_builtin.c
@@ -68,6 +68,7 @@ static void lv_mem_walker(void * ptr, size_t size, int used, void * user);
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 void lv_mem_init(void)
 {
 #if LV_USE_OS
@@ -98,6 +99,7 @@ void lv_mem_init(void)
 #endif
 }
 
+LV_FUNC_SECTION
 void lv_mem_deinit(void)
 {
     lv_ll_clear(&state.pool_ll);
@@ -107,6 +109,7 @@ void lv_mem_deinit(void)
 #endif
 }
 
+LV_FUNC_SECTION
 lv_mem_pool_t lv_mem_add_pool(void * mem, size_t bytes)
 {
     lv_mem_pool_t new_pool = lv_tlsf_add_pool(state.tlsf, mem, bytes);
@@ -122,6 +125,7 @@ lv_mem_pool_t lv_mem_add_pool(void * mem, size_t bytes)
     return new_pool;
 }
 
+LV_FUNC_SECTION
 void lv_mem_remove_pool(lv_mem_pool_t pool)
 {
     lv_pool_t * pool_p;
@@ -136,6 +140,7 @@ void lv_mem_remove_pool(lv_mem_pool_t pool)
     LV_LOG_WARN("invalid pool: %p", pool);
 }
 
+LV_FUNC_SECTION
 void * lv_malloc_core(size_t size)
 {
 #if LV_USE_OS
@@ -154,6 +159,7 @@ void * lv_malloc_core(size_t size)
     return p;
 }
 
+LV_FUNC_SECTION
 void * lv_realloc_core(void * p, size_t new_size)
 {
 #if LV_USE_OS
@@ -175,6 +181,7 @@ void * lv_realloc_core(void * p, size_t new_size)
     return p_new;
 }
 
+LV_FUNC_SECTION
 void lv_free_core(void * p)
 {
 #if LV_USE_OS
@@ -194,6 +201,7 @@ void lv_free_core(void * p)
 #endif
 }
 
+LV_FUNC_SECTION
 void lv_mem_monitor_core(lv_mem_monitor_t * mon_p)
 {
     /*Init the data*/
@@ -219,6 +227,7 @@ void lv_mem_monitor_core(lv_mem_monitor_t * mon_p)
     LV_TRACE_MEM("finished");
 }
 
+LV_FUNC_SECTION
 lv_result_t lv_mem_test_core(void)
 {
 #if LV_USE_OS
@@ -254,6 +263,7 @@ lv_result_t lv_mem_test_core(void)
  *   STATIC FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 static void lv_mem_walker(void * ptr, size_t size, int used, void * user)
 {
     LV_UNUSED(ptr);
diff --git a/src/stdlib/builtin/lv_sprintf_builtin.c b/src/stdlib/builtin/lv_sprintf_builtin.c
index fc34db4d1..65ac6cec0 100644
--- a/src/stdlib/builtin/lv_sprintf_builtin.c
+++ b/src/stdlib/builtin/lv_sprintf_builtin.c
@@ -127,6 +127,7 @@ typedef struct {
 } out_fct_wrap_type;
 
 // internal buffer output
+LV_FUNC_SECTION
 static inline void _out_buffer(char character, void * buffer, size_t idx, size_t maxlen)
 {
     if(idx < maxlen) {
@@ -135,6 +136,7 @@ static inline void _out_buffer(char character, void * buffer, size_t idx, size_t
 }
 
 // internal null output
+LV_FUNC_SECTION
 static inline void _out_null(char character, void * buffer, size_t idx, size_t maxlen)
 {
     LV_UNUSED(character);
@@ -145,6 +147,7 @@ static inline void _out_null(char character, void * buffer, size_t idx, size_t m
 
 // internal secure strlen
 // \return The length of the string (excluding the terminating 0) limited by 'maxsize'
+LV_FUNC_SECTION
 static inline unsigned int _strnlen_s(const char * str, size_t maxsize)
 {
     const char * s;
@@ -154,12 +157,14 @@ static inline unsigned int _strnlen_s(const char * str, size_t maxsize)
 
 // internal test if char is a digit (0-9)
 // \return true if char is a digit
+LV_FUNC_SECTION
 static inline bool _is_digit(char ch)
 {
     return (ch >= '0') && (ch <= '9');
 }
 
 // internal ASCII string to unsigned int conversion
+LV_FUNC_SECTION
 static unsigned int _atoi(const char ** str)
 {
     unsigned int i = 0U;
@@ -170,6 +175,7 @@ static unsigned int _atoi(const char ** str)
 }
 
 // output the specified string in reverse, taking care of any zero-padding
+LV_FUNC_SECTION
 static size_t _out_rev(out_fct_type out, char * buffer, size_t idx, size_t maxlen, const char * buf, size_t len,
                        unsigned int width, unsigned int flags)
 {
@@ -199,6 +205,7 @@ static size_t _out_rev(out_fct_type out, char * buffer, size_t idx, size_t maxle
 }
 
 // internal itoa format
+LV_FUNC_SECTION
 static size_t _ntoa_format(out_fct_type out, char * buffer, size_t idx, size_t maxlen, char * buf, size_t len,
                            bool negative, unsigned int base, unsigned int prec, unsigned int width, unsigned int flags)
 {
@@ -253,6 +260,7 @@ static size_t _ntoa_format(out_fct_type out, char * buffer, size_t idx, size_t m
 }
 
 // internal itoa for 'long' type
+LV_FUNC_SECTION
 static size_t _ntoa_long(out_fct_type out, char * buffer, size_t idx, size_t maxlen, unsigned long value, bool negative,
                          unsigned long base, unsigned int prec, unsigned int width, unsigned int flags)
 {
@@ -278,6 +286,7 @@ static size_t _ntoa_long(out_fct_type out, char * buffer, size_t idx, size_t max
 
 // internal itoa for 'long long' type
 #if defined(PRINTF_SUPPORT_LONG_LONG)
+LV_FUNC_SECTION
 static size_t _ntoa_long_long(out_fct_type out, char * buffer, size_t idx, size_t maxlen, unsigned long long value,
                               bool negative, unsigned long long base, unsigned int prec, unsigned int width, unsigned int flags)
 {
@@ -311,6 +320,7 @@ static size_t _etoa(out_fct_type out, char * buffer, size_t idx, size_t maxlen,
 #endif
 
 // internal ftoa for fixed decimal floating point
+LV_FUNC_SECTION
 static size_t _ftoa(out_fct_type out, char * buffer, size_t idx, size_t maxlen, double value, unsigned int prec,
                     unsigned int width, unsigned int flags)
 {
@@ -440,6 +450,7 @@ static size_t _ftoa(out_fct_type out, char * buffer, size_t idx, size_t maxlen,
 
 #if defined(PRINTF_SUPPORT_EXPONENTIAL)
 // internal ftoa variant for exponential floating-point type, contributed by Martijn Jasperse <m.jasperse@gmail.com>
+LV_FUNC_SECTION
 static size_t _etoa(out_fct_type out, char * buffer, size_t idx, size_t maxlen, double value, unsigned int prec,
                     unsigned int width, unsigned int flags)
 {
@@ -552,6 +563,8 @@ static size_t _etoa(out_fct_type out, char * buffer, size_t idx, size_t maxlen,
 #endif  // PRINTF_SUPPORT_FLOAT
 
 // internal vsnprintf
+#pragma stackfunction 4096
+LV_FUNC_SECTION
 static int lv_vsnprintf_inner(out_fct_type out, char * buffer, const size_t maxlen, const char * format, va_list va)
 {
     unsigned int flags, width, precision, n;
@@ -869,6 +882,7 @@ static int lv_vsnprintf_inner(out_fct_type out, char * buffer, const size_t maxl
 /// GLOBAL FUNCTIONS FOR LVGL
 ///////////////////////////////////////////////////////////////////////////////
 
+LV_FUNC_SECTION
 int lv_snprintf(char * buffer, size_t count, const char * format, ...)
 {
     va_list va;
@@ -878,6 +892,7 @@ int lv_snprintf(char * buffer, size_t count, const char * format, ...)
     return ret;
 }
 
+LV_FUNC_SECTION
 int lv_vsnprintf(char * buffer, size_t count, const char * format, va_list va)
 {
     return lv_vsnprintf_inner(_out_buffer, buffer, count, format, va);
diff --git a/src/stdlib/builtin/lv_string_builtin.c b/src/stdlib/builtin/lv_string_builtin.c
index f225adccf..12e3d4f39 100644
--- a/src/stdlib/builtin/lv_string_builtin.c
+++ b/src/stdlib/builtin/lv_string_builtin.c
@@ -171,6 +171,7 @@ void * LV_ATTRIBUTE_FAST_MEM lv_memmove(void * dst, const void * src, size_t len
     return dst;
 }
 
+LV_FUNC_SECTION
 int lv_memcmp(const void * p1, const void * p2, size_t len)
 {
     const char * s1 = (const char *) p1;
@@ -183,6 +184,7 @@ int lv_memcmp(const void * p1, const void * p2, size_t len)
 }
 
 /* See https://en.cppreference.com/w/c/string/byte/strlen for reference */
+LV_FUNC_SECTION
 size_t lv_strlen(const char * str)
 {
     size_t i = 0;
@@ -191,6 +193,7 @@ size_t lv_strlen(const char * str)
     return i;
 }
 
+LV_FUNC_SECTION
 size_t lv_strlcpy(char * dst, const char * src, size_t dst_size)
 {
     size_t i = 0;
@@ -204,6 +207,7 @@ size_t lv_strlcpy(char * dst, const char * src, size_t dst_size)
     return i;
 }
 
+LV_FUNC_SECTION
 char * lv_strncpy(char * dst, const char * src, size_t dst_size)
 {
     size_t i;
@@ -216,6 +220,7 @@ char * lv_strncpy(char * dst, const char * src, size_t dst_size)
     return dst;
 }
 
+LV_FUNC_SECTION
 char * lv_strcpy(char * dst, const char * src)
 {
     char * tmp = dst;
@@ -223,6 +228,7 @@ char * lv_strcpy(char * dst, const char * src)
     return tmp;
 }
 
+LV_FUNC_SECTION
 int lv_strcmp(const char * s1, const char * s2)
 {
     while(*s1 && (*s1 == *s2)) {
@@ -232,6 +238,7 @@ int lv_strcmp(const char * s1, const char * s2)
     return *(const unsigned char *)s1 - *(const unsigned char *)s2;
 }
 
+LV_FUNC_SECTION
 char * lv_strdup(const char * src)
 {
     size_t len = lv_strlen(src) + 1;
@@ -242,12 +249,14 @@ char * lv_strdup(const char * src)
     return dst;
 }
 
+LV_FUNC_SECTION
 char * lv_strcat(char * dst, const char * src)
 {
     lv_strcpy(dst + lv_strlen(dst), src);
     return dst;
 }
 
+LV_FUNC_SECTION
 char * lv_strncat(char * dst, const char * src, size_t src_len)
 {
     char * tmp = dst;
diff --git a/src/stdlib/builtin/lv_tlsf.c b/src/stdlib/builtin/lv_tlsf.c
index 4232ae324..9a02750f6 100644
--- a/src/stdlib/builtin/lv_tlsf.c
+++ b/src/stdlib/builtin/lv_tlsf.c
@@ -82,6 +82,7 @@
 #if defined (__SNC__)
 /* SNC for PlayStation 3. */
 
+LV_FUNC_SECTION
 tlsf_decl int tlsf_ffs(unsigned int word)
 {
     const unsigned int reverse = word & (~word + 1);
@@ -91,6 +92,7 @@ tlsf_decl int tlsf_ffs(unsigned int word)
 
 #else
 
+LV_FUNC_SECTION
 tlsf_decl int tlsf_ffs(unsigned int word)
 {
     return __builtin_ffs(word) - 1;
@@ -98,6 +100,7 @@ tlsf_decl int tlsf_ffs(unsigned int word)
 
 #endif
 
+LV_FUNC_SECTION
 tlsf_decl int tlsf_fls(unsigned int word)
 {
     const int bit = word ? 32 - __builtin_clz(word) : 0;
@@ -112,12 +115,14 @@ tlsf_decl int tlsf_fls(unsigned int word)
 #pragma intrinsic(_BitScanReverse)
 #pragma intrinsic(_BitScanForward)
 
+LV_FUNC_SECTION
 tlsf_decl int tlsf_fls(unsigned int word)
 {
     unsigned long index;
     return _BitScanReverse(&index, word) ? index : -1;
 }
 
+LV_FUNC_SECTION
 tlsf_decl int tlsf_ffs(unsigned int word)
 {
     unsigned long index;
@@ -129,12 +134,14 @@ tlsf_decl int tlsf_ffs(unsigned int word)
 
 #include <ppcintrinsics.h>
 
+LV_FUNC_SECTION
 tlsf_decl int tlsf_fls(unsigned int word)
 {
     const int bit = 32 - _CountLeadingZeros(word);
     return bit - 1;
 }
 
+LV_FUNC_SECTION
 tlsf_decl int tlsf_ffs(unsigned int word)
 {
     const unsigned int reverse = word & (~word + 1);
@@ -145,6 +152,7 @@ tlsf_decl int tlsf_ffs(unsigned int word)
 #elif defined (__ARMCC_VERSION)
 /* RealView Compilation Tools for ARM */
 
+LV_FUNC_SECTION
 tlsf_decl int tlsf_ffs(unsigned int word)
 {
     const unsigned int reverse = word & (~word + 1);
@@ -152,6 +160,7 @@ tlsf_decl int tlsf_ffs(unsigned int word)
     return bit - 1;
 }
 
+LV_FUNC_SECTION
 tlsf_decl int tlsf_fls(unsigned int word)
 {
     const int bit = word ? 32 - __clz(word) : 0;
@@ -163,6 +172,7 @@ tlsf_decl int tlsf_fls(unsigned int word)
 
 #include <ppc_ghs.h>
 
+LV_FUNC_SECTION
 tlsf_decl int tlsf_ffs(unsigned int word)
 {
     const unsigned int reverse = word & (~word + 1);
@@ -170,6 +180,7 @@ tlsf_decl int tlsf_ffs(unsigned int word)
     return bit - 1;
 }
 
+LV_FUNC_SECTION
 tlsf_decl int tlsf_fls(unsigned int word)
 {
     const int bit = word ? 32 - __CLZ32(word) : 0;
@@ -180,12 +191,14 @@ tlsf_decl int tlsf_fls(unsigned int word)
 /* Fall back to generic implementation. */
 
 /* Implement ffs in terms of fls. */
+LV_FUNC_SECTION
 tlsf_decl int tlsf_ffs(unsigned int word)
 {
     const unsigned int reverse = word & (~word + 1);
     return TLSF_FLS32(reverse) - 1;
 }
 
+LV_FUNC_SECTION
 tlsf_decl int tlsf_fls(unsigned int word)
 {
     return TLSF_FLS32(word) - 1;
@@ -195,6 +208,7 @@ tlsf_decl int tlsf_fls(unsigned int word)
 
 /* Possibly 64-bit version of tlsf_fls. */
 #if defined (TLSF_64BIT)
+LV_FUNC_SECTION
 tlsf_decl int tlsf_fls_sizet(size_t size)
 {
     int high = (int)(size >> 32);
@@ -378,58 +392,69 @@ typedef ptrdiff_t tlsfptr_t;
 ** block_header_t member functions.
 */
 
+LV_FUNC_SECTION
 static size_t block_size(const block_header_t * block)
 {
     return block->size & ~(block_header_free_bit | block_header_prev_free_bit);
 }
 
+LV_FUNC_SECTION
 static void block_set_size(block_header_t * block, size_t size)
 {
     const size_t oldsize = block->size;
     block->size = size | (oldsize & (block_header_free_bit | block_header_prev_free_bit));
 }
 
+LV_FUNC_SECTION
 static int block_is_last(const block_header_t * block)
 {
     return block_size(block) == 0;
 }
 
+LV_FUNC_SECTION
 static int block_is_free(const block_header_t * block)
 {
     return tlsf_cast(int, block->size & block_header_free_bit);
 }
 
+LV_FUNC_SECTION
 static void block_set_free(block_header_t * block)
 {
     block->size |= block_header_free_bit;
 }
 
+LV_FUNC_SECTION
 static void block_set_used(block_header_t * block)
 {
     block->size &= ~block_header_free_bit;
 }
 
+LV_FUNC_SECTION
 static int block_is_prev_free(const block_header_t * block)
 {
     return tlsf_cast(int, block->size & block_header_prev_free_bit);
 }
 
+LV_FUNC_SECTION
 static void block_set_prev_free(block_header_t * block)
 {
     block->size |= block_header_prev_free_bit;
 }
 
+LV_FUNC_SECTION
 static void block_set_prev_used(block_header_t * block)
 {
     block->size &= ~block_header_prev_free_bit;
 }
 
+LV_FUNC_SECTION
 static block_header_t * block_from_ptr(const void * ptr)
 {
     return tlsf_cast(block_header_t *,
                      tlsf_cast(unsigned char *, ptr) - block_start_offset);
 }
 
+LV_FUNC_SECTION
 static void * block_to_ptr(const block_header_t * block)
 {
     return tlsf_cast(void *,
@@ -437,12 +462,14 @@ static void * block_to_ptr(const block_header_t * block)
 }
 
 /* Return location of next block after block of given size. */
+LV_FUNC_SECTION
 static block_header_t * offset_to_block(const void * ptr, size_t size)
 {
     return tlsf_cast(block_header_t *, tlsf_cast(tlsfptr_t, ptr) + size);
 }
 
 /* Return location of previous block. */
+LV_FUNC_SECTION
 static block_header_t * block_prev(const block_header_t * block)
 {
     tlsf_assert(block_is_prev_free(block) && "previous block must be free");
@@ -450,6 +477,7 @@ static block_header_t * block_prev(const block_header_t * block)
 }
 
 /* Return location of next existing block. */
+LV_FUNC_SECTION
 static block_header_t * block_next(const block_header_t * block)
 {
     block_header_t * next = offset_to_block(block_to_ptr(block),
@@ -459,6 +487,7 @@ static block_header_t * block_next(const block_header_t * block)
 }
 
 /* Link a new block with its physical neighbor, return the neighbor. */
+LV_FUNC_SECTION
 static block_header_t * block_link_next(block_header_t * block)
 {
     block_header_t * next = block_next(block);
@@ -466,6 +495,7 @@ static block_header_t * block_link_next(block_header_t * block)
     return next;
 }
 
+LV_FUNC_SECTION
 static void block_mark_as_free(block_header_t * block)
 {
     /* Link the block to the next block, first. */
@@ -474,6 +504,7 @@ static void block_mark_as_free(block_header_t * block)
     block_set_free(block);
 }
 
+LV_FUNC_SECTION
 static void block_mark_as_used(block_header_t * block)
 {
     block_header_t * next = block_next(block);
@@ -481,18 +512,21 @@ static void block_mark_as_used(block_header_t * block)
     block_set_used(block);
 }
 
+LV_FUNC_SECTION
 static size_t align_up(size_t x, size_t align)
 {
     tlsf_assert(0 == (align & (align - 1)) && "must align to a power of two");
     return (x + (align - 1)) & ~(align - 1);
 }
 
+LV_FUNC_SECTION
 static size_t align_down(size_t x, size_t align)
 {
     tlsf_assert(0 == (align & (align - 1)) && "must align to a power of two");
     return x - (x & (align - 1));
 }
 
+LV_FUNC_SECTION
 static void * align_ptr(const void * ptr, size_t align)
 {
     const tlsfptr_t aligned =
@@ -505,6 +539,7 @@ static void * align_ptr(const void * ptr, size_t align)
 ** Adjust an allocation size to be aligned to word size, and no smaller
 ** than internal minimum.
 */
+LV_FUNC_SECTION
 static size_t adjust_request_size(size_t size, size_t align)
 {
     size_t adjust = 0;
@@ -524,6 +559,7 @@ static size_t adjust_request_size(size_t size, size_t align)
 ** the documentation found in the white paper.
 */
 
+LV_FUNC_SECTION
 static void mapping_insert(size_t size, int * fli, int * sli)
 {
     int fl, sl;
@@ -542,6 +578,7 @@ static void mapping_insert(size_t size, int * fli, int * sli)
 }
 
 /* This version rounds up to the next block size (for allocations) */
+LV_FUNC_SECTION
 static void mapping_search(size_t size, int * fli, int * sli)
 {
     if(size >= SMALL_BLOCK_SIZE) {
@@ -551,6 +588,7 @@ static void mapping_search(size_t size, int * fli, int * sli)
     mapping_insert(size, fli, sli);
 }
 
+LV_FUNC_SECTION
 static block_header_t * search_suitable_block(control_t * control, int * fli, int * sli)
 {
     int fl = *fli;
@@ -582,6 +620,7 @@ static block_header_t * search_suitable_block(control_t * control, int * fli, in
 }
 
 /* Remove a free block from the free list.*/
+LV_FUNC_SECTION
 static void remove_free_block(control_t * control, block_header_t * block, int fl, int sl)
 {
     block_header_t * prev = block->prev_free;
@@ -608,6 +647,7 @@ static void remove_free_block(control_t * control, block_header_t * block, int f
 }
 
 /* Insert a free block into the free block list. */
+LV_FUNC_SECTION
 static void insert_free_block(control_t * control, block_header_t * block, int fl, int sl)
 {
     block_header_t * current = control->blocks[fl][sl];
@@ -629,6 +669,7 @@ static void insert_free_block(control_t * control, block_header_t * block, int f
 }
 
 /* Remove a given block from the free list. */
+LV_FUNC_SECTION
 static void block_remove(control_t * control, block_header_t * block)
 {
     int fl, sl;
@@ -637,6 +678,7 @@ static void block_remove(control_t * control, block_header_t * block)
 }
 
 /* Insert a given block into the free list. */
+LV_FUNC_SECTION
 static void block_insert(control_t * control, block_header_t * block)
 {
     int fl, sl;
@@ -644,12 +686,14 @@ static void block_insert(control_t * control, block_header_t * block)
     insert_free_block(control, block, fl, sl);
 }
 
+LV_FUNC_SECTION
 static int block_can_split(block_header_t * block, size_t size)
 {
     return block_size(block) >= sizeof(block_header_t) + size;
 }
 
 /* Split a block into two, the second of which is free. */
+LV_FUNC_SECTION
 static block_header_t * block_split(block_header_t * block, size_t size)
 {
     /* Calculate the amount of space left in the remaining block. */
@@ -672,6 +716,7 @@ static block_header_t * block_split(block_header_t * block, size_t size)
 }
 
 /* Absorb a free block's storage into an adjacent previous free block. */
+LV_FUNC_SECTION
 static block_header_t * block_absorb(block_header_t * prev, block_header_t * block)
 {
     tlsf_assert(!block_is_last(prev) && "previous block can't be last");
@@ -682,6 +727,7 @@ static block_header_t * block_absorb(block_header_t * prev, block_header_t * blo
 }
 
 /* Merge a just-freed block with an adjacent previous free block. */
+LV_FUNC_SECTION
 static block_header_t * block_merge_prev(control_t * control, block_header_t * block)
 {
     if(block_is_prev_free(block)) {
@@ -696,6 +742,7 @@ static block_header_t * block_merge_prev(control_t * control, block_header_t * b
 }
 
 /* Merge a just-freed block with an adjacent free block. */
+LV_FUNC_SECTION
 static block_header_t * block_merge_next(control_t * control, block_header_t * block)
 {
     block_header_t * next = block_next(block);
@@ -711,6 +758,7 @@ static block_header_t * block_merge_next(control_t * control, block_header_t * b
 }
 
 /* Trim any trailing block space off the end of a block, return to pool. */
+LV_FUNC_SECTION
 static void block_trim_free(control_t * control, block_header_t * block, size_t size)
 {
     tlsf_assert(block_is_free(block) && "block must be free");
@@ -723,6 +771,7 @@ static void block_trim_free(control_t * control, block_header_t * block, size_t
 }
 
 /* Trim any trailing block space off the end of a used block, return to pool. */
+LV_FUNC_SECTION
 static void block_trim_used(control_t * control, block_header_t * block, size_t size)
 {
     tlsf_assert(!block_is_free(block) && "block must be used");
@@ -736,6 +785,7 @@ static void block_trim_used(control_t * control, block_header_t * block, size_t
     }
 }
 
+LV_FUNC_SECTION
 static block_header_t * block_trim_free_leading(control_t * control, block_header_t * block, size_t size)
 {
     block_header_t * remaining_block = block;
@@ -751,6 +801,7 @@ static block_header_t * block_trim_free_leading(control_t * control, block_heade
     return remaining_block;
 }
 
+LV_FUNC_SECTION
 static block_header_t * block_locate_free(control_t * control, size_t size)
 {
     int fl = 0, sl = 0;
@@ -778,6 +829,7 @@ static block_header_t * block_locate_free(control_t * control, size_t size)
     return block;
 }
 
+LV_FUNC_SECTION
 static void * block_prepare_used(control_t * control, block_header_t * block, size_t size)
 {
     void * p = 0;
@@ -791,6 +843,7 @@ static void * block_prepare_used(control_t * control, block_header_t * block, si
 }
 
 /* Clear structure and point all empty lists at the null block. */
+LV_FUNC_SECTION
 static void control_constructor(control_t * control)
 {
     int i, j;
@@ -818,6 +871,7 @@ typedef struct integrity_t {
 
 #define tlsf_insist(x) { tlsf_assert(x); if (!(x)) { status--; } }
 
+LV_FUNC_SECTION
 static void integrity_walker(void * ptr, size_t size, int used, void * user)
 {
     block_header_t * block = block_from_ptr(ptr);
@@ -835,6 +889,7 @@ static void integrity_walker(void * ptr, size_t size, int used, void * user)
     integ->status += status;
 }
 
+LV_FUNC_SECTION
 int lv_tlsf_check(lv_tlsf_t tlsf)
 {
     int i, j;
@@ -884,12 +939,14 @@ int lv_tlsf_check(lv_tlsf_t tlsf)
 
 #undef tlsf_insist
 
+LV_FUNC_SECTION
 static void default_walker(void * ptr, size_t size, int used, void * user)
 {
     LV_UNUSED(user);
     printf("\t%p %s size: %x (%p)\n", ptr, used ? "used" : "free", (unsigned int)size, (void *)block_from_ptr(ptr));
 }
 
+LV_FUNC_SECTION
 void lv_tlsf_walk_pool(lv_pool_t pool, lv_tlsf_walker walker, void * user)
 {
     lv_tlsf_walker pool_walker = walker ? walker : default_walker;
@@ -906,6 +963,7 @@ void lv_tlsf_walk_pool(lv_pool_t pool, lv_tlsf_walker walker, void * user)
     }
 }
 
+LV_FUNC_SECTION
 size_t lv_tlsf_block_size(void * ptr)
 {
     size_t size = 0;
@@ -916,6 +974,7 @@ size_t lv_tlsf_block_size(void * ptr)
     return size;
 }
 
+LV_FUNC_SECTION
 int lv_tlsf_check_pool(lv_pool_t pool)
 {
     /* Check that the blocks are physically correct. */
@@ -929,21 +988,25 @@ int lv_tlsf_check_pool(lv_pool_t pool)
 ** Size of the TLSF structures in a given memory block passed to
 ** lv_tlsf_create, equal to the size of a control_t
 */
+LV_FUNC_SECTION
 size_t lv_tlsf_size(void)
 {
     return sizeof(control_t);
 }
 
+LV_FUNC_SECTION
 size_t lv_tlsf_align_size(void)
 {
     return ALIGN_SIZE;
 }
 
+LV_FUNC_SECTION
 size_t lv_tlsf_block_size_min(void)
 {
     return block_size_min;
 }
 
+LV_FUNC_SECTION
 size_t lv_tlsf_block_size_max(void)
 {
     return block_size_max;
@@ -954,16 +1017,19 @@ size_t lv_tlsf_block_size_max(void)
 ** lv_tlsf_add_pool, equal to the overhead of a free block and the
 ** sentinel block.
 */
+LV_FUNC_SECTION
 size_t lv_tlsf_pool_overhead(void)
 {
     return 2 * block_header_overhead;
 }
 
+LV_FUNC_SECTION
 size_t lv_tlsf_alloc_overhead(void)
 {
     return block_header_overhead;
 }
 
+LV_FUNC_SECTION
 lv_pool_t lv_tlsf_add_pool(lv_tlsf_t tlsf, void * mem, size_t bytes)
 {
     block_header_t * block;
@@ -1011,6 +1077,7 @@ lv_pool_t lv_tlsf_add_pool(lv_tlsf_t tlsf, void * mem, size_t bytes)
     return mem;
 }
 
+LV_FUNC_SECTION
 void lv_tlsf_remove_pool(lv_tlsf_t tlsf, lv_pool_t pool)
 {
     control_t * control = tlsf_cast(control_t *, tlsf);
@@ -1031,6 +1098,7 @@ void lv_tlsf_remove_pool(lv_tlsf_t tlsf, lv_pool_t pool)
 */
 
 #if _DEBUG
+LV_FUNC_SECTION
 int test_ffs_fls()
 {
     /* Verify ffs/fls work properly. */
@@ -1057,6 +1125,7 @@ int test_ffs_fls()
 }
 #endif
 
+LV_FUNC_SECTION
 lv_tlsf_t lv_tlsf_create(void * mem)
 {
 #if _DEBUG
@@ -1076,6 +1145,7 @@ lv_tlsf_t lv_tlsf_create(void * mem)
     return tlsf_cast(lv_tlsf_t, mem);
 }
 
+LV_FUNC_SECTION
 lv_tlsf_t lv_tlsf_create_with_pool(void * mem, size_t bytes)
 {
     lv_tlsf_t tlsf = lv_tlsf_create(mem);
@@ -1083,17 +1153,20 @@ lv_tlsf_t lv_tlsf_create_with_pool(void * mem, size_t bytes)
     return tlsf;
 }
 
+LV_FUNC_SECTION
 void lv_tlsf_destroy(lv_tlsf_t tlsf)
 {
     /* Nothing to do. */
     LV_UNUSED(tlsf);
 }
 
+LV_FUNC_SECTION
 lv_pool_t lv_tlsf_get_pool(lv_tlsf_t tlsf)
 {
     return tlsf_cast(lv_pool_t, (char *)tlsf + lv_tlsf_size());
 }
 
+LV_FUNC_SECTION
 void * lv_tlsf_malloc(lv_tlsf_t tlsf, size_t size)
 {
     control_t * control = tlsf_cast(control_t *, tlsf);
@@ -1102,6 +1175,7 @@ void * lv_tlsf_malloc(lv_tlsf_t tlsf, size_t size)
     return block_prepare_used(control, block, adjust);
 }
 
+LV_FUNC_SECTION
 void * lv_tlsf_memalign(lv_tlsf_t tlsf, size_t align, size_t size)
 {
     control_t * control = tlsf_cast(control_t *, tlsf);
@@ -1156,6 +1230,7 @@ void * lv_tlsf_memalign(lv_tlsf_t tlsf, size_t align, size_t size)
     return block_prepare_used(control, block, adjust);
 }
 
+LV_FUNC_SECTION
 size_t lv_tlsf_free(lv_tlsf_t tlsf, const void * ptr)
 {
     size_t size = 0;
@@ -1187,6 +1262,7 @@ size_t lv_tlsf_free(lv_tlsf_t tlsf, const void * ptr)
 ** - an extended buffer size will leave the newly-allocated area with
 **   contents undefined
 */
+LV_FUNC_SECTION
 void * lv_tlsf_realloc(lv_tlsf_t tlsf, void * ptr, size_t size)
 {
     control_t * control = tlsf_cast(control_t *, tlsf);
diff --git a/src/stdlib/clib/lv_mem_core_clib.c b/src/stdlib/clib/lv_mem_core_clib.c
index 9cdddf4d1..e764126b8 100644
--- a/src/stdlib/clib/lv_mem_core_clib.c
+++ b/src/stdlib/clib/lv_mem_core_clib.c
@@ -33,17 +33,20 @@
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 void lv_mem_init(void)
 {
     return; /*Nothing to init*/
 }
 
+LV_FUNC_SECTION
 void lv_mem_deinit(void)
 {
     return; /*Nothing to deinit*/
 
 }
 
+LV_FUNC_SECTION
 lv_mem_pool_t lv_mem_add_pool(void * mem, size_t bytes)
 {
     /*Not supported*/
@@ -52,6 +55,7 @@ lv_mem_pool_t lv_mem_add_pool(void * mem, size_t bytes)
     return NULL;
 }
 
+LV_FUNC_SECTION
 void lv_mem_remove_pool(lv_mem_pool_t pool)
 {
     /*Not supported*/
@@ -59,21 +63,25 @@ void lv_mem_remove_pool(lv_mem_pool_t pool)
     return;
 }
 
+LV_FUNC_SECTION
 void * lv_malloc_core(size_t size)
 {
     return malloc(size);
 }
 
+LV_FUNC_SECTION
 void * lv_realloc_core(void * p, size_t new_size)
 {
     return realloc(p, new_size);
 }
 
+LV_FUNC_SECTION
 void lv_free_core(void * p)
 {
     free(p);
 }
 
+LV_FUNC_SECTION
 void lv_mem_monitor_core(lv_mem_monitor_t * mon_p)
 {
     /*Not supported*/
@@ -81,6 +89,7 @@ void lv_mem_monitor_core(lv_mem_monitor_t * mon_p)
     return;
 }
 
+LV_FUNC_SECTION
 lv_result_t lv_mem_test_core(void)
 {
     /*Not supported*/
diff --git a/src/stdlib/clib/lv_sprintf_clib.c b/src/stdlib/clib/lv_sprintf_clib.c
index 4f4fb9c74..3e91a47d2 100644
--- a/src/stdlib/clib/lv_sprintf_clib.c
+++ b/src/stdlib/clib/lv_sprintf_clib.c
@@ -37,6 +37,7 @@
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 int lv_snprintf(char * buffer, size_t count, const char * format, ...)
 {
     va_list va;
@@ -46,6 +47,7 @@ int lv_snprintf(char * buffer, size_t count, const char * format, ...)
     return ret;
 }
 
+LV_FUNC_SECTION
 int lv_vsnprintf(char * buffer, size_t count, const char * format, va_list va)
 {
     return vsnprintf(buffer, count, format, va);
diff --git a/src/stdlib/clib/lv_string_clib.c b/src/stdlib/clib/lv_string_clib.c
index fd01b93f9..118c9ce4a 100644
--- a/src/stdlib/clib/lv_string_clib.c
+++ b/src/stdlib/clib/lv_string_clib.c
@@ -50,16 +50,19 @@ void * LV_ATTRIBUTE_FAST_MEM lv_memmove(void * dst, const void * src, size_t len
     return memmove(dst, src, len);
 }
 
+LV_FUNC_SECTION
 int lv_memcmp(const void * p1, const void * p2, size_t len)
 {
     return memcmp(p1, p2, len);
 }
 
+LV_FUNC_SECTION
 size_t lv_strlen(const char * str)
 {
     return strlen(str);
 }
 
+LV_FUNC_SECTION
 size_t lv_strlcpy(char * dst, const char * src, size_t dst_size)
 {
     size_t src_len = strlen(src);
@@ -71,21 +74,25 @@ size_t lv_strlcpy(char * dst, const char * src, size_t dst_size)
     return src_len;
 }
 
+LV_FUNC_SECTION
 char * lv_strncpy(char * dst, const char * src, size_t dest_size)
 {
     return strncpy(dst, src, dest_size);
 }
 
+LV_FUNC_SECTION
 char * lv_strcpy(char * dst, const char * src)
 {
     return strcpy(dst, src);
 }
 
+LV_FUNC_SECTION
 int lv_strcmp(const char * s1, const char * s2)
 {
     return strcmp(s1, s2);
 }
 
+LV_FUNC_SECTION
 char * lv_strdup(const char * src)
 {
     /*strdup uses malloc, so use the lv_malloc when LV_USE_STDLIB_MALLOC is not LV_STDLIB_CLIB */
@@ -97,11 +104,13 @@ char * lv_strdup(const char * src)
     return dst;
 }
 
+LV_FUNC_SECTION
 char * lv_strcat(char * dst, const char * src)
 {
     return strcat(dst, src);
 }
 
+LV_FUNC_SECTION
 char * lv_strncat(char * dst, const char * src, size_t src_len)
 {
     return strncat(dst, src, src_len);
diff --git a/src/stdlib/lv_mem.c b/src/stdlib/lv_mem.c
index bfc887fff..28d0e7dec 100644
--- a/src/stdlib/lv_mem.c
+++ b/src/stdlib/lv_mem.c
@@ -59,6 +59,7 @@ lv_result_t lv_mem_test_core(void);
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 void * lv_malloc(size_t size)
 {
     LV_TRACE_MEM("allocating %lu bytes", (unsigned long)size);
@@ -89,6 +90,7 @@ void * lv_malloc(size_t size)
     return alloc;
 }
 
+LV_FUNC_SECTION
 void * lv_malloc_zeroed(size_t size)
 {
     LV_TRACE_MEM("allocating %lu bytes", (unsigned long)size);
@@ -116,6 +118,7 @@ void * lv_malloc_zeroed(size_t size)
     return alloc;
 }
 
+LV_FUNC_SECTION
 void lv_free(void * data)
 {
     LV_TRACE_MEM("freeing %p", data);
@@ -125,6 +128,7 @@ void lv_free(void * data)
     lv_free_core(data);
 }
 
+LV_FUNC_SECTION
 void * lv_realloc(void * data_p, size_t new_size)
 {
     LV_TRACE_MEM("reallocating %p with %lu size", data_p, (unsigned long)new_size);
@@ -147,6 +151,7 @@ void * lv_realloc(void * data_p, size_t new_size)
     return new_p;
 }
 
+LV_FUNC_SECTION
 lv_result_t lv_mem_test(void)
 {
     if(zero_mem != ZERO_MEM_SENTINEL) {
@@ -157,6 +162,7 @@ lv_result_t lv_mem_test(void)
     return lv_mem_test_core();
 }
 
+LV_FUNC_SECTION
 void lv_mem_monitor(lv_mem_monitor_t * mon_p)
 {
     lv_memzero(mon_p, sizeof(lv_mem_monitor_t));
diff --git a/src/stdlib/micropython/lv_mem_core_micropython.c b/src/stdlib/micropython/lv_mem_core_micropython.c
index a671b5e1c..f375adf08 100644
--- a/src/stdlib/micropython/lv_mem_core_micropython.c
+++ b/src/stdlib/micropython/lv_mem_core_micropython.c
@@ -34,17 +34,20 @@
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 void lv_mem_init(void)
 {
     return; /*Nothing to init*/
 }
 
+LV_FUNC_SECTION
 void lv_mem_deinit(void)
 {
     return; /*Nothing to deinit*/
 
 }
 
+LV_FUNC_SECTION
 lv_mem_pool_t lv_mem_add_pool(void * mem, size_t bytes)
 {
     /*Not supported*/
@@ -53,6 +56,7 @@ lv_mem_pool_t lv_mem_add_pool(void * mem, size_t bytes)
     return NULL;
 }
 
+LV_FUNC_SECTION
 void lv_mem_remove_pool(lv_mem_pool_t pool)
 {
     /*Not supported*/
@@ -60,6 +64,7 @@ void lv_mem_remove_pool(lv_mem_pool_t pool)
     return;
 }
 
+LV_FUNC_SECTION
 void * lv_malloc_core(size_t size)
 {
 #if MICROPY_MALLOC_USES_ALLOCATED_SIZE
@@ -69,6 +74,7 @@ void * lv_malloc_core(size_t size)
 #endif
 }
 
+LV_FUNC_SECTION
 void * lv_realloc_core(void * p, size_t new_size)
 {
 
@@ -79,6 +85,7 @@ void * lv_realloc_core(void * p, size_t new_size)
 #endif
 }
 
+LV_FUNC_SECTION
 void lv_free_core(void * p)
 {
 
@@ -90,6 +97,7 @@ void lv_free_core(void * p)
 #endif
 }
 
+LV_FUNC_SECTION
 void lv_mem_monitor_core(lv_mem_monitor_t * mon_p)
 {
     /*Not supported*/
@@ -97,6 +105,7 @@ void lv_mem_monitor_core(lv_mem_monitor_t * mon_p)
     return;
 }
 
+LV_FUNC_SECTION
 lv_result_t lv_mem_test_core(void)
 {
     /*Not supported*/
diff --git a/src/stdlib/rtthread/lv_mem_core_rtthread.c b/src/stdlib/rtthread/lv_mem_core_rtthread.c
index 29a600a6a..9155c7685 100644
--- a/src/stdlib/rtthread/lv_mem_core_rtthread.c
+++ b/src/stdlib/rtthread/lv_mem_core_rtthread.c
@@ -38,16 +38,19 @@
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 void lv_mem_init(void)
 {
     return; /*Nothing to init*/
 }
 
+LV_FUNC_SECTION
 void lv_mem_deinit(void)
 {
     return; /*Nothing to deinit*/
 }
 
+LV_FUNC_SECTION
 lv_mem_pool_t lv_mem_add_pool(void * mem, size_t bytes)
 {
     /*Not supported*/
@@ -56,6 +59,7 @@ lv_mem_pool_t lv_mem_add_pool(void * mem, size_t bytes)
     return NULL;
 }
 
+LV_FUNC_SECTION
 void lv_mem_remove_pool(lv_mem_pool_t pool)
 {
     /*Not supported*/
@@ -63,21 +67,25 @@ void lv_mem_remove_pool(lv_mem_pool_t pool)
     return;
 }
 
+LV_FUNC_SECTION
 void * lv_malloc_core(size_t size)
 {
     return rt_malloc(size);
 }
 
+LV_FUNC_SECTION
 void * lv_realloc_core(void * p, size_t new_size)
 {
     return rt_realloc(p, new_size);
 }
 
+LV_FUNC_SECTION
 void lv_free_core(void * p)
 {
     rt_free(p);
 }
 
+LV_FUNC_SECTION
 void lv_mem_monitor_core(lv_mem_monitor_t * mon_p)
 {
     /*Not supported*/
@@ -85,6 +93,7 @@ void lv_mem_monitor_core(lv_mem_monitor_t * mon_p)
     return;
 }
 
+LV_FUNC_SECTION
 lv_result_t lv_mem_test_core(void)
 {
     /*Not supported*/
diff --git a/src/stdlib/rtthread/lv_sprintf_rtthread.c b/src/stdlib/rtthread/lv_sprintf_rtthread.c
index 721f4fd05..e5e52d1e7 100644
--- a/src/stdlib/rtthread/lv_sprintf_rtthread.c
+++ b/src/stdlib/rtthread/lv_sprintf_rtthread.c
@@ -40,6 +40,7 @@
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 int lv_snprintf(char * buffer, size_t count, const char * format, ...)
 {
     va_list va;
@@ -49,6 +50,7 @@ int lv_snprintf(char * buffer, size_t count, const char * format, ...)
     return ret;
 }
 
+LV_FUNC_SECTION
 int lv_vsnprintf(char * buffer, size_t count, const char * format, va_list va)
 {
     return rt_vsnprintf(buffer, count, format, va);
diff --git a/src/stdlib/rtthread/lv_string_rtthread.c b/src/stdlib/rtthread/lv_string_rtthread.c
index 2ab0a4717..f45f559d3 100644
--- a/src/stdlib/rtthread/lv_string_rtthread.c
+++ b/src/stdlib/rtthread/lv_string_rtthread.c
@@ -50,16 +50,19 @@ void * LV_ATTRIBUTE_FAST_MEM lv_memmove(void * dst, const void * src, size_t len
     return rt_memmove(dst, src, len);
 }
 
+LV_FUNC_SECTION
 size_t lv_strlen(const char * str)
 {
     return rt_strlen(str);
 }
 
+LV_FUNC_SECTION
 int lv_memcmp(const void * p1, const void * p2, size_t len)
 {
     return rt_memcmp(p1, p2, len);
 }
 
+LV_FUNC_SECTION
 size_t lv_strlcpy(char * dst, const char * src, size_t dst_size)
 {
     size_t src_len = lv_strlen(src);
@@ -71,21 +74,25 @@ size_t lv_strlcpy(char * dst, const char * src, size_t dst_size)
     return src_len;
 }
 
+LV_FUNC_SECTION
 char * lv_strncpy(char * dst, const char * src, size_t dest_size)
 {
     return rt_strncpy(dst, src, dest_size);
 }
 
+LV_FUNC_SECTION
 char * lv_strcpy(char * dst, const char * src)
 {
     return rt_strcpy(dst, src);
 }
 
+LV_FUNC_SECTION
 int lv_strcmp(const char * s1, const char * s2)
 {
     return rt_strcmp(s1, s2);
 }
 
+LV_FUNC_SECTION
 char * lv_strdup(const char * src)
 {
     size_t len = lv_strlen(src) + 1;
@@ -96,6 +103,7 @@ char * lv_strdup(const char * src)
     return dst;
 }
 
+LV_FUNC_SECTION
 char * lv_strcat(char * dst, const char * src)
 {
     /*Since RT-thread does not have rt_strcat,
@@ -104,6 +112,7 @@ char * lv_strcat(char * dst, const char * src)
     return dst;
 }
 
+LV_FUNC_SECTION
 char * lv_strncat(char * dst, const char * src, size_t src_len)
 {
     char * tmp = dst;
diff --git a/src/themes/default/lv_theme_default.c b/src/themes/default/lv_theme_default.c
index fa1266219..0440f109d 100644
--- a/src/themes/default/lv_theme_default.c
+++ b/src/themes/default/lv_theme_default.c
@@ -197,12 +197,14 @@ static void style_init_reset(lv_style_t * style);
  *   STATIC FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 static lv_color_t dark_color_filter_cb(const lv_color_filter_dsc_t * f, lv_color_t c, lv_opa_t opa)
 {
     LV_UNUSED(f);
     return lv_color_darken(c, opa);
 }
 
+LV_FUNC_SECTION
 static lv_color_t grey_filter_cb(const lv_color_filter_dsc_t * f, lv_color_t color, lv_opa_t opa)
 {
     LV_UNUSED(f);
@@ -210,6 +212,7 @@ static lv_color_t grey_filter_cb(const lv_color_filter_dsc_t * f, lv_color_t col
     else return lv_color_mix(lv_palette_lighten(LV_PALETTE_GREY, 2), color, opa);
 }
 
+LV_FUNC_SECTION
 static void style_init(my_theme_t * theme)
 {
 #if TRANSITION_TIME
@@ -637,6 +640,7 @@ static void style_init(my_theme_t * theme)
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 lv_theme_t * lv_theme_default_init(lv_display_t * disp, lv_color_t color_primary, lv_color_t color_secondary, bool dark,
                                    const lv_font_t * font)
 {
@@ -690,6 +694,7 @@ lv_theme_t * lv_theme_default_init(lv_display_t * disp, lv_color_t color_primary
     return (lv_theme_t *) theme;
 }
 
+LV_FUNC_SECTION
 void lv_theme_default_deinit(void)
 {
     my_theme_t * theme = theme_def;
@@ -707,6 +712,7 @@ void lv_theme_default_deinit(void)
     }
 }
 
+LV_FUNC_SECTION
 lv_theme_t * lv_theme_default_get(void)
 {
     if(!lv_theme_default_is_inited()) {
@@ -716,6 +722,7 @@ lv_theme_t * lv_theme_default_get(void)
     return (lv_theme_t *)theme_def;
 }
 
+LV_FUNC_SECTION
 bool lv_theme_default_is_inited(void)
 {
     my_theme_t * theme = theme_def;
@@ -723,6 +730,7 @@ bool lv_theme_default_is_inited(void)
     return theme->inited;
 }
 
+LV_FUNC_SECTION
 static void theme_apply(lv_theme_t * th, lv_obj_t * obj)
 {
     LV_UNUSED(th);
@@ -1215,6 +1223,7 @@ static void theme_apply(lv_theme_t * th, lv_obj_t * obj)
  *   STATIC FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 static void style_init_reset(lv_style_t * style)
 {
     if(theme_def->inited) {
diff --git a/src/themes/lv_theme.c b/src/themes/lv_theme.c
index 5dcd6c6ae..306fbd227 100644
--- a/src/themes/lv_theme.c
+++ b/src/themes/lv_theme.c
@@ -37,12 +37,14 @@ static void apply_theme_recursion(lv_theme_t * th, lv_obj_t * obj);
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 lv_theme_t  * lv_theme_get_from_obj(lv_obj_t * obj)
 {
     lv_display_t * disp = obj ? lv_obj_get_display(obj) : lv_display_get_default();
     return lv_display_get_theme(disp);
 }
 
+LV_FUNC_SECTION
 void lv_theme_apply(lv_obj_t * obj)
 {
     lv_theme_t * th = lv_theme_get_from_obj(obj);
@@ -53,40 +55,47 @@ void lv_theme_apply(lv_obj_t * obj)
     apply_theme_recursion(th, obj);    /*Apply the theme including the base theme(s)*/
 }
 
+LV_FUNC_SECTION
 void lv_theme_set_parent(lv_theme_t * new_theme, lv_theme_t * base)
 {
     new_theme->parent = base;
 }
 
+LV_FUNC_SECTION
 void lv_theme_set_apply_cb(lv_theme_t * theme, lv_theme_apply_cb_t apply_cb)
 {
     theme->apply_cb = apply_cb;
 }
 
+LV_FUNC_SECTION
 const lv_font_t * lv_theme_get_font_small(lv_obj_t * obj)
 {
     lv_theme_t * th = lv_theme_get_from_obj(obj);
     return th ? th->font_small : LV_FONT_DEFAULT;
 }
 
+LV_FUNC_SECTION
 const lv_font_t * lv_theme_get_font_normal(lv_obj_t * obj)
 {
     lv_theme_t * th = lv_theme_get_from_obj(obj);
     return th ? th->font_normal : LV_FONT_DEFAULT;
 }
 
+LV_FUNC_SECTION
 const lv_font_t * lv_theme_get_font_large(lv_obj_t * obj)
 {
     lv_theme_t * th = lv_theme_get_from_obj(obj);
     return th ? th->font_large : LV_FONT_DEFAULT;
 }
 
+LV_FUNC_SECTION
 lv_color_t lv_theme_get_color_primary(lv_obj_t * obj)
 {
     lv_theme_t * th = lv_theme_get_from_obj(obj);
     return th ? th->color_primary : lv_palette_main(LV_PALETTE_BLUE_GREY);
 }
 
+LV_FUNC_SECTION
 lv_color_t lv_theme_get_color_secondary(lv_obj_t * obj)
 {
     lv_theme_t * th = lv_theme_get_from_obj(obj);
@@ -96,13 +105,16 @@ lv_color_t lv_theme_get_color_secondary(lv_obj_t * obj)
 /**********************
  *   STATIC FUNCTIONS
  **********************/
-
+#pragma stackfunction 2048
+LV_FUNC_SECTION
 static void apply_theme(lv_theme_t * th, lv_obj_t * obj)
 {
     if(th->parent) apply_theme(th->parent, obj);
     if(th->apply_cb) th->apply_cb(th, obj);
 }
 
+#pragma stackfunction 2048
+LV_FUNC_SECTION
 static void apply_theme_recursion(lv_theme_t * th, lv_obj_t * obj)
 {
     const lv_obj_class_t * original_class_p = obj->class_p;
diff --git a/src/themes/mono/lv_theme_mono.c b/src/themes/mono/lv_theme_mono.c
index cd71ecb3d..707fb1683 100644
--- a/src/themes/mono/lv_theme_mono.c
+++ b/src/themes/mono/lv_theme_mono.c
@@ -83,6 +83,7 @@ static void theme_apply(lv_theme_t * th, lv_obj_t * obj);
  *   STATIC FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 static void style_init(my_theme_t * theme, bool dark_bg, const lv_font_t * font)
 {
     style_init_reset(&theme->styles.scrollbar);
@@ -180,6 +181,7 @@ static void style_init(my_theme_t * theme, bool dark_bg, const lv_font_t * font)
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 bool lv_theme_mono_is_inited(void)
 {
     my_theme_t * theme = theme_def;
@@ -187,6 +189,7 @@ bool lv_theme_mono_is_inited(void)
     return theme->inited;
 }
 
+LV_FUNC_SECTION
 void lv_theme_mono_deinit(void)
 {
     my_theme_t * theme = theme_def;
@@ -203,6 +206,7 @@ void lv_theme_mono_deinit(void)
     }
 }
 
+LV_FUNC_SECTION
 lv_theme_t * lv_theme_mono_init(lv_display_t * disp, bool dark_bg, const lv_font_t * font)
 {
     /*This trick is required only to avoid the garbage collection of
@@ -229,6 +233,7 @@ lv_theme_t * lv_theme_mono_init(lv_display_t * disp, bool dark_bg, const lv_font
     return (lv_theme_t *)theme_def;
 }
 
+LV_FUNC_SECTION
 static void theme_apply(lv_theme_t * th, lv_obj_t * obj)
 {
     LV_UNUSED(th);
@@ -519,6 +524,7 @@ static void theme_apply(lv_theme_t * th, lv_obj_t * obj)
  *   STATIC FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 static void style_init_reset(lv_style_t * style)
 {
     if(lv_theme_mono_is_inited()) {
diff --git a/src/themes/simple/lv_theme_simple.c b/src/themes/simple/lv_theme_simple.c
index 8a325550f..8fc7254b8 100644
--- a/src/themes/simple/lv_theme_simple.c
+++ b/src/themes/simple/lv_theme_simple.c
@@ -74,6 +74,7 @@ static void theme_apply(lv_theme_t * th, lv_obj_t * obj);
  *   STATIC FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 static void style_init(my_theme_t * theme)
 {
     style_init_reset(&theme->styles.scrollbar);
@@ -142,6 +143,7 @@ static void style_init(my_theme_t * theme)
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 bool lv_theme_simple_is_inited(void)
 {
     my_theme_t * theme = theme_def;
@@ -149,6 +151,7 @@ bool lv_theme_simple_is_inited(void)
     return theme->inited;
 }
 
+LV_FUNC_SECTION
 lv_theme_t * lv_theme_simple_get(void)
 {
     if(!lv_theme_simple_is_inited()) {
@@ -158,6 +161,7 @@ lv_theme_t * lv_theme_simple_get(void)
     return (lv_theme_t *)theme_def;
 }
 
+LV_FUNC_SECTION
 void lv_theme_simple_deinit(void)
 {
     my_theme_t * theme = theme_def;
@@ -174,6 +178,7 @@ void lv_theme_simple_deinit(void)
     }
 }
 
+LV_FUNC_SECTION
 lv_theme_t * lv_theme_simple_init(lv_display_t * disp)
 {
     /*This trick is required only to avoid the garbage collection of
@@ -202,6 +207,7 @@ lv_theme_t * lv_theme_simple_init(lv_display_t * disp)
     return (lv_theme_t *)theme_def;
 }
 
+LV_FUNC_SECTION
 static void theme_apply(lv_theme_t * th, lv_obj_t * obj)
 {
     LV_UNUSED(th);
@@ -425,6 +431,7 @@ static void theme_apply(lv_theme_t * th, lv_obj_t * obj)
  *   STATIC FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 static void style_init_reset(lv_style_t * style)
 {
     if(lv_theme_simple_is_inited()) {
diff --git a/src/tick/lv_tick.c b/src/tick/lv_tick.c
index 21e22959d..325d216ba 100644
--- a/src/tick/lv_tick.c
+++ b/src/tick/lv_tick.c
@@ -35,6 +35,7 @@
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 LV_ATTRIBUTE_TICK_INC void lv_tick_inc(uint32_t tick_period)
 {
     lv_tick_state_t * state_p = &state;
@@ -43,6 +44,7 @@ LV_ATTRIBUTE_TICK_INC void lv_tick_inc(uint32_t tick_period)
     state_p->sys_time += tick_period;
 }
 
+LV_FUNC_SECTION
 uint32_t lv_tick_get(void)
 {
     lv_tick_state_t * state_p = &state;
@@ -64,6 +66,7 @@ uint32_t lv_tick_get(void)
     return result;
 }
 
+LV_FUNC_SECTION
 uint32_t lv_tick_elaps(uint32_t prev_tick)
 {
     uint32_t act_time = lv_tick_get();
@@ -80,6 +83,7 @@ uint32_t lv_tick_elaps(uint32_t prev_tick)
     return prev_tick;
 }
 
+LV_FUNC_SECTION
 void lv_delay_ms(uint32_t ms)
 {
     if(state.delay_cb) {
@@ -98,11 +102,13 @@ void lv_delay_ms(uint32_t ms)
     }
 }
 
+LV_FUNC_SECTION
 void lv_tick_set_cb(lv_tick_get_cb_t cb)
 {
     state.tick_get_cb = cb;
 }
 
+LV_FUNC_SECTION
 void lv_delay_set_cb(lv_delay_cb_t cb)
 {
     state.delay_cb = cb;
diff --git a/src/tick/lv_tick_private.h b/src/tick/lv_tick_private.h
index cf8ae9b09..a3b7e84fb 100644
--- a/src/tick/lv_tick_private.h
+++ b/src/tick/lv_tick_private.h
@@ -27,7 +27,9 @@ extern "C" {
 typedef struct {
     uint32_t sys_time;
     volatile uint8_t sys_irq_flag;
+    __attribute__(( fptrgroup("lv_tick_get_cb") ))
     lv_tick_get_cb_t tick_get_cb;
+    __attribute__(( fptrgroup("lv_tick_delay_cb") ))
     lv_delay_cb_t delay_cb;
 } lv_tick_state_t;
 
diff --git a/src/widgets/animimage/lv_animimage.c b/src/widgets/animimage/lv_animimage.c
index 548c48c8c..2a7356e1c 100644
--- a/src/widgets/animimage/lv_animimage.c
+++ b/src/widgets/animimage/lv_animimage.c
@@ -59,6 +59,7 @@ const lv_obj_class_t lv_animimg_class = {
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 lv_obj_t * lv_animimg_create(lv_obj_t * parent)
 {
     LV_LOG_INFO("begin");
@@ -67,6 +68,7 @@ lv_obj_t * lv_animimg_create(lv_obj_t * parent)
     return obj;
 }
 
+LV_FUNC_SECTION
 void lv_animimg_set_src(lv_obj_t * obj, const void * dsc[], size_t num)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -76,6 +78,7 @@ void lv_animimg_set_src(lv_obj_t * obj, const void * dsc[], size_t num)
     lv_anim_set_values(&animimg->anim, 0, (int32_t)num);
 }
 
+LV_FUNC_SECTION
 void lv_animimg_start(lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -87,6 +90,7 @@ void lv_animimg_start(lv_obj_t * obj)
  * Setter functions
  *====================*/
 
+LV_FUNC_SECTION
 void lv_animimg_set_duration(lv_obj_t * obj, uint32_t duration)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -95,6 +99,7 @@ void lv_animimg_set_duration(lv_obj_t * obj, uint32_t duration)
     lv_anim_set_playback_delay(&animimg->anim, duration);
 }
 
+LV_FUNC_SECTION
 void lv_animimg_set_repeat_count(lv_obj_t * obj, uint32_t count)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -106,6 +111,7 @@ void lv_animimg_set_repeat_count(lv_obj_t * obj, uint32_t count)
  * Getter functions
  *====================*/
 
+LV_FUNC_SECTION
 const void ** lv_animimg_get_src(lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -113,6 +119,7 @@ const void ** lv_animimg_get_src(lv_obj_t * obj)
     return animimg->dsc;
 }
 
+LV_FUNC_SECTION
 uint8_t lv_animimg_get_src_count(lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -120,6 +127,7 @@ uint8_t lv_animimg_get_src_count(lv_obj_t * obj)
     return animimg->pic_count;
 }
 
+LV_FUNC_SECTION
 uint32_t lv_animimg_get_duration(lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -127,6 +135,7 @@ uint32_t lv_animimg_get_duration(lv_obj_t * obj)
     return lv_anim_get_time(&animimg->anim);
 }
 
+LV_FUNC_SECTION
 uint32_t lv_animimg_get_repeat_count(lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -134,6 +143,7 @@ uint32_t lv_animimg_get_repeat_count(lv_obj_t * obj)
     return lv_anim_get_repeat_count(&animimg->anim);
 }
 
+LV_FUNC_SECTION
 lv_anim_t * lv_animimg_get_anim(lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -145,6 +155,7 @@ lv_anim_t * lv_animimg_get_anim(lv_obj_t * obj)
  *   STATIC FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 static void lv_animimg_constructor(const lv_obj_class_t * class_p, lv_obj_t * obj)
 {
     LV_TRACE_OBJ_CREATE("begin");
@@ -164,6 +175,7 @@ static void lv_animimg_constructor(const lv_obj_class_t * class_p, lv_obj_t * ob
     lv_anim_set_repeat_count(&animimg->anim, LV_ANIM_REPEAT_INFINITE);
 }
 
+__attribute__(( fptrgroup("lv_anim_exec_cb") ))
 static void index_change(lv_obj_t * obj, int32_t idx)
 {
     lv_animimg_t * animimg = (lv_animimg_t *)obj;
diff --git a/src/widgets/arc/lv_arc.c b/src/widgets/arc/lv_arc.c
index 6aa14840d..1b537f0ce 100644
--- a/src/widgets/arc/lv_arc.c
+++ b/src/widgets/arc/lv_arc.c
@@ -71,6 +71,7 @@ const lv_obj_class_t lv_arc_class  = {
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 lv_obj_t * lv_arc_create(lv_obj_t * parent)
 {
     LV_LOG_INFO("begin");
@@ -91,6 +92,7 @@ lv_obj_t * lv_arc_create(lv_obj_t * parent)
  * Setter functions
  *====================*/
 
+LV_FUNC_SECTION
 void lv_arc_set_start_angle(lv_obj_t * obj, lv_value_precise_t start)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -115,6 +117,7 @@ void lv_arc_set_start_angle(lv_obj_t * obj, lv_value_precise_t start)
     inv_knob_area(obj);
 }
 
+LV_FUNC_SECTION
 void lv_arc_set_end_angle(lv_obj_t * obj, lv_value_precise_t end)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -138,12 +141,14 @@ void lv_arc_set_end_angle(lv_obj_t * obj, lv_value_precise_t end)
     inv_knob_area(obj);
 }
 
+LV_FUNC_SECTION
 void lv_arc_set_angles(lv_obj_t * obj, lv_value_precise_t start, lv_value_precise_t end)
 {
     lv_arc_set_end_angle(obj, end);
     lv_arc_set_start_angle(obj, start);
 }
 
+LV_FUNC_SECTION
 void lv_arc_set_bg_start_angle(lv_obj_t * obj, lv_value_precise_t start)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -166,6 +171,7 @@ void lv_arc_set_bg_start_angle(lv_obj_t * obj, lv_value_precise_t start)
     value_update(obj);
 }
 
+LV_FUNC_SECTION
 void lv_arc_set_bg_end_angle(lv_obj_t * obj, lv_value_precise_t end)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -188,12 +194,14 @@ void lv_arc_set_bg_end_angle(lv_obj_t * obj, lv_value_precise_t end)
     value_update(obj);
 }
 
+LV_FUNC_SECTION
 void lv_arc_set_bg_angles(lv_obj_t * obj, lv_value_precise_t start, lv_value_precise_t end)
 {
     lv_arc_set_bg_end_angle(obj, end);
     lv_arc_set_bg_start_angle(obj, start);
 }
 
+LV_FUNC_SECTION
 void lv_arc_set_rotation(lv_obj_t * obj, int32_t rotation)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -207,6 +215,7 @@ void lv_arc_set_rotation(lv_obj_t * obj, int32_t rotation)
     lv_obj_invalidate(obj);
 }
 
+LV_FUNC_SECTION
 void lv_arc_set_mode(lv_obj_t * obj, lv_arc_mode_t type)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -236,6 +245,7 @@ void lv_arc_set_mode(lv_obj_t * obj, lv_arc_mode_t type)
     lv_arc_set_value(obj, val);
 }
 
+LV_FUNC_SECTION
 void lv_arc_set_value(lv_obj_t * obj, int32_t value)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -253,6 +263,7 @@ void lv_arc_set_value(lv_obj_t * obj, int32_t value)
     value_update(obj);
 }
 
+LV_FUNC_SECTION
 void lv_arc_set_range(lv_obj_t * obj, int32_t min, int32_t max)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -273,6 +284,7 @@ void lv_arc_set_range(lv_obj_t * obj, int32_t min, int32_t max)
     value_update(obj); /*value has changed relative to the new range*/
 }
 
+LV_FUNC_SECTION
 void lv_arc_set_change_rate(lv_obj_t * obj, uint32_t rate)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -281,6 +293,7 @@ void lv_arc_set_change_rate(lv_obj_t * obj, uint32_t rate)
     arc->chg_rate = rate;
 }
 
+LV_FUNC_SECTION
 void lv_arc_set_knob_offset(lv_obj_t * obj, int32_t offset)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -293,60 +306,70 @@ void lv_arc_set_knob_offset(lv_obj_t * obj, int32_t offset)
  * Getter functions
  *====================*/
 
+LV_FUNC_SECTION
 lv_value_precise_t lv_arc_get_angle_start(lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
     return ((lv_arc_t *) obj)->indic_angle_start;
 }
 
+LV_FUNC_SECTION
 lv_value_precise_t lv_arc_get_angle_end(lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
     return ((lv_arc_t *) obj)->indic_angle_end;
 }
 
+LV_FUNC_SECTION
 lv_value_precise_t lv_arc_get_bg_angle_start(lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
     return ((lv_arc_t *) obj)->bg_angle_start;
 }
 
+LV_FUNC_SECTION
 lv_value_precise_t lv_arc_get_bg_angle_end(lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
     return ((lv_arc_t *) obj)->bg_angle_end;
 }
 
+LV_FUNC_SECTION
 int32_t lv_arc_get_value(const lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
     return ((lv_arc_t *) obj)->value;
 }
 
+LV_FUNC_SECTION
 int32_t lv_arc_get_min_value(const lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
     return ((lv_arc_t *) obj)->min_value;
 }
 
+LV_FUNC_SECTION
 int32_t lv_arc_get_max_value(const lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
     return ((lv_arc_t *) obj)->max_value;
 }
 
+LV_FUNC_SECTION
 lv_arc_mode_t lv_arc_get_mode(const lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
     return ((lv_arc_t *) obj)->type;
 }
 
+LV_FUNC_SECTION
 int32_t lv_arc_get_rotation(const lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
     return ((lv_arc_t *)obj)->rotation;
 }
 
+LV_FUNC_SECTION
 int32_t lv_arc_get_knob_offset(const lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -357,6 +380,7 @@ int32_t lv_arc_get_knob_offset(const lv_obj_t * obj)
  * Other functions
  *====================*/
 
+LV_FUNC_SECTION
 void lv_arc_align_obj_to_angle(const lv_obj_t * obj, lv_obj_t * obj_to_align, int32_t r_offset)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -378,6 +402,7 @@ void lv_arc_align_obj_to_angle(const lv_obj_t * obj, lv_obj_t * obj_to_align, in
     lv_obj_align_to(obj_to_align, obj, LV_ALIGN_CENTER, knob_x, knob_y);
 }
 
+LV_FUNC_SECTION
 void lv_arc_rotate_obj_to_angle(const lv_obj_t * obj, lv_obj_t * obj_to_rotate, int32_t r_offset)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -409,6 +434,7 @@ void lv_arc_rotate_obj_to_angle(const lv_obj_t * obj, lv_obj_t * obj_to_rotate,
  *   STATIC FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 static void lv_arc_constructor(const lv_obj_class_t * class_p, lv_obj_t * obj)
 {
     LV_UNUSED(class_p);
@@ -440,6 +466,7 @@ static void lv_arc_constructor(const lv_obj_class_t * class_p, lv_obj_t * obj)
     LV_TRACE_OBJ_CREATE("finished");
 }
 
+LV_FUNC_SECTION
 static void lv_arc_event(const lv_obj_class_t * class_p, lv_event_t * e)
 {
     LV_UNUSED(class_p);
@@ -706,6 +733,7 @@ static void lv_arc_event(const lv_obj_class_t * class_p, lv_event_t * e)
     }
 }
 
+LV_FUNC_SECTION
 static void lv_arc_draw(lv_event_t * e)
 {
     lv_obj_t * obj = lv_event_get_current_target(e);
@@ -757,6 +785,7 @@ static void lv_arc_draw(lv_event_t * e)
     lv_draw_rect(layer, &knob_rect_dsc, &knob_area);
 }
 
+LV_FUNC_SECTION
 static void inv_arc_area(lv_obj_t * obj, lv_value_precise_t start_angle, lv_value_precise_t end_angle, lv_part_t part)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -790,6 +819,7 @@ static void inv_arc_area(lv_obj_t * obj, lv_value_precise_t start_angle, lv_valu
     lv_obj_invalidate_area(obj, &inv_area);
 }
 
+LV_FUNC_SECTION
 static void inv_knob_area(lv_obj_t * obj)
 {
     lv_point_t c;
@@ -808,6 +838,7 @@ static void inv_knob_area(lv_obj_t * obj)
     lv_obj_invalidate_area(obj, &a);
 }
 
+LV_FUNC_SECTION
 static void get_center(const lv_obj_t * obj, lv_point_t * center, int32_t * arc_r)
 {
     int32_t left_bg = lv_obj_get_style_pad_left(obj, LV_PART_MAIN);
@@ -824,6 +855,7 @@ static void get_center(const lv_obj_t * obj, lv_point_t * center, int32_t * arc_
     if(arc_r) *arc_r = r;
 }
 
+LV_FUNC_SECTION
 static lv_value_precise_t get_angle(const lv_obj_t * obj)
 {
     lv_arc_t * arc = (lv_arc_t *)obj;
@@ -849,6 +881,7 @@ static lv_value_precise_t get_angle(const lv_obj_t * obj)
     return angle;
 }
 
+LV_FUNC_SECTION
 static void get_knob_area(lv_obj_t * obj, const lv_point_t * center, int32_t r, lv_area_t * knob_area)
 {
     int32_t indic_width = lv_obj_get_style_arc_width(obj, LV_PART_INDICATOR);
@@ -875,6 +908,7 @@ static void get_knob_area(lv_obj_t * obj, const lv_point_t * center, int32_t r,
  * Used internally to update arc angles after a value change
  * @param arc pointer to an arc object
  */
+LV_FUNC_SECTION
 static void value_update(lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -920,6 +954,7 @@ static void value_update(lv_obj_t * obj)
     arc->last_angle = angle; /*Cache angle for slew rate limiting*/
 }
 
+LV_FUNC_SECTION
 static int32_t knob_get_extra_size(lv_obj_t * obj)
 {
     int32_t knob_shadow_size = 0;
@@ -957,6 +992,7 @@ static int32_t knob_get_extra_size(lv_obj_t * obj)
  *
  * @return true if angle is within arc background bounds, false otherwise
  */
+LV_FUNC_SECTION
 static bool lv_arc_angle_within_bg_bounds(lv_obj_t * obj, const lv_value_precise_t angle,
                                           const lv_value_precise_t tolerance_deg)
 {
diff --git a/src/widgets/bar/lv_bar.c b/src/widgets/bar/lv_bar.c
index 6fc7b231a..4be9378d4 100644
--- a/src/widgets/bar/lv_bar.c
+++ b/src/widgets/bar/lv_bar.c
@@ -80,6 +80,7 @@ const lv_obj_class_t lv_bar_class = {
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 lv_obj_t * lv_bar_create(lv_obj_t * parent)
 {
     LV_LOG_INFO("begin");
@@ -92,6 +93,7 @@ lv_obj_t * lv_bar_create(lv_obj_t * parent)
  * Setter functions
  *====================*/
 
+LV_FUNC_SECTION
 void lv_bar_set_value(lv_obj_t * obj, int32_t value, lv_anim_enable_t anim)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -107,6 +109,7 @@ void lv_bar_set_value(lv_obj_t * obj, int32_t value, lv_anim_enable_t anim)
     lv_bar_set_value_with_anim(obj, value, &bar->cur_value, &bar->cur_value_anim, anim);
 }
 
+LV_FUNC_SECTION
 void lv_bar_set_start_value(lv_obj_t * obj, int32_t value, lv_anim_enable_t anim)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -125,6 +128,7 @@ void lv_bar_set_start_value(lv_obj_t * obj, int32_t value, lv_anim_enable_t anim
     lv_bar_set_value_with_anim(obj, value, &bar->start_value, &bar->start_value_anim, anim);
 }
 
+LV_FUNC_SECTION
 void lv_bar_set_range(lv_obj_t * obj, int32_t min, int32_t max)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -155,6 +159,7 @@ void lv_bar_set_range(lv_obj_t * obj, int32_t min, int32_t max)
     lv_obj_invalidate(obj);
 }
 
+LV_FUNC_SECTION
 void lv_bar_set_mode(lv_obj_t * obj, lv_bar_mode_t mode)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -168,6 +173,7 @@ void lv_bar_set_mode(lv_obj_t * obj, lv_bar_mode_t mode)
     lv_obj_invalidate(obj);
 }
 
+LV_FUNC_SECTION
 void lv_bar_set_orientation(lv_obj_t * obj, lv_bar_orientation_t orientation)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -181,6 +187,7 @@ void lv_bar_set_orientation(lv_obj_t * obj, lv_bar_orientation_t orientation)
  * Getter functions
  *====================*/
 
+LV_FUNC_SECTION
 int32_t lv_bar_get_value(const lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -189,6 +196,7 @@ int32_t lv_bar_get_value(const lv_obj_t * obj)
     return LV_BAR_GET_ANIM_VALUE(bar->cur_value, bar->cur_value_anim);
 }
 
+LV_FUNC_SECTION
 int32_t lv_bar_get_start_value(const lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -199,6 +207,7 @@ int32_t lv_bar_get_start_value(const lv_obj_t * obj)
     return LV_BAR_GET_ANIM_VALUE(bar->start_value, bar->start_value_anim);
 }
 
+LV_FUNC_SECTION
 int32_t lv_bar_get_min_value(const lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -206,6 +215,7 @@ int32_t lv_bar_get_min_value(const lv_obj_t * obj)
     return bar->val_reversed ? bar->max_value : bar->min_value;
 }
 
+LV_FUNC_SECTION
 int32_t lv_bar_get_max_value(const lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -214,6 +224,7 @@ int32_t lv_bar_get_max_value(const lv_obj_t * obj)
     return bar->val_reversed ? bar->min_value : bar->max_value;
 }
 
+LV_FUNC_SECTION
 lv_bar_mode_t lv_bar_get_mode(lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -222,6 +233,7 @@ lv_bar_mode_t lv_bar_get_mode(lv_obj_t * obj)
     return bar->mode;
 }
 
+LV_FUNC_SECTION
 lv_bar_orientation_t lv_bar_get_orientation(lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -230,6 +242,7 @@ lv_bar_orientation_t lv_bar_get_orientation(lv_obj_t * obj)
     return bar->orientation;
 }
 
+LV_FUNC_SECTION
 bool lv_bar_is_symmetrical(lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -243,6 +256,7 @@ bool lv_bar_is_symmetrical(lv_obj_t * obj)
  *   STATIC FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 static void lv_bar_constructor(const lv_obj_class_t * class_p, lv_obj_t * obj)
 {
     LV_UNUSED(class_p);
@@ -271,6 +285,7 @@ static void lv_bar_constructor(const lv_obj_class_t * class_p, lv_obj_t * obj)
     LV_TRACE_OBJ_CREATE("finished");
 }
 
+LV_FUNC_SECTION
 static void lv_bar_destructor(const lv_obj_class_t * class_p, lv_obj_t * obj)
 {
     LV_UNUSED(class_p);
@@ -280,6 +295,7 @@ static void lv_bar_destructor(const lv_obj_class_t * class_p, lv_obj_t * obj)
     lv_anim_delete(&bar->start_value_anim, NULL);
 }
 
+LV_FUNC_SECTION
 static void draw_indic(lv_event_t * e)
 {
     lv_obj_t * obj = lv_event_get_current_target(e);
@@ -585,6 +601,7 @@ static void draw_indic(lv_event_t * e)
     }
 }
 
+LV_FUNC_SECTION
 static void lv_bar_event(const lv_obj_class_t * class_p, lv_event_t * e)
 {
     LV_UNUSED(class_p);
@@ -626,6 +643,7 @@ static void lv_bar_event(const lv_obj_class_t * class_p, lv_event_t * e)
     }
 }
 
+__attribute__(( fptrgroup("lv_anim_exec_cb") ))
 static void lv_bar_anim(void * var, int32_t value)
 {
     lv_bar_anim_t * bar_anim = var;
@@ -633,6 +651,7 @@ static void lv_bar_anim(void * var, int32_t value)
     lv_obj_invalidate(bar_anim->bar);
 }
 
+__attribute__(( fptrgroup("lv_anim_completed_cb") ))
 static void lv_bar_anim_completed(lv_anim_t * a)
 {
     lv_bar_anim_t * var = a->var;
@@ -647,6 +666,7 @@ static void lv_bar_anim_completed(lv_anim_t * a)
     lv_obj_invalidate(var->bar);
 }
 
+LV_FUNC_SECTION
 static void lv_bar_set_value_with_anim(lv_obj_t * obj, int32_t new_value, int32_t * value_ptr,
                                        lv_bar_anim_t * anim_info, lv_anim_enable_t en)
 {
@@ -687,6 +707,7 @@ static void lv_bar_set_value_with_anim(lv_obj_t * obj, int32_t new_value, int32_
     }
 }
 
+LV_FUNC_SECTION
 static void lv_bar_init_anim(lv_obj_t * obj, lv_bar_anim_t * bar_anim)
 {
     bar_anim->bar = obj;
diff --git a/src/widgets/button/lv_button.c b/src/widgets/button/lv_button.c
index 096dc2954..e2828141e 100644
--- a/src/widgets/button/lv_button.c
+++ b/src/widgets/button/lv_button.c
@@ -46,6 +46,7 @@ const lv_obj_class_t lv_button_class  = {
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 lv_obj_t * lv_button_create(lv_obj_t * parent)
 {
     LV_LOG_INFO("begin");
@@ -58,6 +59,7 @@ lv_obj_t * lv_button_create(lv_obj_t * parent)
  *   STATIC FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 static void lv_button_constructor(const lv_obj_class_t * class_p, lv_obj_t * obj)
 {
     LV_UNUSED(class_p);
diff --git a/src/widgets/buttonmatrix/lv_buttonmatrix.c b/src/widgets/buttonmatrix/lv_buttonmatrix.c
index e20ac2ebe..827685261 100644
--- a/src/widgets/buttonmatrix/lv_buttonmatrix.c
+++ b/src/widgets/buttonmatrix/lv_buttonmatrix.c
@@ -84,6 +84,7 @@ const lv_obj_class_t lv_buttonmatrix_class = {
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 lv_obj_t * lv_buttonmatrix_create(lv_obj_t * parent)
 {
     LV_LOG_INFO("begin");
@@ -96,6 +97,7 @@ lv_obj_t * lv_buttonmatrix_create(lv_obj_t * parent)
  * Setter functions
  *====================*/
 
+LV_FUNC_SECTION
 void lv_buttonmatrix_set_map(lv_obj_t * obj, const char * const map[])
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -187,6 +189,7 @@ void lv_buttonmatrix_set_map(lv_obj_t * obj, const char * const map[])
     lv_obj_invalidate(obj);
 }
 
+LV_FUNC_SECTION
 void lv_buttonmatrix_set_ctrl_map(lv_obj_t * obj, const lv_buttonmatrix_ctrl_t ctrl_map[])
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -197,6 +200,7 @@ void lv_buttonmatrix_set_ctrl_map(lv_obj_t * obj, const lv_buttonmatrix_ctrl_t c
     lv_buttonmatrix_set_map(obj, btnm->map_p);
 }
 
+LV_FUNC_SECTION
 void lv_buttonmatrix_set_selected_button(lv_obj_t * obj, uint32_t btn_id)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -210,6 +214,7 @@ void lv_buttonmatrix_set_selected_button(lv_obj_t * obj, uint32_t btn_id)
     invalidate_button_area(obj, btn_id);
 }
 
+LV_FUNC_SECTION
 void lv_buttonmatrix_set_button_ctrl(lv_obj_t * obj, uint32_t btn_id, lv_buttonmatrix_ctrl_t ctrl)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -230,6 +235,7 @@ void lv_buttonmatrix_set_button_ctrl(lv_obj_t * obj, uint32_t btn_id, lv_buttonm
     }
 }
 
+LV_FUNC_SECTION
 void lv_buttonmatrix_clear_button_ctrl(lv_obj_t * obj, uint32_t btn_id, lv_buttonmatrix_ctrl_t ctrl)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -246,6 +252,7 @@ void lv_buttonmatrix_clear_button_ctrl(lv_obj_t * obj, uint32_t btn_id, lv_butto
     }
 }
 
+LV_FUNC_SECTION
 void lv_buttonmatrix_set_button_ctrl_all(lv_obj_t * obj, lv_buttonmatrix_ctrl_t ctrl)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -257,6 +264,7 @@ void lv_buttonmatrix_set_button_ctrl_all(lv_obj_t * obj, lv_buttonmatrix_ctrl_t
     }
 }
 
+LV_FUNC_SECTION
 void lv_buttonmatrix_clear_button_ctrl_all(lv_obj_t * obj, lv_buttonmatrix_ctrl_t ctrl)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -268,6 +276,7 @@ void lv_buttonmatrix_clear_button_ctrl_all(lv_obj_t * obj, lv_buttonmatrix_ctrl_
     }
 }
 
+LV_FUNC_SECTION
 void lv_buttonmatrix_set_button_width(lv_obj_t * obj, uint32_t btn_id, uint32_t width)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -280,6 +289,7 @@ void lv_buttonmatrix_set_button_width(lv_obj_t * obj, uint32_t btn_id, uint32_t
     lv_buttonmatrix_set_map(obj, btnm->map_p);
 }
 
+LV_FUNC_SECTION
 void lv_buttonmatrix_set_one_checked(lv_obj_t * obj, bool en)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -295,6 +305,7 @@ void lv_buttonmatrix_set_one_checked(lv_obj_t * obj, bool en)
  * Getter functions
  *====================*/
 
+LV_FUNC_SECTION
 const char * const * lv_buttonmatrix_get_map(const lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -303,6 +314,7 @@ const char * const * lv_buttonmatrix_get_map(const lv_obj_t * obj)
     return btnm->map_p;
 }
 
+LV_FUNC_SECTION
 uint32_t lv_buttonmatrix_get_selected_button(const lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -311,6 +323,7 @@ uint32_t lv_buttonmatrix_get_selected_button(const lv_obj_t * obj)
     return btnm->btn_id_sel;
 }
 
+LV_FUNC_SECTION
 const char * lv_buttonmatrix_get_button_text(const lv_obj_t * obj, uint32_t btn_id)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -336,6 +349,7 @@ const char * lv_buttonmatrix_get_button_text(const lv_obj_t * obj, uint32_t btn_
     return btnm->map_p[txt_i];
 }
 
+LV_FUNC_SECTION
 bool lv_buttonmatrix_has_button_ctrl(lv_obj_t * obj, uint32_t btn_id, lv_buttonmatrix_ctrl_t ctrl)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -346,6 +360,7 @@ bool lv_buttonmatrix_has_button_ctrl(lv_obj_t * obj, uint32_t btn_id, lv_buttonm
     return (btnm->ctrl_bits[btn_id] & ctrl) == ctrl;
 }
 
+LV_FUNC_SECTION
 bool lv_buttonmatrix_get_one_checked(const lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -359,6 +374,7 @@ bool lv_buttonmatrix_get_one_checked(const lv_obj_t * obj)
  *   STATIC FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 static void lv_buttonmatrix_constructor(const lv_obj_class_t * class_p, lv_obj_t * obj)
 {
     LV_UNUSED(class_p);
@@ -379,6 +395,7 @@ static void lv_buttonmatrix_constructor(const lv_obj_class_t * class_p, lv_obj_t
     LV_TRACE_OBJ_CREATE("finished");
 }
 
+LV_FUNC_SECTION
 static void lv_buttonmatrix_destructor(const lv_obj_class_t * class_p, lv_obj_t * obj)
 {
     LV_TRACE_OBJ_CREATE("begin");
@@ -391,6 +408,7 @@ static void lv_buttonmatrix_destructor(const lv_obj_class_t * class_p, lv_obj_t
     LV_TRACE_OBJ_CREATE("finished");
 }
 
+LV_FUNC_SECTION
 static void lv_buttonmatrix_event(const lv_obj_class_t * class_p, lv_event_t * e)
 {
     LV_UNUSED(class_p);
@@ -662,6 +680,7 @@ static void lv_buttonmatrix_event(const lv_obj_class_t * class_p, lv_event_t * e
 
 }
 
+LV_FUNC_SECTION
 static void draw_main(lv_event_t * e)
 {
     lv_obj_t * obj = lv_event_get_current_target(e);
@@ -813,6 +832,7 @@ static void draw_main(lv_event_t * e)
  * @param obj pointer to button matrix object
  * @param map_p pointer to a string array
  */
+LV_FUNC_SECTION
 static void allocate_button_areas_and_controls(const lv_obj_t * obj, const char * const * map)
 {
     lv_buttonmatrix_t * btnm = (lv_buttonmatrix_t *)obj;
@@ -858,47 +878,56 @@ static void allocate_button_areas_and_controls(const lv_obj_t * obj, const char
  * @param ctrl_bits least significant 3 bits used (1..7 valid values)
  * @return the width of the button in units
  */
+LV_FUNC_SECTION
 static uint32_t get_button_width(lv_buttonmatrix_ctrl_t ctrl_bits)
 {
     uint32_t w = ctrl_bits & LV_BUTTONMATRIX_WIDTH_MASK;
     return w != 0 ? w : 1;
 }
 
+LV_FUNC_SECTION
 static bool button_is_hidden(lv_buttonmatrix_ctrl_t ctrl_bits)
 {
     return ctrl_bits & LV_BUTTONMATRIX_CTRL_HIDDEN;
 }
 
+LV_FUNC_SECTION
 static bool button_is_checked(lv_buttonmatrix_ctrl_t ctrl_bits)
 {
     return ctrl_bits & LV_BUTTONMATRIX_CTRL_CHECKED;
 }
 
+LV_FUNC_SECTION
 static bool button_is_repeat_disabled(lv_buttonmatrix_ctrl_t ctrl_bits)
 {
     return ctrl_bits & LV_BUTTONMATRIX_CTRL_NO_REPEAT;
 }
 
+LV_FUNC_SECTION
 static bool button_is_inactive(lv_buttonmatrix_ctrl_t ctrl_bits)
 {
     return ctrl_bits & LV_BUTTONMATRIX_CTRL_DISABLED;
 }
 
+LV_FUNC_SECTION
 static bool button_is_click_trig(lv_buttonmatrix_ctrl_t ctrl_bits)
 {
     return ctrl_bits & LV_BUTTONMATRIX_CTRL_CLICK_TRIG;
 }
 
+LV_FUNC_SECTION
 static bool button_is_popover(lv_buttonmatrix_ctrl_t ctrl_bits)
 {
     return ctrl_bits & LV_BUTTONMATRIX_CTRL_POPOVER;
 }
 
+LV_FUNC_SECTION
 static bool button_is_checkable(lv_buttonmatrix_ctrl_t ctrl_bits)
 {
     return ctrl_bits & LV_BUTTONMATRIX_CTRL_CHECKABLE;
 }
 
+LV_FUNC_SECTION
 static bool button_get_checked(lv_buttonmatrix_ctrl_t ctrl_bits)
 {
     return ctrl_bits & LV_BUTTONMATRIX_CTRL_CHECKED;
@@ -910,6 +939,7 @@ static bool button_get_checked(lv_buttonmatrix_ctrl_t ctrl_bits)
  * @param p a point with absolute coordinates
  * @return the id of the button or LV_BUTTONMATRIX_BUTTON_NONE.
  */
+LV_FUNC_SECTION
 static uint32_t get_button_from_point(lv_obj_t * obj, lv_point_t * p)
 {
     lv_area_t obj_cords;
@@ -963,6 +993,7 @@ static uint32_t get_button_from_point(lv_obj_t * obj, lv_point_t * p)
     return i;
 }
 
+LV_FUNC_SECTION
 static void invalidate_button_area(const lv_obj_t * obj, uint32_t btn_idx)
 {
     if(btn_idx == LV_BUTTONMATRIX_BUTTON_NONE) return;
@@ -1006,6 +1037,7 @@ static void invalidate_button_area(const lv_obj_t * obj, uint32_t btn_idx)
  * @param obj Button matrix object
  * @param btn_idx Button that should remain toggled
  */
+LV_FUNC_SECTION
 static void make_one_button_checked(lv_obj_t * obj, uint32_t btn_idx)
 {
     /*Save whether the button was toggled*/
@@ -1021,6 +1053,7 @@ static void make_one_button_checked(lv_obj_t * obj, uint32_t btn_idx)
  * @param obj Button matrix object
  * @return true if at least one button has the flag, false otherwise
  */
+LV_FUNC_SECTION
 static bool has_popovers_in_top_row(lv_obj_t * obj)
 {
     lv_buttonmatrix_t * btnm = (lv_buttonmatrix_t *)obj;
diff --git a/src/widgets/calendar/lv_calendar.c b/src/widgets/calendar/lv_calendar.c
index 560e24a1d..ec39cd536 100644
--- a/src/widgets/calendar/lv_calendar.c
+++ b/src/widgets/calendar/lv_calendar.c
@@ -68,6 +68,7 @@ static const char * day_names_def[7] = LV_CALENDAR_DEFAULT_DAY_NAMES;
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 lv_obj_t * lv_calendar_create(lv_obj_t * parent)
 {
     LV_LOG_INFO("begin");
@@ -80,6 +81,7 @@ lv_obj_t * lv_calendar_create(lv_obj_t * parent)
  * Setter functions
  *====================*/
 
+LV_FUNC_SECTION
 void lv_calendar_set_day_names(lv_obj_t * obj, const char * day_names[])
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -92,6 +94,7 @@ void lv_calendar_set_day_names(lv_obj_t * obj, const char * day_names[])
     lv_obj_invalidate(obj);
 }
 
+LV_FUNC_SECTION
 void lv_calendar_set_today_date(lv_obj_t * obj, uint32_t year, uint32_t month, uint32_t day)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -104,6 +107,7 @@ void lv_calendar_set_today_date(lv_obj_t * obj, uint32_t year, uint32_t month, u
     highlight_update(obj);
 }
 
+LV_FUNC_SECTION
 void lv_calendar_set_highlighted_dates(lv_obj_t * obj, lv_calendar_date_t highlighted[], size_t date_num)
 {
     LV_ASSERT_NULL(highlighted);
@@ -117,6 +121,7 @@ void lv_calendar_set_highlighted_dates(lv_obj_t * obj, lv_calendar_date_t highli
     highlight_update(obj);
 }
 
+LV_FUNC_SECTION
 void lv_calendar_set_showed_date(lv_obj_t * obj, uint32_t year, uint32_t month)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -216,6 +221,7 @@ void lv_calendar_set_showed_date(lv_obj_t * obj, uint32_t year, uint32_t month)
  * Getter functions
  *====================*/
 
+LV_FUNC_SECTION
 lv_obj_t * lv_calendar_get_btnmatrix(const lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -223,6 +229,7 @@ lv_obj_t * lv_calendar_get_btnmatrix(const lv_obj_t * obj)
     return calendar->btnm;
 }
 
+LV_FUNC_SECTION
 const lv_calendar_date_t * lv_calendar_get_today_date(const lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -231,6 +238,7 @@ const lv_calendar_date_t * lv_calendar_get_today_date(const lv_obj_t * obj)
     return &calendar->today;
 }
 
+LV_FUNC_SECTION
 const lv_calendar_date_t * lv_calendar_get_showed_date(const lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -239,6 +247,7 @@ const lv_calendar_date_t * lv_calendar_get_showed_date(const lv_obj_t * obj)
     return &calendar->showed_date;
 }
 
+LV_FUNC_SECTION
 lv_calendar_date_t * lv_calendar_get_highlighted_dates(const lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -247,6 +256,7 @@ lv_calendar_date_t * lv_calendar_get_highlighted_dates(const lv_obj_t * obj)
     return calendar->highlighted_dates;
 }
 
+LV_FUNC_SECTION
 size_t lv_calendar_get_highlighted_dates_num(const lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -255,6 +265,7 @@ size_t lv_calendar_get_highlighted_dates_num(const lv_obj_t * obj)
     return calendar->highlighted_dates_num;
 }
 
+LV_FUNC_SECTION
 lv_result_t lv_calendar_get_pressed_date(const lv_obj_t * obj, lv_calendar_date_t * date)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -283,6 +294,7 @@ lv_result_t lv_calendar_get_pressed_date(const lv_obj_t * obj, lv_calendar_date_
  *  STATIC FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 static void lv_calendar_constructor(const lv_obj_class_t * class_p, lv_obj_t * obj)
 {
     LV_UNUSED(class_p);
@@ -336,6 +348,7 @@ static void lv_calendar_constructor(const lv_obj_class_t * class_p, lv_obj_t * o
     lv_calendar_set_today_date(obj, calendar->today.year, calendar->today.month, calendar->today.day);
 }
 
+__attribute__(( fptrgroup("lv_event_cb") ))
 static void draw_task_added_event_cb(lv_event_t * e)
 {
     lv_obj_t * obj = lv_event_get_current_target(e);
@@ -384,6 +397,7 @@ static void draw_task_added_event_cb(lv_event_t * e)
  *              supported to handle next/prev. year
  * @return [28..31]
  */
+LV_FUNC_SECTION
 static uint8_t get_month_length(int32_t year, int32_t month)
 {
     month--;
@@ -405,6 +419,7 @@ static uint8_t get_month_length(int32_t year, int32_t month)
  * @param year a year
  * @return 0: not leap year; 1: leap year
  */
+LV_FUNC_SECTION
 static uint8_t is_leap_year(uint32_t year)
 {
     return (year % 4) || ((year % 100 == 0) && (year % 400)) ? 0 : 1;
@@ -417,6 +432,7 @@ static uint8_t is_leap_year(uint32_t year)
  * @param day a day [1..32]
  * @return [0..6] which means [Sun..Sat] or [Mon..Sun] depending on LV_CALENDAR_WEEK_STARTS_MONDAY
  */
+LV_FUNC_SECTION
 static uint8_t get_day_of_week(uint32_t year, uint32_t month, uint32_t day)
 {
     uint32_t a = month < 3 ? 1 : 0;
@@ -431,6 +447,7 @@ static uint8_t get_day_of_week(uint32_t year, uint32_t month, uint32_t day)
     return day_of_week  ;
 }
 
+LV_FUNC_SECTION
 static void highlight_update(lv_obj_t * obj)
 {
     lv_calendar_t * calendar = (lv_calendar_t *)obj;
@@ -457,6 +474,7 @@ static void highlight_update(lv_obj_t * obj)
 
 #if LV_USE_CALENDAR_CHINESE
 
+LV_FUNC_SECTION
 static lv_calendar_date_t gregorian_get_last_month_time(lv_calendar_date_t * time)
 {
     lv_calendar_date_t last_month_time;
@@ -471,6 +489,7 @@ static lv_calendar_date_t gregorian_get_last_month_time(lv_calendar_date_t * tim
     return last_month_time;
 }
 
+LV_FUNC_SECTION
 static lv_calendar_date_t gregorian_get_next_month_time(lv_calendar_date_t * time)
 {
     lv_calendar_date_t next_month_time;
@@ -485,6 +504,7 @@ static lv_calendar_date_t gregorian_get_next_month_time(lv_calendar_date_t * tim
     return next_month_time;
 }
 
+LV_FUNC_SECTION
 static void chinese_calendar_set_day_name(lv_obj_t * obj, uint8_t index, uint8_t day,
                                           lv_calendar_date_t * gregorian_time)
 {
diff --git a/src/widgets/calendar/lv_calendar_chinese.c b/src/widgets/calendar/lv_calendar_chinese.c
index ee24133ad..8b466fbdc 100644
--- a/src/widgets/calendar/lv_calendar_chinese.c
+++ b/src/widgets/calendar/lv_calendar_chinese.c
@@ -112,6 +112,7 @@ static const lv_calendar_festival_t festivals_base_gregorian[] = {
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 void lv_calendar_set_chinese_mode(lv_obj_t * obj, bool en)
 {
     lv_calendar_t * calendar = (lv_calendar_t *)obj;
@@ -119,6 +120,7 @@ void lv_calendar_set_chinese_mode(lv_obj_t * obj, bool en)
     lv_calendar_set_showed_date(obj, calendar->today.year, calendar->today.month);
 }
 
+LV_FUNC_SECTION
 const char * lv_calendar_get_day_name(lv_calendar_date_t * gregorian)
 {
     uint16_t i, len;
@@ -169,6 +171,7 @@ const char * lv_calendar_get_day_name(lv_calendar_date_t * gregorian)
     return (char *)chinese_calendar_day_name[chinese_calendar.today.day - 1];
 }
 
+LV_FUNC_SECTION
 void lv_calendar_gregorian_to_chinese(lv_calendar_date_t * gregorian_time, lv_calendar_chinese_t * chinese_time)
 {
     uint16_t year = gregorian_time->year;
diff --git a/src/widgets/calendar/lv_calendar_header_arrow.c b/src/widgets/calendar/lv_calendar_header_arrow.c
index 09b201d04..8efa247d6 100644
--- a/src/widgets/calendar/lv_calendar_header_arrow.c
+++ b/src/widgets/calendar/lv_calendar_header_arrow.c
@@ -53,6 +53,7 @@ static const char * month_names_def[12] = LV_CALENDAR_DEFAULT_MONTH_NAMES;
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 lv_obj_t * lv_calendar_header_arrow_create(lv_obj_t * parent)
 {
     lv_obj_t * obj = lv_obj_class_create_obj(&lv_calendar_header_arrow_class, parent);
@@ -64,6 +65,7 @@ lv_obj_t * lv_calendar_header_arrow_create(lv_obj_t * parent)
  *  STATIC FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 static void my_constructor(const lv_obj_class_t * class_p, lv_obj_t * obj)
 {
     LV_TRACE_OBJ_CREATE("begin");
@@ -102,6 +104,7 @@ static void my_constructor(const lv_obj_class_t * class_p, lv_obj_t * obj)
     lv_obj_send_event(obj, LV_EVENT_VALUE_CHANGED, NULL);
 }
 
+__attribute__(( fptrgroup("lv_event_cb") ))
 static void month_event_cb(lv_event_t * e)
 {
     lv_obj_t * btn = lv_event_get_current_target(e);
@@ -142,6 +145,7 @@ static void month_event_cb(lv_event_t * e)
     lv_label_set_text_fmt(label, "%d %s", newd.year, month_names_def[newd.month - 1]);
 }
 
+__attribute__(( fptrgroup("lv_event_cb") ))
 static void value_changed_event_cb(lv_event_t * e)
 {
     lv_obj_t * header = lv_event_get_current_target(e);
diff --git a/src/widgets/calendar/lv_calendar_header_dropdown.c b/src/widgets/calendar/lv_calendar_header_dropdown.c
index 41fe53a82..37212442a 100644
--- a/src/widgets/calendar/lv_calendar_header_dropdown.c
+++ b/src/widgets/calendar/lv_calendar_header_dropdown.c
@@ -61,6 +61,7 @@ static const char * year_list = {
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 lv_obj_t * lv_calendar_header_dropdown_create(lv_obj_t * parent)
 {
     lv_obj_t * obj = lv_obj_class_create_obj(&lv_calendar_header_dropdown_class, parent);
@@ -69,6 +70,7 @@ lv_obj_t * lv_calendar_header_dropdown_create(lv_obj_t * parent)
     return obj;
 }
 
+LV_FUNC_SECTION
 void lv_calendar_header_dropdown_set_year_list(lv_obj_t * parent, const char * years_list)
 {
     /* Search for the header dropdown */
@@ -98,6 +100,7 @@ void lv_calendar_header_dropdown_set_year_list(lv_obj_t * parent, const char * y
  *  STATIC FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 static void my_constructor(const lv_obj_class_t * class_p, lv_obj_t * obj)
 {
     LV_TRACE_OBJ_CREATE("begin");
@@ -123,6 +126,7 @@ static void my_constructor(const lv_obj_class_t * class_p, lv_obj_t * obj)
     lv_obj_send_event(obj, LV_EVENT_VALUE_CHANGED, NULL);
 }
 
+__attribute__(( fptrgroup("lv_event_cb") ))
 static void month_event_cb(lv_event_t * e)
 {
     lv_obj_t * dropdown = lv_event_get_current_target(e);
@@ -138,6 +142,7 @@ static void month_event_cb(lv_event_t * e)
     lv_calendar_set_showed_date(calendar, newd.year, newd.month);
 }
 
+__attribute__(( fptrgroup("lv_event_cb") ))
 static void year_event_cb(lv_event_t * e)
 {
     lv_obj_t * dropdown = lv_event_get_current_target(e);
@@ -160,6 +165,7 @@ static void year_event_cb(lv_event_t * e)
     lv_calendar_set_showed_date(calendar, newd.year, newd.month);
 }
 
+__attribute__(( fptrgroup("lv_event_cb") ))
 static void value_changed_event_cb(lv_event_t * e)
 {
     lv_obj_t * header = lv_event_get_current_target(e);
diff --git a/src/widgets/canvas/lv_canvas.c b/src/widgets/canvas/lv_canvas.c
index 4aa46f33b..f8b63f3e6 100644
--- a/src/widgets/canvas/lv_canvas.c
+++ b/src/widgets/canvas/lv_canvas.c
@@ -56,6 +56,7 @@ const lv_obj_class_t lv_canvas_class = {
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 lv_obj_t * lv_canvas_create(lv_obj_t * parent)
 {
     LV_LOG_INFO("begin");
@@ -68,6 +69,7 @@ lv_obj_t * lv_canvas_create(lv_obj_t * parent)
  * Setter functions
  *====================*/
 
+LV_FUNC_SECTION
 void lv_canvas_set_buffer(lv_obj_t * obj, void * buf, int32_t w, int32_t h, lv_color_format_t cf)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -87,6 +89,7 @@ void lv_canvas_set_buffer(lv_obj_t * obj, void * buf, int32_t w, int32_t h, lv_c
     lv_image_cache_drop(canvas->draw_buf);
 }
 
+LV_FUNC_SECTION
 void lv_canvas_set_draw_buf(lv_obj_t * obj, lv_draw_buf_t * draw_buf)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -104,6 +107,7 @@ void lv_canvas_set_draw_buf(lv_obj_t * obj, lv_draw_buf_t * draw_buf)
     lv_image_cache_drop(draw_buf);
 }
 
+LV_FUNC_SECTION
 void lv_canvas_set_px(lv_obj_t * obj, int32_t x, int32_t y, lv_color_t color, lv_opa_t opa)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -177,6 +181,7 @@ void lv_canvas_set_px(lv_obj_t * obj, int32_t x, int32_t y, lv_color_t color, lv
     lv_obj_invalidate(obj);
 }
 
+LV_FUNC_SECTION
 void lv_canvas_set_palette(lv_obj_t * obj, uint8_t index, lv_color32_t color)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -191,6 +196,7 @@ void lv_canvas_set_palette(lv_obj_t * obj, uint8_t index, lv_color32_t color)
  * Getter functions
  *====================*/
 
+LV_FUNC_SECTION
 lv_draw_buf_t * lv_canvas_get_draw_buf(lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -199,6 +205,7 @@ lv_draw_buf_t * lv_canvas_get_draw_buf(lv_obj_t * obj)
     return canvas->draw_buf;
 }
 
+LV_FUNC_SECTION
 lv_color32_t lv_canvas_get_px(lv_obj_t * obj, int32_t x, int32_t y)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -252,6 +259,7 @@ lv_color32_t lv_canvas_get_px(lv_obj_t * obj, int32_t x, int32_t y)
     return ret;
 }
 
+LV_FUNC_SECTION
 lv_image_dsc_t * lv_canvas_get_image(lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -260,6 +268,7 @@ lv_image_dsc_t * lv_canvas_get_image(lv_obj_t * obj)
     return (lv_image_dsc_t *)canvas->draw_buf;
 }
 
+LV_FUNC_SECTION
 const void * lv_canvas_get_buf(lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -275,6 +284,7 @@ const void * lv_canvas_get_buf(lv_obj_t * obj)
  * Other functions
  *====================*/
 
+LV_FUNC_SECTION
 void lv_canvas_copy_buf(lv_obj_t * obj, const lv_area_t * canvas_area, lv_draw_buf_t * dest_buf,
                         const lv_area_t * dest_area)
 {
@@ -289,6 +299,7 @@ void lv_canvas_copy_buf(lv_obj_t * obj, const lv_area_t * canvas_area, lv_draw_b
     lv_draw_buf_copy(canvas->draw_buf, canvas_area, dest_buf, dest_area);
 }
 
+LV_FUNC_SECTION
 void lv_canvas_fill_bg(lv_obj_t * obj, lv_color_t color, lv_opa_t opa)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -367,6 +378,7 @@ void lv_canvas_fill_bg(lv_obj_t * obj, lv_color_t color, lv_opa_t opa)
     lv_obj_invalidate(obj);
 }
 
+LV_FUNC_SECTION
 void lv_canvas_init_layer(lv_obj_t * obj, lv_layer_t * layer)
 {
     LV_ASSERT_NULL(obj);
@@ -388,6 +400,7 @@ void lv_canvas_init_layer(lv_obj_t * obj, lv_layer_t * layer)
 #endif
 }
 
+LV_FUNC_SECTION
 void lv_canvas_finish_layer(lv_obj_t * canvas, lv_layer_t * layer)
 {
     if(layer->draw_task_head == NULL) return;
@@ -406,6 +419,7 @@ void lv_canvas_finish_layer(lv_obj_t * canvas, lv_layer_t * layer)
     lv_obj_invalidate(canvas);
 }
 
+LV_FUNC_SECTION
 uint32_t lv_canvas_buf_size(int32_t w, int32_t h, uint8_t bpp, uint8_t stride)
 {
     return (uint32_t)LV_CANVAS_BUF_SIZE(w, h, bpp, stride);
@@ -415,12 +429,14 @@ uint32_t lv_canvas_buf_size(int32_t w, int32_t h, uint8_t bpp, uint8_t stride)
  *   STATIC FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 static void lv_canvas_constructor(const lv_obj_class_t * class_p, lv_obj_t * obj)
 {
     LV_UNUSED(class_p);
     LV_UNUSED(obj);
 }
 
+LV_FUNC_SECTION
 static void lv_canvas_destructor(const lv_obj_class_t * class_p, lv_obj_t * obj)
 {
     LV_UNUSED(class_p);
diff --git a/src/widgets/chart/lv_chart.c b/src/widgets/chart/lv_chart.c
index 4639cd5a5..8b144eec9 100644
--- a/src/widgets/chart/lv_chart.c
+++ b/src/widgets/chart/lv_chart.c
@@ -68,6 +68,7 @@ const lv_obj_class_t lv_chart_class = {
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 lv_obj_t * lv_chart_create(lv_obj_t * parent)
 {
     LV_LOG_INFO("begin");
@@ -76,6 +77,7 @@ lv_obj_t * lv_chart_create(lv_obj_t * parent)
     return obj;
 }
 
+LV_FUNC_SECTION
 void lv_chart_set_type(lv_obj_t * obj, lv_chart_type_t type)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -105,6 +107,7 @@ void lv_chart_set_type(lv_obj_t * obj, lv_chart_type_t type)
     lv_chart_refresh(obj);
 }
 
+LV_FUNC_SECTION
 void lv_chart_set_point_count(lv_obj_t * obj, uint32_t cnt)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -129,6 +132,7 @@ void lv_chart_set_point_count(lv_obj_t * obj, uint32_t cnt)
     lv_chart_refresh(obj);
 }
 
+LV_FUNC_SECTION
 void lv_chart_set_range(lv_obj_t * obj, lv_chart_axis_t axis, int32_t min, int32_t max)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -161,6 +165,7 @@ void lv_chart_set_range(lv_obj_t * obj, lv_chart_axis_t axis, int32_t min, int32
     lv_chart_refresh(obj);
 }
 
+LV_FUNC_SECTION
 void lv_chart_set_update_mode(lv_obj_t * obj, lv_chart_update_mode_t update_mode)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -172,6 +177,7 @@ void lv_chart_set_update_mode(lv_obj_t * obj, lv_chart_update_mode_t update_mode
     lv_obj_invalidate(obj);
 }
 
+LV_FUNC_SECTION
 void lv_chart_set_div_line_count(lv_obj_t * obj, uint8_t hdiv, uint8_t vdiv)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -185,6 +191,7 @@ void lv_chart_set_div_line_count(lv_obj_t * obj, uint8_t hdiv, uint8_t vdiv)
     lv_obj_invalidate(obj);
 }
 
+LV_FUNC_SECTION
 lv_chart_type_t lv_chart_get_type(const lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -193,6 +200,7 @@ lv_chart_type_t lv_chart_get_type(const lv_obj_t * obj)
     return chart->type;
 }
 
+LV_FUNC_SECTION
 uint32_t lv_chart_get_point_count(const lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -201,6 +209,7 @@ uint32_t lv_chart_get_point_count(const lv_obj_t * obj)
     return chart->point_cnt;
 }
 
+LV_FUNC_SECTION
 uint32_t lv_chart_get_x_start_point(const lv_obj_t * obj, lv_chart_series_t * ser)
 {
     LV_ASSERT_NULL(ser);
@@ -209,6 +218,7 @@ uint32_t lv_chart_get_x_start_point(const lv_obj_t * obj, lv_chart_series_t * se
     return ser->start_point;
 }
 
+LV_FUNC_SECTION
 void lv_chart_get_point_pos_by_id(lv_obj_t * obj, lv_chart_series_t * ser, uint32_t id, lv_point_t * p_out)
 {
     LV_ASSERT_NULL(obj);
@@ -270,6 +280,7 @@ void lv_chart_get_point_pos_by_id(lv_obj_t * obj, lv_chart_series_t * ser, uint3
     p_out->y -= lv_obj_get_scroll_top(obj);
 }
 
+LV_FUNC_SECTION
 void lv_chart_refresh(lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -281,6 +292,7 @@ void lv_chart_refresh(lv_obj_t * obj)
  * Series
  *=====================*/
 
+LV_FUNC_SECTION
 lv_chart_series_t * lv_chart_add_series(lv_obj_t * obj, lv_color_t color, lv_chart_axis_t axis)
 {
     LV_LOG_INFO("begin");
@@ -343,6 +355,7 @@ lv_chart_series_t * lv_chart_add_series(lv_obj_t * obj, lv_color_t color, lv_cha
     return ser;
 }
 
+LV_FUNC_SECTION
 void lv_chart_remove_series(lv_obj_t * obj, lv_chart_series_t * series)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -358,6 +371,7 @@ void lv_chart_remove_series(lv_obj_t * obj, lv_chart_series_t * series)
     return;
 }
 
+LV_FUNC_SECTION
 void lv_chart_hide_series(lv_obj_t * chart, lv_chart_series_t * series, bool hide)
 {
     LV_ASSERT_OBJ(chart, MY_CLASS);
@@ -367,6 +381,7 @@ void lv_chart_hide_series(lv_obj_t * chart, lv_chart_series_t * series, bool hid
     lv_chart_refresh(chart);
 }
 
+LV_FUNC_SECTION
 void lv_chart_set_series_color(lv_obj_t * chart, lv_chart_series_t * series, lv_color_t color)
 {
     LV_ASSERT_OBJ(chart, MY_CLASS);
@@ -376,6 +391,7 @@ void lv_chart_set_series_color(lv_obj_t * chart, lv_chart_series_t * series, lv_
     lv_chart_refresh(chart);
 }
 
+LV_FUNC_SECTION
 lv_color_t lv_chart_get_series_color(lv_obj_t * chart, const lv_chart_series_t * series)
 {
     LV_ASSERT_OBJ(chart, MY_CLASS);
@@ -385,6 +401,7 @@ lv_color_t lv_chart_get_series_color(lv_obj_t * chart, const lv_chart_series_t *
     return series->color;
 }
 
+LV_FUNC_SECTION
 void lv_chart_set_x_start_point(lv_obj_t * obj, lv_chart_series_t * ser, uint32_t id)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -395,6 +412,7 @@ void lv_chart_set_x_start_point(lv_obj_t * obj, lv_chart_series_t * ser, uint32_
     ser->start_point = id;
 }
 
+LV_FUNC_SECTION
 lv_chart_series_t * lv_chart_get_series_next(const lv_obj_t * obj, const lv_chart_series_t * ser)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -408,6 +426,7 @@ lv_chart_series_t * lv_chart_get_series_next(const lv_obj_t * obj, const lv_char
  * Cursor
  *====================*/
 
+LV_FUNC_SECTION
 lv_chart_cursor_t  * lv_chart_add_cursor(lv_obj_t * obj, lv_color_t color, lv_dir_t dir)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -426,6 +445,7 @@ lv_chart_cursor_t  * lv_chart_add_cursor(lv_obj_t * obj, lv_color_t color, lv_di
     return cursor;
 }
 
+LV_FUNC_SECTION
 void lv_chart_set_cursor_pos(lv_obj_t * chart, lv_chart_cursor_t * cursor, lv_point_t * pos)
 {
     LV_ASSERT_NULL(cursor);
@@ -436,6 +456,7 @@ void lv_chart_set_cursor_pos(lv_obj_t * chart, lv_chart_cursor_t * cursor, lv_po
     lv_chart_refresh(chart);
 }
 
+LV_FUNC_SECTION
 void lv_chart_set_cursor_point(lv_obj_t * chart, lv_chart_cursor_t * cursor, lv_chart_series_t * ser, uint32_t point_id)
 {
     LV_ASSERT_NULL(cursor);
@@ -448,6 +469,7 @@ void lv_chart_set_cursor_point(lv_obj_t * chart, lv_chart_cursor_t * cursor, lv_
     lv_chart_refresh(chart);
 }
 
+LV_FUNC_SECTION
 lv_point_t lv_chart_get_cursor_point(lv_obj_t * chart, lv_chart_cursor_t * cursor)
 {
     LV_ASSERT_NULL(cursor);
@@ -460,6 +482,7 @@ lv_point_t lv_chart_get_cursor_point(lv_obj_t * chart, lv_chart_cursor_t * curso
  * Set/Get value(s)
  *====================*/
 
+LV_FUNC_SECTION
 void lv_chart_set_all_value(lv_obj_t * obj, lv_chart_series_t * ser, int32_t value)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -474,6 +497,7 @@ void lv_chart_set_all_value(lv_obj_t * obj, lv_chart_series_t * ser, int32_t val
     lv_chart_refresh(obj);
 }
 
+LV_FUNC_SECTION
 void lv_chart_set_next_value(lv_obj_t * obj, lv_chart_series_t * ser, int32_t value)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -486,6 +510,7 @@ void lv_chart_set_next_value(lv_obj_t * obj, lv_chart_series_t * ser, int32_t va
     invalidate_point(obj, ser->start_point);
 }
 
+LV_FUNC_SECTION
 void lv_chart_set_next_value2(lv_obj_t * obj, lv_chart_series_t * ser, int32_t x_value, int32_t y_value)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -504,6 +529,7 @@ void lv_chart_set_next_value2(lv_obj_t * obj, lv_chart_series_t * ser, int32_t x
     invalidate_point(obj, ser->start_point);
 }
 
+LV_FUNC_SECTION
 void lv_chart_set_value_by_id(lv_obj_t * obj, lv_chart_series_t * ser, uint32_t id, int32_t value)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -515,6 +541,7 @@ void lv_chart_set_value_by_id(lv_obj_t * obj, lv_chart_series_t * ser, uint32_t
     invalidate_point(obj, id);
 }
 
+LV_FUNC_SECTION
 void lv_chart_set_value_by_id2(lv_obj_t * obj, lv_chart_series_t * ser, uint32_t id, int32_t x_value,
                                int32_t y_value)
 {
@@ -533,6 +560,7 @@ void lv_chart_set_value_by_id2(lv_obj_t * obj, lv_chart_series_t * ser, uint32_t
     invalidate_point(obj, id);
 }
 
+LV_FUNC_SECTION
 void lv_chart_set_ext_y_array(lv_obj_t * obj, lv_chart_series_t * ser, int32_t array[])
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -544,6 +572,7 @@ void lv_chart_set_ext_y_array(lv_obj_t * obj, lv_chart_series_t * ser, int32_t a
     lv_obj_invalidate(obj);
 }
 
+LV_FUNC_SECTION
 void lv_chart_set_ext_x_array(lv_obj_t * obj, lv_chart_series_t * ser, int32_t array[])
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -555,6 +584,7 @@ void lv_chart_set_ext_x_array(lv_obj_t * obj, lv_chart_series_t * ser, int32_t a
     lv_obj_invalidate(obj);
 }
 
+LV_FUNC_SECTION
 int32_t * lv_chart_get_y_array(const lv_obj_t * obj, lv_chart_series_t * ser)
 {
     LV_UNUSED(obj);
@@ -563,6 +593,7 @@ int32_t * lv_chart_get_y_array(const lv_obj_t * obj, lv_chart_series_t * ser)
     return ser->y_points;
 }
 
+LV_FUNC_SECTION
 int32_t * lv_chart_get_x_array(const lv_obj_t * obj, lv_chart_series_t * ser)
 {
     LV_UNUSED(obj);
@@ -571,12 +602,14 @@ int32_t * lv_chart_get_x_array(const lv_obj_t * obj, lv_chart_series_t * ser)
     return ser->x_points;
 }
 
+LV_FUNC_SECTION
 uint32_t lv_chart_get_pressed_point(const lv_obj_t * obj)
 {
     lv_chart_t * chart = (lv_chart_t *)obj;
     return chart->pressed_point_id;
 }
 
+LV_FUNC_SECTION
 int32_t lv_chart_get_first_point_center_offset(lv_obj_t * obj)
 {
     lv_chart_t * chart = (lv_chart_t *)obj;
@@ -599,6 +632,7 @@ int32_t lv_chart_get_first_point_center_offset(lv_obj_t * obj)
  *   STATIC FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 static void lv_chart_constructor(const lv_obj_class_t * class_p, lv_obj_t * obj)
 {
     LV_UNUSED(class_p);
@@ -628,6 +662,7 @@ static void lv_chart_constructor(const lv_obj_class_t * class_p, lv_obj_t * obj)
     LV_TRACE_OBJ_CREATE("finished");
 }
 
+LV_FUNC_SECTION
 static void lv_chart_destructor(const lv_obj_class_t * class_p, lv_obj_t * obj)
 {
     LV_UNUSED(class_p);
@@ -658,6 +693,7 @@ static void lv_chart_destructor(const lv_obj_class_t * class_p, lv_obj_t * obj)
     LV_TRACE_OBJ_CREATE("finished");
 }
 
+LV_FUNC_SECTION
 static void lv_chart_event(const lv_obj_class_t * class_p, lv_event_t * e)
 {
     LV_UNUSED(class_p);
@@ -704,6 +740,7 @@ static void lv_chart_event(const lv_obj_class_t * class_p, lv_event_t * e)
     }
 }
 
+LV_FUNC_SECTION
 static void draw_div_lines(lv_obj_t * obj, lv_layer_t * layer)
 {
     lv_chart_t * chart  = (lv_chart_t *)obj;
@@ -780,6 +817,7 @@ static void draw_div_lines(lv_obj_t * obj, lv_layer_t * layer)
     layer->_clip_area = clip_area_ori;
 }
 
+LV_FUNC_SECTION
 static void draw_series_line(lv_obj_t * obj, lv_layer_t * layer)
 {
     lv_area_t clip_area;
@@ -933,6 +971,7 @@ static void draw_series_line(lv_obj_t * obj, lv_layer_t * layer)
     layer->_clip_area = clip_area_ori;
 }
 
+LV_FUNC_SECTION
 static void draw_series_scatter(lv_obj_t * obj, lv_layer_t * layer)
 {
 
@@ -1054,6 +1093,7 @@ static void draw_series_scatter(lv_obj_t * obj, lv_layer_t * layer)
     }
 }
 
+LV_FUNC_SECTION
 static void draw_series_bar(lv_obj_t * obj, lv_layer_t * layer)
 {
     lv_area_t clip_area;
@@ -1130,6 +1170,7 @@ static void draw_series_bar(lv_obj_t * obj, lv_layer_t * layer)
     layer->_clip_area = clip_area_ori;
 }
 
+LV_FUNC_SECTION
 static void draw_cursors(lv_obj_t * obj, lv_layer_t * layer)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -1234,6 +1275,7 @@ static void draw_cursors(lv_obj_t * obj, lv_layer_t * layer)
  * @param coord the coordination of the point relative to the series area.
  * @return the found index
  */
+LV_FUNC_SECTION
 static uint32_t get_index_from_x(lv_obj_t * obj, int32_t x)
 {
     lv_chart_t * chart  = (lv_chart_t *)obj;
@@ -1249,6 +1291,7 @@ static uint32_t get_index_from_x(lv_obj_t * obj, int32_t x)
     return 0;
 }
 
+LV_FUNC_SECTION
 static void invalidate_point(lv_obj_t * obj, uint32_t i)
 {
     lv_chart_t * chart  = (lv_chart_t *)obj;
@@ -1311,6 +1354,7 @@ static void invalidate_point(lv_obj_t * obj, uint32_t i)
     }
 }
 
+LV_FUNC_SECTION
 static void new_points_alloc(lv_obj_t * obj, lv_chart_series_t * ser, uint32_t cnt, int32_t ** a)
 {
     if((*a) == NULL) return;
diff --git a/src/widgets/checkbox/lv_checkbox.c b/src/widgets/checkbox/lv_checkbox.c
index 7a987ef3e..fd27c46c0 100644
--- a/src/widgets/checkbox/lv_checkbox.c
+++ b/src/widgets/checkbox/lv_checkbox.c
@@ -57,6 +57,7 @@ const lv_obj_class_t lv_checkbox_class = {
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 lv_obj_t * lv_checkbox_create(lv_obj_t * parent)
 {
     LV_LOG_INFO("begin");
@@ -69,6 +70,7 @@ lv_obj_t * lv_checkbox_create(lv_obj_t * parent)
  * Setter functions
  *====================*/
 
+LV_FUNC_SECTION
 void lv_checkbox_set_text(lv_obj_t * obj, const char * txt)
 {
     lv_checkbox_t * cb = (lv_checkbox_t *)obj;
@@ -101,6 +103,7 @@ void lv_checkbox_set_text(lv_obj_t * obj, const char * txt)
     lv_obj_invalidate(obj);
 }
 
+LV_FUNC_SECTION
 void lv_checkbox_set_text_static(lv_obj_t * obj, const char * txt)
 {
     lv_checkbox_t * cb = (lv_checkbox_t *)obj;
@@ -118,6 +121,7 @@ void lv_checkbox_set_text_static(lv_obj_t * obj, const char * txt)
  * Getter functions
  *====================*/
 
+LV_FUNC_SECTION
 const char * lv_checkbox_get_text(const lv_obj_t * obj)
 {
     lv_checkbox_t * cb = (lv_checkbox_t *)obj;
@@ -128,6 +132,7 @@ const char * lv_checkbox_get_text(const lv_obj_t * obj)
  *   STATIC FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 static void lv_checkbox_constructor(const lv_obj_class_t * class_p, lv_obj_t * obj)
 {
     LV_UNUSED(class_p);
@@ -151,6 +156,7 @@ static void lv_checkbox_constructor(const lv_obj_class_t * class_p, lv_obj_t * o
     LV_TRACE_OBJ_CREATE("finished");
 }
 
+LV_FUNC_SECTION
 static void lv_checkbox_destructor(const lv_obj_class_t * class_p, lv_obj_t * obj)
 {
     LV_UNUSED(class_p);
@@ -164,6 +170,7 @@ static void lv_checkbox_destructor(const lv_obj_class_t * class_p, lv_obj_t * ob
     LV_TRACE_OBJ_CREATE("finished");
 }
 
+LV_FUNC_SECTION
 static void lv_checkbox_event(const lv_obj_class_t * class_p, lv_event_t * e)
 {
     LV_UNUSED(class_p);
@@ -210,6 +217,7 @@ static void lv_checkbox_event(const lv_obj_class_t * class_p, lv_event_t * e)
     }
 }
 
+LV_FUNC_SECTION
 static void lv_checkbox_draw(lv_event_t * e)
 {
     lv_obj_t * obj = lv_event_get_current_target(e);
diff --git a/src/widgets/dropdown/lv_dropdown.c b/src/widgets/dropdown/lv_dropdown.c
index 517479cdb..499b430b7 100644
--- a/src/widgets/dropdown/lv_dropdown.c
+++ b/src/widgets/dropdown/lv_dropdown.c
@@ -153,6 +153,7 @@ const lv_obj_class_t lv_dropdownlist_class = {
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 lv_obj_t * lv_dropdown_create(lv_obj_t * parent)
 {
     LV_LOG_INFO("begin");
@@ -165,6 +166,7 @@ lv_obj_t * lv_dropdown_create(lv_obj_t * parent)
  * Setter functions
  *====================*/
 
+LV_FUNC_SECTION
 void lv_dropdown_set_text(lv_obj_t * obj, const char * txt)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -176,6 +178,7 @@ void lv_dropdown_set_text(lv_obj_t * obj, const char * txt)
     lv_obj_invalidate(obj);
 }
 
+LV_FUNC_SECTION
 void lv_dropdown_set_options(lv_obj_t * obj, const char * options)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -223,6 +226,7 @@ void lv_dropdown_set_options(lv_obj_t * obj, const char * options)
     if(dropdown->list) lv_obj_invalidate(dropdown->list);
 }
 
+LV_FUNC_SECTION
 void lv_dropdown_set_options_static(lv_obj_t * obj, const char * options)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -252,6 +256,7 @@ void lv_dropdown_set_options_static(lv_obj_t * obj, const char * options)
     if(dropdown->list) lv_obj_invalidate(dropdown->list);
 }
 
+LV_FUNC_SECTION
 void lv_dropdown_add_option(lv_obj_t * obj, const char * option, uint32_t pos)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -319,6 +324,7 @@ void lv_dropdown_add_option(lv_obj_t * obj, const char * option, uint32_t pos)
     if(dropdown->list) lv_obj_invalidate(dropdown->list);
 }
 
+LV_FUNC_SECTION
 void lv_dropdown_clear_options(lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -336,6 +342,7 @@ void lv_dropdown_clear_options(lv_obj_t * obj)
     if(dropdown->list) lv_obj_invalidate(dropdown->list);
 }
 
+LV_FUNC_SECTION
 void lv_dropdown_set_selected(lv_obj_t * obj, uint32_t sel_opt)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -353,6 +360,7 @@ void lv_dropdown_set_selected(lv_obj_t * obj, uint32_t sel_opt)
     lv_obj_invalidate(obj);
 }
 
+LV_FUNC_SECTION
 void lv_dropdown_set_dir(lv_obj_t * obj, lv_dir_t dir)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -365,6 +373,7 @@ void lv_dropdown_set_dir(lv_obj_t * obj, lv_dir_t dir)
     lv_obj_invalidate(obj);
 }
 
+LV_FUNC_SECTION
 void lv_dropdown_set_symbol(lv_obj_t * obj, const void * symbol)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -374,6 +383,7 @@ void lv_dropdown_set_symbol(lv_obj_t * obj, const void * symbol)
     lv_obj_invalidate(obj);
 }
 
+LV_FUNC_SECTION
 void lv_dropdown_set_selected_highlight(lv_obj_t * obj, bool en)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -387,6 +397,7 @@ void lv_dropdown_set_selected_highlight(lv_obj_t * obj, bool en)
  * Getter functions
  *====================*/
 
+LV_FUNC_SECTION
 lv_obj_t * lv_dropdown_get_list(lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -395,6 +406,7 @@ lv_obj_t * lv_dropdown_get_list(lv_obj_t * obj)
     return dropdown->list;
 }
 
+LV_FUNC_SECTION
 const char * lv_dropdown_get_text(lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -403,6 +415,7 @@ const char * lv_dropdown_get_text(lv_obj_t * obj)
     return dropdown->text;
 }
 
+LV_FUNC_SECTION
 const char * lv_dropdown_get_options(const lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -411,6 +424,7 @@ const char * lv_dropdown_get_options(const lv_obj_t * obj)
     return dropdown->options == NULL ? "" : dropdown->options;
 }
 
+LV_FUNC_SECTION
 uint32_t lv_dropdown_get_selected(const lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -420,6 +434,7 @@ uint32_t lv_dropdown_get_selected(const lv_obj_t * obj)
     return dropdown->sel_opt_id;
 }
 
+LV_FUNC_SECTION
 uint32_t lv_dropdown_get_option_count(const lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -429,6 +444,7 @@ uint32_t lv_dropdown_get_option_count(const lv_obj_t * obj)
     return dropdown->option_cnt;
 }
 
+LV_FUNC_SECTION
 void lv_dropdown_get_selected_str(const lv_obj_t * obj, char * buf, uint32_t buf_size)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -463,6 +479,7 @@ void lv_dropdown_get_selected_str(const lv_obj_t * obj, char * buf, uint32_t buf
     buf[c] = '\0';
 }
 
+LV_FUNC_SECTION
 int32_t lv_dropdown_get_option_index(lv_obj_t * obj, const char * option)
 {
     const char * opts = lv_dropdown_get_options(obj);
@@ -487,6 +504,7 @@ int32_t lv_dropdown_get_option_index(lv_obj_t * obj, const char * option)
     return -1;
 }
 
+LV_FUNC_SECTION
 const char * lv_dropdown_get_symbol(lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -494,6 +512,7 @@ const char * lv_dropdown_get_symbol(lv_obj_t * obj)
     return dropdown->symbol;
 }
 
+LV_FUNC_SECTION
 bool lv_dropdown_get_selected_highlight(lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -501,6 +520,7 @@ bool lv_dropdown_get_selected_highlight(lv_obj_t * obj)
     return dropdown->selected_highlight;
 }
 
+LV_FUNC_SECTION
 lv_dir_t lv_dropdown_get_dir(const lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -512,6 +532,7 @@ lv_dir_t lv_dropdown_get_dir(const lv_obj_t * obj)
  * Other functions
  *====================*/
 
+LV_FUNC_SECTION
 void lv_dropdown_open(lv_obj_t * dropdown_obj)
 {
     LV_ASSERT_OBJ(dropdown_obj, MY_CLASS);
@@ -610,6 +631,7 @@ void lv_dropdown_open(lv_obj_t * dropdown_obj)
     }
 }
 
+LV_FUNC_SECTION
 void lv_dropdown_close(lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -623,6 +645,7 @@ void lv_dropdown_close(lv_obj_t * obj)
     lv_obj_send_event(obj, LV_EVENT_CANCEL, NULL);
 }
 
+LV_FUNC_SECTION
 bool lv_dropdown_is_open(lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -635,6 +658,7 @@ bool lv_dropdown_is_open(lv_obj_t * obj)
  *   STATIC FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 static lv_obj_t * lv_dropdown_list_create(lv_obj_t * parent)
 {
     LV_LOG_INFO("begin");
@@ -643,6 +667,7 @@ static lv_obj_t * lv_dropdown_list_create(lv_obj_t * parent)
     return obj;
 }
 
+LV_FUNC_SECTION
 static void lv_dropdown_constructor(const lv_obj_class_t * class_p, lv_obj_t * obj)
 {
     LV_UNUSED(class_p);
@@ -675,6 +700,7 @@ static void lv_dropdown_constructor(const lv_obj_class_t * class_p, lv_obj_t * o
     LV_TRACE_OBJ_CREATE("finished");
 }
 
+LV_FUNC_SECTION
 static void lv_dropdown_destructor(const lv_obj_class_t * class_p, lv_obj_t * obj)
 {
     LV_UNUSED(class_p);
@@ -691,6 +717,7 @@ static void lv_dropdown_destructor(const lv_obj_class_t * class_p, lv_obj_t * ob
     }
 }
 
+LV_FUNC_SECTION
 static void lv_dropdownlist_constructor(const lv_obj_class_t * class_p, lv_obj_t * obj)
 {
     LV_UNUSED(class_p);
@@ -706,6 +733,7 @@ static void lv_dropdownlist_constructor(const lv_obj_class_t * class_p, lv_obj_t
     LV_TRACE_OBJ_CREATE("finished");
 }
 
+LV_FUNC_SECTION
 static void lv_dropdownlist_destructor(const lv_obj_class_t * class_p, lv_obj_t * list_obj)
 {
     LV_UNUSED(class_p);
@@ -715,6 +743,7 @@ static void lv_dropdownlist_destructor(const lv_obj_class_t * class_p, lv_obj_t
     dropdown->list = NULL;
 }
 
+LV_FUNC_SECTION
 static void lv_dropdown_event(const lv_obj_class_t * class_p, lv_event_t * e)
 {
     LV_UNUSED(class_p);
@@ -818,6 +847,7 @@ static void lv_dropdown_event(const lv_obj_class_t * class_p, lv_event_t * e)
     }
 }
 
+LV_FUNC_SECTION
 static void lv_dropdown_list_event(const lv_obj_class_t * class_p, lv_event_t * e)
 {
     LV_UNUSED(class_p);
@@ -853,6 +883,7 @@ static void lv_dropdown_list_event(const lv_obj_class_t * class_p, lv_event_t *
     }
 }
 
+LV_FUNC_SECTION
 static void draw_main(lv_event_t * e)
 {
     lv_obj_t * obj = lv_event_get_current_target(e);
@@ -966,6 +997,7 @@ static void draw_main(lv_event_t * e)
     lv_draw_label(layer, &label_dsc, &txt_area);
 }
 
+LV_FUNC_SECTION
 static void draw_list(lv_event_t * e)
 {
     lv_obj_t * list_obj = lv_event_get_current_target(e);
@@ -1002,6 +1034,7 @@ static void draw_list(lv_event_t * e)
     }
 }
 
+LV_FUNC_SECTION
 static void draw_box(lv_obj_t * dropdown_obj, lv_layer_t * layer, uint32_t id, lv_state_t state)
 {
     if(id == LV_DROPDOWN_PR_NONE) return;
@@ -1040,6 +1073,7 @@ static void draw_box(lv_obj_t * dropdown_obj, lv_layer_t * layer, uint32_t id, l
     list_obj->skip_trans = 0;
 }
 
+LV_FUNC_SECTION
 static void draw_box_label(lv_obj_t * dropdown_obj, lv_layer_t * layer, uint32_t id, lv_state_t state)
 {
     if(id == LV_DROPDOWN_PR_NONE) return;
@@ -1087,6 +1121,7 @@ static void draw_box_label(lv_obj_t * dropdown_obj, lv_layer_t * layer, uint32_t
     list_obj->skip_trans = 0;
 }
 
+LV_FUNC_SECTION
 static lv_result_t btn_release_handler(lv_obj_t * obj)
 {
     lv_dropdown_t * dropdown = (lv_dropdown_t *)obj;
@@ -1123,6 +1158,7 @@ static lv_result_t btn_release_handler(lv_obj_t * obj)
  * @param list pointer to the drop down list's list
  * @return LV_RESULT_INVALID if the list is not being deleted in the user callback. Else LV_RESULT_OK
  */
+LV_FUNC_SECTION
 static lv_result_t list_release_handler(lv_obj_t * list_obj)
 {
     lv_dropdown_list_t * list = (lv_dropdown_list_t *) list_obj;
@@ -1159,6 +1195,7 @@ static lv_result_t list_release_handler(lv_obj_t * list_obj)
     return LV_RESULT_OK;
 }
 
+LV_FUNC_SECTION
 static void list_press_handler(lv_obj_t * list_obj)
 {
     lv_dropdown_list_t * list = (lv_dropdown_list_t *) list_obj;
@@ -1174,6 +1211,7 @@ static void list_press_handler(lv_obj_t * list_obj)
     }
 }
 
+LV_FUNC_SECTION
 static uint32_t get_id_on_point(lv_obj_t * dropdown_obj, int32_t y)
 {
     lv_dropdown_t * dropdown = (lv_dropdown_t *)dropdown_obj;
@@ -1198,6 +1236,7 @@ static uint32_t get_id_on_point(lv_obj_t * dropdown_obj, int32_t y)
  * Set the position of list when it is closed to show the selected item
  * @param ddlist pointer to a drop down list
  */
+LV_FUNC_SECTION
 static void position_to_selected(lv_obj_t * dropdown_obj)
 {
     lv_dropdown_t * dropdown = (lv_dropdown_t *)dropdown_obj;
@@ -1218,6 +1257,7 @@ static void position_to_selected(lv_obj_t * dropdown_obj)
     lv_obj_invalidate(dropdown->list);
 }
 
+LV_FUNC_SECTION
 static lv_obj_t * get_label(const lv_obj_t * obj)
 {
     lv_dropdown_t * dropdown = (lv_dropdown_t *)obj;
diff --git a/src/widgets/image/lv_image.c b/src/widgets/image/lv_image.c
index 5fdcc12d5..df3a06030 100644
--- a/src/widgets/image/lv_image.c
+++ b/src/widgets/image/lv_image.c
@@ -133,6 +133,7 @@ const lv_obj_class_t lv_image_class = {
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 lv_obj_t * lv_image_create(lv_obj_t * parent)
 {
     LV_LOG_INFO("begin");
@@ -145,6 +146,7 @@ lv_obj_t * lv_image_create(lv_obj_t * parent)
  * Setter functions
  *====================*/
 
+LV_FUNC_SECTION
 void lv_image_set_src(lv_obj_t * obj, const void * src)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -247,6 +249,7 @@ void lv_image_set_src(lv_obj_t * obj, const void * src)
     lv_obj_invalidate(obj);
 }
 
+LV_FUNC_SECTION
 void lv_image_set_offset_x(lv_obj_t * obj, int32_t x)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -257,6 +260,7 @@ void lv_image_set_offset_x(lv_obj_t * obj, int32_t x)
     lv_obj_invalidate(obj);
 }
 
+LV_FUNC_SECTION
 void lv_image_set_offset_y(lv_obj_t * obj, int32_t y)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -267,6 +271,7 @@ void lv_image_set_offset_y(lv_obj_t * obj, int32_t y)
     lv_obj_invalidate(obj);
 }
 
+LV_FUNC_SECTION
 void lv_image_set_rotation(lv_obj_t * obj, int32_t angle)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -312,6 +317,7 @@ void lv_image_set_rotation(lv_obj_t * obj, int32_t angle)
     lv_obj_invalidate_area(obj, &a);
 }
 
+LV_FUNC_SECTION
 void lv_image_set_pivot(lv_obj_t * obj, int32_t x, int32_t y)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -355,6 +361,7 @@ void lv_image_set_pivot(lv_obj_t * obj, int32_t x, int32_t y)
     lv_obj_invalidate_area(obj, &a);
 }
 
+LV_FUNC_SECTION
 void lv_image_set_scale(lv_obj_t * obj, uint32_t zoom)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -371,6 +378,7 @@ void lv_image_set_scale(lv_obj_t * obj, uint32_t zoom)
     scale_update(obj, zoom, zoom);
 }
 
+LV_FUNC_SECTION
 void lv_image_set_scale_x(lv_obj_t * obj, uint32_t zoom)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -387,6 +395,7 @@ void lv_image_set_scale_x(lv_obj_t * obj, uint32_t zoom)
     scale_update(obj, zoom, img->scale_y);
 }
 
+LV_FUNC_SECTION
 void lv_image_set_scale_y(lv_obj_t * obj, uint32_t zoom)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -403,6 +412,7 @@ void lv_image_set_scale_y(lv_obj_t * obj, uint32_t zoom)
     scale_update(obj, img->scale_x, zoom);
 }
 
+LV_FUNC_SECTION
 void lv_image_set_blend_mode(lv_obj_t * obj, lv_blend_mode_t blend_mode)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -417,6 +427,7 @@ void lv_image_set_blend_mode(lv_obj_t * obj, lv_blend_mode_t blend_mode)
     lv_obj_invalidate(obj);
 }
 
+LV_FUNC_SECTION
 void lv_image_set_antialias(lv_obj_t * obj, bool antialias)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -428,6 +439,7 @@ void lv_image_set_antialias(lv_obj_t * obj, bool antialias)
     lv_obj_invalidate(obj);
 }
 
+LV_FUNC_SECTION
 void lv_image_set_inner_align(lv_obj_t * obj, lv_image_align_t align)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -446,6 +458,7 @@ void lv_image_set_inner_align(lv_obj_t * obj, lv_image_align_t align)
     lv_obj_invalidate(obj);
 }
 
+LV_FUNC_SECTION
 void lv_image_set_bitmap_map_src(lv_obj_t * obj, const lv_image_dsc_t * src)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -458,6 +471,7 @@ void lv_image_set_bitmap_map_src(lv_obj_t * obj, const lv_image_dsc_t * src)
  * Getter functions
  *====================*/
 
+LV_FUNC_SECTION
 const void * lv_image_get_src(lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -467,6 +481,7 @@ const void * lv_image_get_src(lv_obj_t * obj)
     return img->src;
 }
 
+LV_FUNC_SECTION
 int32_t lv_image_get_offset_x(lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -476,6 +491,7 @@ int32_t lv_image_get_offset_x(lv_obj_t * obj)
     return img->offset.x;
 }
 
+LV_FUNC_SECTION
 int32_t lv_image_get_offset_y(lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -485,6 +501,7 @@ int32_t lv_image_get_offset_y(lv_obj_t * obj)
     return img->offset.y;
 }
 
+LV_FUNC_SECTION
 int32_t lv_image_get_rotation(lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -494,6 +511,7 @@ int32_t lv_image_get_rotation(lv_obj_t * obj)
     return img->rotation;
 }
 
+LV_FUNC_SECTION
 void lv_image_get_pivot(lv_obj_t * obj, lv_point_t * pivot)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -504,6 +522,7 @@ void lv_image_get_pivot(lv_obj_t * obj, lv_point_t * pivot)
     pivot->y = lv_pct_to_px(img->pivot.y, img->h);
 }
 
+LV_FUNC_SECTION
 int32_t lv_image_get_scale(lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -513,6 +532,7 @@ int32_t lv_image_get_scale(lv_obj_t * obj)
     return img->scale_x;
 }
 
+LV_FUNC_SECTION
 int32_t lv_image_get_scale_x(lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -522,6 +542,7 @@ int32_t lv_image_get_scale_x(lv_obj_t * obj)
     return img->scale_x;
 }
 
+LV_FUNC_SECTION
 int32_t lv_image_get_scale_y(lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -531,6 +552,7 @@ int32_t lv_image_get_scale_y(lv_obj_t * obj)
     return img->scale_y;
 }
 
+LV_FUNC_SECTION
 lv_blend_mode_t lv_image_get_blend_mode(lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -540,6 +562,7 @@ lv_blend_mode_t lv_image_get_blend_mode(lv_obj_t * obj)
     return img->blend_mode;
 }
 
+LV_FUNC_SECTION
 bool lv_image_get_antialias(lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -549,6 +572,7 @@ bool lv_image_get_antialias(lv_obj_t * obj)
     return img->antialias ? true : false;
 }
 
+LV_FUNC_SECTION
 lv_image_align_t lv_image_get_inner_align(lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -558,6 +582,7 @@ lv_image_align_t lv_image_get_inner_align(lv_obj_t * obj)
     return img->align;
 }
 
+LV_FUNC_SECTION
 const lv_image_dsc_t * lv_image_get_bitmap_map_src(lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -571,6 +596,7 @@ const lv_image_dsc_t * lv_image_get_bitmap_map_src(lv_obj_t * obj)
  *   STATIC FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 static void lv_image_constructor(const lv_obj_class_t * class_p, lv_obj_t * obj)
 {
     LV_UNUSED(class_p);
@@ -597,6 +623,7 @@ static void lv_image_constructor(const lv_obj_class_t * class_p, lv_obj_t * obj)
     LV_TRACE_OBJ_CREATE("finished");
 }
 
+LV_FUNC_SECTION
 static void lv_image_destructor(const lv_obj_class_t * class_p, lv_obj_t * obj)
 {
     LV_UNUSED(class_p);
@@ -608,6 +635,7 @@ static void lv_image_destructor(const lv_obj_class_t * class_p, lv_obj_t * obj)
     }
 }
 
+LV_FUNC_SECTION
 static void lv_image_event(const lv_obj_class_t * class_p, lv_event_t * e)
 {
     LV_UNUSED(class_p);
@@ -685,6 +713,7 @@ static void lv_image_event(const lv_obj_class_t * class_p, lv_event_t * e)
     }
 }
 
+LV_FUNC_SECTION
 static void draw_image(lv_event_t * e)
 {
     lv_event_code_t code = lv_event_get_code(e);
@@ -813,6 +842,7 @@ static void draw_image(lv_event_t * e)
     }
 }
 
+LV_FUNC_SECTION
 static void scale_update(lv_obj_t * obj, int32_t scale_x, int32_t scale_y)
 {
     lv_image_t * img = (lv_image_t *)obj;
@@ -848,6 +878,7 @@ static void scale_update(lv_obj_t * obj, int32_t scale_x, int32_t scale_y)
     lv_obj_invalidate_area(obj, &a);
 }
 
+LV_FUNC_SECTION
 static void update_align(lv_obj_t * obj)
 {
     lv_image_t * img = (lv_image_t *)obj;
@@ -869,11 +900,13 @@ static void update_align(lv_obj_t * obj)
 }
 
 #if LV_USE_OBJ_PROPERTY
+LV_FUNC_SECTION
 static void lv_image_set_pivot_helper(lv_obj_t * obj, lv_point_t * pivot)
 {
     lv_image_set_pivot(obj, pivot->x, pivot->y);
 }
 
+LV_FUNC_SECTION
 static lv_point_t lv_image_get_pivot_helper(lv_obj_t * obj)
 {
     lv_point_t pivot;
diff --git a/src/widgets/imagebutton/lv_imagebutton.c b/src/widgets/imagebutton/lv_imagebutton.c
index 3aef3a42b..e4fed088b 100644
--- a/src/widgets/imagebutton/lv_imagebutton.c
+++ b/src/widgets/imagebutton/lv_imagebutton.c
@@ -60,6 +60,7 @@ const lv_obj_class_t lv_imagebutton_class = {
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 lv_obj_t * lv_imagebutton_create(lv_obj_t * parent)
 {
     LV_LOG_INFO("begin");
@@ -72,6 +73,7 @@ lv_obj_t * lv_imagebutton_create(lv_obj_t * parent)
  * Setter functions
  *====================*/
 
+LV_FUNC_SECTION
 void lv_imagebutton_set_src(lv_obj_t * obj, lv_imagebutton_state_t state, const void * src_left, const void * src_mid,
                             const void * src_right)
 {
@@ -86,6 +88,7 @@ void lv_imagebutton_set_src(lv_obj_t * obj, lv_imagebutton_state_t state, const
     refr_image(obj);
 }
 
+LV_FUNC_SECTION
 void lv_imagebutton_set_state(lv_obj_t * obj, lv_imagebutton_state_t state)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -110,6 +113,7 @@ void lv_imagebutton_set_state(lv_obj_t * obj, lv_imagebutton_state_t state)
  * Getter functions
  *====================*/
 
+LV_FUNC_SECTION
 const void * lv_imagebutton_get_src_left(lv_obj_t * obj, lv_imagebutton_state_t state)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -119,6 +123,7 @@ const void * lv_imagebutton_get_src_left(lv_obj_t * obj, lv_imagebutton_state_t
     return imagebutton->src_left[state].img_src;
 }
 
+LV_FUNC_SECTION
 const void * lv_imagebutton_get_src_middle(lv_obj_t * obj, lv_imagebutton_state_t state)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -127,6 +132,7 @@ const void * lv_imagebutton_get_src_middle(lv_obj_t * obj, lv_imagebutton_state_
     return imagebutton->src_mid[state].img_src;
 }
 
+LV_FUNC_SECTION
 const void * lv_imagebutton_get_src_right(lv_obj_t * obj, lv_imagebutton_state_t state)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -139,6 +145,7 @@ const void * lv_imagebutton_get_src_right(lv_obj_t * obj, lv_imagebutton_state_t
  *   STATIC FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 static void lv_imagebutton_constructor(const lv_obj_class_t * class_p, lv_obj_t * obj)
 {
     LV_UNUSED(class_p);
@@ -150,6 +157,7 @@ static void lv_imagebutton_constructor(const lv_obj_class_t * class_p, lv_obj_t
     lv_memzero(&imagebutton->src_right, sizeof(imagebutton->src_right));
 }
 
+LV_FUNC_SECTION
 static void lv_imagebutton_event(const lv_obj_class_t * class_p, lv_event_t * e)
 {
     LV_UNUSED(class_p);
@@ -181,6 +189,7 @@ static void lv_imagebutton_event(const lv_obj_class_t * class_p, lv_event_t * e)
     }
 }
 
+LV_FUNC_SECTION
 static void draw_main(lv_event_t * e)
 {
     lv_obj_t * obj = lv_event_get_current_target(e);
@@ -248,6 +257,7 @@ static void draw_main(lv_event_t * e)
     }
 }
 
+LV_FUNC_SECTION
 static void refr_image(lv_obj_t * obj)
 {
     lv_imagebutton_t * imagebutton = (lv_imagebutton_t *)obj;
@@ -269,6 +279,7 @@ static void refr_image(lv_obj_t * obj)
  * @param state the state to convert
  * @return the suggested state
  */
+LV_FUNC_SECTION
 static lv_imagebutton_state_t suggest_state(lv_obj_t * obj, lv_imagebutton_state_t state)
 {
     lv_imagebutton_t * imagebutton = (lv_imagebutton_t *)obj;
@@ -300,6 +311,7 @@ static lv_imagebutton_state_t suggest_state(lv_obj_t * obj, lv_imagebutton_state
     return state;
 }
 
+LV_FUNC_SECTION
 static lv_imagebutton_state_t get_state(const lv_obj_t * imagebutton)
 {
     LV_ASSERT_OBJ(imagebutton, MY_CLASS);
@@ -321,6 +333,7 @@ static lv_imagebutton_state_t get_state(const lv_obj_t * imagebutton)
     }
 }
 
+LV_FUNC_SECTION
 static void update_src_info(lv_imagebutton_src_info_t * info, const void * src)
 {
     if(!src) {
diff --git a/src/widgets/keyboard/lv_keyboard.c b/src/widgets/keyboard/lv_keyboard.c
index e781eb397..6f94f22d7 100644
--- a/src/widgets/keyboard/lv_keyboard.c
+++ b/src/widgets/keyboard/lv_keyboard.c
@@ -213,6 +213,7 @@ static const lv_buttonmatrix_ctrl_t * kb_ctrl[10] = {
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 lv_obj_t * lv_keyboard_create(lv_obj_t * parent)
 {
     LV_LOG_INFO("begin");
@@ -225,6 +226,7 @@ lv_obj_t * lv_keyboard_create(lv_obj_t * parent)
  * Setter functions
  *====================*/
 
+LV_FUNC_SECTION
 void lv_keyboard_set_textarea(lv_obj_t * obj, lv_obj_t * ta)
 {
     if(ta) {
@@ -247,6 +249,7 @@ void lv_keyboard_set_textarea(lv_obj_t * obj, lv_obj_t * ta)
     }
 }
 
+LV_FUNC_SECTION
 void lv_keyboard_set_mode(lv_obj_t * obj, lv_keyboard_mode_t mode)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -257,6 +260,7 @@ void lv_keyboard_set_mode(lv_obj_t * obj, lv_keyboard_mode_t mode)
     lv_keyboard_update_map(obj);
 }
 
+LV_FUNC_SECTION
 void lv_keyboard_set_popovers(lv_obj_t * obj, bool en)
 {
     lv_keyboard_t * keyboard = (lv_keyboard_t *)obj;
@@ -269,6 +273,7 @@ void lv_keyboard_set_popovers(lv_obj_t * obj, bool en)
     lv_keyboard_update_ctrl_map(obj);
 }
 
+LV_FUNC_SECTION
 void lv_keyboard_set_map(lv_obj_t * obj, lv_keyboard_mode_t mode, const char * const map[],
                          const lv_buttonmatrix_ctrl_t ctrl_map[])
 {
@@ -282,6 +287,7 @@ void lv_keyboard_set_map(lv_obj_t * obj, lv_keyboard_mode_t mode, const char * c
  * Getter functions
  *====================*/
 
+LV_FUNC_SECTION
 lv_obj_t * lv_keyboard_get_textarea(const lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -289,6 +295,7 @@ lv_obj_t * lv_keyboard_get_textarea(const lv_obj_t * obj)
     return keyboard->ta;
 }
 
+LV_FUNC_SECTION
 lv_keyboard_mode_t lv_keyboard_get_mode(const lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -296,6 +303,7 @@ lv_keyboard_mode_t lv_keyboard_get_mode(const lv_obj_t * obj)
     return keyboard->mode;
 }
 
+LV_FUNC_SECTION
 bool lv_keyboard_get_popovers(const lv_obj_t * obj)
 {
     lv_keyboard_t * keyboard = (lv_keyboard_t *)obj;
@@ -305,7 +313,7 @@ bool lv_keyboard_get_popovers(const lv_obj_t * obj)
 /*=====================
  * Other functions
  *====================*/
-
+__attribute__(( fptrgroup("lv_event_cb") ))
 void lv_keyboard_def_event_cb(lv_event_t * e)
 {
     lv_obj_t * obj = lv_event_get_current_target(e);
@@ -410,16 +418,19 @@ void lv_keyboard_def_event_cb(lv_event_t * e)
     }
 }
 
+LV_FUNC_SECTION
 const char * const * lv_keyboard_get_map_array(const lv_obj_t * kb)
 {
     return lv_buttonmatrix_get_map(kb);
 }
 
+LV_FUNC_SECTION
 uint32_t lv_keyboard_get_selected_button(const lv_obj_t * obj)
 {
     return lv_buttonmatrix_get_selected_button(obj);
 }
 
+LV_FUNC_SECTION
 const char * lv_keyboard_get_button_text(const lv_obj_t * obj, uint32_t btn_id)
 {
     return lv_buttonmatrix_get_button_text(obj, btn_id);
@@ -429,6 +440,7 @@ const char * lv_keyboard_get_button_text(const lv_obj_t * obj, uint32_t btn_id)
  *   STATIC FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 static void lv_keyboard_constructor(const lv_obj_class_t * class_p, lv_obj_t * obj)
 {
     LV_UNUSED(class_p);
@@ -450,6 +462,7 @@ static void lv_keyboard_constructor(const lv_obj_class_t * class_p, lv_obj_t * o
  * Update the key and control map for the current mode
  * @param obj pointer to a keyboard object
  */
+LV_FUNC_SECTION
 static void lv_keyboard_update_map(lv_obj_t * obj)
 {
     lv_keyboard_t * keyboard = (lv_keyboard_t *)obj;
@@ -461,6 +474,7 @@ static void lv_keyboard_update_map(lv_obj_t * obj)
  * Update the control map for the current mode
  * @param obj pointer to a keyboard object
  */
+LV_FUNC_SECTION
 static void lv_keyboard_update_ctrl_map(lv_obj_t * obj)
 {
     lv_keyboard_t * keyboard = (lv_keyboard_t *)obj;
diff --git a/src/widgets/label/lv_label.c b/src/widgets/label/lv_label.c
index ae0711251..59f809729 100644
--- a/src/widgets/label/lv_label.c
+++ b/src/widgets/label/lv_label.c
@@ -120,6 +120,7 @@ const lv_obj_class_t lv_label_class = {
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 lv_obj_t * lv_label_create(lv_obj_t * parent)
 {
     LV_LOG_INFO("begin");
@@ -132,6 +133,7 @@ lv_obj_t * lv_label_create(lv_obj_t * parent)
  * Setter functions
  *====================*/
 
+LV_FUNC_SECTION
 void lv_label_set_text(lv_obj_t * obj, const char * text)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -175,6 +177,7 @@ void lv_label_set_text(lv_obj_t * obj, const char * text)
     lv_label_refr_text(obj);
 }
 
+LV_FUNC_SECTION
 void lv_label_set_text_fmt(lv_obj_t * obj, const char * fmt, ...)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -203,6 +206,7 @@ void lv_label_set_text_fmt(lv_obj_t * obj, const char * fmt, ...)
     lv_label_refr_text(obj);
 }
 
+LV_FUNC_SECTION
 void lv_label_set_text_static(lv_obj_t * obj, const char * text)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -221,6 +225,7 @@ void lv_label_set_text_static(lv_obj_t * obj, const char * text)
     lv_label_refr_text(obj);
 }
 
+LV_FUNC_SECTION
 void lv_label_set_long_mode(lv_obj_t * obj, lv_label_long_mode_t long_mode)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -246,6 +251,7 @@ void lv_label_set_long_mode(lv_obj_t * obj, lv_label_long_mode_t long_mode)
     lv_label_refr_text(obj);
 }
 
+LV_FUNC_SECTION
 void lv_label_set_text_selection_start(lv_obj_t * obj, uint32_t index)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -260,6 +266,7 @@ void lv_label_set_text_selection_start(lv_obj_t * obj, uint32_t index)
 #endif
 }
 
+LV_FUNC_SECTION
 void lv_label_set_text_selection_end(lv_obj_t * obj, uint32_t index)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -278,6 +285,7 @@ void lv_label_set_text_selection_end(lv_obj_t * obj, uint32_t index)
  * Getter functions
  *====================*/
 
+LV_FUNC_SECTION
 char * lv_label_get_text(const lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -285,6 +293,7 @@ char * lv_label_get_text(const lv_obj_t * obj)
     return label->text;
 }
 
+LV_FUNC_SECTION
 lv_label_long_mode_t lv_label_get_long_mode(const lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -292,6 +301,7 @@ lv_label_long_mode_t lv_label_get_long_mode(const lv_obj_t * obj)
     return label->long_mode;
 }
 
+LV_FUNC_SECTION
 void lv_label_get_letter_pos(const lv_obj_t * obj, uint32_t char_id, lv_point_t * pos)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -399,6 +409,7 @@ void lv_label_get_letter_pos(const lv_obj_t * obj, uint32_t char_id, lv_point_t
 #endif
 }
 
+LV_FUNC_SECTION
 uint32_t lv_label_get_letter_on(const lv_obj_t * obj, lv_point_t * pos_in, bool bidi)
 {
     LV_UNUSED(bidi);
@@ -519,6 +530,7 @@ uint32_t lv_label_get_letter_on(const lv_obj_t * obj, lv_point_t * pos_in, bool
     return  logical_pos + lv_text_encoded_get_char_id(txt, line_start);
 }
 
+LV_FUNC_SECTION
 bool lv_label_is_char_under_pos(const lv_obj_t * obj, lv_point_t * pos)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -593,6 +605,7 @@ bool lv_label_is_char_under_pos(const lv_obj_t * obj, lv_point_t * pos)
     return (pos->x >= (last_x - letter_space) && pos->x <= (last_x + max_diff));
 }
 
+LV_FUNC_SECTION
 uint32_t lv_label_get_text_selection_start(const lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -606,6 +619,7 @@ uint32_t lv_label_get_text_selection_start(const lv_obj_t * obj)
 #endif
 }
 
+LV_FUNC_SECTION
 uint32_t lv_label_get_text_selection_end(const lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -623,6 +637,7 @@ uint32_t lv_label_get_text_selection_end(const lv_obj_t * obj)
  * Other functions
  *====================*/
 
+LV_FUNC_SECTION
 void lv_label_ins_text(lv_obj_t * obj, uint32_t pos, const char * txt)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -651,6 +666,7 @@ void lv_label_ins_text(lv_obj_t * obj, uint32_t pos, const char * txt)
     lv_label_set_text(obj, NULL);
 }
 
+LV_FUNC_SECTION
 void lv_label_cut_text(lv_obj_t * obj, uint32_t pos, uint32_t cnt)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -673,6 +689,7 @@ void lv_label_cut_text(lv_obj_t * obj, uint32_t pos, uint32_t cnt)
  *   STATIC FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 static void lv_label_constructor(const lv_obj_class_t * class_p, lv_obj_t * obj)
 {
     LV_UNUSED(class_p);
@@ -706,6 +723,7 @@ static void lv_label_constructor(const lv_obj_class_t * class_p, lv_obj_t * obj)
     LV_TRACE_OBJ_CREATE("finished");
 }
 
+LV_FUNC_SECTION
 static void lv_label_destructor(const lv_obj_class_t * class_p, lv_obj_t * obj)
 {
     LV_UNUSED(class_p);
@@ -716,6 +734,7 @@ static void lv_label_destructor(const lv_obj_class_t * class_p, lv_obj_t * obj)
     label->text = NULL;
 }
 
+LV_FUNC_SECTION
 static void lv_label_event(const lv_obj_class_t * class_p, lv_event_t * e)
 {
     LV_UNUSED(class_p);
@@ -769,6 +788,7 @@ static void lv_label_event(const lv_obj_class_t * class_p, lv_event_t * e)
     }
 }
 
+LV_FUNC_SECTION
 static void draw_main(lv_event_t * e)
 {
     lv_obj_t * obj = lv_event_get_current_target(e);
@@ -864,6 +884,7 @@ static void draw_main(lv_event_t * e)
     layer->_clip_area = clip_area_ori;
 }
 
+LV_FUNC_SECTION
 static void overwrite_anim_property(lv_anim_t * dest, const lv_anim_t * src, lv_label_long_mode_t mode)
 {
     switch(mode) {
@@ -893,6 +914,8 @@ static void overwrite_anim_property(lv_anim_t * dest, const lv_anim_t * src, lv_
  * Refresh the label with its text stored in its extended data
  * @param label pointer to a label object
  */
+#pragma stackfunction 2048
+LV_FUNC_SECTION
 static void lv_label_refr_text(lv_obj_t * obj)
 {
     lv_label_t * label = (lv_label_t *)obj;
@@ -1175,6 +1198,7 @@ static void lv_label_refr_text(lv_obj_t * obj)
     lv_obj_invalidate(obj);
 }
 
+LV_FUNC_SECTION
 static void lv_label_revert_dots(lv_obj_t * obj)
 {
     lv_label_t * label = (lv_label_t *)obj;
@@ -1206,6 +1230,7 @@ static void lv_label_revert_dots(lv_obj_t * obj)
  * @param len Number of characters to store.
  * @return true on success.
  */
+LV_FUNC_SECTION
 static bool lv_label_set_dot_tmp(lv_obj_t * obj, char * data, uint32_t len)
 {
 
@@ -1236,6 +1261,7 @@ static bool lv_label_set_dot_tmp(lv_obj_t * obj, char * data, uint32_t len)
  * @param label pointer to label object
  * @return char pointer to a stored characters. Is *not* necessarily NULL-terminated.
  */
+LV_FUNC_SECTION
 static char * lv_label_get_dot_tmp(lv_obj_t * obj)
 {
     lv_label_t * label = (lv_label_t *)obj;
@@ -1252,6 +1278,7 @@ static char * lv_label_get_dot_tmp(lv_obj_t * obj)
  * Always clears the field
  * @param label pointer to label object.
  */
+LV_FUNC_SECTION
 static void lv_label_dot_tmp_free(lv_obj_t * obj)
 {
     lv_label_t * label = (lv_label_t *)obj;
@@ -1262,6 +1289,7 @@ static void lv_label_dot_tmp_free(lv_obj_t * obj)
     label->dot.tmp_ptr   = NULL;
 }
 
+__attribute__(( fptrgroup("lv_anim_exec_cb") ))
 static void set_ofs_x_anim(void * obj, int32_t v)
 {
     lv_label_t * label = (lv_label_t *)obj;
@@ -1269,6 +1297,7 @@ static void set_ofs_x_anim(void * obj, int32_t v)
     lv_obj_invalidate(obj);
 }
 
+__attribute__(( fptrgroup("lv_anim_exec_cb") ))
 static void set_ofs_y_anim(void * obj, int32_t v)
 {
     lv_label_t * label = (lv_label_t *)obj;
@@ -1276,6 +1305,7 @@ static void set_ofs_y_anim(void * obj, int32_t v)
     lv_obj_invalidate(obj);
 }
 
+LV_FUNC_SECTION
 static size_t get_text_length(const char * text)
 {
     size_t len = 0;
@@ -1288,6 +1318,7 @@ static size_t get_text_length(const char * text)
     return len;
 }
 
+LV_FUNC_SECTION
 static void copy_text_to_label(lv_label_t * label, const char * text)
 {
 #if LV_USE_ARABIC_PERSIAN_CHARS
@@ -1297,6 +1328,7 @@ static void copy_text_to_label(lv_label_t * label, const char * text)
 #endif
 }
 
+LV_FUNC_SECTION
 static lv_text_flag_t get_label_flags(lv_label_t * label)
 {
     lv_text_flag_t flag = LV_TEXT_FLAG_NONE;
@@ -1314,6 +1346,7 @@ static lv_text_flag_t get_label_flags(lv_label_t * label)
 }
 
 /* Function created because of this pattern be used in multiple functions */
+LV_FUNC_SECTION
 static void calculate_x_coordinate(int32_t * x, const lv_text_align_t align, const char * txt, uint32_t length,
                                    const lv_font_t * font, int32_t letter_space, lv_area_t * txt_coords)
 {
diff --git a/src/widgets/led/lv_led.c b/src/widgets/led/lv_led.c
index 6a8c29bbf..856a024b0 100644
--- a/src/widgets/led/lv_led.c
+++ b/src/widgets/led/lv_led.c
@@ -53,6 +53,7 @@ const lv_obj_class_t lv_led_class  = {
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 lv_obj_t * lv_led_create(lv_obj_t * parent)
 {
     LV_LOG_INFO("begin");
@@ -65,6 +66,7 @@ lv_obj_t * lv_led_create(lv_obj_t * parent)
  * Setter functions
  *====================*/
 
+LV_FUNC_SECTION
 void lv_led_set_color(lv_obj_t * obj, lv_color_t color)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -74,6 +76,7 @@ void lv_led_set_color(lv_obj_t * obj, lv_color_t color)
     lv_obj_invalidate(obj);
 }
 
+LV_FUNC_SECTION
 void lv_led_set_brightness(lv_obj_t * obj, uint8_t bright)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -87,16 +90,19 @@ void lv_led_set_brightness(lv_obj_t * obj, uint8_t bright)
     lv_obj_invalidate(obj);
 }
 
+LV_FUNC_SECTION
 void lv_led_on(lv_obj_t * led)
 {
     lv_led_set_brightness(led, LV_LED_BRIGHT_MAX);
 }
 
+LV_FUNC_SECTION
 void lv_led_off(lv_obj_t * led)
 {
     lv_led_set_brightness(led, LV_LED_BRIGHT_MIN);
 }
 
+LV_FUNC_SECTION
 void lv_led_toggle(lv_obj_t * obj)
 {
     uint8_t bright = lv_led_get_brightness(obj);
@@ -110,6 +116,7 @@ void lv_led_toggle(lv_obj_t * obj)
  * Getter functions
  *====================*/
 
+LV_FUNC_SECTION
 uint8_t lv_led_get_brightness(const lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -122,6 +129,7 @@ uint8_t lv_led_get_brightness(const lv_obj_t * obj)
  *   STATIC FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 static void lv_led_constructor(const lv_obj_class_t * class_p, lv_obj_t * obj)
 {
     LV_UNUSED(class_p);
@@ -130,6 +138,7 @@ static void lv_led_constructor(const lv_obj_class_t * class_p, lv_obj_t * obj)
     led->bright = LV_LED_BRIGHT_MAX;
 }
 
+LV_FUNC_SECTION
 static void lv_led_event(const lv_obj_class_t * class_p, lv_event_t * e)
 {
     LV_UNUSED(class_p);
diff --git a/src/widgets/line/lv_line.c b/src/widgets/line/lv_line.c
index a251aae72..b419f6dd8 100644
--- a/src/widgets/line/lv_line.c
+++ b/src/widgets/line/lv_line.c
@@ -53,6 +53,7 @@ const lv_obj_class_t lv_line_class = {
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 lv_obj_t * lv_line_create(lv_obj_t * parent)
 {
     LV_LOG_INFO("begin");
@@ -65,16 +66,19 @@ lv_obj_t * lv_line_create(lv_obj_t * parent)
  * Setter functions
  *====================*/
 
+LV_FUNC_SECTION
 void lv_line_set_points(lv_obj_t * obj, const lv_point_precise_t points[], uint32_t point_num)
 {
     line_set_points(obj, points, point_num, false);
 }
 
+LV_FUNC_SECTION
 void lv_line_set_points_mutable(lv_obj_t * obj, lv_point_precise_t points[], uint32_t point_num)
 {
     line_set_points(obj, points, point_num, true);
 }
 
+LV_FUNC_SECTION
 void lv_line_set_y_invert(lv_obj_t * obj, bool en)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -91,6 +95,7 @@ void lv_line_set_y_invert(lv_obj_t * obj, bool en)
  * Getter functions
  *====================*/
 
+LV_FUNC_SECTION
 const lv_point_precise_t * lv_line_get_points(lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -99,6 +104,7 @@ const lv_point_precise_t * lv_line_get_points(lv_obj_t * obj)
     return line->point_array.constant;
 }
 
+LV_FUNC_SECTION
 uint32_t lv_line_get_point_count(lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -107,6 +113,7 @@ uint32_t lv_line_get_point_count(lv_obj_t * obj)
     return line->point_num;
 }
 
+LV_FUNC_SECTION
 bool lv_line_is_point_array_mutable(lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -115,6 +122,7 @@ bool lv_line_is_point_array_mutable(lv_obj_t * obj)
     return line->point_array_is_mutable;
 }
 
+LV_FUNC_SECTION
 lv_point_precise_t * lv_line_get_points_mutable(lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -127,6 +135,7 @@ lv_point_precise_t * lv_line_get_points_mutable(lv_obj_t * obj)
     return line->point_array.mut;
 }
 
+LV_FUNC_SECTION
 bool lv_line_get_y_invert(const lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -140,6 +149,7 @@ bool lv_line_get_y_invert(const lv_obj_t * obj)
  *   STATIC FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 static void lv_line_constructor(const lv_obj_class_t * class_p, lv_obj_t * obj)
 {
     LV_UNUSED(class_p);
@@ -157,6 +167,7 @@ static void lv_line_constructor(const lv_obj_class_t * class_p, lv_obj_t * obj)
     LV_TRACE_OBJ_CREATE("finished");
 }
 
+LV_FUNC_SECTION
 static void line_set_points(lv_obj_t * obj, const lv_point_precise_t points[], uint32_t point_num, bool mut)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -171,6 +182,7 @@ static void line_set_points(lv_obj_t * obj, const lv_point_precise_t points[], u
     lv_obj_invalidate(obj);
 }
 
+LV_FUNC_SECTION
 static inline lv_value_precise_t resolve_point_coord(lv_value_precise_t coord, int32_t max)
 {
     if(LV_COORD_IS_PCT((int32_t)coord)) {
@@ -181,6 +193,7 @@ static inline lv_value_precise_t resolve_point_coord(lv_value_precise_t coord, i
     }
 }
 
+LV_FUNC_SECTION
 static void lv_line_event(const lv_obj_class_t * class_p, lv_event_t * e)
 {
     LV_UNUSED(class_p);
diff --git a/src/widgets/list/lv_list.c b/src/widgets/list/lv_list.c
index 3556ef1dc..45bec4295 100644
--- a/src/widgets/list/lv_list.c
+++ b/src/widgets/list/lv_list.c
@@ -63,6 +63,7 @@ const lv_obj_class_t lv_list_text_class = {
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 lv_obj_t * lv_list_create(lv_obj_t * parent)
 {
     LV_LOG_INFO("begin");
@@ -72,6 +73,7 @@ lv_obj_t * lv_list_create(lv_obj_t * parent)
     return obj;
 }
 
+LV_FUNC_SECTION
 lv_obj_t * lv_list_add_text(lv_obj_t * list, const char * txt)
 {
     LV_LOG_INFO("begin");
@@ -82,6 +84,7 @@ lv_obj_t * lv_list_add_text(lv_obj_t * list, const char * txt)
     return obj;
 }
 
+LV_FUNC_SECTION
 lv_obj_t * lv_list_add_button(lv_obj_t * list, const void * icon, const char * txt)
 {
     LV_LOG_INFO("begin");
@@ -106,6 +109,7 @@ lv_obj_t * lv_list_add_button(lv_obj_t * list, const void * icon, const char * t
     return obj;
 }
 
+LV_FUNC_SECTION
 const char * lv_list_get_button_text(lv_obj_t * list, lv_obj_t * btn)
 {
     LV_UNUSED(list);
@@ -121,6 +125,7 @@ const char * lv_list_get_button_text(lv_obj_t * list, lv_obj_t * btn)
     return "";
 }
 
+LV_FUNC_SECTION
 void lv_list_set_button_text(lv_obj_t * list, lv_obj_t * btn, const char * txt)
 {
     LV_UNUSED(list);
diff --git a/src/widgets/lottie/lv_lottie.c b/src/widgets/lottie/lv_lottie.c
index 48ae25814..3995a0db9 100644
--- a/src/widgets/lottie/lv_lottie.c
+++ b/src/widgets/lottie/lv_lottie.c
@@ -61,6 +61,7 @@ const lv_obj_class_t lv_lottie_class = {
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 lv_obj_t * lv_lottie_create(lv_obj_t * parent)
 {
     LV_LOG_INFO("begin");
@@ -69,6 +70,7 @@ lv_obj_t * lv_lottie_create(lv_obj_t * parent)
     return obj;
 }
 
+LV_FUNC_SECTION
 void lv_lottie_set_buffer(lv_obj_t * obj, int32_t w, int32_t h, void * buf)
 {
     lv_lottie_t * lottie = (lv_lottie_t *)obj;
@@ -90,6 +92,7 @@ void lv_lottie_set_buffer(lv_obj_t * obj, int32_t w, int32_t h, void * buf)
     anim_exec_cb(obj, (int32_t) f_current);
 }
 
+LV_FUNC_SECTION
 void lv_lottie_set_draw_buf(lv_obj_t * obj, lv_draw_buf_t * draw_buf)
 {
     if(draw_buf->header.cf != LV_COLOR_FORMAT_ARGB8888) {
@@ -113,6 +116,7 @@ void lv_lottie_set_draw_buf(lv_obj_t * obj, lv_draw_buf_t * draw_buf)
     anim_exec_cb(obj, (int32_t) f_current);
 }
 
+LV_FUNC_SECTION
 void lv_lottie_set_src_data(lv_obj_t * obj, const void * src, size_t src_size)
 {
     lv_lottie_t * lottie = (lv_lottie_t *)obj;
@@ -131,6 +135,7 @@ void lv_lottie_set_src_data(lv_obj_t * obj, const void * src, size_t src_size)
     lottie_update(lottie, 0);   /*Render immediately*/
 }
 
+LV_FUNC_SECTION
 void lv_lottie_set_src_file(lv_obj_t * obj, const char * src)
 {
     lv_lottie_t * lottie = (lv_lottie_t *)obj;
@@ -150,6 +155,7 @@ void lv_lottie_set_src_file(lv_obj_t * obj, const char * src)
 }
 
 
+LV_FUNC_SECTION
 lv_anim_t * lv_lottie_get_anim(lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -161,6 +167,7 @@ lv_anim_t * lv_lottie_get_anim(lv_obj_t * obj)
  *   STATIC FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 static void lv_lottie_constructor(const lv_obj_class_t * class_p, lv_obj_t * obj)
 {
     LV_UNUSED(class_p);
@@ -185,6 +192,7 @@ static void lv_lottie_constructor(const lv_obj_class_t * class_p, lv_obj_t * obj
     LV_TRACE_OBJ_CREATE("finished");
 }
 
+LV_FUNC_SECTION
 static void lv_lottie_destructor(const lv_obj_class_t * class_p, lv_obj_t * obj)
 {
     LV_UNUSED(class_p);
@@ -194,6 +202,7 @@ static void lv_lottie_destructor(const lv_obj_class_t * class_p, lv_obj_t * obj)
     tvg_canvas_destroy(lottie->tvg_canvas);
 }
 
+__attribute__(( fptrgroup("lv_anim_exec_cb") ))
 static void anim_exec_cb(void * var, int32_t v)
 {
     lv_lottie_t * lottie = var;
@@ -214,6 +223,7 @@ static void anim_exec_cb(void * var, int32_t v)
     }
 }
 
+LV_FUNC_SECTION
 static void lottie_update(lv_lottie_t * lottie, int32_t v)
 {
     lv_obj_t * obj = (lv_obj_t *) lottie;
diff --git a/src/widgets/menu/lv_menu.c b/src/widgets/menu/lv_menu.c
index f9b49fc0e..3434747d4 100644
--- a/src/widgets/menu/lv_menu.c
+++ b/src/widgets/menu/lv_menu.c
@@ -116,6 +116,7 @@ static void lv_menu_value_changed_event_cb(lv_event_t * e);
 bool lv_menu_item_back_button_is_root(lv_obj_t * menu, lv_obj_t * obj);
 void lv_menu_clear_history(lv_obj_t * obj);
 
+LV_FUNC_SECTION
 lv_obj_t * lv_menu_create(lv_obj_t * parent)
 {
     LV_LOG_INFO("begin");
@@ -124,6 +125,7 @@ lv_obj_t * lv_menu_create(lv_obj_t * parent)
     return obj;
 }
 
+LV_FUNC_SECTION
 lv_obj_t * lv_menu_page_create(lv_obj_t * parent, char const * const title)
 {
     LV_LOG_INFO("begin");
@@ -139,6 +141,7 @@ lv_obj_t * lv_menu_page_create(lv_obj_t * parent, char const * const title)
     return obj;
 }
 
+LV_FUNC_SECTION
 lv_obj_t * lv_menu_cont_create(lv_obj_t * parent)
 {
     LV_LOG_INFO("begin");
@@ -147,6 +150,7 @@ lv_obj_t * lv_menu_cont_create(lv_obj_t * parent)
     return obj;
 }
 
+LV_FUNC_SECTION
 lv_obj_t * lv_menu_section_create(lv_obj_t * parent)
 {
     LV_LOG_INFO("begin");
@@ -155,6 +159,7 @@ lv_obj_t * lv_menu_section_create(lv_obj_t * parent)
     return obj;
 }
 
+LV_FUNC_SECTION
 lv_obj_t * lv_menu_separator_create(lv_obj_t * parent)
 {
     LV_LOG_INFO("begin");
@@ -163,6 +168,7 @@ lv_obj_t * lv_menu_separator_create(lv_obj_t * parent)
     return obj;
 }
 
+LV_FUNC_SECTION
 void lv_menu_refr(lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -191,6 +197,7 @@ void lv_menu_refr(lv_obj_t * obj)
  * Setter functions
  *====================*/
 
+LV_FUNC_SECTION
 void lv_menu_set_page(lv_obj_t * obj, lv_obj_t * page)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -271,6 +278,7 @@ void lv_menu_set_page(lv_obj_t * obj, lv_obj_t * page)
     lv_menu_refr_main_header_mode(obj);
 }
 
+LV_FUNC_SECTION
 void lv_menu_set_sidebar_page(lv_obj_t * obj, lv_obj_t * page)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -334,6 +342,7 @@ void lv_menu_set_sidebar_page(lv_obj_t * obj, lv_obj_t * page)
     lv_menu_refr(obj);
 }
 
+LV_FUNC_SECTION
 void lv_menu_set_mode_header(lv_obj_t * obj, lv_menu_mode_header_t mode)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -347,6 +356,7 @@ void lv_menu_set_mode_header(lv_obj_t * obj, lv_menu_mode_header_t mode)
     }
 }
 
+LV_FUNC_SECTION
 void lv_menu_set_mode_root_back_button(lv_obj_t * obj, lv_menu_mode_root_back_button_t mode)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -359,6 +369,7 @@ void lv_menu_set_mode_root_back_button(lv_obj_t * obj, lv_menu_mode_root_back_bu
     }
 }
 
+LV_FUNC_SECTION
 void lv_menu_set_load_page_event(lv_obj_t * menu, lv_obj_t * obj, lv_obj_t * page)
 {
     LV_ASSERT_OBJ(menu, MY_CLASS);
@@ -387,6 +398,7 @@ void lv_menu_set_load_page_event(lv_obj_t * menu, lv_obj_t * obj, lv_obj_t * pag
     lv_obj_add_event_cb(obj, lv_menu_obj_delete_event_cb, LV_EVENT_DELETE, event_data);
 }
 
+LV_FUNC_SECTION
 void lv_menu_set_page_title(lv_obj_t * page_obj, char const * const title)
 {
     LV_LOG_INFO("begin");
@@ -412,6 +424,7 @@ void lv_menu_set_page_title(lv_obj_t * page_obj, char const * const title)
     }
 }
 
+LV_FUNC_SECTION
 void lv_menu_set_page_title_static(lv_obj_t * page_obj, char const * const title)
 {
     LV_LOG_INFO("begin");
@@ -437,6 +450,7 @@ void lv_menu_set_page_title_static(lv_obj_t * page_obj, char const * const title
 /*=====================
  * Getter functions
  *====================*/
+LV_FUNC_SECTION
 lv_obj_t * lv_menu_get_cur_main_page(lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -445,6 +459,7 @@ lv_obj_t * lv_menu_get_cur_main_page(lv_obj_t * obj)
     return menu->main_page;
 }
 
+LV_FUNC_SECTION
 lv_obj_t * lv_menu_get_cur_sidebar_page(lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -453,6 +468,7 @@ lv_obj_t * lv_menu_get_cur_sidebar_page(lv_obj_t * obj)
     return menu->sidebar_page;
 }
 
+LV_FUNC_SECTION
 lv_obj_t * lv_menu_get_main_header(lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -461,6 +477,7 @@ lv_obj_t * lv_menu_get_main_header(lv_obj_t * obj)
     return menu->main_header;
 }
 
+LV_FUNC_SECTION
 lv_obj_t * lv_menu_get_main_header_back_button(lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -469,6 +486,7 @@ lv_obj_t * lv_menu_get_main_header_back_button(lv_obj_t * obj)
     return menu->main_header_back_btn;
 }
 
+LV_FUNC_SECTION
 lv_obj_t * lv_menu_get_sidebar_header(lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -477,6 +495,7 @@ lv_obj_t * lv_menu_get_sidebar_header(lv_obj_t * obj)
     return menu->sidebar_header;
 }
 
+LV_FUNC_SECTION
 lv_obj_t * lv_menu_get_sidebar_header_back_button(lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -485,6 +504,7 @@ lv_obj_t * lv_menu_get_sidebar_header_back_button(lv_obj_t * obj)
     return menu->sidebar_header_back_btn;
 }
 
+LV_FUNC_SECTION
 bool lv_menu_back_button_is_root(lv_obj_t * menu, lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(menu, MY_CLASS);
@@ -500,6 +520,7 @@ bool lv_menu_back_button_is_root(lv_obj_t * menu, lv_obj_t * obj)
     return false;
 }
 
+LV_FUNC_SECTION
 void lv_menu_clear_history(lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -516,6 +537,7 @@ void lv_menu_clear_history(lv_obj_t * obj)
  *   STATIC FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 static void lv_menu_constructor(const lv_obj_class_t * class_p, lv_obj_t * obj)
 {
     LV_UNUSED(class_p);
@@ -583,6 +605,7 @@ static void lv_menu_constructor(const lv_obj_class_t * class_p, lv_obj_t * obj)
     LV_TRACE_OBJ_CREATE("finished");
 }
 
+LV_FUNC_SECTION
 static void lv_menu_destructor(const lv_obj_class_t * class_p, lv_obj_t * obj)
 {
     LV_UNUSED(class_p);
@@ -596,6 +619,7 @@ static void lv_menu_destructor(const lv_obj_class_t * class_p, lv_obj_t * obj)
     LV_TRACE_OBJ_CREATE("finished");
 }
 
+LV_FUNC_SECTION
 static void lv_menu_page_constructor(const lv_obj_class_t * class_p, lv_obj_t * obj)
 {
     LV_UNUSED(class_p);
@@ -608,6 +632,7 @@ static void lv_menu_page_constructor(const lv_obj_class_t * class_p, lv_obj_t *
     lv_obj_add_flag(obj, LV_OBJ_FLAG_EVENT_BUBBLE);
 }
 
+LV_FUNC_SECTION
 static void lv_menu_page_destructor(const lv_obj_class_t * class_p, lv_obj_t * obj)
 {
     LV_UNUSED(class_p);
@@ -621,6 +646,7 @@ static void lv_menu_page_destructor(const lv_obj_class_t * class_p, lv_obj_t * o
     page->static_title = false;
 }
 
+LV_FUNC_SECTION
 static void lv_menu_cont_constructor(const lv_obj_class_t * class_p, lv_obj_t * obj)
 {
     LV_UNUSED(class_p);
@@ -629,6 +655,7 @@ static void lv_menu_cont_constructor(const lv_obj_class_t * class_p, lv_obj_t *
     lv_obj_remove_flag(obj, LV_OBJ_FLAG_CLICKABLE);
 }
 
+LV_FUNC_SECTION
 static void lv_menu_section_constructor(const lv_obj_class_t * class_p, lv_obj_t * obj)
 {
     LV_UNUSED(class_p);
@@ -636,6 +663,7 @@ static void lv_menu_section_constructor(const lv_obj_class_t * class_p, lv_obj_t
     lv_obj_remove_flag(obj, LV_OBJ_FLAG_CLICKABLE);
 }
 
+LV_FUNC_SECTION
 static void lv_menu_refr_sidebar_header_mode(lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -671,6 +699,7 @@ static void lv_menu_refr_sidebar_header_mode(lv_obj_t * obj)
     }
 }
 
+LV_FUNC_SECTION
 static void lv_menu_refr_main_header_mode(lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -707,6 +736,7 @@ static void lv_menu_refr_main_header_mode(lv_obj_t * obj)
     }
 }
 
+__attribute__(( fptrgroup("lv_event_cb") ))
 static void lv_menu_load_page_event_cb(lv_event_t * e)
 {
     lv_obj_t * obj = lv_event_get_current_target(e);
@@ -748,12 +778,14 @@ static void lv_menu_load_page_event_cb(lv_event_t * e)
     }
 }
 
+__attribute__(( fptrgroup("lv_event_cb") ))
 static void lv_menu_obj_delete_event_cb(lv_event_t * e)
 {
     lv_menu_load_page_event_data_t * event_data = lv_event_get_user_data(e);
     lv_free(event_data);
 }
 
+__attribute__(( fptrgroup("lv_event_cb") ))
 static void lv_menu_back_event_cb(lv_event_t * e)
 {
     lv_event_code_t code = lv_event_get_code(e);
@@ -793,6 +825,7 @@ static void lv_menu_back_event_cb(lv_event_t * e)
     }
 }
 
+__attribute__(( fptrgroup("lv_event_cb") ))
 static void lv_menu_value_changed_event_cb(lv_event_t * e)
 {
     lv_obj_t * obj = lv_event_get_user_data(e);
diff --git a/src/widgets/msgbox/lv_msgbox.c b/src/widgets/msgbox/lv_msgbox.c
index 98ad81e16..f369bfb62 100644
--- a/src/widgets/msgbox/lv_msgbox.c
+++ b/src/widgets/msgbox/lv_msgbox.c
@@ -104,6 +104,7 @@ const lv_obj_class_t lv_msgbox_backdrop_class = {
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 lv_obj_t * lv_msgbox_create(lv_obj_t * parent)
 {
     LV_LOG_INFO("begin");
@@ -137,6 +138,7 @@ lv_obj_t * lv_msgbox_create(lv_obj_t * parent)
     return obj;
 }
 
+LV_FUNC_SECTION
 lv_obj_t * lv_msgbox_add_title(lv_obj_t * obj, const char * title)
 {
     lv_msgbox_t * mbox = (lv_msgbox_t *)obj;
@@ -163,6 +165,7 @@ lv_obj_t * lv_msgbox_add_title(lv_obj_t * obj, const char * title)
     return mbox->title;
 }
 
+LV_FUNC_SECTION
 lv_obj_t * lv_msgbox_add_header_button(lv_obj_t * obj, const void * icon)
 {
     lv_msgbox_t * mbox = (lv_msgbox_t *)obj;
@@ -185,6 +188,7 @@ lv_obj_t * lv_msgbox_add_header_button(lv_obj_t * obj, const void * icon)
     return btn;
 }
 
+LV_FUNC_SECTION
 lv_obj_t * lv_msgbox_add_text(lv_obj_t * obj, const char * text)
 {
     lv_msgbox_t * mbox = (lv_msgbox_t *)obj;
@@ -196,6 +200,7 @@ lv_obj_t * lv_msgbox_add_text(lv_obj_t * obj, const char * text)
     return label;
 }
 
+LV_FUNC_SECTION
 lv_obj_t * lv_msgbox_add_footer_button(lv_obj_t * obj, const char * text)
 {
     lv_msgbox_t * mbox = (lv_msgbox_t *)obj;
@@ -225,6 +230,7 @@ lv_obj_t * lv_msgbox_add_footer_button(lv_obj_t * obj, const char * text)
     return btn;
 }
 
+LV_FUNC_SECTION
 lv_obj_t * lv_msgbox_add_close_button(lv_obj_t * obj)
 {
     lv_obj_t * btn = lv_msgbox_add_header_button(obj, LV_SYMBOL_CLOSE);
@@ -232,6 +238,7 @@ lv_obj_t * lv_msgbox_add_close_button(lv_obj_t * obj)
     return btn;
 }
 
+LV_FUNC_SECTION
 lv_obj_t * lv_msgbox_get_header(lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -239,6 +246,7 @@ lv_obj_t * lv_msgbox_get_header(lv_obj_t * obj)
     return mbox->header;
 }
 
+LV_FUNC_SECTION
 lv_obj_t * lv_msgbox_get_footer(lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -246,6 +254,7 @@ lv_obj_t * lv_msgbox_get_footer(lv_obj_t * obj)
     return mbox->footer;
 }
 
+LV_FUNC_SECTION
 lv_obj_t * lv_msgbox_get_content(lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -253,6 +262,7 @@ lv_obj_t * lv_msgbox_get_content(lv_obj_t * obj)
     return mbox->content;
 }
 
+LV_FUNC_SECTION
 lv_obj_t * lv_msgbox_get_title(lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -260,12 +270,14 @@ lv_obj_t * lv_msgbox_get_title(lv_obj_t * obj)
     return mbox->title;
 }
 
+LV_FUNC_SECTION
 void lv_msgbox_close(lv_obj_t * obj)
 {
     if(lv_obj_has_flag(obj, LV_MSGBOX_FLAG_AUTO_PARENT)) lv_obj_delete(lv_obj_get_parent(obj));
     else lv_obj_delete(obj);
 }
 
+LV_FUNC_SECTION
 void lv_msgbox_close_async(lv_obj_t * obj)
 {
     if(lv_obj_has_flag(obj, LV_MSGBOX_FLAG_AUTO_PARENT)) lv_obj_delete_async(lv_obj_get_parent(obj));
@@ -275,7 +287,7 @@ void lv_msgbox_close_async(lv_obj_t * obj)
 /**********************
  *   STATIC FUNCTIONS
  **********************/
-
+__attribute__(( fptrgroup("lv_event_cb") ))
 static void msgbox_close_click_event_cb(lv_event_t * e)
 {
     lv_obj_t * btn = lv_event_get_current_target(e);
@@ -283,6 +295,7 @@ static void msgbox_close_click_event_cb(lv_event_t * e)
     lv_msgbox_close(mbox);
 }
 
+__attribute__(( fptrgroup("lv_event_cb") ))
 static void msgbox_size_changed_event_cb(lv_event_t * e)
 {
     lv_obj_t * mbox = lv_event_get_target(e);
diff --git a/src/widgets/objx_templ/lv_objx_templ.c b/src/widgets/objx_templ/lv_objx_templ.c
index eaf5c1270..e85aaed66 100644
--- a/src/widgets/objx_templ/lv_objx_templ.c
+++ b/src/widgets/objx_templ/lv_objx_templ.c
@@ -59,6 +59,7 @@ const lv_obj_class_t lv_templ_class = {
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 lv_obj_t * lv_templ_create(lv_obj_t * parent)
 {
 
@@ -104,6 +105,7 @@ lv_obj_t * lv_templ_create(lv_obj_t * parent)
  *   STATIC FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 static void lv_templ_constructor(const lv_obj_class_t * class_p, lv_obj_t * obj)
 {
     LV_UNUSED(class_p);
@@ -115,12 +117,14 @@ static void lv_templ_constructor(const lv_obj_class_t * class_p, lv_obj_t * obj)
     LV_TRACE_OBJ_CREATE("finished");
 }
 
+LV_FUNC_SECTION
 static void lv_templ_destructor(const lv_obj_class_t * class_p, lv_obj_t * obj)
 {
     lv_templ_t * templ = (lv_templ_t *)obj;
     /*Free the widget specific data*/
 }
 
+LV_FUNC_SECTION
 static void lv_templ_event(const lv_obj_class_t * class_p, lv_event_t * e)
 {
     LV_UNUSED(class_p);
diff --git a/src/widgets/roller/lv_roller.c b/src/widgets/roller/lv_roller.c
index b762a1e25..aa2913994 100644
--- a/src/widgets/roller/lv_roller.c
+++ b/src/widgets/roller/lv_roller.c
@@ -113,6 +113,7 @@ const lv_obj_class_t lv_roller_label_class  = {
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 lv_obj_t * lv_roller_create(lv_obj_t * parent)
 {
     LV_LOG_INFO("begin");
@@ -125,6 +126,7 @@ lv_obj_t * lv_roller_create(lv_obj_t * parent)
  * Setter functions
  *====================*/
 
+LV_FUNC_SECTION
 void lv_roller_set_options(lv_obj_t * obj, const char * options, lv_roller_mode_t mode)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -186,6 +188,7 @@ void lv_roller_set_options(lv_obj_t * obj, const char * options, lv_roller_mode_
     lv_obj_refresh_ext_draw_size(label);
 }
 
+LV_FUNC_SECTION
 void lv_roller_set_selected(lv_obj_t * obj, uint32_t sel_opt, lv_anim_enable_t anim)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -220,6 +223,7 @@ void lv_roller_set_selected(lv_obj_t * obj, uint32_t sel_opt, lv_anim_enable_t a
     refr_position(obj, anim);
 }
 
+LV_FUNC_SECTION
 void lv_roller_set_visible_row_count(lv_obj_t * obj, uint32_t row_cnt)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -234,6 +238,7 @@ void lv_roller_set_visible_row_count(lv_obj_t * obj, uint32_t row_cnt)
  * Getter functions
  *====================*/
 
+LV_FUNC_SECTION
 uint32_t lv_roller_get_selected(const lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -248,6 +253,7 @@ uint32_t lv_roller_get_selected(const lv_obj_t * obj)
     }
 }
 
+LV_FUNC_SECTION
 void lv_roller_get_selected_str(const lv_obj_t * obj, char * buf, uint32_t buf_size)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -280,6 +286,7 @@ void lv_roller_get_selected_str(const lv_obj_t * obj, char * buf, uint32_t buf_s
  * @param roller pointer to roller object
  * @return the options separated by '\n'-s (E.g. "Option1\nOption2\nOption3")
  */
+LV_FUNC_SECTION
 const char * lv_roller_get_options(const lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -287,6 +294,7 @@ const char * lv_roller_get_options(const lv_obj_t * obj)
     return lv_label_get_text(get_label(obj));
 }
 
+LV_FUNC_SECTION
 uint32_t lv_roller_get_option_count(const lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -304,6 +312,7 @@ uint32_t lv_roller_get_option_count(const lv_obj_t * obj)
  *   STATIC FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 static void lv_roller_constructor(const lv_obj_class_t * class_p, lv_obj_t * obj)
 {
     LV_UNUSED(class_p);
@@ -326,6 +335,7 @@ static void lv_roller_constructor(const lv_obj_class_t * class_p, lv_obj_t * obj
     LV_LOG_TRACE("finished");
 }
 
+LV_FUNC_SECTION
 static void lv_roller_event(const lv_obj_class_t * class_p, lv_event_t * e)
 {
     LV_UNUSED(class_p);
@@ -450,6 +460,7 @@ static void lv_roller_event(const lv_obj_class_t * class_p, lv_event_t * e)
     }
 }
 
+LV_FUNC_SECTION
 static void lv_roller_label_event(const lv_obj_class_t * class_p, lv_event_t * e)
 {
     LV_UNUSED(class_p);
@@ -481,6 +492,7 @@ static void lv_roller_label_event(const lv_obj_class_t * class_p, lv_event_t * e
     }
 }
 
+LV_FUNC_SECTION
 static void draw_main(lv_event_t * e)
 {
     lv_event_code_t code = lv_event_get_code(e);
@@ -560,6 +572,7 @@ static void draw_main(lv_event_t * e)
     }
 }
 
+LV_FUNC_SECTION
 static void draw_label(lv_event_t * e)
 {
     /* Split the drawing of the label into  an upper (above the selected area)
@@ -610,6 +623,7 @@ static void draw_label(lv_event_t * e)
     layer->_clip_area = clip_area_ori;
 }
 
+LV_FUNC_SECTION
 static void get_sel_area(lv_obj_t * obj, lv_area_t * sel_area)
 {
 
@@ -634,6 +648,7 @@ static void get_sel_area(lv_obj_t * obj, lv_area_t * sel_area)
  * @param roller pointer to a roller object
  * @param anim_en LV_ANIM_ON: refresh with animation; LV_ANIM_OFF: without animation
  */
+LV_FUNC_SECTION
 static void refr_position(lv_obj_t * obj, lv_anim_enable_t anim_en)
 {
     lv_obj_t * label = get_label(obj);
@@ -694,6 +709,7 @@ static void refr_position(lv_obj_t * obj, lv_anim_enable_t anim_en)
     }
 }
 
+LV_FUNC_SECTION
 static lv_result_t release_handler(lv_obj_t * obj)
 {
     lv_obj_t * label = get_label(obj);
@@ -783,6 +799,7 @@ static lv_result_t release_handler(lv_obj_t * obj)
  * Set the middle page for the roller if infinite is enabled
  * @param roller pointer to a roller object
  */
+LV_FUNC_SECTION
 static void inf_normalize(lv_obj_t * obj)
 {
     lv_roller_t * roller = (lv_roller_t *)obj;
@@ -810,11 +827,13 @@ static void inf_normalize(lv_obj_t * obj)
     }
 }
 
+LV_FUNC_SECTION
 static lv_obj_t * get_label(const lv_obj_t * obj)
 {
     return lv_obj_get_child(obj, 0);
 }
 
+LV_FUNC_SECTION
 static int32_t get_selected_label_width(const lv_obj_t * obj)
 {
     lv_obj_t * label = get_label(obj);
@@ -828,17 +847,20 @@ static int32_t get_selected_label_width(const lv_obj_t * obj)
     return size.x;
 }
 
+__attribute__(( fptrgroup("lv_anim_completed_cb") ))
 static void scroll_anim_completed_cb(lv_anim_t * a)
 {
     lv_obj_t * obj = lv_obj_get_parent(a->var); /*The label is animated*/
     inf_normalize(obj);
 }
 
+__attribute__(( fptrgroup("lv_anim_exec_cb") ))
 static void set_y_anim(void * obj, int32_t v)
 {
     lv_obj_set_y(obj, v);
 }
 
+LV_FUNC_SECTION
 static void transform_vect_recursive(lv_obj_t * roller, lv_point_t * vect)
 {
     int16_t angle = 0;
diff --git a/src/widgets/scale/lv_scale.c b/src/widgets/scale/lv_scale.c
index fbab46018..80b6e2e11 100644
--- a/src/widgets/scale/lv_scale.c
+++ b/src/widgets/scale/lv_scale.c
@@ -89,6 +89,7 @@ const lv_obj_class_t lv_scale_class  = {
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 lv_obj_t * lv_scale_create(lv_obj_t * parent)
 {
     LV_LOG_INFO("begin");
@@ -109,6 +110,7 @@ lv_obj_t * lv_scale_create(lv_obj_t * parent)
  * Setter functions
  *====================*/
 
+LV_FUNC_SECTION
 void lv_scale_set_mode(lv_obj_t * obj, lv_scale_mode_t mode)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -119,6 +121,7 @@ void lv_scale_set_mode(lv_obj_t * obj, lv_scale_mode_t mode)
     lv_obj_invalidate(obj);
 }
 
+LV_FUNC_SECTION
 void lv_scale_set_total_tick_count(lv_obj_t * obj, uint32_t total_tick_count)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -129,6 +132,7 @@ void lv_scale_set_total_tick_count(lv_obj_t * obj, uint32_t total_tick_count)
     lv_obj_invalidate(obj);
 }
 
+LV_FUNC_SECTION
 void lv_scale_set_major_tick_every(lv_obj_t * obj, uint32_t major_tick_every)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -139,6 +143,7 @@ void lv_scale_set_major_tick_every(lv_obj_t * obj, uint32_t major_tick_every)
     lv_obj_invalidate(obj);
 }
 
+LV_FUNC_SECTION
 void lv_scale_set_label_show(lv_obj_t * obj, bool show_label)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -149,6 +154,7 @@ void lv_scale_set_label_show(lv_obj_t * obj, bool show_label)
     lv_obj_invalidate(obj);
 }
 
+LV_FUNC_SECTION
 void lv_scale_set_range(lv_obj_t * obj, int32_t min, int32_t max)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -160,6 +166,7 @@ void lv_scale_set_range(lv_obj_t * obj, int32_t min, int32_t max)
     lv_obj_invalidate(obj);
 }
 
+LV_FUNC_SECTION
 void lv_scale_set_angle_range(lv_obj_t * obj, uint32_t angle_range)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -170,6 +177,7 @@ void lv_scale_set_angle_range(lv_obj_t * obj, uint32_t angle_range)
     lv_obj_invalidate(obj);
 }
 
+LV_FUNC_SECTION
 void lv_scale_set_rotation(lv_obj_t * obj, int32_t rotation)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -180,6 +188,7 @@ void lv_scale_set_rotation(lv_obj_t * obj, int32_t rotation)
     lv_obj_invalidate(obj);
 }
 
+LV_FUNC_SECTION
 void lv_scale_set_line_needle_value(lv_obj_t * obj, lv_obj_t * needle_line, int32_t needle_length,
                                     int32_t value)
 {
@@ -262,6 +271,7 @@ void lv_scale_set_line_needle_value(lv_obj_t * obj, lv_obj_t * needle_line, int3
     lv_line_set_points_mutable(needle_line, needle_line_points, 2);
 }
 
+LV_FUNC_SECTION
 void lv_scale_set_image_needle_value(lv_obj_t * obj, lv_obj_t * needle_img, int32_t value)
 {
     int32_t angle;
@@ -285,6 +295,7 @@ void lv_scale_set_image_needle_value(lv_obj_t * obj, lv_obj_t * needle_img, int3
     lv_image_set_rotation(needle_img, (scale->rotation + angle) * 10);
 }
 
+LV_FUNC_SECTION
 void lv_scale_set_text_src(lv_obj_t * obj, const char * txt_src[])
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -302,6 +313,7 @@ void lv_scale_set_text_src(lv_obj_t * obj, const char * txt_src[])
     lv_obj_invalidate(obj);
 }
 
+LV_FUNC_SECTION
 void lv_scale_set_post_draw(lv_obj_t * obj, bool en)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -312,6 +324,7 @@ void lv_scale_set_post_draw(lv_obj_t * obj, bool en)
     lv_obj_invalidate(obj);
 }
 
+LV_FUNC_SECTION
 void lv_scale_set_draw_ticks_on_top(lv_obj_t * obj, bool en)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -322,6 +335,7 @@ void lv_scale_set_draw_ticks_on_top(lv_obj_t * obj, bool en)
     lv_obj_invalidate(obj);
 }
 
+LV_FUNC_SECTION
 lv_scale_section_t * lv_scale_add_section(lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -347,6 +361,7 @@ lv_scale_section_t * lv_scale_add_section(lv_obj_t * obj)
     return section;
 }
 
+LV_FUNC_SECTION
 void lv_scale_section_set_range(lv_scale_section_t * section, int32_t minor_range, int32_t major_range)
 {
     if(NULL == section) return;
@@ -355,6 +370,7 @@ void lv_scale_section_set_range(lv_scale_section_t * section, int32_t minor_rang
     section->major_range = major_range;
 }
 
+LV_FUNC_SECTION
 void lv_scale_section_set_style(lv_scale_section_t * section, lv_part_t part, lv_style_t * section_part_style)
 {
     if(NULL == section) return;
@@ -379,42 +395,49 @@ void lv_scale_section_set_style(lv_scale_section_t * section, lv_part_t part, lv
  * Getter functions
  *====================*/
 
+LV_FUNC_SECTION
 lv_scale_mode_t lv_scale_get_mode(lv_obj_t * obj)
 {
     lv_scale_t * scale = (lv_scale_t *)obj;
     return scale->mode;
 }
 
+LV_FUNC_SECTION
 int32_t lv_scale_get_total_tick_count(lv_obj_t * obj)
 {
     lv_scale_t * scale = (lv_scale_t *)obj;
     return scale->total_tick_count;
 }
 
+LV_FUNC_SECTION
 int32_t lv_scale_get_major_tick_every(lv_obj_t * obj)
 {
     lv_scale_t * scale = (lv_scale_t *)obj;
     return scale->major_tick_every;
 }
 
+LV_FUNC_SECTION
 bool lv_scale_get_label_show(lv_obj_t * obj)
 {
     lv_scale_t * scale = (lv_scale_t *)obj;
     return scale->label_enabled;
 }
 
+LV_FUNC_SECTION
 uint32_t lv_scale_get_angle_range(lv_obj_t * obj)
 {
     lv_scale_t * scale = (lv_scale_t *)obj;
     return scale->angle_range;
 }
 
+LV_FUNC_SECTION
 int32_t lv_scale_get_range_min_value(lv_obj_t * obj)
 {
     lv_scale_t * scale = (lv_scale_t *)obj;
     return scale->range_min;
 }
 
+LV_FUNC_SECTION
 int32_t lv_scale_get_range_max_value(lv_obj_t * obj)
 {
     lv_scale_t * scale = (lv_scale_t *)obj;
@@ -429,6 +452,7 @@ int32_t lv_scale_get_range_max_value(lv_obj_t * obj)
  *   STATIC FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 static void lv_scale_constructor(const lv_obj_class_t * class_p, lv_obj_t * obj)
 {
     LV_UNUSED(class_p);
@@ -458,6 +482,7 @@ static void lv_scale_constructor(const lv_obj_class_t * class_p, lv_obj_t * obj)
     LV_TRACE_OBJ_CREATE("finished");
 }
 
+LV_FUNC_SECTION
 static void lv_scale_destructor(const lv_obj_class_t * class_p, lv_obj_t * obj)
 {
     LV_UNUSED(class_p);
@@ -475,6 +500,7 @@ static void lv_scale_destructor(const lv_obj_class_t * class_p, lv_obj_t * obj)
     LV_TRACE_OBJ_CREATE("finished");
 }
 
+LV_FUNC_SECTION
 static void lv_scale_event(const lv_obj_class_t * class_p, lv_event_t * event)
 {
     LV_UNUSED(class_p);
@@ -527,6 +553,7 @@ static void lv_scale_event(const lv_obj_class_t * class_p, lv_event_t * event)
     }
 }
 
+LV_FUNC_SECTION
 static void scale_draw_indicator(lv_obj_t * obj, lv_event_t * event)
 {
     lv_scale_t * scale = (lv_scale_t *)obj;
@@ -615,6 +642,7 @@ static void scale_draw_indicator(lv_obj_t * obj, lv_event_t * event)
     }
 }
 
+LV_FUNC_SECTION
 static void scale_draw_label(lv_obj_t * obj, lv_event_t * event, lv_draw_label_dsc_t * label_dsc,
                              const uint32_t major_tick_idx, const int32_t tick_value, lv_point_t * tick_point_b,
                              const uint32_t tick_idx)
@@ -680,6 +708,7 @@ static void scale_draw_label(lv_obj_t * obj, lv_event_t * event, lv_draw_label_d
     lv_draw_label(layer, label_dsc, &label_coords);
 }
 
+LV_FUNC_SECTION
 static void scale_calculate_main_compensation(lv_obj_t * obj)
 {
     lv_scale_t * scale = (lv_scale_t *)obj;
@@ -739,6 +768,7 @@ static void scale_calculate_main_compensation(lv_obj_t * obj)
     }
 }
 
+LV_FUNC_SECTION
 static void scale_draw_main(lv_obj_t * obj, lv_event_t * event)
 {
     lv_scale_t * scale = (lv_scale_t *)obj;
@@ -912,6 +942,7 @@ static void scale_draw_main(lv_obj_t * obj, lv_event_t * event)
  * @param center    pointer to center
  * @param arc_r     pointer to arc radius
  */
+LV_FUNC_SECTION
 static void scale_get_center(const lv_obj_t * obj, lv_point_t * center, int32_t * arc_r)
 {
     int32_t left_bg = lv_obj_get_style_pad_left(obj, LV_PART_MAIN);
@@ -938,6 +969,7 @@ static void scale_get_center(const lv_obj_t * obj, lv_point_t * center, int32_t
  * @param tick_point_a  pointer to point 'a' of the tick
  * @param tick_point_b  pointer to point 'b' of the tick
  */
+LV_FUNC_SECTION
 static void scale_get_tick_points(lv_obj_t * obj, const uint32_t tick_idx, bool is_major_tick,
                                   lv_point_t * tick_point_a, lv_point_t * tick_point_b)
 {
@@ -1102,6 +1134,7 @@ static void scale_get_tick_points(lv_obj_t * obj, const uint32_t tick_idx, bool
  * @param tick_point    pointer to reference tick
  * @param label_coords  pointer to label coordinates output
  */
+LV_FUNC_SECTION
 static void scale_get_label_coords(lv_obj_t * obj, lv_draw_label_dsc_t * label_dsc, lv_point_t * tick_point,
                                    lv_area_t * label_coords)
 {
@@ -1158,6 +1191,7 @@ static void scale_get_label_coords(lv_obj_t * obj, lv_draw_label_dsc_t * label_d
  * @param items_section_style  pointer to indicator section style
  * @param part      line part, example: LV_PART_INDICATOR, LV_PART_ITEMS, LV_PART_MAIN
  */
+LV_FUNC_SECTION
 static void scale_set_line_properties(lv_obj_t * obj, lv_draw_line_dsc_t * line_dsc, lv_style_t * section_style,
                                       lv_part_t part)
 {
@@ -1208,6 +1242,7 @@ static void scale_set_line_properties(lv_obj_t * obj, lv_draw_line_dsc_t * line_
  * @param line_dsc  pointer to arc descriptor
  * @param items_section_style  pointer to indicator section style
  */
+LV_FUNC_SECTION
 static void scale_set_arc_properties(lv_obj_t * obj, lv_draw_arc_dsc_t * arc_dsc, lv_style_t * section_style)
 {
     if(section_style) {
@@ -1257,6 +1292,7 @@ static void scale_set_arc_properties(lv_obj_t * obj, lv_draw_arc_dsc_t * arc_dsc
  * @param label_dsc  pointer to label descriptor
  * @param items_section_style  pointer to indicator section style
  */
+LV_FUNC_SECTION
 static void scale_set_indicator_label_properties(lv_obj_t * obj, lv_draw_label_dsc_t * label_dsc,
                                                  lv_style_t * indicator_section_style)
 {
@@ -1309,6 +1345,7 @@ static void scale_set_indicator_label_properties(lv_obj_t * obj, lv_draw_label_d
     }
 }
 
+LV_FUNC_SECTION
 static void scale_find_section_tick_idx(lv_obj_t * obj)
 {
     lv_scale_t * scale = (lv_scale_t *)obj;
@@ -1353,6 +1390,7 @@ static void scale_find_section_tick_idx(lv_obj_t * obj)
  * @param major_tick_width width of the major tick
  * @param minor_tick_width width of the minor tick
  */
+LV_FUNC_SECTION
 static void scale_store_main_line_tick_width_compensation(lv_obj_t * obj, const uint32_t tick_idx,
                                                           const bool is_major_tick, const int32_t major_tick_width, const int32_t minor_tick_width)
 {
@@ -1400,6 +1438,7 @@ static void scale_store_main_line_tick_width_compensation(lv_obj_t * obj, const
  * @param label_dsc pointer to the label descriptor
  * @param major_tick_idx  index of the current major tick
  */
+LV_FUNC_SECTION
 static void scale_build_custom_label_text(lv_obj_t * obj, lv_draw_label_dsc_t * label_dsc,
                                           const uint16_t major_tick_idx)
 {
@@ -1432,6 +1471,7 @@ static void scale_build_custom_label_text(lv_obj_t * obj, lv_draw_label_dsc_t *
  * @param tick_idx Current tick index
  * @param tick_point_a Pointer to tick point a
  */
+LV_FUNC_SECTION
 static void scale_store_section_line_tick_width_compensation(lv_obj_t * obj, const bool is_major_tick,
                                                              lv_draw_line_dsc_t * major_tick_dsc, lv_draw_line_dsc_t * minor_tick_dsc,
                                                              const int32_t tick_value, const uint8_t tick_idx, lv_point_t * tick_point_a)
@@ -1495,6 +1535,7 @@ static void scale_store_section_line_tick_width_compensation(lv_obj_t * obj, con
     }
 }
 
+__attribute__(( fptrgroup("lv_event_cb") ))
 static void scale_free_line_needle_points_cb(lv_event_t * e)
 {
     lv_point_precise_t * needle_line_points = lv_event_get_user_data(e);
diff --git a/src/widgets/slider/lv_slider.c b/src/widgets/slider/lv_slider.c
index e58597c88..0346a6b0d 100644
--- a/src/widgets/slider/lv_slider.c
+++ b/src/widgets/slider/lv_slider.c
@@ -67,6 +67,7 @@ const lv_obj_class_t lv_slider_class = {
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 lv_obj_t * lv_slider_create(lv_obj_t * parent)
 {
     LV_LOG_INFO("begin");
@@ -75,6 +76,7 @@ lv_obj_t * lv_slider_create(lv_obj_t * parent)
     return obj;
 }
 
+LV_FUNC_SECTION
 bool lv_slider_is_dragged(const lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -83,46 +85,55 @@ bool lv_slider_is_dragged(const lv_obj_t * obj)
     return slider->dragging;
 }
 
+LV_FUNC_SECTION
 void lv_slider_set_value(lv_obj_t * obj, int32_t value, lv_anim_enable_t anim)
 {
     lv_bar_set_value(obj, value, anim);
 }
 
+LV_FUNC_SECTION
 void lv_slider_set_left_value(lv_obj_t * obj, int32_t value, lv_anim_enable_t anim)
 {
     lv_bar_set_start_value(obj, value, anim);
 }
 
+LV_FUNC_SECTION
 void lv_slider_set_range(lv_obj_t * obj, int32_t min, int32_t max)
 {
     lv_bar_set_range(obj, min, max);
 }
 
+LV_FUNC_SECTION
 void lv_slider_set_mode(lv_obj_t * obj, lv_slider_mode_t mode)
 {
     lv_bar_set_mode(obj, (lv_bar_mode_t)mode);
 }
 
+LV_FUNC_SECTION
 int32_t lv_slider_get_value(const lv_obj_t * obj)
 {
     return lv_bar_get_value(obj);
 }
 
+LV_FUNC_SECTION
 int32_t lv_slider_get_left_value(const lv_obj_t * obj)
 {
     return lv_bar_get_start_value(obj);
 }
 
+LV_FUNC_SECTION
 int32_t lv_slider_get_min_value(const lv_obj_t * obj)
 {
     return lv_bar_get_min_value(obj);
 }
 
+LV_FUNC_SECTION
 int32_t lv_slider_get_max_value(const lv_obj_t * obj)
 {
     return lv_bar_get_max_value(obj);
 }
 
+LV_FUNC_SECTION
 lv_slider_mode_t lv_slider_get_mode(lv_obj_t * slider)
 {
     lv_bar_mode_t mode = lv_bar_get_mode(slider);
@@ -131,6 +142,7 @@ lv_slider_mode_t lv_slider_get_mode(lv_obj_t * slider)
     else return LV_SLIDER_MODE_NORMAL;
 }
 
+LV_FUNC_SECTION
 bool lv_slider_is_symmetrical(lv_obj_t * obj)
 {
     return lv_bar_is_symmetrical(obj);
@@ -140,6 +152,7 @@ bool lv_slider_is_symmetrical(lv_obj_t * obj)
  *   STATIC FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 static void lv_slider_constructor(const lv_obj_class_t * class_p, lv_obj_t * obj)
 {
     LV_UNUSED(class_p);
@@ -156,6 +169,7 @@ static void lv_slider_constructor(const lv_obj_class_t * class_p, lv_obj_t * obj
     lv_obj_set_ext_click_area(obj, LV_DPX(8));
 }
 
+LV_FUNC_SECTION
 static void lv_slider_event(const lv_obj_class_t * class_p, lv_event_t * e)
 {
     LV_UNUSED(class_p);
@@ -295,6 +309,7 @@ static void lv_slider_event(const lv_obj_class_t * class_p, lv_event_t * e)
     }
 }
 
+LV_FUNC_SECTION
 static void draw_knob(lv_event_t * e)
 {
     lv_obj_t * obj = lv_event_get_current_target(e);
@@ -356,6 +371,7 @@ static void draw_knob(lv_event_t * e)
     }
 }
 
+LV_FUNC_SECTION
 static void position_knob(lv_obj_t * obj, lv_area_t * knob_area, const int32_t knob_size, const bool hor)
 {
     if(hor) {
@@ -386,11 +402,13 @@ static void position_knob(lv_obj_t * obj, lv_area_t * knob_area, const int32_t k
     knob_area->y2 += knob_bottom + transf_h;
 }
 
+LV_FUNC_SECTION
 static bool is_slider_horizontal(lv_obj_t * obj)
 {
     return lv_obj_get_width(obj) >= lv_obj_get_height(obj);
 }
 
+LV_FUNC_SECTION
 static void drag_start(lv_obj_t * obj)
 {
     lv_slider_t * slider = (lv_slider_t *)obj;
@@ -455,6 +473,7 @@ static void drag_start(lv_obj_t * obj)
     }
 }
 
+LV_FUNC_SECTION
 static void update_knob_pos(lv_obj_t * obj, bool check_drag)
 {
     lv_slider_t * slider = (lv_slider_t *)obj;
diff --git a/src/widgets/span/lv_span.c b/src/widgets/span/lv_span.c
index c4afb4373..d4969f951 100644
--- a/src/widgets/span/lv_span.c
+++ b/src/widgets/span/lv_span.c
@@ -91,6 +91,7 @@ const lv_obj_class_t lv_spangroup_class  = {
 /**********************
  *   GLOBAL FUNCTIONS
  **********************/
+LV_FUNC_SECTION
 void lv_span_stack_init(void)
 {
     struct _snippet_stack * stack = snippet_stack = lv_malloc(sizeof(struct _snippet_stack));
@@ -100,11 +101,13 @@ void lv_span_stack_init(void)
     }
 }
 
+LV_FUNC_SECTION
 void lv_span_stack_deinit(void)
 {
     lv_free(snippet_stack);
 }
 
+LV_FUNC_SECTION
 lv_obj_t * lv_spangroup_create(lv_obj_t * par)
 {
     lv_obj_t * obj = lv_obj_class_create_obj(&lv_spangroup_class, par);
@@ -112,6 +115,7 @@ lv_obj_t * lv_spangroup_create(lv_obj_t * par)
     return obj;
 }
 
+LV_FUNC_SECTION
 lv_span_t * lv_spangroup_new_span(lv_obj_t * obj)
 {
     if(obj == NULL) {
@@ -133,6 +137,7 @@ lv_span_t * lv_spangroup_new_span(lv_obj_t * obj)
     return span;
 }
 
+LV_FUNC_SECTION
 void lv_spangroup_delete_span(lv_obj_t * obj, lv_span_t * span)
 {
     if(obj == NULL || span == NULL) {
@@ -163,6 +168,7 @@ void lv_spangroup_delete_span(lv_obj_t * obj, lv_span_t * span)
  * Setter functions
  *====================*/
 
+LV_FUNC_SECTION
 void lv_span_set_text(lv_span_t * span, const char * text)
 {
     if(span == NULL || text == NULL) {
@@ -188,6 +194,7 @@ void lv_span_set_text(lv_span_t * span, const char * text)
     refresh_self_size(span->spangroup);
 }
 
+LV_FUNC_SECTION
 void lv_span_set_text_static(lv_span_t * span, const char * text)
 {
     if(span == NULL || text == NULL) {
@@ -204,11 +211,13 @@ void lv_span_set_text_static(lv_span_t * span, const char * text)
     refresh_self_size(span->spangroup);
 }
 
+LV_FUNC_SECTION
 void lv_spangroup_set_align(lv_obj_t * obj, lv_text_align_t align)
 {
     lv_obj_set_style_text_align(obj, align, LV_PART_MAIN);
 }
 
+LV_FUNC_SECTION
 void lv_spangroup_set_overflow(lv_obj_t * obj, lv_span_overflow_t overflow)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -219,6 +228,7 @@ void lv_spangroup_set_overflow(lv_obj_t * obj, lv_span_overflow_t overflow)
     lv_obj_invalidate(obj);
 }
 
+LV_FUNC_SECTION
 void lv_spangroup_set_indent(lv_obj_t * obj, int32_t indent)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -230,6 +240,7 @@ void lv_spangroup_set_indent(lv_obj_t * obj, int32_t indent)
     refresh_self_size(obj);
 }
 
+LV_FUNC_SECTION
 void lv_spangroup_set_mode(lv_obj_t * obj, lv_span_mode_t mode)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -241,6 +252,7 @@ void lv_spangroup_set_mode(lv_obj_t * obj, lv_span_mode_t mode)
     lv_spangroup_refr_mode(obj);
 }
 
+LV_FUNC_SECTION
 void lv_spangroup_set_max_lines(lv_obj_t * obj, int32_t lines)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -253,11 +265,13 @@ void lv_spangroup_set_max_lines(lv_obj_t * obj, int32_t lines)
  * Getter functions
  *====================*/
 
+LV_FUNC_SECTION
 lv_style_t * lv_span_get_style(lv_span_t * span)
 {
     return &span->style;
 }
 
+LV_FUNC_SECTION
 lv_span_t * lv_spangroup_get_child(const lv_obj_t * obj, int32_t id)
 {
     if(obj == NULL) {
@@ -295,6 +309,7 @@ lv_span_t * lv_spangroup_get_child(const lv_obj_t * obj, int32_t id)
     return NULL;
 }
 
+LV_FUNC_SECTION
 uint32_t lv_spangroup_get_span_count(const lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -308,11 +323,13 @@ uint32_t lv_spangroup_get_span_count(const lv_obj_t * obj)
     return lv_ll_get_len(&(spans->child_ll));
 }
 
+LV_FUNC_SECTION
 lv_text_align_t lv_spangroup_get_align(lv_obj_t * obj)
 {
     return lv_obj_get_style_text_align(obj, LV_PART_MAIN);
 }
 
+LV_FUNC_SECTION
 lv_span_overflow_t lv_spangroup_get_overflow(lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -320,6 +337,7 @@ lv_span_overflow_t lv_spangroup_get_overflow(lv_obj_t * obj)
     return spans->overflow;
 }
 
+LV_FUNC_SECTION
 int32_t lv_spangroup_get_indent(lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -327,6 +345,7 @@ int32_t lv_spangroup_get_indent(lv_obj_t * obj)
     return spans->indent;
 }
 
+LV_FUNC_SECTION
 lv_span_mode_t lv_spangroup_get_mode(lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -334,6 +353,7 @@ lv_span_mode_t lv_spangroup_get_mode(lv_obj_t * obj)
     return spans->mode;
 }
 
+LV_FUNC_SECTION
 int32_t lv_spangroup_get_max_lines(lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -341,6 +361,7 @@ int32_t lv_spangroup_get_max_lines(lv_obj_t * obj)
     return spans->lines;
 }
 
+LV_FUNC_SECTION
 void lv_spangroup_refr_mode(lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -375,6 +396,7 @@ void lv_spangroup_refr_mode(lv_obj_t * obj)
     refresh_self_size(obj);
 }
 
+LV_FUNC_SECTION
 int32_t lv_spangroup_get_max_line_height(lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -393,6 +415,7 @@ int32_t lv_spangroup_get_max_line_height(lv_obj_t * obj)
     return max_line_h;
 }
 
+LV_FUNC_SECTION
 uint32_t lv_spangroup_get_expand_width(lv_obj_t * obj, uint32_t max_width)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -425,6 +448,7 @@ uint32_t lv_spangroup_get_expand_width(lv_obj_t * obj, uint32_t max_width)
     return width - letter_space;
 }
 
+LV_FUNC_SECTION
 int32_t lv_spangroup_get_expand_height(lv_obj_t * obj, int32_t width)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -538,6 +562,7 @@ int32_t lv_spangroup_get_expand_height(lv_obj_t * obj, int32_t width)
  *   STATIC FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 static void lv_spangroup_constructor(const lv_obj_class_t * class_p, lv_obj_t * obj)
 {
     LV_UNUSED(class_p);
@@ -552,6 +577,7 @@ static void lv_spangroup_constructor(const lv_obj_class_t * class_p, lv_obj_t *
     spans->refresh = 1;
 }
 
+LV_FUNC_SECTION
 static void lv_spangroup_destructor(const lv_obj_class_t * class_p, lv_obj_t * obj)
 {
     LV_UNUSED(class_p);
@@ -569,6 +595,7 @@ static void lv_spangroup_destructor(const lv_obj_class_t * class_p, lv_obj_t * o
     }
 }
 
+LV_FUNC_SECTION
 static void lv_spangroup_event(const lv_obj_class_t * class_p, lv_event_t * e)
 {
     LV_UNUSED(class_p);
@@ -626,6 +653,7 @@ static void lv_spangroup_event(const lv_obj_class_t * class_p, lv_event_t * e)
     }
 }
 
+LV_FUNC_SECTION
 static void draw_main(lv_event_t * e)
 {
     lv_obj_t * obj = lv_event_get_current_target(e);
@@ -637,6 +665,7 @@ static void draw_main(lv_event_t * e)
 /**
  * @return true for txt fill the max_width.
  */
+LV_FUNC_SECTION
 static bool lv_text_get_snippet(const char * txt, const lv_font_t * font,
                                 int32_t letter_space, int32_t max_width, lv_text_flag_t flag,
                                 int32_t * use_width, uint32_t * end_ofs)
@@ -665,6 +694,7 @@ static bool lv_text_get_snippet(const char * txt, const lv_font_t * font,
     }
 }
 
+LV_FUNC_SECTION
 static void lv_snippet_push(lv_snippet_t * item)
 {
     struct _snippet_stack * stack_p = snippet_stack;
@@ -677,21 +707,25 @@ static void lv_snippet_push(lv_snippet_t * item)
     }
 }
 
+LV_FUNC_SECTION
 static uint32_t lv_get_snippet_count(void)
 {
     return snippet_stack->index;
 }
 
+LV_FUNC_SECTION
 static lv_snippet_t * lv_get_snippet(uint32_t index)
 {
     return &snippet_stack->stack[index];
 }
 
+LV_FUNC_SECTION
 static void lv_snippet_clear(void)
 {
     snippet_stack->index = 0;
 }
 
+LV_FUNC_SECTION
 static const lv_font_t * lv_span_get_style_text_font(lv_obj_t * par, lv_span_t * span)
 {
     const lv_font_t * font;
@@ -706,6 +740,7 @@ static const lv_font_t * lv_span_get_style_text_font(lv_obj_t * par, lv_span_t *
     return font;
 }
 
+LV_FUNC_SECTION
 static int32_t lv_span_get_style_text_letter_space(lv_obj_t * par, lv_span_t * span)
 {
     int32_t letter_space;
@@ -720,6 +755,7 @@ static int32_t lv_span_get_style_text_letter_space(lv_obj_t * par, lv_span_t * s
     return letter_space;
 }
 
+LV_FUNC_SECTION
 static lv_color_t lv_span_get_style_text_color(lv_obj_t * par, lv_span_t * span)
 {
     lv_style_value_t value;
@@ -730,6 +766,7 @@ static lv_color_t lv_span_get_style_text_color(lv_obj_t * par, lv_span_t * span)
     return value.color;
 }
 
+LV_FUNC_SECTION
 static lv_opa_t lv_span_get_style_text_opa(lv_obj_t * par, lv_span_t * span)
 {
     lv_opa_t opa;
@@ -744,6 +781,7 @@ static lv_opa_t lv_span_get_style_text_opa(lv_obj_t * par, lv_span_t * span)
     return opa;
 }
 
+LV_FUNC_SECTION
 static lv_blend_mode_t lv_span_get_style_text_blend_mode(lv_obj_t * par, lv_span_t * span)
 {
     lv_blend_mode_t mode;
@@ -758,6 +796,7 @@ static lv_blend_mode_t lv_span_get_style_text_blend_mode(lv_obj_t * par, lv_span
     return mode;
 }
 
+LV_FUNC_SECTION
 static int32_t lv_span_get_style_text_decor(lv_obj_t * par, lv_span_t * span)
 {
     int32_t decor;
@@ -772,6 +811,7 @@ static int32_t lv_span_get_style_text_decor(lv_obj_t * par, lv_span_t * span)
     return decor;
 }
 
+LV_FUNC_SECTION
 static inline void span_text_check(const char ** text)
 {
     if(*text == NULL) {
@@ -780,6 +820,7 @@ static inline void span_text_check(const char ** text)
     }
 }
 
+LV_FUNC_SECTION
 static int32_t convert_indent_pct(lv_obj_t * obj, int32_t width)
 {
     lv_spangroup_t * spans = (lv_spangroup_t *)obj;
@@ -803,6 +844,7 @@ static int32_t convert_indent_pct(lv_obj_t * obj, int32_t width)
  * @param coords coordinates of the label
  * @param mask the label will be drawn only in this area
  */
+LV_FUNC_SECTION
 static void lv_draw_span(lv_obj_t * obj, lv_layer_t * layer)
 {
 
@@ -1078,6 +1120,7 @@ Next_line_init:
     layer->_clip_area = clip_area_ori;
 }
 
+LV_FUNC_SECTION
 static void refresh_self_size(lv_obj_t * obj)
 {
     lv_spangroup_t * spans = (lv_spangroup_t *)obj;
diff --git a/src/widgets/spinbox/lv_spinbox.c b/src/widgets/spinbox/lv_spinbox.c
index 69e8d13da..f2b3fc799 100644
--- a/src/widgets/spinbox/lv_spinbox.c
+++ b/src/widgets/spinbox/lv_spinbox.c
@@ -53,6 +53,7 @@ const lv_obj_class_t lv_spinbox_class = {
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 lv_obj_t * lv_spinbox_create(lv_obj_t * parent)
 {
     LV_LOG_INFO("begin");
@@ -65,6 +66,7 @@ lv_obj_t * lv_spinbox_create(lv_obj_t * parent)
  * Setter functions
  *====================*/
 
+LV_FUNC_SECTION
 void lv_spinbox_set_value(lv_obj_t * obj, int32_t v)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -78,6 +80,7 @@ void lv_spinbox_set_value(lv_obj_t * obj, int32_t v)
     lv_spinbox_updatevalue(obj);
 }
 
+LV_FUNC_SECTION
 void lv_spinbox_set_rollover(lv_obj_t * obj, bool rollover)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -86,6 +89,7 @@ void lv_spinbox_set_rollover(lv_obj_t * obj, bool rollover)
     spinbox->rollover = rollover;
 }
 
+LV_FUNC_SECTION
 void lv_spinbox_set_digit_format(lv_obj_t * obj, uint32_t digit_count, uint32_t sep_pos)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -107,6 +111,7 @@ void lv_spinbox_set_digit_format(lv_obj_t * obj, uint32_t digit_count, uint32_t
     lv_spinbox_updatevalue(obj);
 }
 
+LV_FUNC_SECTION
 void lv_spinbox_set_step(lv_obj_t * obj, uint32_t step)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -116,6 +121,7 @@ void lv_spinbox_set_step(lv_obj_t * obj, uint32_t step)
     lv_spinbox_updatevalue(obj);
 }
 
+LV_FUNC_SECTION
 void lv_spinbox_set_range(lv_obj_t * obj, int32_t range_min, int32_t range_max)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -130,6 +136,7 @@ void lv_spinbox_set_range(lv_obj_t * obj, int32_t range_min, int32_t range_max)
     lv_spinbox_updatevalue(obj);
 }
 
+LV_FUNC_SECTION
 void lv_spinbox_set_cursor_pos(lv_obj_t * obj, uint32_t pos)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -144,6 +151,7 @@ void lv_spinbox_set_cursor_pos(lv_obj_t * obj, uint32_t pos)
     lv_spinbox_updatevalue(obj);
 }
 
+LV_FUNC_SECTION
 void lv_spinbox_set_digit_step_direction(lv_obj_t * obj, lv_dir_t direction)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -156,6 +164,7 @@ void lv_spinbox_set_digit_step_direction(lv_obj_t * obj, lv_dir_t direction)
  * Getter functions
  *====================*/
 
+LV_FUNC_SECTION
 int32_t lv_spinbox_get_value(lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -164,6 +173,7 @@ int32_t lv_spinbox_get_value(lv_obj_t * obj)
     return spinbox->value;
 }
 
+LV_FUNC_SECTION
 int32_t lv_spinbox_get_step(lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -176,6 +186,7 @@ int32_t lv_spinbox_get_step(lv_obj_t * obj)
  * Other functions
  *====================*/
 
+LV_FUNC_SECTION
 void lv_spinbox_step_next(lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -187,6 +198,7 @@ void lv_spinbox_step_next(lv_obj_t * obj)
     lv_spinbox_updatevalue(obj);
 }
 
+LV_FUNC_SECTION
 void lv_spinbox_step_prev(lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -199,6 +211,7 @@ void lv_spinbox_step_prev(lv_obj_t * obj)
     lv_spinbox_updatevalue(obj);
 }
 
+LV_FUNC_SECTION
 bool lv_spinbox_get_rollover(lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -207,6 +220,7 @@ bool lv_spinbox_get_rollover(lv_obj_t * obj)
     return spinbox->rollover;
 }
 
+LV_FUNC_SECTION
 void lv_spinbox_increment(lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -236,6 +250,7 @@ void lv_spinbox_increment(lv_obj_t * obj)
     }
 }
 
+LV_FUNC_SECTION
 void lv_spinbox_decrement(lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -269,6 +284,7 @@ void lv_spinbox_decrement(lv_obj_t * obj)
  *   STATIC FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 static void lv_spinbox_constructor(const lv_obj_class_t * class_p, lv_obj_t * obj)
 {
     LV_UNUSED(class_p);
@@ -294,6 +310,7 @@ static void lv_spinbox_constructor(const lv_obj_class_t * class_p, lv_obj_t * ob
     LV_LOG_TRACE("Spinbox constructor finished");
 }
 
+LV_FUNC_SECTION
 static void lv_spinbox_event(const lv_obj_class_t * class_p, lv_event_t * e)
 {
     LV_UNUSED(class_p);
@@ -397,6 +414,7 @@ static void lv_spinbox_event(const lv_obj_class_t * class_p, lv_event_t * e)
     }
 }
 
+LV_FUNC_SECTION
 static void lv_spinbox_updatevalue(lv_obj_t * obj)
 {
     lv_spinbox_t * spinbox = (lv_spinbox_t *)obj;
diff --git a/src/widgets/spinner/lv_spinner.c b/src/widgets/spinner/lv_spinner.c
index 18cb0050f..9dc5e6a10 100644
--- a/src/widgets/spinner/lv_spinner.c
+++ b/src/widgets/spinner/lv_spinner.c
@@ -45,6 +45,7 @@ const lv_obj_class_t lv_spinner_class = {
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 lv_obj_t * lv_spinner_create(lv_obj_t * parent)
 {
 
@@ -53,6 +54,7 @@ lv_obj_t * lv_spinner_create(lv_obj_t * parent)
     return obj;
 }
 
+LV_FUNC_SECTION
 void lv_spinner_set_anim_params(lv_obj_t * obj, uint32_t t, uint32_t angle)
 {
     /*Delete the current animation*/
@@ -82,6 +84,7 @@ void lv_spinner_set_anim_params(lv_obj_t * obj, uint32_t t, uint32_t angle)
  *   STATIC FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 static void lv_spinner_constructor(const lv_obj_class_t * class_p, lv_obj_t * obj)
 {
     LV_TRACE_OBJ_CREATE("begin");
@@ -93,11 +96,13 @@ static void lv_spinner_constructor(const lv_obj_class_t * class_p, lv_obj_t * ob
     lv_spinner_set_anim_params(obj, DEF_TIME, DEF_ARC_ANGLE);
 }
 
+__attribute__(( fptrgroup("lv_anim_exec_cb") ))
 static void arc_anim_start_angle(void * obj, int32_t v)
 {
     lv_arc_set_start_angle(obj, (uint32_t) v);
 }
 
+__attribute__(( fptrgroup("lv_anim_exec_cb") ))
 static void arc_anim_end_angle(void * obj, int32_t v)
 {
     lv_arc_set_end_angle(obj, (uint32_t) v);
diff --git a/src/widgets/switch/lv_switch.c b/src/widgets/switch/lv_switch.c
index 89b4b6363..a65e1f1be 100644
--- a/src/widgets/switch/lv_switch.c
+++ b/src/widgets/switch/lv_switch.c
@@ -72,6 +72,7 @@ const lv_obj_class_t lv_switch_class = {
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 lv_obj_t * lv_switch_create(lv_obj_t * parent)
 {
     LV_LOG_INFO("begin");
@@ -84,6 +85,7 @@ lv_obj_t * lv_switch_create(lv_obj_t * parent)
  *   STATIC FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 static void lv_switch_constructor(const lv_obj_class_t * class_p, lv_obj_t * obj)
 {
     LV_UNUSED(class_p);
@@ -100,6 +102,7 @@ static void lv_switch_constructor(const lv_obj_class_t * class_p, lv_obj_t * obj
     LV_TRACE_OBJ_CREATE("finished");
 }
 
+LV_FUNC_SECTION
 static void lv_switch_destructor(const lv_obj_class_t * class_p, lv_obj_t * obj)
 {
     LV_UNUSED(class_p);
@@ -108,6 +111,7 @@ static void lv_switch_destructor(const lv_obj_class_t * class_p, lv_obj_t * obj)
     lv_anim_delete(sw, NULL);
 }
 
+LV_FUNC_SECTION
 static void lv_switch_event(const lv_obj_class_t * class_p, lv_event_t * e)
 {
     LV_UNUSED(class_p);
@@ -145,6 +149,7 @@ static void lv_switch_event(const lv_obj_class_t * class_p, lv_event_t * e)
     }
 }
 
+LV_FUNC_SECTION
 static void draw_main(lv_event_t * e)
 {
     lv_obj_t * obj = lv_event_get_current_target(e);
@@ -204,6 +209,7 @@ static void draw_main(lv_event_t * e)
     lv_draw_rect(layer, &knob_rect_dsc, &knob_area);
 }
 
+__attribute__(( fptrgroup("lv_anim_exec_cb") ))
 static void lv_switch_anim_exec_cb(void * var, int32_t value)
 {
     lv_switch_t * sw = var;
@@ -214,6 +220,7 @@ static void lv_switch_anim_exec_cb(void * var, int32_t value)
 /**
  * Resets the switch's animation state to "no animation in progress".
  */
+__attribute__(( fptrgroup("lv_anim_completed_cb") ))
 static void lv_switch_anim_completed(lv_anim_t * a)
 {
     lv_switch_t * sw = a->var;
@@ -225,6 +232,7 @@ static void lv_switch_anim_completed(lv_anim_t * a)
  * Starts an animation for the switch knob. if the anim_time style property is greater than 0
  * @param obj the switch to animate
  */
+LV_FUNC_SECTION
 static void lv_switch_trigger_anim(lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
diff --git a/src/widgets/table/lv_table.c b/src/widgets/table/lv_table.c
index affb99b88..20cc931f9 100644
--- a/src/widgets/table/lv_table.c
+++ b/src/widgets/table/lv_table.c
@@ -48,6 +48,7 @@ static void copy_cell_txt(lv_table_cell_t * dst, const char * txt);
 static void get_cell_area(lv_obj_t * obj, uint32_t row, uint32_t col, lv_area_t * area);
 static void scroll_to_selected_cell(lv_obj_t * obj);
 
+LV_FUNC_SECTION
 static inline bool is_cell_empty(void * cell)
 {
     return cell == NULL;
@@ -76,6 +77,7 @@ const lv_obj_class_t lv_table_class  = {
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 lv_obj_t * lv_table_create(lv_obj_t * parent)
 {
     LV_LOG_INFO("begin");
@@ -88,6 +90,7 @@ lv_obj_t * lv_table_create(lv_obj_t * parent)
  * Setter functions
  *====================*/
 
+LV_FUNC_SECTION
 void lv_table_set_cell_value(lv_obj_t * obj, uint32_t row, uint32_t col, const char * txt)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -123,6 +126,7 @@ void lv_table_set_cell_value(lv_obj_t * obj, uint32_t row, uint32_t col, const c
     refr_cell_size(obj, row, col);
 }
 
+LV_FUNC_SECTION
 void lv_table_set_cell_value_fmt(lv_obj_t * obj, uint32_t row, uint32_t col, const char * fmt, ...)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -200,6 +204,7 @@ void lv_table_set_cell_value_fmt(lv_obj_t * obj, uint32_t row, uint32_t col, con
     refr_cell_size(obj, row, col);
 }
 
+LV_FUNC_SECTION
 void lv_table_set_row_count(lv_obj_t * obj, uint32_t row_cnt)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -243,6 +248,7 @@ void lv_table_set_row_count(lv_obj_t * obj, uint32_t row_cnt)
     refr_size_form_row(obj, 0);
 }
 
+LV_FUNC_SECTION
 void lv_table_set_column_count(lv_obj_t * obj, uint32_t col_cnt)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -302,6 +308,7 @@ void lv_table_set_column_count(lv_obj_t * obj, uint32_t col_cnt)
     refr_size_form_row(obj, 0) ;
 }
 
+LV_FUNC_SECTION
 void lv_table_set_column_width(lv_obj_t * obj, uint32_t col_id, int32_t w)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -315,6 +322,7 @@ void lv_table_set_column_width(lv_obj_t * obj, uint32_t col_id, int32_t w)
     refr_size_form_row(obj, 0);
 }
 
+LV_FUNC_SECTION
 void lv_table_add_cell_ctrl(lv_obj_t * obj, uint32_t row, uint32_t col, lv_table_cell_ctrl_t ctrl)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -340,6 +348,7 @@ void lv_table_add_cell_ctrl(lv_obj_t * obj, uint32_t row, uint32_t col, lv_table
     table->cell_data[cell]->ctrl |= ctrl;
 }
 
+LV_FUNC_SECTION
 void lv_table_clear_cell_ctrl(lv_obj_t * obj, uint32_t row, uint32_t col, lv_table_cell_ctrl_t ctrl)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -365,6 +374,7 @@ void lv_table_clear_cell_ctrl(lv_obj_t * obj, uint32_t row, uint32_t col, lv_tab
     table->cell_data[cell]->ctrl &= (~ctrl);
 }
 
+LV_FUNC_SECTION
 void lv_table_set_cell_user_data(lv_obj_t * obj, uint16_t row, uint16_t col, void * user_data)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -394,6 +404,7 @@ void lv_table_set_cell_user_data(lv_obj_t * obj, uint16_t row, uint16_t col, voi
     table->cell_data[cell]->user_data = user_data;
 }
 
+LV_FUNC_SECTION
 void lv_table_set_selected_cell(lv_obj_t * obj, uint16_t row, uint16_t col)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -418,6 +429,7 @@ void lv_table_set_selected_cell(lv_obj_t * obj, uint16_t row, uint16_t col)
  * Getter functions
  *====================*/
 
+LV_FUNC_SECTION
 const char * lv_table_get_cell_value(lv_obj_t * obj, uint32_t row, uint32_t col)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -434,6 +446,7 @@ const char * lv_table_get_cell_value(lv_obj_t * obj, uint32_t row, uint32_t col)
     return table->cell_data[cell]->txt;
 }
 
+LV_FUNC_SECTION
 uint32_t lv_table_get_row_count(lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -442,6 +455,7 @@ uint32_t lv_table_get_row_count(lv_obj_t * obj)
     return table->row_cnt;
 }
 
+LV_FUNC_SECTION
 uint32_t lv_table_get_column_count(lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -450,6 +464,7 @@ uint32_t lv_table_get_column_count(lv_obj_t * obj)
     return table->col_cnt;
 }
 
+LV_FUNC_SECTION
 int32_t lv_table_get_column_width(lv_obj_t * obj, uint32_t col)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -464,6 +479,7 @@ int32_t lv_table_get_column_width(lv_obj_t * obj, uint32_t col)
     return table->col_w[col];
 }
 
+LV_FUNC_SECTION
 bool lv_table_has_cell_ctrl(lv_obj_t * obj, uint32_t row, uint32_t col, lv_table_cell_ctrl_t ctrl)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -479,6 +495,7 @@ bool lv_table_has_cell_ctrl(lv_obj_t * obj, uint32_t row, uint32_t col, lv_table
     else return (table->cell_data[cell]->ctrl & ctrl) == ctrl;
 }
 
+LV_FUNC_SECTION
 void lv_table_get_selected_cell(lv_obj_t * obj, uint32_t * row, uint32_t * col)
 {
     lv_table_t * table = (lv_table_t *)obj;
@@ -486,6 +503,7 @@ void lv_table_get_selected_cell(lv_obj_t * obj, uint32_t * row, uint32_t * col)
     *col = table->col_act;
 }
 
+LV_FUNC_SECTION
 void * lv_table_get_cell_user_data(lv_obj_t * obj, uint16_t row, uint16_t col)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -506,6 +524,7 @@ void * lv_table_get_cell_user_data(lv_obj_t * obj, uint16_t row, uint16_t col)
  *   STATIC FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 static void lv_table_constructor(const lv_obj_class_t * class_p, lv_obj_t * obj)
 {
     LV_UNUSED(class_p);
@@ -525,6 +544,7 @@ static void lv_table_constructor(const lv_obj_class_t * class_p, lv_obj_t * obj)
     LV_TRACE_OBJ_CREATE("finished");
 }
 
+LV_FUNC_SECTION
 static void lv_table_destructor(const lv_obj_class_t * class_p, lv_obj_t * obj)
 {
     LV_UNUSED(class_p);
@@ -547,6 +567,7 @@ static void lv_table_destructor(const lv_obj_class_t * class_p, lv_obj_t * obj)
     if(table->col_w) lv_free(table->col_w);
 }
 
+LV_FUNC_SECTION
 static void lv_table_event(const lv_obj_class_t * class_p, lv_event_t * e)
 {
     LV_UNUSED(class_p);
@@ -668,6 +689,7 @@ static void lv_table_event(const lv_obj_class_t * class_p, lv_event_t * e)
     }
 }
 
+LV_FUNC_SECTION
 static void draw_main(lv_event_t * e)
 {
     lv_obj_t * obj = lv_event_get_current_target(e);
@@ -858,6 +880,7 @@ static void draw_main(lv_event_t * e)
 }
 
 /* Refreshes size of the table starting from @start_row row */
+LV_FUNC_SECTION
 static void refr_size_form_row(lv_obj_t * obj, uint32_t start_row)
 {
     const int32_t cell_pad_left = lv_obj_get_style_pad_left(obj, LV_PART_ITEMS);
@@ -884,6 +907,7 @@ static void refr_size_form_row(lv_obj_t * obj, uint32_t start_row)
     lv_obj_invalidate(obj);
 }
 
+LV_FUNC_SECTION
 static void refr_cell_size(lv_obj_t * obj, uint32_t row, uint32_t col)
 {
     const int32_t cell_pad_left = lv_obj_get_style_pad_left(obj, LV_PART_ITEMS);
@@ -918,6 +942,7 @@ static void refr_cell_size(lv_obj_t * obj, uint32_t row, uint32_t col)
     }
 }
 
+LV_FUNC_SECTION
 static int32_t get_row_height(lv_obj_t * obj, uint32_t row_id, const lv_font_t * font,
                               int32_t letter_space, int32_t line_space,
                               int32_t cell_left, int32_t cell_right, int32_t cell_top, int32_t cell_bottom)
@@ -983,6 +1008,7 @@ static int32_t get_row_height(lv_obj_t * obj, uint32_t row_id, const lv_font_t *
     return h_max;
 }
 
+LV_FUNC_SECTION
 static lv_result_t get_pressed_cell(lv_obj_t * obj, uint32_t * row, uint32_t * col)
 {
     lv_table_t * table = (lv_table_t *)obj;
@@ -1035,6 +1061,7 @@ static lv_result_t get_pressed_cell(lv_obj_t * obj, uint32_t * row, uint32_t * c
 }
 
 /* Returns number of bytes to allocate based on chars configuration */
+LV_FUNC_SECTION
 static size_t get_cell_txt_len(const char * txt)
 {
     size_t retval = 0;
@@ -1049,6 +1076,7 @@ static size_t get_cell_txt_len(const char * txt)
 }
 
 /* Copy txt into dst skipping the format byte */
+LV_FUNC_SECTION
 static void copy_cell_txt(lv_table_cell_t * dst, const char * txt)
 {
 #if LV_USE_ARABIC_PERSIAN_CHARS
@@ -1058,6 +1086,7 @@ static void copy_cell_txt(lv_table_cell_t * dst, const char * txt)
 #endif
 }
 
+LV_FUNC_SECTION
 static void get_cell_area(lv_obj_t * obj, uint32_t row, uint32_t col, lv_area_t * area)
 {
     lv_table_t * table = (lv_table_t *)obj;
@@ -1093,6 +1122,7 @@ static void get_cell_area(lv_obj_t * obj, uint32_t row, uint32_t col, lv_area_t
 
 }
 
+LV_FUNC_SECTION
 static void scroll_to_selected_cell(lv_obj_t * obj)
 {
     lv_table_t * table = (lv_table_t *)obj;
diff --git a/src/widgets/tabview/lv_tabview.c b/src/widgets/tabview/lv_tabview.c
index 29e3e2e27..9510f63d9 100644
--- a/src/widgets/tabview/lv_tabview.c
+++ b/src/widgets/tabview/lv_tabview.c
@@ -58,6 +58,7 @@ typedef struct {
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 lv_obj_t * lv_tabview_create(lv_obj_t * parent)
 {
     LV_LOG_INFO("begin");
@@ -67,6 +68,7 @@ lv_obj_t * lv_tabview_create(lv_obj_t * parent)
     return obj;
 }
 
+LV_FUNC_SECTION
 lv_obj_t * lv_tabview_add_tab(lv_obj_t * obj, const char * name)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -96,6 +98,7 @@ lv_obj_t * lv_tabview_add_tab(lv_obj_t * obj, const char * name)
     return page;
 }
 
+LV_FUNC_SECTION
 void lv_tabview_rename_tab(lv_obj_t * obj, uint32_t idx, const char * new_name)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -106,6 +109,7 @@ void lv_tabview_rename_tab(lv_obj_t * obj, uint32_t idx, const char * new_name)
     lv_label_set_text(label, new_name);
 }
 
+LV_FUNC_SECTION
 void lv_tabview_set_active(lv_obj_t * obj, uint32_t idx, lv_anim_enable_t anim_en)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -152,6 +156,7 @@ void lv_tabview_set_active(lv_obj_t * obj, uint32_t idx, lv_anim_enable_t anim_e
     tabview->tab_cur = idx;
 }
 
+LV_FUNC_SECTION
 void lv_tabview_set_tab_bar_position(lv_obj_t * obj, lv_dir_t dir)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -221,6 +226,7 @@ void lv_tabview_set_tab_bar_position(lv_obj_t * obj, lv_dir_t dir)
     tabview->tab_pos = dir;
 }
 
+LV_FUNC_SECTION
 void lv_tabview_set_tab_bar_size(lv_obj_t * obj, int32_t size)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -236,6 +242,7 @@ void lv_tabview_set_tab_bar_size(lv_obj_t * obj, int32_t size)
 
 }
 
+LV_FUNC_SECTION
 uint32_t lv_tabview_get_tab_active(lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -243,6 +250,7 @@ uint32_t lv_tabview_get_tab_active(lv_obj_t * obj)
     return tabview->tab_cur;
 }
 
+LV_FUNC_SECTION
 uint32_t lv_tabview_get_tab_count(lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -250,11 +258,13 @@ uint32_t lv_tabview_get_tab_count(lv_obj_t * obj)
     return lv_obj_get_child_count_by_type(tab_bar, &lv_button_class);
 }
 
+LV_FUNC_SECTION
 lv_obj_t * lv_tabview_get_content(lv_obj_t * tv)
 {
     return lv_obj_get_child(tv, 1);
 }
 
+LV_FUNC_SECTION
 lv_obj_t * lv_tabview_get_tab_bar(lv_obj_t * tv)
 {
     return lv_obj_get_child(tv, 0);
@@ -264,6 +274,7 @@ lv_obj_t * lv_tabview_get_tab_bar(lv_obj_t * tv)
  *   STATIC FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 static void lv_tabview_constructor(const lv_obj_class_t * class_p, lv_obj_t * obj)
 {
     LV_UNUSED(class_p);
@@ -286,6 +297,7 @@ static void lv_tabview_constructor(const lv_obj_class_t * class_p, lv_obj_t * ob
     lv_obj_remove_flag(cont, LV_OBJ_FLAG_SCROLL_ON_FOCUS);
 }
 
+LV_FUNC_SECTION
 static void lv_tabview_event(const lv_obj_class_t * class_p, lv_event_t * e)
 {
     LV_UNUSED(class_p);
@@ -300,6 +312,7 @@ static void lv_tabview_event(const lv_obj_class_t * class_p, lv_event_t * e)
     }
 }
 
+__attribute__(( fptrgroup("lv_event_cb") ))
 static void button_clicked_event_cb(lv_event_t * e)
 {
     lv_obj_t * button = lv_event_get_current_target(e);
@@ -309,6 +322,8 @@ static void button_clicked_event_cb(lv_event_t * e)
     lv_tabview_set_active(tv, idx, LV_ANIM_OFF);
 }
 
+#pragma stackfunction 2048
+__attribute__(( fptrgroup("lv_event_cb") ))
 static void cont_scroll_end_event_cb(lv_event_t * e)
 {
     lv_obj_t * cont = lv_event_get_current_target(e);
diff --git a/src/widgets/textarea/lv_textarea.c b/src/widgets/textarea/lv_textarea.c
index 1958371b3..ea42a316a 100644
--- a/src/widgets/textarea/lv_textarea.c
+++ b/src/widgets/textarea/lv_textarea.c
@@ -182,6 +182,7 @@ static const char * ta_insert_replace;
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 lv_obj_t * lv_textarea_create(lv_obj_t * parent)
 {
     LV_LOG_INFO("begin");
@@ -194,6 +195,7 @@ lv_obj_t * lv_textarea_create(lv_obj_t * parent)
  * Add/remove functions
  *=====================*/
 
+LV_FUNC_SECTION
 void lv_textarea_add_char(lv_obj_t * obj, uint32_t c)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -266,6 +268,7 @@ void lv_textarea_add_char(lv_obj_t * obj, uint32_t c)
     lv_obj_send_event(obj, LV_EVENT_VALUE_CHANGED, NULL);
 }
 
+LV_FUNC_SECTION
 void lv_textarea_add_text(lv_obj_t * obj, const char * txt)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -316,6 +319,7 @@ void lv_textarea_add_text(lv_obj_t * obj, const char * txt)
     lv_obj_send_event(obj, LV_EVENT_VALUE_CHANGED, NULL);
 }
 
+LV_FUNC_SECTION
 void lv_textarea_delete_char(lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -360,6 +364,7 @@ void lv_textarea_delete_char(lv_obj_t * obj)
 
 }
 
+LV_FUNC_SECTION
 void lv_textarea_delete_char_forward(lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -373,6 +378,7 @@ void lv_textarea_delete_char_forward(lv_obj_t * obj)
  * Setter functions
  *====================*/
 
+LV_FUNC_SECTION
 void lv_textarea_set_text(lv_obj_t * obj, const char * txt)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -419,6 +425,7 @@ void lv_textarea_set_text(lv_obj_t * obj, const char * txt)
     lv_obj_send_event(obj, LV_EVENT_VALUE_CHANGED, NULL);
 }
 
+LV_FUNC_SECTION
 void lv_textarea_set_placeholder_text(lv_obj_t * obj, const char * txt)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -448,6 +455,7 @@ void lv_textarea_set_placeholder_text(lv_obj_t * obj, const char * txt)
     lv_obj_invalidate(obj);
 }
 
+LV_FUNC_SECTION
 void lv_textarea_set_cursor_pos(lv_obj_t * obj, int32_t pos)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -500,6 +508,7 @@ void lv_textarea_set_cursor_pos(lv_obj_t * obj, int32_t pos)
     refr_cursor_area(obj);
 }
 
+LV_FUNC_SECTION
 void lv_textarea_set_cursor_click_pos(lv_obj_t * obj, bool en)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -508,6 +517,7 @@ void lv_textarea_set_cursor_click_pos(lv_obj_t * obj, bool en)
     ta->cursor.click_pos = en ? 1U : 0U;
 }
 
+LV_FUNC_SECTION
 void lv_textarea_set_password_mode(lv_obj_t * obj, bool en)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -539,6 +549,7 @@ void lv_textarea_set_password_mode(lv_obj_t * obj, bool en)
     refr_cursor_area(obj);
 }
 
+LV_FUNC_SECTION
 void lv_textarea_set_password_bullet(lv_obj_t * obj, const char * bullet)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -569,6 +580,7 @@ void lv_textarea_set_password_bullet(lv_obj_t * obj, const char * bullet)
     pwd_char_hider(obj);
 }
 
+LV_FUNC_SECTION
 void lv_textarea_set_one_line(lv_obj_t * obj, bool en)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -593,6 +605,7 @@ void lv_textarea_set_one_line(lv_obj_t * obj, bool en)
     lv_obj_scroll_to(obj, 0, 0, LV_ANIM_OFF);
 }
 
+LV_FUNC_SECTION
 void lv_textarea_set_accepted_chars(lv_obj_t * obj, const char * list)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -602,6 +615,7 @@ void lv_textarea_set_accepted_chars(lv_obj_t * obj, const char * list)
     ta->accepted_chars = list;
 }
 
+LV_FUNC_SECTION
 void lv_textarea_set_max_length(lv_obj_t * obj, uint32_t num)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -611,6 +625,7 @@ void lv_textarea_set_max_length(lv_obj_t * obj, uint32_t num)
     ta->max_length = num;
 }
 
+LV_FUNC_SECTION
 void lv_textarea_set_insert_replace(lv_obj_t * obj, const char * txt)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -619,6 +634,7 @@ void lv_textarea_set_insert_replace(lv_obj_t * obj, const char * txt)
     ta_insert_replace = txt;
 }
 
+LV_FUNC_SECTION
 void lv_textarea_set_text_selection(lv_obj_t * obj, bool en)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -635,6 +651,7 @@ void lv_textarea_set_text_selection(lv_obj_t * obj, bool en)
 #endif
 }
 
+LV_FUNC_SECTION
 void lv_textarea_set_password_show_time(lv_obj_t * obj, uint32_t time)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -644,6 +661,7 @@ void lv_textarea_set_password_show_time(lv_obj_t * obj, uint32_t time)
     pwd_char_hider(obj);
 }
 
+LV_FUNC_SECTION
 void lv_textarea_set_align(lv_obj_t * obj, lv_text_align_t align)
 {
     LV_LOG_WARN("Deprecated: use the normal text_align style property instead");
@@ -667,6 +685,7 @@ void lv_textarea_set_align(lv_obj_t * obj, lv_text_align_t align)
  * Getter functions
  *====================*/
 
+LV_FUNC_SECTION
 const char * lv_textarea_get_text(const lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -684,6 +703,7 @@ const char * lv_textarea_get_text(const lv_obj_t * obj)
     return txt;
 }
 
+LV_FUNC_SECTION
 const char * lv_textarea_get_placeholder_text(lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -693,6 +713,7 @@ const char * lv_textarea_get_placeholder_text(lv_obj_t * obj)
     else return "";
 }
 
+LV_FUNC_SECTION
 lv_obj_t * lv_textarea_get_label(const lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -701,6 +722,7 @@ lv_obj_t * lv_textarea_get_label(const lv_obj_t * obj)
     return ta->label;
 }
 
+LV_FUNC_SECTION
 uint32_t lv_textarea_get_cursor_pos(const lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -709,6 +731,7 @@ uint32_t lv_textarea_get_cursor_pos(const lv_obj_t * obj)
     return ta->cursor.pos;
 }
 
+LV_FUNC_SECTION
 bool lv_textarea_get_cursor_click_pos(lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -717,6 +740,7 @@ bool lv_textarea_get_cursor_click_pos(lv_obj_t * obj)
     return ta->cursor.click_pos;
 }
 
+LV_FUNC_SECTION
 bool lv_textarea_get_password_mode(const lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -725,6 +749,7 @@ bool lv_textarea_get_password_mode(const lv_obj_t * obj)
     return ta->pwd_mode == 1U;
 }
 
+LV_FUNC_SECTION
 const char * lv_textarea_get_password_bullet(lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -742,6 +767,7 @@ const char * lv_textarea_get_password_bullet(lv_obj_t * obj)
     return "*";
 }
 
+LV_FUNC_SECTION
 bool lv_textarea_get_one_line(const lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -750,6 +776,7 @@ bool lv_textarea_get_one_line(const lv_obj_t * obj)
     return ta->one_line == 1U;
 }
 
+LV_FUNC_SECTION
 const char * lv_textarea_get_accepted_chars(lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -759,6 +786,7 @@ const char * lv_textarea_get_accepted_chars(lv_obj_t * obj)
     return ta->accepted_chars;
 }
 
+LV_FUNC_SECTION
 uint32_t lv_textarea_get_max_length(lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -767,6 +795,7 @@ uint32_t lv_textarea_get_max_length(lv_obj_t * obj)
     return ta->max_length;
 }
 
+LV_FUNC_SECTION
 bool lv_textarea_text_is_selected(const lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -787,6 +816,7 @@ bool lv_textarea_text_is_selected(const lv_obj_t * obj)
 #endif
 }
 
+LV_FUNC_SECTION
 bool lv_textarea_get_text_selection(lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -800,6 +830,7 @@ bool lv_textarea_get_text_selection(lv_obj_t * obj)
 #endif
 }
 
+LV_FUNC_SECTION
 uint32_t lv_textarea_get_password_show_time(lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -809,6 +840,7 @@ uint32_t lv_textarea_get_password_show_time(lv_obj_t * obj)
     return ta->pwd_show_time;
 }
 
+LV_FUNC_SECTION
 uint32_t lv_textarea_get_current_char(lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -826,6 +858,7 @@ uint32_t lv_textarea_get_current_char(lv_obj_t * obj)
  * Other functions
  *====================*/
 
+LV_FUNC_SECTION
 void lv_textarea_clear_selection(lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -843,6 +876,7 @@ void lv_textarea_clear_selection(lv_obj_t * obj)
 #endif
 }
 
+LV_FUNC_SECTION
 void lv_textarea_cursor_right(lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -852,6 +886,7 @@ void lv_textarea_cursor_right(lv_obj_t * obj)
     lv_textarea_set_cursor_pos(obj, cp);
 }
 
+LV_FUNC_SECTION
 void lv_textarea_cursor_left(lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -863,6 +898,7 @@ void lv_textarea_cursor_left(lv_obj_t * obj)
     }
 }
 
+LV_FUNC_SECTION
 void lv_textarea_cursor_down(lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -892,6 +928,7 @@ void lv_textarea_cursor_down(lv_obj_t * obj)
     }
 }
 
+LV_FUNC_SECTION
 void lv_textarea_cursor_up(lv_obj_t * obj)
 {
     LV_ASSERT_OBJ(obj, MY_CLASS);
@@ -920,6 +957,7 @@ void lv_textarea_cursor_up(lv_obj_t * obj)
  *   STATIC FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 static void lv_textarea_constructor(const lv_obj_class_t * class_p, lv_obj_t * obj)
 {
     LV_UNUSED(class_p);
@@ -959,6 +997,7 @@ static void lv_textarea_constructor(const lv_obj_class_t * class_p, lv_obj_t * o
     LV_TRACE_OBJ_CREATE("finished");
 }
 
+LV_FUNC_SECTION
 static void lv_textarea_destructor(const lv_obj_class_t * class_p, lv_obj_t * obj)
 {
     LV_UNUSED(class_p);
@@ -978,6 +1017,7 @@ static void lv_textarea_destructor(const lv_obj_class_t * class_p, lv_obj_t * ob
     }
 }
 
+LV_FUNC_SECTION
 static void lv_textarea_event(const lv_obj_class_t * class_p, lv_event_t * e)
 {
     LV_UNUSED(class_p);
@@ -1029,6 +1069,7 @@ static void lv_textarea_event(const lv_obj_class_t * class_p, lv_event_t * e)
     }
 }
 
+__attribute__(( fptrgroup("lv_event_cb") ))
 static void label_event_cb(lv_event_t * e)
 {
     lv_event_code_t code = lv_event_get_code(e);
@@ -1047,6 +1088,7 @@ static void label_event_cb(lv_event_t * e)
  * @param ta pointer to a text area
  * @param hide 1: hide the cursor, 0: show it
  */
+__attribute__(( fptrgroup("lv_anim_exec_cb") ))
 static void cursor_blink_anim_cb(void * obj, int32_t show)
 {
     lv_textarea_t * ta = (lv_textarea_t *)obj;
@@ -1069,6 +1111,7 @@ static void cursor_blink_anim_cb(void * obj, int32_t show)
  * @param ta unused
  * @param x unused
  */
+__attribute__(( fptrgroup("lv_anim_exec_cb") ))
 static void pwd_char_hider_anim(void * obj, int32_t x)
 {
     LV_UNUSED(obj);
@@ -1079,6 +1122,7 @@ static void pwd_char_hider_anim(void * obj, int32_t x)
  * Call when an animation is ready to convert all characters to '*'
  * @param a pointer to the animation
  */
+__attribute__(( fptrgroup("lv_anim_completed_cb") ))
 static void pwd_char_hider_anim_completed(lv_anim_t * a)
 {
     lv_obj_t * obj = a->var;
@@ -1089,6 +1133,7 @@ static void pwd_char_hider_anim_completed(lv_anim_t * a)
  * Hide all characters (convert them to '*')
  * @param ta pointer to text area object
  */
+LV_FUNC_SECTION
 static void pwd_char_hider(lv_obj_t * obj)
 {
     lv_textarea_t * ta = (lv_textarea_t *)obj;
@@ -1125,6 +1170,7 @@ static void pwd_char_hider(lv_obj_t * obj)
  * @param c a unicode character
  * @return true: accepted; false: rejected
  */
+LV_FUNC_SECTION
 static bool char_is_accepted(lv_obj_t * obj, uint32_t c)
 {
     lv_textarea_t * ta = (lv_textarea_t *)obj;
@@ -1146,6 +1192,7 @@ static bool char_is_accepted(lv_obj_t * obj, uint32_t c)
     return false; /*The character wasn't in the list*/
 }
 
+LV_FUNC_SECTION
 static void start_cursor_blink(lv_obj_t * obj)
 {
     lv_textarea_t * ta = (lv_textarea_t *)obj;
@@ -1168,6 +1215,7 @@ static void start_cursor_blink(lv_obj_t * obj)
     }
 }
 
+LV_FUNC_SECTION
 static void refr_cursor_area(lv_obj_t * obj)
 {
     lv_textarea_t * ta = (lv_textarea_t *)obj;
@@ -1249,6 +1297,7 @@ static void refr_cursor_area(lv_obj_t * obj)
     lv_obj_invalidate_area(obj, &area_tmp);
 }
 
+LV_FUNC_SECTION
 static void update_cursor_position_on_click(lv_event_t * e)
 {
     lv_indev_t * click_source = lv_indev_active();
@@ -1367,6 +1416,7 @@ static void update_cursor_position_on_click(lv_event_t * e)
 
 /* Returns LV_RESULT_OK when no operation were performed
  * Returns LV_RESULT_INVALID when a user defined text was inserted */
+LV_FUNC_SECTION
 static lv_result_t insert_handler(lv_obj_t * obj, const char * txt)
 {
     ta_insert_replace = NULL;
@@ -1387,6 +1437,7 @@ static lv_result_t insert_handler(lv_obj_t * obj, const char * txt)
     return LV_RESULT_OK;
 }
 
+LV_FUNC_SECTION
 static void draw_placeholder(lv_event_t * e)
 {
     lv_obj_t * obj = lv_event_get_current_target(e);
@@ -1418,6 +1469,7 @@ static void draw_placeholder(lv_event_t * e)
     }
 }
 
+LV_FUNC_SECTION
 static void draw_cursor(lv_event_t * e)
 {
     lv_obj_t * obj = lv_event_get_current_target(e);
@@ -1465,6 +1517,7 @@ static void draw_cursor(lv_event_t * e)
     }
 }
 
+LV_FUNC_SECTION
 static void auto_hide_characters(lv_obj_t * obj)
 {
     lv_textarea_t * ta = (lv_textarea_t *) obj;
@@ -1485,11 +1538,13 @@ static void auto_hide_characters(lv_obj_t * obj)
     }
 }
 
+LV_FUNC_SECTION
 static void auto_hide_characters_cancel(lv_obj_t * obj)
 {
     lv_anim_delete(obj, pwd_char_hider_anim);
 }
 
+LV_FUNC_SECTION
 static inline bool is_valid_but_non_printable_char(const uint32_t letter)
 {
     if(letter == '\0' || letter == '\n' || letter == '\r') {
diff --git a/src/widgets/tileview/lv_tileview.c b/src/widgets/tileview/lv_tileview.c
index 8844a89ae..1876aabae 100644
--- a/src/widgets/tileview/lv_tileview.c
+++ b/src/widgets/tileview/lv_tileview.c
@@ -53,6 +53,7 @@ const lv_obj_class_t lv_tileview_tile_class = {
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 lv_obj_t * lv_tileview_create(lv_obj_t * parent)
 {
     LV_LOG_INFO("begin");
@@ -65,6 +66,7 @@ lv_obj_t * lv_tileview_create(lv_obj_t * parent)
  * Add/remove functions
  *=====================*/
 
+LV_FUNC_SECTION
 lv_obj_t * lv_tileview_add_tile(lv_obj_t * tv, uint8_t col_id, uint8_t row_id, lv_dir_t dir)
 {
     LV_LOG_INFO("begin");
@@ -82,6 +84,7 @@ lv_obj_t * lv_tileview_add_tile(lv_obj_t * tv, uint8_t col_id, uint8_t row_id, l
     return obj;
 }
 
+LV_FUNC_SECTION
 void lv_tileview_set_tile(lv_obj_t * obj, lv_obj_t * tile_obj, lv_anim_enable_t anim_en)
 {
     int32_t tx = lv_obj_get_x(tile_obj);
@@ -95,6 +98,7 @@ void lv_tileview_set_tile(lv_obj_t * obj, lv_obj_t * tile_obj, lv_anim_enable_t
     lv_obj_scroll_to(obj, tx, ty, anim_en);
 }
 
+LV_FUNC_SECTION
 void lv_tileview_set_tile_by_index(lv_obj_t * tv, uint32_t col_id, uint32_t row_id, lv_anim_enable_t anim_en)
 {
     lv_obj_update_layout(tv);
@@ -119,6 +123,7 @@ void lv_tileview_set_tile_by_index(lv_obj_t * tv, uint32_t col_id, uint32_t row_
     LV_LOG_WARN("No tile found with at (%d,%d) index", (int)col_id, (int)row_id);
 }
 
+LV_FUNC_SECTION
 lv_obj_t * lv_tileview_get_tile_active(lv_obj_t * obj)
 {
     lv_tileview_t * tv = (lv_tileview_t *) obj;
@@ -129,6 +134,7 @@ lv_obj_t * lv_tileview_get_tile_active(lv_obj_t * obj)
  *   STATIC FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 static void lv_tileview_constructor(const lv_obj_class_t * class_p, lv_obj_t * obj)
 {
     LV_UNUSED(class_p);
@@ -140,6 +146,7 @@ static void lv_tileview_constructor(const lv_obj_class_t * class_p, lv_obj_t * o
 
 }
 
+LV_FUNC_SECTION
 static void lv_tileview_tile_constructor(const lv_obj_class_t * class_p, lv_obj_t * obj)
 {
 
@@ -148,6 +155,7 @@ static void lv_tileview_tile_constructor(const lv_obj_class_t * class_p, lv_obj_
     lv_obj_update_layout(obj);  /*Be sure the size is correct*/
 }
 
+__attribute__(( fptrgroup("lv_event_cb") ))
 static void tileview_event_cb(lv_event_t * e)
 {
     lv_event_code_t code = lv_event_get_code(e);
diff --git a/src/widgets/win/lv_win.c b/src/widgets/win/lv_win.c
index 508d2f010..9455ace52 100644
--- a/src/widgets/win/lv_win.c
+++ b/src/widgets/win/lv_win.c
@@ -43,6 +43,7 @@ const lv_obj_class_t lv_win_class = {
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 lv_obj_t * lv_win_create(lv_obj_t * parent)
 {
     LV_LOG_INFO("begin");
@@ -51,6 +52,7 @@ lv_obj_t * lv_win_create(lv_obj_t * parent)
     return obj;
 }
 
+LV_FUNC_SECTION
 lv_obj_t * lv_win_add_title(lv_obj_t * win, const char * txt)
 {
     lv_obj_t * header = lv_win_get_header(win);
@@ -61,6 +63,7 @@ lv_obj_t * lv_win_add_title(lv_obj_t * win, const char * txt)
     return title;
 }
 
+LV_FUNC_SECTION
 lv_obj_t * lv_win_add_button(lv_obj_t * win, const void * icon, int32_t btn_w)
 {
     lv_obj_t * header = lv_win_get_header(win);
@@ -76,11 +79,13 @@ lv_obj_t * lv_win_add_button(lv_obj_t * win, const void * icon, int32_t btn_w)
     return btn;
 }
 
+LV_FUNC_SECTION
 lv_obj_t * lv_win_get_header(lv_obj_t * win)
 {
     return lv_obj_get_child(win, 0);
 }
 
+LV_FUNC_SECTION
 lv_obj_t * lv_win_get_content(lv_obj_t * win)
 {
     return lv_obj_get_child(win, 1);
@@ -90,6 +95,7 @@ lv_obj_t * lv_win_get_content(lv_obj_t * win)
  *   STATIC FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 static void lv_win_constructor(const lv_obj_class_t * class_p, lv_obj_t * obj)
 {
     LV_UNUSED(class_p);
diff --git a/tests/makefile/test.c b/tests/makefile/test.c
index 326fb7fa0..ed5b683ab 100644
--- a/tests/makefile/test.c
+++ b/tests/makefile/test.c
@@ -2,6 +2,7 @@
 #include <stdio.h>
 #include "../../lvgl.h"
 
+LV_FUNC_SECTION
 int main(void)
 {
     lv_init();
diff --git a/tests/makefile_uefi/test.c b/tests/makefile_uefi/test.c
index f40b0e7a3..684415c7c 100644
--- a/tests/makefile_uefi/test.c
+++ b/tests/makefile_uefi/test.c
@@ -1,6 +1,7 @@
 #if LV_BUILD_TEST
 #include "../../lvgl.h"
 
+LV_FUNC_SECTION
 int efi_main(void * image_handle, void * system_table)
 {
     lv_init();
@@ -8,6 +9,7 @@ int efi_main(void * image_handle, void * system_table)
 }
 
 // memcpy is required as symbol for the clang compiler
+LV_FUNC_SECTION
 void * memcpy(void * s, const void * ct, size_t n)
 {
     const uint8_t * ct_8 = (const uint8_t *) ct;
@@ -21,6 +23,7 @@ void * memcpy(void * s, const void * ct, size_t n)
 }
 
 // memset is required as symbol for the clang compiler
+LV_FUNC_SECTION
 void * memset(void * s, int c, size_t n)
 {
     uint8_t * s_8 = (uint8_t *)s;
diff --git a/tests/src/lv_test_helpers.c b/tests/src/lv_test_helpers.c
index 7362bfd68..b89ebac4b 100644
--- a/tests/src/lv_test_helpers.c
+++ b/tests/src/lv_test_helpers.c
@@ -2,6 +2,7 @@
 
 #include "lv_test_helpers.h"
 
+LV_FUNC_SECTION
 void lv_test_wait(uint32_t ms)
 {
     lv_tick_inc(ms);
diff --git a/tests/src/lv_test_indev.c b/tests/src/lv_test_indev.c
index 503660074..3bd5b91af 100644
--- a/tests/src/lv_test_indev.c
+++ b/tests/src/lv_test_indev.c
@@ -15,6 +15,7 @@ static bool mouse_pressed;
 static bool key_pressed;
 static bool enc_pressed;
 
+LV_FUNC_SECTION
 void lv_test_mouse_read_cb(lv_indev_t * indev, lv_indev_data_t * data)
 {
     LV_UNUSED(indev);
@@ -22,28 +23,33 @@ void lv_test_mouse_read_cb(lv_indev_t * indev, lv_indev_data_t * data)
     data->state = mouse_pressed ? LV_INDEV_STATE_PRESSED : LV_INDEV_STATE_RELEASED;
 }
 
+LV_FUNC_SECTION
 void lv_test_mouse_move_to(int32_t x, int32_t y)
 {
     x_act = x;
     y_act = y;
 }
 
+LV_FUNC_SECTION
 void lv_test_mouse_move_by(int32_t x, int32_t y)
 {
     x_act += x;
     y_act += y;
 }
 
+LV_FUNC_SECTION
 void lv_test_mouse_press(void)
 {
     mouse_pressed = true;
 }
 
+LV_FUNC_SECTION
 void lv_test_mouse_release(void)
 {
     mouse_pressed = false;
 }
 
+LV_FUNC_SECTION
 void lv_test_mouse_click_at(int32_t x, int32_t y)
 {
     lv_test_mouse_release();
@@ -55,6 +61,7 @@ void lv_test_mouse_click_at(int32_t x, int32_t y)
     lv_test_indev_wait(50);
 }
 
+LV_FUNC_SECTION
 void lv_test_keypad_read_cb(lv_indev_t * indev, lv_indev_data_t * data)
 {
     LV_UNUSED(indev);
@@ -62,17 +69,20 @@ void lv_test_keypad_read_cb(lv_indev_t * indev, lv_indev_data_t * data)
     data->state = key_pressed ? LV_INDEV_STATE_PRESSED : LV_INDEV_STATE_RELEASED;
 }
 
+LV_FUNC_SECTION
 void lv_test_key_press(uint32_t k)
 {
     key_act = k;
     key_pressed = true;
 }
 
+LV_FUNC_SECTION
 void lv_test_key_release(void)
 {
     key_pressed = false;
 }
 
+LV_FUNC_SECTION
 void lv_test_key_hit(uint32_t k)
 {
     lv_test_key_release();
@@ -84,6 +94,7 @@ void lv_test_key_hit(uint32_t k)
     lv_test_indev_wait(50);
 }
 
+LV_FUNC_SECTION
 void lv_test_encoder_read_cb(lv_indev_t * indev, lv_indev_data_t * data)
 {
     LV_UNUSED(indev);
@@ -92,27 +103,32 @@ void lv_test_encoder_read_cb(lv_indev_t * indev, lv_indev_data_t * data)
     diff_act = 0;
 }
 
+LV_FUNC_SECTION
 void lv_test_encoder_add_diff(int32_t d)
 {
     diff_act += d;
 }
 
+LV_FUNC_SECTION
 void lv_test_encoder_turn(int32_t d)
 {
     diff_act += d;
     lv_test_indev_wait(50);
 }
 
+LV_FUNC_SECTION
 void lv_test_encoder_press(void)
 {
     enc_pressed = true;
 }
 
+LV_FUNC_SECTION
 void lv_test_encoder_release(void)
 {
     enc_pressed = false;
 }
 
+LV_FUNC_SECTION
 void lv_test_encoder_click(void)
 {
     lv_test_encoder_release();
@@ -123,6 +139,7 @@ void lv_test_encoder_click(void)
     lv_test_indev_wait(50);
 }
 
+LV_FUNC_SECTION
 void lv_test_indev_wait(uint32_t ms)
 {
     uint32_t t = lv_tick_get();
diff --git a/tests/src/lv_test_init.c b/tests/src/lv_test_init.c
index 035d9de1e..562d8d58e 100644
--- a/tests/src/lv_test_init.c
+++ b/tests/src/lv_test_init.c
@@ -16,6 +16,7 @@ lv_indev_t * lv_test_mouse_indev;
 lv_indev_t * lv_test_keypad_indev;
 lv_indev_t * lv_test_encoder_indev;
 
+LV_FUNC_SECTION
 void lv_test_init(void)
 {
     lv_init();
@@ -30,11 +31,13 @@ void lv_test_init(void)
 #endif
 }
 
+LV_FUNC_SECTION
 void lv_test_deinit(void)
 {
     lv_mem_deinit();
 }
 
+LV_FUNC_SECTION
 static void color_format_changled_event_cb(lv_event_t * e)
 {
     lv_display_t * disp = lv_event_get_target(e);
@@ -46,6 +49,7 @@ static void color_format_changled_event_cb(lv_event_t * e)
 
 }
 
+LV_FUNC_SECTION
 static void hal_init(void)
 {
 
@@ -68,6 +72,7 @@ static void hal_init(void)
     lv_indev_set_read_cb(lv_test_encoder_indev,  lv_test_encoder_read_cb);
 }
 
+LV_FUNC_SECTION
 static void dummy_flush_cb(lv_display_t * disp, const lv_area_t * area, uint8_t * color_p)
 {
     LV_UNUSED(area);
@@ -76,6 +81,7 @@ static void dummy_flush_cb(lv_display_t * disp, const lv_area_t * area, uint8_t
     lv_display_flush_ready(disp);
 }
 
+LV_FUNC_SECTION
 void lv_test_assert_fail(void)
 {
     /*Handle error on test*/
diff --git a/tests/src/test_cases/_test_template.c b/tests/src/test_cases/_test_template.c
index 5ad821137..47b196d2f 100644
--- a/tests/src/test_cases/_test_template.c
+++ b/tests/src/test_cases/_test_template.c
@@ -3,17 +3,20 @@
 
 #include "unity/unity.h"
 
+LV_FUNC_SECTION
 void setUp(void)
 {
     /* Function run before every test */
 }
 
+LV_FUNC_SECTION
 void tearDown(void)
 {
     /* Function run after every test */
     lv_obj_clean(lv_screen_active());
 }
 
+LV_FUNC_SECTION
 void test_func_1(void)
 {
     TEST_FAIL();
diff --git a/tests/src/test_cases/cache/test_cache.c b/tests/src/test_cases/cache/test_cache.c
index ce181bf7e..aa39ffed4 100644
--- a/tests/src/test_cases/cache/test_cache.c
+++ b/tests/src/test_cases/cache/test_cache.c
@@ -22,6 +22,7 @@ typedef struct _test_data {
     void * data; // malloced data
 } test_data;
 
+LV_FUNC_SECTION
 static lv_cache_compare_res_t compare_cb(const test_data * lhs, const test_data * rhs)
 {
     if(lhs->key1 != rhs->key1) {
@@ -33,12 +34,14 @@ static lv_cache_compare_res_t compare_cb(const test_data * lhs, const test_data
     return 0;
 }
 
+LV_FUNC_SECTION
 static void free_cb(test_data * node, void * user_data)
 {
     LV_UNUSED(user_data);
     lv_free(node->data);
 }
 
+LV_FUNC_SECTION
 void setUp(void)
 {
     /* Function run before every test */
@@ -52,6 +55,7 @@ void setUp(void)
     cache = lv_cache_create(&lv_cache_class_lru_rb_size, sizeof(test_data), CACHE_SIZE_BYTES, ops);
 }
 
+LV_FUNC_SECTION
 void tearDown(void)
 {
     /* Function run after every test */
@@ -61,6 +65,7 @@ void tearDown(void)
     TEST_ASSERT_MEM_LEAK_LESS_THAN(MEM_SIZE, 32);
 }
 
+LV_FUNC_SECTION
 void test_cache_1(void)
 {
 
diff --git a/tests/src/test_cases/draw/test_clip_corner.c b/tests/src/test_cases/draw/test_clip_corner.c
index e839be83c..ab45f4f34 100644
--- a/tests/src/test_cases/draw/test_clip_corner.c
+++ b/tests/src/test_cases/draw/test_clip_corner.c
@@ -4,16 +4,19 @@
 
 #include "unity/unity.h"
 
+LV_FUNC_SECTION
 void setUp(void)
 {
     /* Function run before every test */
 }
 
+LV_FUNC_SECTION
 void tearDown(void)
 {
     /* Function run after every test */
 }
 
+LV_FUNC_SECTION
 static lv_obj_t * create_panel(int32_t radius, bool transform)
 {
     lv_obj_t * parent = lv_obj_create(lv_screen_active());
@@ -42,6 +45,7 @@ static lv_obj_t * create_panel(int32_t radius, bool transform)
     return parent;
 }
 
+LV_FUNC_SECTION
 void test_clip_corner_1(void)
 {
     lv_obj_set_flex_flow(lv_screen_active(), LV_FLEX_FLOW_ROW_WRAP);
diff --git a/tests/src/test_cases/draw/test_draw_blend.c b/tests/src/test_cases/draw/test_draw_blend.c
index 598590309..4916ae5c9 100644
--- a/tests/src/test_cases/draw/test_draw_blend.c
+++ b/tests/src/test_cases/draw/test_draw_blend.c
@@ -5,6 +5,7 @@
 
 #include "unity/unity.h"
 
+LV_FUNC_SECTION
 void setUp(void)
 {
     /* Function run before every test */
@@ -13,11 +14,13 @@ void setUp(void)
 
 }
 
+LV_FUNC_SECTION
 void tearDown(void)
 {
     /* Function run after every test */
 }
 
+LV_FUNC_SECTION
 static void canvas_basic_render(uint8_t * canvas_buf, lv_color_format_t render_cf, const char * name_main,
                                 const char * name_sub)
 {
@@ -88,6 +91,7 @@ static void canvas_basic_render(uint8_t * canvas_buf, lv_color_format_t render_c
     lv_obj_delete(canvas);
 }
 
+LV_FUNC_SECTION
 void canvas_blend_test(lv_obj_t  * canvas_large, lv_draw_image_dsc_t * img_dsc, const char * name_main,
                        const char * name_sub, lv_color_format_t small_render_cf, uint32_t idx)
 {
@@ -119,6 +123,7 @@ void canvas_blend_test(lv_obj_t  * canvas_large, lv_draw_image_dsc_t * img_dsc,
     lv_image_cache_drop(img);
 }
 
+LV_FUNC_SECTION
 static void canvas_draw(const char * name, lv_color_format_t large_render_cf)
 {
     lv_obj_clean(lv_screen_active());
@@ -147,21 +152,25 @@ static void canvas_draw(const char * name, lv_color_format_t large_render_cf)
     TEST_ASSERT_EQUAL_SCREENSHOT(fn_buf);
 }
 
+LV_FUNC_SECTION
 void test_xrgb8888(void)
 {
     canvas_draw("xrgb8888", LV_COLOR_FORMAT_XRGB8888);
 }
 
+LV_FUNC_SECTION
 void test_argb8888(void)
 {
     canvas_draw("argb8888", LV_COLOR_FORMAT_ARGB8888);
 }
 
+LV_FUNC_SECTION
 void test_rgb888(void)
 {
     canvas_draw("rgb888", LV_COLOR_FORMAT_RGB888);
 }
 
+LV_FUNC_SECTION
 void test_rgb565(void)
 {
     canvas_draw("rgb565", LV_COLOR_FORMAT_RGB565);
diff --git a/tests/src/test_cases/draw/test_draw_label.c b/tests/src/test_cases/draw/test_draw_label.c
index 749e9fcb8..bffb01598 100644
--- a/tests/src/test_cases/draw/test_draw_label.c
+++ b/tests/src/test_cases/draw/test_draw_label.c
@@ -4,6 +4,7 @@
 
 #include "unity/unity.h"
 
+LV_FUNC_SECTION
 void setUp(void)
 {
     /* Function run before every test */
@@ -11,12 +12,14 @@ void setUp(void)
     lv_obj_set_flex_align(lv_screen_active(), LV_FLEX_ALIGN_SPACE_EVENLY, LV_FLEX_ALIGN_CENTER, LV_FLEX_ALIGN_SPACE_EVENLY);
 }
 
+LV_FUNC_SECTION
 void tearDown(void)
 {
     /* Function run after every test */
     lv_obj_clean(lv_screen_active());
 }
 
+LV_FUNC_SECTION
 static lv_obj_t * label_create(const lv_font_t * font, lv_style_t * style, const char * text_base)
 {
     lv_obj_t * label = lv_label_create(lv_screen_active());
@@ -28,6 +31,7 @@ static lv_obj_t * label_create(const lv_font_t * font, lv_style_t * style, const
     return label;
 }
 
+LV_FUNC_SECTION
 static void all_labels_create(const char * name, lv_style_t * style)
 {
     LV_FONT_DECLARE(test_font_montserrat_ascii_1bpp);
@@ -47,11 +51,13 @@ static void all_labels_create(const char * name, lv_style_t * style)
     TEST_ASSERT_EQUAL_SCREENSHOT(buf);
 }
 
+LV_FUNC_SECTION
 void test_draw_label_normal(void)
 {
     all_labels_create("normal", NULL);
 }
 
+LV_FUNC_SECTION
 void test_draw_label_color(void)
 {
     static lv_style_t style;
@@ -61,6 +67,7 @@ void test_draw_label_color(void)
 
 }
 
+LV_FUNC_SECTION
 void test_draw_label_opa(void)
 {
     static lv_style_t style;
@@ -69,6 +76,7 @@ void test_draw_label_opa(void)
     all_labels_create("opa", &style);
 }
 
+LV_FUNC_SECTION
 void test_draw_label_color_and_opa(void)
 {
     static lv_style_t style;
@@ -78,6 +86,7 @@ void test_draw_label_color_and_opa(void)
     all_labels_create("color_and_opa", &style);
 }
 
+LV_FUNC_SECTION
 static lv_obj_t * decor_label_create(lv_text_decor_t decor, lv_text_align_t align, lv_opa_t opa)
 {
     lv_color_t color = lv_palette_main(LV_PALETTE_BLUE);
@@ -98,6 +107,7 @@ static lv_obj_t * decor_label_create(lv_text_decor_t decor, lv_text_align_t alig
     return label;
 }
 
+LV_FUNC_SECTION
 static void all_decor_labels_create(lv_text_decor_t decor)
 {
 
@@ -113,6 +123,7 @@ static void all_decor_labels_create(lv_text_decor_t decor)
     label = decor_label_create(decor, LV_TEXT_ALIGN_RIGHT, LV_OPA_50);
 }
 
+LV_FUNC_SECTION
 void test_label_decor(void)
 {
     all_decor_labels_create(LV_TEXT_DECOR_NONE);
diff --git a/tests/src/test_cases/draw/test_draw_layer.c b/tests/src/test_cases/draw/test_draw_layer.c
index c60ffd2d8..21bc7f697 100644
--- a/tests/src/test_cases/draw/test_draw_layer.c
+++ b/tests/src/test_cases/draw/test_draw_layer.c
@@ -4,17 +4,20 @@
 
 #include "unity/unity.h"
 
+LV_FUNC_SECTION
 void setUp(void)
 {
     /* Function run before every test */
 }
 
+LV_FUNC_SECTION
 void tearDown(void)
 {
     /* Function run after every test */
     lv_obj_clean(lv_screen_active());
 }
 
+LV_FUNC_SECTION
 void test_draw_layer_bitmap_mask_from_variable(void)
 {
     LV_IMAGE_DECLARE(test_image_cogwheel_a8);
@@ -34,6 +37,7 @@ void test_draw_layer_bitmap_mask_from_variable(void)
     TEST_ASSERT_EQUAL_SCREENSHOT("draw/draw_layer_bitmap_mask.png");
 }
 
+LV_FUNC_SECTION
 void test_draw_layer_bitmap_mask_from_image(void)
 {
     lv_obj_t * obj = lv_obj_create(lv_screen_active());
@@ -52,6 +56,7 @@ void test_draw_layer_bitmap_mask_from_image(void)
 }
 
 
+LV_FUNC_SECTION
 void test_draw_layer_bitmap_mask_from_image_not_found(void)
 {
     lv_obj_t * obj = lv_obj_create(lv_screen_active());
diff --git a/tests/src/test_cases/draw/test_draw_sw_post_process.c b/tests/src/test_cases/draw/test_draw_sw_post_process.c
index 4d8397ac0..93bb21f17 100644
--- a/tests/src/test_cases/draw/test_draw_sw_post_process.c
+++ b/tests/src/test_cases/draw/test_draw_sw_post_process.c
@@ -4,16 +4,19 @@
 
 #include "unity/unity.h"
 
+LV_FUNC_SECTION
 void setUp(void)
 {
     /* Function run before every test */
 }
 
+LV_FUNC_SECTION
 void tearDown(void)
 {
     /* Function run after every test */
 }
 
+LV_FUNC_SECTION
 void test_rotate90_RGB565(void)
 {
     uint16_t srcArray[3 * 2] = {
@@ -38,6 +41,7 @@ void test_rotate90_RGB565(void)
     TEST_ASSERT_EQUAL_UINT8_ARRAY(expectedArray, dstArray, sizeof(dstArray));
 }
 
+LV_FUNC_SECTION
 void test_rotate180_RGB565(void)
 {
     uint16_t srcArray[3 * 2] = {
@@ -59,6 +63,7 @@ void test_rotate180_RGB565(void)
     TEST_ASSERT_EQUAL_UINT8_ARRAY(expectedArray, dstArray, sizeof(dstArray));
 }
 
+LV_FUNC_SECTION
 void test_rotate270_RGB565(void)
 {
     uint16_t srcArray[3 * 2] = {
@@ -83,6 +88,7 @@ void test_rotate270_RGB565(void)
     TEST_ASSERT_EQUAL_UINT8_ARRAY(expectedArray, dstArray, sizeof(dstArray));
 }
 
+LV_FUNC_SECTION
 void test_rotate90_RGB888(void)
 {
     uint8_t srcArray[3 * 2 * 3] = {
@@ -107,6 +113,7 @@ void test_rotate90_RGB888(void)
     TEST_ASSERT_EQUAL_UINT8_ARRAY(expectedArray, dstArray, sizeof(dstArray));
 }
 
+LV_FUNC_SECTION
 void test_rotate180_RGB888(void)
 {
     uint8_t srcArray[3 * 2 * 3] = {
@@ -130,6 +137,7 @@ void test_rotate180_RGB888(void)
     TEST_ASSERT_EQUAL_UINT8_ARRAY(expectedArray, dstArray, sizeof(dstArray));
 }
 
+LV_FUNC_SECTION
 void test_rotate270_RGB888(void)
 {
     uint8_t srcArray[3 * 2 * 3] = {
@@ -154,6 +162,7 @@ void test_rotate270_RGB888(void)
     TEST_ASSERT_EQUAL_UINT8_ARRAY(expectedArray, dstArray, sizeof(dstArray));
 }
 
+LV_FUNC_SECTION
 void test_rotate90_ARGB8888(void)
 {
     uint32_t srcArray[3 * 2] = {
@@ -179,6 +188,7 @@ void test_rotate90_ARGB8888(void)
     TEST_ASSERT_EQUAL_UINT8_ARRAY(expectedArray, dstArray, sizeof(dstArray));
 }
 
+LV_FUNC_SECTION
 void test_rotate180_ARGB8888(void)
 {
     uint32_t srcArray[3 * 2] = {
@@ -203,6 +213,7 @@ void test_rotate180_ARGB8888(void)
     TEST_ASSERT_EQUAL_UINT8_ARRAY(expectedArray, dstArray, sizeof(dstArray));
 }
 
+LV_FUNC_SECTION
 void test_rotate270_ARGB8888(void)
 {
     uint32_t srcArray[3 * 2] = {
@@ -225,6 +236,7 @@ void test_rotate270_ARGB8888(void)
     TEST_ASSERT_EQUAL_UINT8_ARRAY(expectedArray, dstArray, sizeof(dstArray));
 }
 
+LV_FUNC_SECTION
 void test_rotate90_L8(void)
 {
     uint8_t srcArray[3 * 2] = {
@@ -250,6 +262,7 @@ void test_rotate90_L8(void)
 }
 
 
+LV_FUNC_SECTION
 void test_rotate180_L8(void)
 {
     uint8_t srcArray[3 * 2] = {
@@ -271,6 +284,7 @@ void test_rotate180_L8(void)
     TEST_ASSERT_EQUAL_UINT8_ARRAY(expectedArray, dstArray, sizeof(dstArray));
 }
 
+LV_FUNC_SECTION
 void test_rotate270_L8(void)
 {
     uint8_t srcArray[3 * 2] = {
@@ -295,6 +309,7 @@ void test_rotate270_L8(void)
     TEST_ASSERT_EQUAL_UINT8_ARRAY(expectedArray, dstArray, sizeof(dstArray));
 }
 
+LV_FUNC_SECTION
 void test_invert(void)
 {
     uint8_t expected_buf[10] = {0xff, 0xfe, 0xfd, 0xfc, 0xfb, 0xfa, 0xf9, 0xf8, 0xf7, 0xf6};
diff --git a/tests/src/test_cases/draw/test_draw_vector.c b/tests/src/test_cases/draw/test_draw_vector.c
index 914e03ba9..65a65ac55 100644
--- a/tests/src/test_cases/draw/test_draw_vector.c
+++ b/tests/src/test_cases/draw/test_draw_vector.c
@@ -5,16 +5,19 @@
 
 #include "unity/unity.h"
 
+LV_FUNC_SECTION
 void setUp(void)
 {
     /* Function run before every test */
 }
 
+LV_FUNC_SECTION
 void tearDown(void)
 {
     /* Function run after every test */
 }
 
+LV_FUNC_SECTION
 static void draw_shapes(lv_layer_t * layer)
 {
     lv_vector_dsc_t * ctx = lv_vector_dsc_create(layer);
@@ -133,6 +136,7 @@ static void draw_shapes(lv_layer_t * layer)
     lv_vector_dsc_delete(ctx);
 }
 
+LV_FUNC_SECTION
 static void draw_lines(lv_layer_t * layer)
 {
     lv_vector_dsc_t * ctx = lv_vector_dsc_create(layer);
@@ -235,6 +239,7 @@ static void draw_lines(lv_layer_t * layer)
     lv_vector_dsc_delete(ctx);
 }
 
+LV_FUNC_SECTION
 static void canvas_draw(const char * name, void (*draw_cb)(lv_layer_t *))
 {
     LV_UNUSED(name);
@@ -268,6 +273,7 @@ static void canvas_draw(const char * name, void (*draw_cb)(lv_layer_t *))
     lv_obj_delete(canvas);
 }
 
+LV_FUNC_SECTION
 void test_transform(void)
 {
     lv_matrix_t matrix;
@@ -297,16 +303,19 @@ void test_transform(void)
     lv_vector_path_delete(path);
 }
 
+LV_FUNC_SECTION
 void test_draw_lines(void)
 {
     canvas_draw("draw_lines", draw_lines);
 }
 
+LV_FUNC_SECTION
 void test_draw_shapes(void)
 {
     canvas_draw("draw_shapes", draw_shapes);
 }
 
+LV_FUNC_SECTION
 static void event_cb(lv_event_t * e)
 {
     lv_layer_t * layer = lv_event_get_layer(e);
@@ -330,6 +339,7 @@ static void event_cb(lv_event_t * e)
     lv_vector_dsc_delete(dsc);
 }
 
+LV_FUNC_SECTION
 void test_draw_during_rendering(void)
 {
     lv_obj_t * obj = lv_obj_create(lv_screen_active());
diff --git a/tests/src/test_cases/draw/test_image_formats.c b/tests/src/test_cases/draw/test_image_formats.c
index ffe47457f..f0d15946f 100644
--- a/tests/src/test_cases/draw/test_image_formats.c
+++ b/tests/src/test_cases/draw/test_image_formats.c
@@ -221,6 +221,7 @@ static const void * c_array_images[sizeof(stride_align)][sizeof(compressions)][s
     }
 };
 
+LV_FUNC_SECTION
 void setUp(void)
 {
     /* Function run before every test */
@@ -231,11 +232,13 @@ void setUp(void)
 
 }
 
+LV_FUNC_SECTION
 void tearDown(void)
 {
     /* Function run after every test */
 }
 
+LV_FUNC_SECTION
 static void img_create(const char * name, const void * img_src, bool rotate, bool recolor)
 {
     lv_obj_t * cont = lv_obj_create(lv_screen_active());
@@ -255,6 +258,7 @@ static void img_create(const char * name, const void * img_src, bool rotate, boo
     lv_label_set_text(label, name);
 }
 
+LV_FUNC_SECTION
 static void bin_image_create(bool rotate, bool recolor, int align, int compress)
 {
     char name[32];
@@ -268,6 +272,7 @@ static void bin_image_create(bool rotate, bool recolor, int align, int compress)
     }
 }
 
+LV_FUNC_SECTION
 static void c_array_image_create(bool rotate, bool recolor, int align, int compress)
 {
     char name[32];
@@ -278,6 +283,7 @@ static void c_array_image_create(bool rotate, bool recolor, int align, int compr
     }
 }
 
+LV_FUNC_SECTION
 void test_image_formats(void)
 {
     for(unsigned align = 0; align <= 1; align++) {
diff --git a/tests/src/test_cases/draw/test_layer_transform.c b/tests/src/test_cases/draw/test_layer_transform.c
index a5e11693b..3c668bffb 100644
--- a/tests/src/test_cases/draw/test_layer_transform.c
+++ b/tests/src/test_cases/draw/test_layer_transform.c
@@ -4,17 +4,20 @@
 
 #include "unity/unity.h"
 
+LV_FUNC_SECTION
 void setUp(void)
 {
     /* Function run before every test */
 }
 
+LV_FUNC_SECTION
 void tearDown(void)
 {
     /* Function run after every test */
     lv_obj_clean(lv_screen_active());
 }
 
+LV_FUNC_SECTION
 void test_no_residual_border_on_scale_down(void)
 {
     lv_obj_t * obj = lv_obj_create(lv_screen_active());
@@ -42,6 +45,7 @@ void test_no_residual_border_on_scale_down(void)
 
 }
 
+LV_FUNC_SECTION
 void test_update_layer_type_on_state_change(void)
 {
     static lv_style_t style;
diff --git a/tests/src/test_cases/draw/test_render_to_al88.c b/tests/src/test_cases/draw/test_render_to_al88.c
index c65194471..d351eef2e 100644
--- a/tests/src/test_cases/draw/test_render_to_al88.c
+++ b/tests/src/test_cases/draw/test_render_to_al88.c
@@ -5,17 +5,20 @@
 
 #include "unity/unity.h"
 
+LV_FUNC_SECTION
 void setUp(void)
 {
     /* Function run before every test */
 }
 
+LV_FUNC_SECTION
 void tearDown(void)
 {
     /* Function run after every test */
     lv_display_set_color_format(NULL, LV_COLOR_FORMAT_XRGB8888);
 }
 
+LV_FUNC_SECTION
 void test_render_to_al88(void)
 {
 #if LV_USE_DRAW_VG_LITE
diff --git a/tests/src/test_cases/draw/test_render_to_argb8888.c b/tests/src/test_cases/draw/test_render_to_argb8888.c
index 695fed29f..45199414e 100644
--- a/tests/src/test_cases/draw/test_render_to_argb8888.c
+++ b/tests/src/test_cases/draw/test_render_to_argb8888.c
@@ -5,17 +5,20 @@
 
 #include "unity/unity.h"
 
+LV_FUNC_SECTION
 void setUp(void)
 {
     /* Function run before every test */
 }
 
+LV_FUNC_SECTION
 void tearDown(void)
 {
     /* Function run after every test */
     lv_display_set_color_format(NULL, LV_COLOR_FORMAT_XRGB8888);
 }
 
+LV_FUNC_SECTION
 void test_render_to_argb8888(void)
 {
     lv_display_set_color_format(NULL, LV_COLOR_FORMAT_ARGB8888);
diff --git a/tests/src/test_cases/draw/test_render_to_i1.c b/tests/src/test_cases/draw/test_render_to_i1.c
index 7afc93d29..9becfb5d9 100644
--- a/tests/src/test_cases/draw/test_render_to_i1.c
+++ b/tests/src/test_cases/draw/test_render_to_i1.c
@@ -4,17 +4,20 @@
 
 #include "unity/unity.h"
 
+LV_FUNC_SECTION
 void setUp(void)
 {
     /* Function run before every test */
 }
 
+LV_FUNC_SECTION
 void tearDown(void)
 {
     /* Function run after every test */
     lv_display_set_color_format(NULL, LV_COLOR_FORMAT_XRGB8888);
 }
 
+LV_FUNC_SECTION
 void test_render_to_i1(void)
 {
 #if LV_BIN_DECODER_RAM_LOAD && LV_USE_DRAW_VG_LITE == 0
diff --git a/tests/src/test_cases/draw/test_render_to_l8.c b/tests/src/test_cases/draw/test_render_to_l8.c
index 93339b230..5a7fc16ff 100644
--- a/tests/src/test_cases/draw/test_render_to_l8.c
+++ b/tests/src/test_cases/draw/test_render_to_l8.c
@@ -5,17 +5,20 @@
 
 #include "unity/unity.h"
 
+LV_FUNC_SECTION
 void setUp(void)
 {
     /* Function run before every test */
 }
 
+LV_FUNC_SECTION
 void tearDown(void)
 {
     /* Function run after every test */
     lv_display_set_color_format(NULL, LV_COLOR_FORMAT_XRGB8888);
 }
 
+LV_FUNC_SECTION
 void test_render_to_l8(void)
 {
 #if LV_USE_DRAW_VG_LITE
diff --git a/tests/src/test_cases/draw/test_render_to_rgb565.c b/tests/src/test_cases/draw/test_render_to_rgb565.c
index 52d855944..edb89e17a 100644
--- a/tests/src/test_cases/draw/test_render_to_rgb565.c
+++ b/tests/src/test_cases/draw/test_render_to_rgb565.c
@@ -5,17 +5,20 @@
 
 #include "unity/unity.h"
 
+LV_FUNC_SECTION
 void setUp(void)
 {
     /* Function run before every test */
 }
 
+LV_FUNC_SECTION
 void tearDown(void)
 {
     /* Function run after every test */
     lv_display_set_color_format(NULL, LV_COLOR_FORMAT_XRGB8888);
 }
 
+LV_FUNC_SECTION
 void test_render_to_rgb565(void)
 {
     lv_display_set_color_format(NULL, LV_COLOR_FORMAT_RGB565);
diff --git a/tests/src/test_cases/draw/test_render_to_rgb888.c b/tests/src/test_cases/draw/test_render_to_rgb888.c
index 12e72a2bd..1fe0b7b32 100644
--- a/tests/src/test_cases/draw/test_render_to_rgb888.c
+++ b/tests/src/test_cases/draw/test_render_to_rgb888.c
@@ -5,17 +5,20 @@
 
 #include "unity/unity.h"
 
+LV_FUNC_SECTION
 void setUp(void)
 {
     /* Function run before every test */
 }
 
+LV_FUNC_SECTION
 void tearDown(void)
 {
     /* Function run after every test */
     lv_display_set_color_format(NULL, LV_COLOR_FORMAT_XRGB8888);
 }
 
+LV_FUNC_SECTION
 void test_render_to_rgb888(void)
 {
     lv_display_set_color_format(NULL, LV_COLOR_FORMAT_RGB888);
diff --git a/tests/src/test_cases/draw/test_render_to_xrgb8888.c b/tests/src/test_cases/draw/test_render_to_xrgb8888.c
index e21addf2c..859e3b3f6 100644
--- a/tests/src/test_cases/draw/test_render_to_xrgb8888.c
+++ b/tests/src/test_cases/draw/test_render_to_xrgb8888.c
@@ -5,17 +5,20 @@
 
 #include "unity/unity.h"
 
+LV_FUNC_SECTION
 void setUp(void)
 {
     /* Function run before every test */
 }
 
+LV_FUNC_SECTION
 void tearDown(void)
 {
     /* Function run after every test */
     lv_display_set_color_format(NULL, LV_COLOR_FORMAT_XRGB8888);
 }
 
+LV_FUNC_SECTION
 void test_render_to_xrgb8888(void)
 {
     lv_display_set_color_format(NULL, LV_COLOR_FORMAT_XRGB8888);
diff --git a/tests/src/test_cases/libs/test_barcode.c b/tests/src/test_cases/libs/test_barcode.c
index fabd6712c..992990e1d 100644
--- a/tests/src/test_cases/libs/test_barcode.c
+++ b/tests/src/test_cases/libs/test_barcode.c
@@ -8,16 +8,19 @@
 
 static lv_obj_t * active_screen = NULL;
 
+LV_FUNC_SECTION
 void setUp(void)
 {
     active_screen = lv_screen_active();
 }
 
+LV_FUNC_SECTION
 void tearDown(void)
 {
     lv_obj_clean(active_screen);
 }
 
+LV_FUNC_SECTION
 void test_barcode_normal(void)
 {
     lv_obj_t * barcode = lv_barcode_create(active_screen);
@@ -71,14 +74,17 @@ void test_barcode_normal(void)
 
 #else
 
+LV_FUNC_SECTION
 void setUp(void)
 {
 }
 
+LV_FUNC_SECTION
 void tearDown(void)
 {
 }
 
+LV_FUNC_SECTION
 void test_barcode_normal(void)
 {
 }
diff --git a/tests/src/test_cases/libs/test_bin_decoder.c b/tests/src/test_cases/libs/test_bin_decoder.c
index a1d642519..31d26fb75 100644
--- a/tests/src/test_cases/libs/test_bin_decoder.c
+++ b/tests/src/test_cases/libs/test_bin_decoder.c
@@ -4,16 +4,19 @@
 
 #include "unity/unity.h"
 
+LV_FUNC_SECTION
 void setUp(void)
 {
     /* Function run before every test */
 }
 
+LV_FUNC_SECTION
 void tearDown(void)
 {
     lv_obj_clean(lv_screen_active());
 }
 
+LV_FUNC_SECTION
 static void create_image(const void * src)
 {
     lv_obj_t * img = lv_image_create(lv_screen_active());
@@ -21,6 +24,7 @@ static void create_image(const void * src)
     lv_obj_center(img);
 }
 
+LV_FUNC_SECTION
 static void bin_decoder(const void * src, const char * screenshot)
 {
     create_image(src);
@@ -40,6 +44,7 @@ static void bin_decoder(const void * src, const char * screenshot)
     TEST_ASSERT_MEM_LEAK_LESS_THAN(mem_before, 0);
 }
 
+LV_FUNC_SECTION
 static void create_image_tile(const void * src)
 {
     lv_obj_t * img = lv_image_create(lv_screen_active());
@@ -49,6 +54,7 @@ static void create_image_tile(const void * src)
     lv_image_set_inner_align(img, LV_IMAGE_ALIGN_TILE);
 }
 
+LV_FUNC_SECTION
 void bin_decoder_tile(const void * src, const char * screenshot)
 {
     create_image_tile(src);
@@ -68,21 +74,25 @@ void bin_decoder_tile(const void * src, const char * screenshot)
     TEST_ASSERT_MEM_LEAK_LESS_THAN(mem_before, 0);
 }
 
+LV_FUNC_SECTION
 void test_bin_decoder_i4(void)
 {
     LV_IMAGE_DECLARE(test_image_cogwheel_i4);
     bin_decoder(&test_image_cogwheel_i4, "libs/bin_decoder_1.png");
 }
+LV_FUNC_SECTION
 void test_bin_decoder_i4_tile(void)
 {
     LV_IMAGE_DECLARE(test_image_cogwheel_i4);
     bin_decoder_tile(&test_image_cogwheel_i4, "libs/bin_decoder_2.png");
 }
+LV_FUNC_SECTION
 void test_bin_decoder_argb8888(void)
 {
     LV_IMAGE_DECLARE(test_image_cogwheel_argb8888);
     bin_decoder(&test_image_cogwheel_argb8888, "libs/bin_decoder_3.png");
 }
+LV_FUNC_SECTION
 void test_bin_decoder_argb8888_tile(void)
 {
     LV_IMAGE_DECLARE(test_image_cogwheel_argb8888);
diff --git a/tests/src/test_cases/libs/test_bmp.c b/tests/src/test_cases/libs/test_bmp.c
index 6230647d6..7bfbf1310 100644
--- a/tests/src/test_cases/libs/test_bmp.c
+++ b/tests/src/test_cases/libs/test_bmp.c
@@ -5,16 +5,19 @@
 #include "unity/unity.h"
 #include "lv_test_helpers.h"
 
+LV_FUNC_SECTION
 void setUp(void)
 {
     /* Function run before every test */
 }
 
+LV_FUNC_SECTION
 void tearDown(void)
 {
     lv_obj_clean(lv_screen_active());
 }
 
+LV_FUNC_SECTION
 static void create_image(void)
 {
     lv_obj_t * img = lv_image_create(lv_screen_active());
@@ -22,6 +25,7 @@ static void create_image(void)
     lv_obj_center(img);
 }
 
+LV_FUNC_SECTION
 void test_bmp(void)
 {
     create_image();
@@ -41,6 +45,7 @@ void test_bmp(void)
     TEST_ASSERT_MEM_LEAK_LESS_THAN(mem_before, 0);
 }
 
+LV_FUNC_SECTION
 static void create_image_tile(void)
 {
     lv_obj_t * img = lv_image_create(lv_screen_active());
@@ -50,6 +55,7 @@ static void create_image_tile(void)
     lv_image_set_inner_align(img, LV_IMAGE_ALIGN_TILE);
 }
 
+LV_FUNC_SECTION
 void test_bmp_align_tile(void)
 {
     create_image_tile();
diff --git a/tests/src/test_cases/libs/test_font_stress.c b/tests/src/test_cases/libs/test_font_stress.c
index a18a9a2b4..f4cb45bab 100644
--- a/tests/src/test_cases/libs/test_font_stress.c
+++ b/tests/src/test_cases/libs/test_font_stress.c
@@ -78,6 +78,7 @@ static const uint16_t font_style[] = {
  *   STATIC FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 static lv_obj_t * label_create(const char * font_name, lv_obj_t * par, int size, int x, int y)
 {
     uint32_t index = lv_rand(0, sizeof(font_style) / sizeof(uint16_t) - 1);
@@ -106,6 +107,7 @@ static lv_obj_t * label_create(const char * font_name, lv_obj_t * par, int size,
     lv_label_set_text(label, (char *)str);
     return label;
 }
+LV_FUNC_SECTION
 static void label_delete(lv_obj_t * label)
 {
     const lv_font_t * font = lv_obj_get_style_text_font(label, 0);
@@ -113,6 +115,7 @@ static void label_delete(lv_obj_t * label)
     lv_freetype_font_delete((lv_font_t *)font);
     lv_obj_del(label);
 }
+LV_FUNC_SECTION
 static void label_delete_all(stress_test_ctx_t * ctx)
 {
     for(int i = 0; i < ctx->config.label_cnt; i++) {
@@ -123,6 +126,7 @@ static void label_delete_all(stress_test_ctx_t * ctx)
         }
     }
 }
+LV_FUNC_SECTION
 static void update_cb(void)
 {
     stress_test_ctx_t * ctx = &g_ctx;
@@ -150,6 +154,7 @@ static void update_cb(void)
     }
 }
 
+LV_FUNC_SECTION
 void setUp(void)
 {
     lv_freetype_init(LV_FREETYPE_CACHE_FT_GLYPH_CNT);
@@ -169,6 +174,7 @@ void setUp(void)
     lv_rand_set_seed(RND_START_SEED);
 }
 
+LV_FUNC_SECTION
 void tearDown(void)
 {
     label_delete_all(&g_ctx);
@@ -177,6 +183,7 @@ void tearDown(void)
     lv_free(g_ctx.label_arr);
 }
 
+LV_FUNC_SECTION
 void test_font_stress(void)
 {
     for(uint32_t i = 0; g_ctx.config.loop_cnt > 0; g_ctx.config.loop_cnt--) {
@@ -193,14 +200,17 @@ void test_font_stress(void)
 
 #else
 
+LV_FUNC_SECTION
 void setUp(void)
 {
 }
 
+LV_FUNC_SECTION
 void tearDown(void)
 {
 }
 
+LV_FUNC_SECTION
 void test_font_stress(void)
 {
 }
diff --git a/tests/src/test_cases/libs/test_freetype.c b/tests/src/test_cases/libs/test_freetype.c
index 86768938b..e5698f9bc 100644
--- a/tests/src/test_cases/libs/test_freetype.c
+++ b/tests/src/test_cases/libs/test_freetype.c
@@ -391,16 +391,19 @@ static void vegravis_generate_vector_ops_string(lv_freetype_outline_event_param_
                                                 uint32_t buf_len);
 #endif
 
+LV_FUNC_SECTION
 void setUp(void)
 {
     /* Function run before every test */
 }
 
+LV_FUNC_SECTION
 void tearDown(void)
 {
     /* Function run after every test */
 }
 
+LV_FUNC_SECTION
 void test_freetype_bitmap_rendering_test(void)
 {
     /*Create a font*/
@@ -459,6 +462,7 @@ void test_freetype_bitmap_rendering_test(void)
     TEST_FREETYPE_ASSERT_EQUAL_SCREENSHOT("1");
 }
 
+LV_FUNC_SECTION
 void test_freetype_outline_rendering_test(void)
 {
     /*Create a font*/
@@ -511,6 +515,7 @@ void test_freetype_outline_rendering_test(void)
     lv_freetype_font_delete(font_italic);
 }
 
+LV_FUNC_SECTION
 static void freetype_outline_event_cb(lv_event_t * e)
 {
     lv_event_code_t code = lv_event_get_code(e);
@@ -536,6 +541,7 @@ static void freetype_outline_event_cb(lv_event_t * e)
 }
 
 #if OPTION_GENERATE_VECTOR_OPS_STRING
+LV_FUNC_SECTION
 static void vegravis_generate_vector_ops_string(lv_freetype_outline_event_param_t * param, char * buf, uint32_t buf_len)
 {
     float x, y, p1x, p1y, p2x, p2y;
@@ -571,18 +577,22 @@ static void vegravis_generate_vector_ops_string(lv_freetype_outline_event_param_
 
 #else
 
+LV_FUNC_SECTION
 void setUp(void)
 {
 }
 
+LV_FUNC_SECTION
 void tearDown(void)
 {
 }
 
+LV_FUNC_SECTION
 void test_freetype_bitmap_rendering_test(void)
 {
 }
 
+LV_FUNC_SECTION
 void test_freetype_outline_rendering_test(void)
 {
 }
diff --git a/tests/src/test_cases/libs/test_libjpeg_turbo.c b/tests/src/test_cases/libs/test_libjpeg_turbo.c
index b084de569..d328a3021 100644
--- a/tests/src/test_cases/libs/test_libjpeg_turbo.c
+++ b/tests/src/test_cases/libs/test_libjpeg_turbo.c
@@ -5,16 +5,19 @@
 #include "unity/unity.h"
 #include "lv_test_helpers.h"
 
+LV_FUNC_SECTION
 void setUp(void)
 {
     /* Function run before every test */
 }
 
+LV_FUNC_SECTION
 void tearDown(void)
 {
     /* Function run after every test */
 }
 
+LV_FUNC_SECTION
 static void create_images(void)
 {
     lv_obj_clean(lv_screen_active());
@@ -55,6 +58,7 @@ static void create_images(void)
     lv_obj_align(label, LV_ALIGN_CENTER, 150, 150);
 }
 
+LV_FUNC_SECTION
 void test_jpg_2(void)
 {
     /* Temporarily remove tjpgd decoder */
diff --git a/tests/src/test_cases/libs/test_libpng.c b/tests/src/test_cases/libs/test_libpng.c
index 714eab355..39f416915 100644
--- a/tests/src/test_cases/libs/test_libpng.c
+++ b/tests/src/test_cases/libs/test_libpng.c
@@ -5,16 +5,19 @@
 #include "unity/unity.h"
 #include "lv_test_helpers.h"
 
+LV_FUNC_SECTION
 void setUp(void)
 {
     /* Function run before every test */
 }
 
+LV_FUNC_SECTION
 void tearDown(void)
 {
     /* Function run after every test */
 }
 
+LV_FUNC_SECTION
 static void create_images(void)
 {
     lv_obj_clean(lv_screen_active());
@@ -51,6 +54,7 @@ static void create_images(void)
     lv_obj_align(label, LV_ALIGN_CENTER, 100, 100);
 }
 
+LV_FUNC_SECTION
 void test_libpng_1(void)
 {
     /* Temporarily remove lodepng decoder */
diff --git a/tests/src/test_cases/libs/test_lodepng.c b/tests/src/test_cases/libs/test_lodepng.c
index 5f3f1cf78..8cfd9b435 100644
--- a/tests/src/test_cases/libs/test_lodepng.c
+++ b/tests/src/test_cases/libs/test_lodepng.c
@@ -5,16 +5,19 @@
 #include "unity/unity.h"
 #include "lv_test_helpers.h"
 
+LV_FUNC_SECTION
 void setUp(void)
 {
     /* Function run before every test */
 }
 
+LV_FUNC_SECTION
 void tearDown(void)
 {
     /* Function run after every test */
 }
 
+LV_FUNC_SECTION
 static void create_images(void)
 {
     lv_obj_clean(lv_screen_active());
@@ -51,6 +54,7 @@ static void create_images(void)
     lv_obj_align(label, LV_ALIGN_CENTER, 100, 100);
 }
 
+LV_FUNC_SECTION
 void test_lodepng_1(void)
 {
     /* Temporarily remove libpng decoder */
diff --git a/tests/src/test_cases/libs/test_memmove.c b/tests/src/test_cases/libs/test_memmove.c
index cb28a5b73..495fa0cb5 100644
--- a/tests/src/test_cases/libs/test_memmove.c
+++ b/tests/src/test_cases/libs/test_memmove.c
@@ -5,16 +5,19 @@
 #include "unity/unity.h"
 #include "lv_test_helpers.h"
 
+LV_FUNC_SECTION
 void setUp(void)
 {
     /* Function run before every test */
 }
 
+LV_FUNC_SECTION
 void tearDown(void)
 {
     /* Function run after every test */
 }
 
+LV_FUNC_SECTION
 void test_memmove(void)
 {
 #if LV_USE_STDLIB_STRING == LV_STDLIB_BUILTIN
diff --git a/tests/src/test_cases/libs/test_qrcode.c b/tests/src/test_cases/libs/test_qrcode.c
index 4720b20f4..6caab4bab 100644
--- a/tests/src/test_cases/libs/test_qrcode.c
+++ b/tests/src/test_cases/libs/test_qrcode.c
@@ -9,16 +9,19 @@
 
 static lv_obj_t * active_screen = NULL;
 
+LV_FUNC_SECTION
 void setUp(void)
 {
     active_screen = lv_screen_active();
 }
 
+LV_FUNC_SECTION
 void tearDown(void)
 {
     lv_obj_clean(active_screen);
 }
 
+LV_FUNC_SECTION
 void test_barcode_normal(void)
 {
     lv_color_t bg_color = lv_palette_lighten(LV_PALETTE_LIGHT_BLUE, 5);
@@ -44,14 +47,17 @@ void test_barcode_normal(void)
 
 #else
 
+LV_FUNC_SECTION
 void setUp(void)
 {
 }
 
+LV_FUNC_SECTION
 void tearDown(void)
 {
 }
 
+LV_FUNC_SECTION
 void test_barcode_normal(void)
 {
 }
diff --git a/tests/src/test_cases/libs/test_tiny_ttf.c b/tests/src/test_cases/libs/test_tiny_ttf.c
index 2f82b765d..ac3598ed9 100644
--- a/tests/src/test_cases/libs/test_tiny_ttf.c
+++ b/tests/src/test_cases/libs/test_tiny_ttf.c
@@ -4,16 +4,19 @@
 
 #include "unity/unity.h"
 
+LV_FUNC_SECTION
 void setUp(void)
 {
     /* Function run before every test */
 }
 
+LV_FUNC_SECTION
 void tearDown(void)
 {
     /* Function run after every test */
 }
 
+LV_FUNC_SECTION
 void test_tiny_ttf_rendering_test(void)
 {
 #if LV_USE_TINY_TTF
@@ -49,6 +52,7 @@ void test_tiny_ttf_rendering_test(void)
 #endif
 }
 
+LV_FUNC_SECTION
 void test_tiny_ttf_kerning(void)
 {
 #if LV_USE_TINY_TTF
diff --git a/tests/src/test_cases/libs/test_tjpgd.c b/tests/src/test_cases/libs/test_tjpgd.c
index 2ee8422d3..0b5338c0f 100644
--- a/tests/src/test_cases/libs/test_tjpgd.c
+++ b/tests/src/test_cases/libs/test_tjpgd.c
@@ -5,16 +5,19 @@
 #include "unity/unity.h"
 #include "lv_test_helpers.h"
 
+LV_FUNC_SECTION
 void setUp(void)
 {
     /* Function run before every test */
 }
 
+LV_FUNC_SECTION
 void tearDown(void)
 {
     lv_obj_clean(lv_screen_active());
 }
 
+LV_FUNC_SECTION
 static void create_images(void)
 {
     lv_obj_clean(lv_screen_active());
@@ -40,6 +43,7 @@ static void create_images(void)
     lv_obj_align(label, LV_ALIGN_CENTER, 100, 20);
 }
 
+LV_FUNC_SECTION
 void test_tjpgd_1(void)
 {
     /* Temporarily remove libjpeg_turbo decoder */
@@ -65,6 +69,7 @@ void test_tjpgd_1(void)
     lv_libjpeg_turbo_init();
 }
 
+LV_FUNC_SECTION
 static void create_image_2(void)
 {
     LV_IMG_DECLARE(test_img_lvgl_logo_jpg);
@@ -75,6 +80,7 @@ static void create_image_2(void)
     lv_image_set_inner_align(img, LV_IMAGE_ALIGN_TILE);
 }
 
+LV_FUNC_SECTION
 void test_jdpgd_align_tile(void)
 {
     /* Temporarily remove libjpeg_turbo decoder */
diff --git a/tests/src/test_cases/test_align_flex.c b/tests/src/test_cases/test_align_flex.c
index feb6cf8a6..16a515175 100644
--- a/tests/src/test_cases/test_align_flex.c
+++ b/tests/src/test_cases/test_align_flex.c
@@ -6,16 +6,19 @@
 
 static lv_obj_t * active_screen = NULL;
 
+LV_FUNC_SECTION
 void setUp(void)
 {
     active_screen = lv_screen_active();
 }
 
+LV_FUNC_SECTION
 void tearDown(void)
 {
     lv_obj_clean(active_screen);
 }
 
+LV_FUNC_SECTION
 static void simple_style(lv_obj_t * obj)
 {
     lv_obj_set_style_radius(obj, 0, LV_PART_MAIN);
@@ -27,6 +30,7 @@ static void simple_style(lv_obj_t * obj)
     lv_obj_set_style_outline_width(obj, 0, LV_PART_MAIN);
 }
 
+LV_FUNC_SECTION
 static lv_obj_t * create_row(lv_flex_align_t main_place, int n_children)
 {
     lv_obj_t * row = lv_obj_create(lv_screen_active());
@@ -43,6 +47,7 @@ static lv_obj_t * create_row(lv_flex_align_t main_place, int n_children)
     return row;
 }
 
+LV_FUNC_SECTION
 void test_align(void)
 {
     create_row(LV_FLEX_ALIGN_CENTER, 1);
diff --git a/tests/src/test_cases/test_anim.c b/tests/src/test_cases/test_anim.c
index 3f041aaf4..c7e8f4859 100644
--- a/tests/src/test_cases/test_anim.c
+++ b/tests/src/test_cases/test_anim.c
@@ -5,28 +5,33 @@
 #include "unity/unity.h"
 #include "lv_test_helpers.h"
 
+LV_FUNC_SECTION
 void setUp(void)
 {
     /* Function run before every test */
 }
 
+LV_FUNC_SECTION
 void tearDown(void)
 {
     /* Function run after every test */
 }
 
+LV_FUNC_SECTION
 static void exec_cb(void * var, int32_t v)
 {
     int32_t * var_i32 = var;
     *var_i32 = v;
 }
 
+LV_FUNC_SECTION
 static void custom_exec_cb(lv_anim_t * a, int32_t v)
 {
     int32_t * var_i32 = a->var;
     *var_i32 = v;
 }
 
+LV_FUNC_SECTION
 void test_anim_delete(void)
 {
     int32_t var;
@@ -59,6 +64,7 @@ void test_anim_delete(void)
     TEST_ASSERT_EQUAL(39, var);
 }
 
+LV_FUNC_SECTION
 void test_anim_delete_custom(void)
 {
     int32_t var;
diff --git a/tests/src/test_cases/test_anim_timeline.c b/tests/src/test_cases/test_anim_timeline.c
index c97f7340f..cb74475e8 100644
--- a/tests/src/test_cases/test_anim_timeline.c
+++ b/tests/src/test_cases/test_anim_timeline.c
@@ -13,12 +13,14 @@ static uint32_t anim2_start_called;
 static uint32_t anim1_completed_called;
 static uint32_t anim2_completed_called;
 
+LV_FUNC_SECTION
 void setUp(void)
 {
     /* Function run before every test */
     anim_timeline = NULL;
 }
 
+LV_FUNC_SECTION
 void tearDown(void)
 {
     /* Function run after every test */
@@ -26,6 +28,7 @@ void tearDown(void)
     lv_obj_clean(lv_screen_active());
 }
 
+LV_FUNC_SECTION
 void test_anim_timeline_progress_1(void)
 {
     lv_obj_t * obj = lv_obj_create(lv_screen_active());
@@ -86,6 +89,7 @@ void test_anim_timeline_progress_1(void)
 
 }
 
+LV_FUNC_SECTION
 void test_anim_timeline_progress_2(void)
 {
     lv_obj_t * obj = lv_obj_create(lv_screen_active());
@@ -150,6 +154,7 @@ void test_anim_timeline_progress_2(void)
     TEST_ASSERT_EQUAL(300, lv_obj_get_y(obj));
 }
 
+LV_FUNC_SECTION
 void test_anim_timeline_start(void)
 {
     lv_obj_t * obj = lv_obj_create(lv_screen_active());
@@ -241,6 +246,7 @@ void test_anim_timeline_start(void)
     TEST_ASSERT_EQUAL(20, lv_obj_get_x(obj));
 }
 
+LV_FUNC_SECTION
 void test_anim_timeline_reverse(void)
 {
     lv_obj_t * obj = lv_obj_create(lv_screen_active());
@@ -327,6 +333,7 @@ void test_anim_timeline_reverse(void)
     TEST_ASSERT_EQUAL(20, lv_obj_get_x(obj));
 }
 
+LV_FUNC_SECTION
 void test_anim_timeline_repeat(void)
 {
     lv_obj_t * obj = lv_obj_create(lv_screen_active());
@@ -383,6 +390,7 @@ void test_anim_timeline_repeat(void)
 }
 
 
+LV_FUNC_SECTION
 void test_anim_timeline_delay(void)
 {
 
@@ -439,38 +447,45 @@ void test_anim_timeline_delay(void)
 
 }
 
+__attribute__(( fptrgroup("lv_anim_exec_cb") ))
 void anim1_exec_cb(void * var, int32_t v)
 {
     LV_UNUSED(var);
     LV_UNUSED(v);
 }
+LV_FUNC_SECTION
 void anim1_start(lv_anim_t * a)
 {
     LV_UNUSED(a);
     anim1_start_called++;
 }
+LV_FUNC_SECTION
 void anim1_completed(lv_anim_t * a)
 {
     LV_UNUSED(a);
     anim1_completed_called++;
 }
 
+__attribute__(( fptrgroup("lv_anim_exec_cb") ))
 void anim2_exec_cb(void * var, int32_t v)
 {
     LV_UNUSED(var);
     LV_UNUSED(v);
 }
+LV_FUNC_SECTION
 void anim2_start(lv_anim_t * a)
 {
     LV_UNUSED(a);
     anim2_start_called++;
 }
+LV_FUNC_SECTION
 void anim2_completed(lv_anim_t * a)
 {
     LV_UNUSED(a);
     anim2_completed_called++;
 }
 
+LV_FUNC_SECTION
 void test_anim_timeline_with_anim_start_cb_and_completed_cb(void)
 {
     lv_anim_t anim1;
diff --git a/tests/src/test_cases/test_area.c b/tests/src/test_cases/test_area.c
index e683acc66..4bfb52d50 100644
--- a/tests/src/test_cases/test_area.c
+++ b/tests/src/test_cases/test_area.c
@@ -6,17 +6,20 @@
 
 #define PCT_MAX_VALUE 268435455
 
+LV_FUNC_SECTION
 void setUp(void)
 {
     /* Function run before every test */
 }
 
+LV_FUNC_SECTION
 void tearDown(void)
 {
     /* Function run after every test */
     lv_obj_clean(lv_screen_active());
 }
 
+LV_FUNC_SECTION
 void test_pct(void)
 {
     int32_t pct_val;
diff --git a/tests/src/test_cases/test_array.c b/tests/src/test_cases/test_array.c
index 604b21f96..7be640032 100644
--- a/tests/src/test_cases/test_array.c
+++ b/tests/src/test_cases/test_array.c
@@ -6,16 +6,19 @@
 
 static lv_array_t array;
 
+LV_FUNC_SECTION
 void setUp(void)
 {
     lv_array_init(&array, LV_ARRAY_DEFAULT_CAPACITY, sizeof(int32_t));
 }
 
+LV_FUNC_SECTION
 void tearDown(void)
 {
     lv_array_deinit(&array);
 }
 
+LV_FUNC_SECTION
 void test_array_append_values(void)
 {
     const int32_t new_size = LV_ARRAY_DEFAULT_CAPACITY + 2;
@@ -27,6 +30,7 @@ void test_array_append_values(void)
     TEST_ASSERT_EQUAL_UINT32(new_size, lv_array_size(&array));
 }
 
+LV_FUNC_SECTION
 void test_array_set_get(void)
 {
     int32_t v = 100;
@@ -35,6 +39,7 @@ void test_array_set_get(void)
     TEST_ASSERT_EQUAL_UINT32(100, *r);
 }
 
+LV_FUNC_SECTION
 void test_array_size(void)
 {
     for(int32_t i = 0; i < 10; i++) {
@@ -47,6 +52,7 @@ void test_array_size(void)
     TEST_ASSERT_EQUAL_UINT32(0, lv_array_size(&array));
 }
 
+LV_FUNC_SECTION
 void test_array_resize(void)
 {
     for(int32_t i = 0; i < LV_ARRAY_DEFAULT_CAPACITY; i++) {
@@ -62,6 +68,7 @@ void test_array_resize(void)
     TEST_ASSERT_EQUAL_UINT32(6, lv_array_capacity(&array));
 }
 
+LV_FUNC_SECTION
 void test_array_copy(void)
 {
     for(int32_t i = 0; i < LV_ARRAY_DEFAULT_CAPACITY; i++) {
@@ -78,6 +85,7 @@ void test_array_copy(void)
     lv_array_deinit(&array2);
 }
 
+LV_FUNC_SECTION
 void test_array_concat(void)
 {
     lv_array_t a, b;
diff --git a/tests/src/test_cases/test_bindings.c b/tests/src/test_cases/test_bindings.c
index 47eaa08f5..aa492d8ea 100644
--- a/tests/src/test_cases/test_bindings.c
+++ b/tests/src/test_cases/test_bindings.c
@@ -13,16 +13,19 @@ static lv_obj_t * list_button_create(lv_obj_t * parent);
 static void opa_anim_cb(void * var, int32_t v);
 static void draw_to_canvas(lv_obj_t * canvas);
 
+LV_FUNC_SECTION
 void setUp(void)
 {
     /* Function run before every test */
 }
 
+LV_FUNC_SECTION
 void tearDown(void)
 {
     /* Function run after every test */
 }
 
+LV_FUNC_SECTION
 void test_binding(void)
 {
     create_ui();
@@ -33,6 +36,7 @@ void test_binding(void)
     TEST_ASSERT_EQUAL_SCREENSHOT("binding.png");
 }
 
+LV_FUNC_SECTION
 static void create_ui(void)
 {
     /*Create a colors*/
@@ -194,6 +198,7 @@ static void create_ui(void)
     lv_image_set_scale_x(img, 400);
 }
 
+LV_FUNC_SECTION
 static void chart_type_observer_cb(lv_observer_t * observer, lv_subject_t * subject)
 {
     int32_t v = lv_subject_get_int(subject);
@@ -201,6 +206,7 @@ static void chart_type_observer_cb(lv_observer_t * observer, lv_subject_t * subj
     lv_chart_set_type(chart, v == 0 ? LV_CHART_TYPE_LINE : LV_CHART_TYPE_BAR);
 }
 
+LV_FUNC_SECTION
 static void buttonmatrix_event_cb(lv_event_t * e)
 {
     lv_obj_t * label = lv_event_get_user_data(e);
@@ -211,6 +217,7 @@ static void buttonmatrix_event_cb(lv_event_t * e)
     lv_label_set_text(label, text);
 }
 
+LV_FUNC_SECTION
 static lv_obj_t * list_button_create(lv_obj_t * parent)
 {
     lv_obj_t * btn = lv_button_create(parent);
@@ -226,11 +233,13 @@ static lv_obj_t * list_button_create(lv_obj_t * parent)
     return btn;
 }
 
+LV_FUNC_SECTION
 static void opa_anim_cb(void * var, int32_t v)
 {
     lv_obj_set_style_opa(var, v, 0);
 }
 
+LV_FUNC_SECTION
 static void draw_to_canvas(lv_obj_t * canvas)
 {
     lv_layer_t layer;
diff --git a/tests/src/test_cases/test_config.c b/tests/src/test_cases/test_config.c
index c852d2ea2..3cd865e09 100644
--- a/tests/src/test_cases/test_config.c
+++ b/tests/src/test_cases/test_config.c
@@ -6,6 +6,7 @@
 
 void test_config(void);
 
+LV_FUNC_SECTION
 void test_config(void)
 {
     TEST_ASSERT_EQUAL(130, LV_DPI_DEF);
diff --git a/tests/src/test_cases/test_demo_stress.c b/tests/src/test_cases/test_demo_stress.c
index 56ee06744..249fa7994 100644
--- a/tests/src/test_cases/test_demo_stress.c
+++ b/tests/src/test_cases/test_demo_stress.c
@@ -8,6 +8,7 @@
 #include "lv_test_helpers.h"
 #include "lv_test_indev.h"
 
+LV_FUNC_SECTION
 static void loop_through_stress_test(void)
 {
 #if LV_USE_DEMO_STRESS
@@ -20,6 +21,7 @@ static void loop_through_stress_test(void)
     }
 #endif
 }
+LV_FUNC_SECTION
 void test_demo_stress(void)
 {
 #if LV_USE_DEMO_STRESS
diff --git a/tests/src/test_cases/test_demo_widgets.c b/tests/src/test_cases/test_demo_widgets.c
index b9c5e55e3..2f4cb7555 100644
--- a/tests/src/test_cases/test_demo_widgets.c
+++ b/tests/src/test_cases/test_demo_widgets.c
@@ -8,6 +8,7 @@
 #include "lv_test_helpers.h"
 #include "lv_test_indev.h"
 
+LV_FUNC_SECTION
 void test_demo_widgets(void)
 {
 #if LV_USE_DEMO_WIDGETS
diff --git a/tests/src/test_cases/test_draw_buf_stride.c b/tests/src/test_cases/test_draw_buf_stride.c
index a3ec51e37..15b82677b 100644
--- a/tests/src/test_cases/test_draw_buf_stride.c
+++ b/tests/src/test_cases/test_draw_buf_stride.c
@@ -5,16 +5,19 @@
 #include "unity/unity.h"
 #include "lv_test_helpers.h"
 
+LV_FUNC_SECTION
 void setUp(void)
 {
     /* Function run before every test */
 }
 
+LV_FUNC_SECTION
 void tearDown(void)
 {
     /* Function run after every test */
 }
 
+LV_FUNC_SECTION
 void test_draw_buf_stride_adjust(void)
 {
 #if LV_BIN_DECODER_RAM_LOAD == 1
diff --git a/tests/src/test_cases/test_event.c b/tests/src/test_cases/test_event.c
index ee5186dda..5c7ca4b69 100644
--- a/tests/src/test_cases/test_event.c
+++ b/tests/src/test_cases/test_event.c
@@ -5,6 +5,7 @@
 #include "unity/unity.h"
 #include "lv_test_indev.h"
 
+LV_FUNC_SECTION
 static void event_object_deletion_cb(const lv_obj_class_t * cls, lv_event_t * e)
 {
     LV_UNUSED(cls);
@@ -19,6 +20,7 @@ static const lv_obj_class_t event_object_deletion_class = {
 };
 
 /* Checks for memory leaks/invalid memory accesses on deleted objects */
+LV_FUNC_SECTION
 void test_event_object_deletion(void)
 {
     lv_obj_t * obj = lv_obj_class_create_obj(&event_object_deletion_class, lv_screen_active());
@@ -26,6 +28,7 @@ void test_event_object_deletion(void)
 }
 
 /* Add and then remove event should not memory leak */
+LV_FUNC_SECTION
 void test_event_should_not_memory_lean(void)
 {
     lv_mem_monitor_t monitor;
@@ -51,24 +54,28 @@ static uint32_t post_cnt_2;
 static bool pre_stop_1;
 static bool post_stop_1;
 
+LV_FUNC_SECTION
 static void event_pre_1_cb(lv_event_t * e)
 {
     pre_cnt_1++;
     if(pre_stop_1) lv_event_stop_processing(e);
 }
 
+LV_FUNC_SECTION
 static void event_pre_2_cb(lv_event_t * e)
 {
     LV_UNUSED(e);
     pre_cnt_2++;
 }
 
+LV_FUNC_SECTION
 static void event_post_1_cb(lv_event_t * e)
 {
     post_cnt_1++;
     if(post_stop_1) lv_event_stop_processing(e);
 }
 
+LV_FUNC_SECTION
 static void event_post_2_cb(lv_event_t * e)
 {
     LV_UNUSED(e);
@@ -76,6 +83,7 @@ static void event_post_2_cb(lv_event_t * e)
 }
 
 /* Add and then remove event should not memory leak */
+LV_FUNC_SECTION
 void test_event_stop_processing(void)
 {
     lv_obj_t * btn = lv_button_create(lv_screen_active());
diff --git a/tests/src/test_cases/test_font_loader.c b/tests/src/test_cases/test_font_loader.c
index 26a4d7524..2b7b1306b 100644
--- a/tests/src/test_cases/test_font_loader.c
+++ b/tests/src/test_cases/test_font_loader.c
@@ -55,17 +55,20 @@ static lv_font_t * font_1_bin = NULL;
 static lv_font_t * font_2_bin = NULL;
 static lv_font_t * font_3_bin = NULL;
 
+LV_FUNC_SECTION
 void setUp(void)
 {
     /* Function run before every test */
 }
 
+LV_FUNC_SECTION
 void tearDown(void)
 {
     /* Function run after every test */
 
 }
 
+LV_FUNC_SECTION
 static void common(void)
 {
     compare_fonts(&test_font_1, font_1_bin);
@@ -97,6 +100,7 @@ static void common(void)
     lv_binfont_destroy(font_3_bin);
 }
 
+LV_FUNC_SECTION
 void test_font_loader_with_cache(void)
 {
     /*Test with cache ('A' has cache)*/
@@ -113,6 +117,7 @@ void test_font_loader_with_cache(void)
     common();
 }
 
+LV_FUNC_SECTION
 void test_font_loader_no_cache(void)
 {
     /*Test without cache ('B' has NO cache)*/
@@ -129,6 +134,7 @@ void test_font_loader_no_cache(void)
     common();
 }
 
+LV_FUNC_SECTION
 void test_font_loader_from_buffer(void)
 {
     /*Test with memfs*/
@@ -145,6 +151,7 @@ void test_font_loader_from_buffer(void)
     common();
 }
 
+LV_FUNC_SECTION
 void test_font_loader_reload(void)
 {
     /*Reload a font which is being used by a label*/
@@ -178,6 +185,7 @@ void test_font_loader_reload(void)
     lv_binfont_destroy(font);
 }
 
+LV_FUNC_SECTION
 static int compare_fonts(lv_font_t * f1, lv_font_t * f2)
 {
     TEST_ASSERT_NOT_NULL_MESSAGE(f1, "font not null");
diff --git a/tests/src/test_cases/test_fs.c b/tests/src/test_cases/test_fs.c
index 25ca52825..a04795940 100644
--- a/tests/src/test_cases/test_fs.c
+++ b/tests/src/test_cases/test_fs.c
@@ -12,11 +12,13 @@ static void read_range(lv_fs_file_t * f, uint32_t from, uint32_t to);
 
 static void read_random_drv(char drv_letter, uint32_t cache_size);
 
+LV_FUNC_SECTION
 void setUp(void)
 {
     /* Function run before every test */
 }
 
+LV_FUNC_SECTION
 void tearDown(void)
 {
     /* Function run after every test */
@@ -25,6 +27,7 @@ void tearDown(void)
 #include <errno.h>
 #include <unistd.h>
 
+LV_FUNC_SECTION
 void test_read(void)
 {
     lv_fs_res_t res;
@@ -65,6 +68,7 @@ void test_read(void)
     lv_fs_close(&fb);
 }
 
+LV_FUNC_SECTION
 void test_read_random(void)
 {
     read_random_drv('A', 8);
@@ -84,6 +88,7 @@ void test_read_random(void)
  * Read bytes from the `from` index to the `to index`
  * Assume that file `f` has 256 byte of content 0..255
  */
+LV_FUNC_SECTION
 static void read_range(lv_fs_file_t * f, uint32_t from, uint32_t to)
 {
     lv_fs_seek(f, from, LV_FS_SEEK_SET);
@@ -101,6 +106,7 @@ static void read_range(lv_fs_file_t * f, uint32_t from, uint32_t to)
     }
 }
 
+LV_FUNC_SECTION
 static void read_next(lv_fs_file_t * f, uint32_t from, uint32_t len)
 {
     uint8_t buf_rd[256];
@@ -115,6 +121,7 @@ static void read_next(lv_fs_file_t * f, uint32_t from, uint32_t len)
     }
 }
 
+LV_FUNC_SECTION
 static void read_random_drv(char drv_letter, uint32_t cache_size)
 {
     /*Hack to force a small cache size*/
@@ -179,6 +186,7 @@ static void read_random_drv(char drv_letter, uint32_t cache_size)
     drv->cache_size = original_cache_size;
 }
 
+LV_FUNC_SECTION
 void test_write_read_random(void)
 {
     lv_fs_drv_t * drv = lv_fs_get_drv('A');
diff --git a/tests/src/test_cases/test_grid.c b/tests/src/test_cases/test_grid.c
index 865678145..cb40d0fa1 100644
--- a/tests/src/test_cases/test_grid.c
+++ b/tests/src/test_cases/test_grid.c
@@ -4,17 +4,20 @@
 
 #include "unity/unity.h"
 
+LV_FUNC_SECTION
 void setUp(void)
 {
     /* Function run before every test */
     lv_obj_clean(lv_screen_active());
 }
 
+LV_FUNC_SECTION
 void tearDown(void)
 {
     /* Function run after every test */
 }
 
+LV_FUNC_SECTION
 static void button_create(lv_obj_t * parent, const char * text, int32_t x, int32_t y)
 {
     lv_obj_t * btn = lv_button_create(parent);
@@ -26,6 +29,7 @@ static void button_create(lv_obj_t * parent, const char * text, int32_t x, int32
 
 }
 
+LV_FUNC_SECTION
 void test_subgrid_row(void)
 {
 
@@ -56,6 +60,7 @@ void test_subgrid_row(void)
     TEST_ASSERT_EQUAL_SCREENSHOT("subgrid_row.png");
 }
 
+LV_FUNC_SECTION
 void test_subgrid_col(void)
 {
 
diff --git a/tests/src/test_cases/test_grid_fr.c b/tests/src/test_cases/test_grid_fr.c
index c8d09c7cd..4c433015c 100644
--- a/tests/src/test_cases/test_grid_fr.c
+++ b/tests/src/test_cases/test_grid_fr.c
@@ -5,11 +5,13 @@
 
 static lv_obj_t * active_screen = NULL;
 
+LV_FUNC_SECTION
 void setUp(void)
 {
     active_screen = lv_screen_active();
 }
 
+LV_FUNC_SECTION
 void tearDown(void)
 {
     lv_obj_clean(active_screen);
@@ -19,6 +21,7 @@ void tearDown(void)
  * Tests that green/blue checker pattern of various row and column sizes
  * completely covers underyling screen, no red background visible.
  */
+LV_FUNC_SECTION
 void test_grid_fr(void)
 {
     static int32_t col_dsc[] = {3 * 9, LV_GRID_FR(1), LV_GRID_FR(2), LV_GRID_FR(3), LV_GRID_FR(4), LV_GRID_TEMPLATE_LAST};
diff --git a/tests/src/test_cases/test_gridnav.c b/tests/src/test_cases/test_gridnav.c
index 014a74772..6ae1174ed 100644
--- a/tests/src/test_cases/test_gridnav.c
+++ b/tests/src/test_cases/test_gridnav.c
@@ -12,6 +12,7 @@ static struct {
     lv_obj_t * obj;
 } g_key_data;
 
+LV_FUNC_SECTION
 void setUp(void)
 {
     g_screen = lv_screen_active();
@@ -19,12 +20,14 @@ void setUp(void)
     g_key_data.press_happened = false;
 }
 
+LV_FUNC_SECTION
 void tearDown(void)
 {
     lv_obj_clean(g_screen);
     lv_group_delete(g_group); /* also removes all indevs set to the group */
 }
 
+LV_FUNC_SECTION
 static void key_event_cb(lv_event_t * e)
 {
     TEST_ASSERT_FALSE(g_key_data.press_happened);
@@ -33,6 +36,7 @@ static void key_event_cb(lv_event_t * e)
     g_key_data.obj = lv_event_get_target_obj(e);
 }
 
+LV_FUNC_SECTION
 static void gridnav_one_axis_move_only(uint32_t key_grid_axis_next,
                                        uint32_t key_grid_axis_prev,
                                        uint32_t key_obj_axis_next,
@@ -91,6 +95,7 @@ static void gridnav_one_axis_move_only(uint32_t key_grid_axis_next,
     TEST_ASSERT_FALSE(g_key_data.press_happened);
 }
 
+LV_FUNC_SECTION
 void test_gridnav_vertical_move_only(void)
 {
     gridnav_one_axis_move_only(LV_KEY_DOWN,
@@ -101,6 +106,7 @@ void test_gridnav_vertical_move_only(void)
                                LV_FLEX_FLOW_COLUMN);
 }
 
+LV_FUNC_SECTION
 void test_gridnav_horizontal_move_only(void)
 {
     gridnav_one_axis_move_only(LV_KEY_RIGHT,
diff --git a/tests/src/test_cases/test_group.c b/tests/src/test_cases/test_group.c
index 2c4d55c8a..bbe2be9bd 100644
--- a/tests/src/test_cases/test_group.c
+++ b/tests/src/test_cases/test_group.c
@@ -4,14 +4,17 @@
 
 #include "unity/unity.h"
 
+LV_FUNC_SECTION
 void setUp(void)
 {
 }
 
+LV_FUNC_SECTION
 void tearDown(void)
 {
 }
 
+LV_FUNC_SECTION
 void test_group_count(void)
 {
     lv_group_t * group_1 = lv_group_create();
@@ -26,6 +29,7 @@ void test_group_count(void)
     TEST_ASSERT_EQUAL_UINT32(lv_group_get_count(), 0U);
 }
 
+LV_FUNC_SECTION
 void test_group_by_index(void)
 {
     lv_group_t * group_1 = lv_group_create();
@@ -39,6 +43,7 @@ void test_group_by_index(void)
     lv_group_delete(group_2);
 }
 
+LV_FUNC_SECTION
 void test_group_obj_by_index(void)
 {
     lv_group_t * group = lv_group_create();
diff --git a/tests/src/test_cases/test_hover.c b/tests/src/test_cases/test_hover.c
index 66cbcfb0c..835f226e3 100644
--- a/tests/src/test_cases/test_hover.c
+++ b/tests/src/test_cases/test_hover.c
@@ -22,23 +22,27 @@ static const lv_point_t pointer2[] = {
     {0, 0}, {60, 100}, {80, 100}, {120, 120}, {0, 0},
 };
 
+LV_FUNC_SECTION
 void setUp(void)
 {
     /* Function run before every test */
 }
 
+LV_FUNC_SECTION
 void tearDown(void)
 {
     /* Function run after every test */
     lv_obj_clean(lv_screen_active());
 }
 
+LV_FUNC_SECTION
 static void hovered_event_cb(lv_event_t * e)
 {
     test_hover_t * hover = lv_event_get_user_data(e);
     lv_log("Object(ID:%s) hovered %u/%d times.\n", hover->id, hover->counts, TEST_HOVER_COUNTS);
 }
 
+LV_FUNC_SECTION
 static void test_move_mouse(lv_point_t * point, uint8_t size)
 {
     lv_point_t * p = point;
@@ -51,6 +55,7 @@ static void test_move_mouse(lv_point_t * point, uint8_t size)
     }
 }
 
+LV_FUNC_SECTION
 void test_hover_basic(void)
 {
     lv_obj_t * label = lv_label_create(lv_screen_active());
@@ -79,6 +84,7 @@ void test_hover_basic(void)
     test_move_mouse((lv_point_t *)pointer2, 5);
 }
 
+LV_FUNC_SECTION
 void test_hover_delete(void)
 {
     for(int i = 0; i < 4; i++) {
diff --git a/tests/src/test_cases/test_margin_align.c b/tests/src/test_cases/test_margin_align.c
index 12d118e0f..b82405913 100644
--- a/tests/src/test_cases/test_margin_align.c
+++ b/tests/src/test_cases/test_margin_align.c
@@ -6,16 +6,19 @@
 
 static lv_obj_t * active_screen = NULL;
 
+LV_FUNC_SECTION
 void setUp(void)
 {
     active_screen = lv_screen_active();
 }
 
+LV_FUNC_SECTION
 void tearDown(void)
 {
     lv_obj_clean(active_screen);
 }
 
+LV_FUNC_SECTION
 lv_obj_t * obj_create(lv_obj_t * parent, lv_color_t color)
 {
     lv_obj_t * obj = lv_obj_create(parent);
@@ -26,6 +29,7 @@ lv_obj_t * obj_create(lv_obj_t * parent, lv_color_t color)
     return obj;
 }
 
+LV_FUNC_SECTION
 void obj_set_margin(lv_obj_t * obj, int32_t left, int32_t top, int32_t right, int32_t bottom)
 {
     lv_obj_set_style_margin_left(obj, left, LV_PART_MAIN);
@@ -35,6 +39,7 @@ void obj_set_margin(lv_obj_t * obj, int32_t left, int32_t top, int32_t right, in
 }
 
 // takes no effect on position but size.
+LV_FUNC_SECTION
 void test_align(void)
 {
     lv_obj_t * obj0 = active_screen;
diff --git a/tests/src/test_cases/test_margin_flex.c b/tests/src/test_cases/test_margin_flex.c
index e52c03db5..faaa32ca2 100644
--- a/tests/src/test_cases/test_margin_flex.c
+++ b/tests/src/test_cases/test_margin_flex.c
@@ -6,16 +6,19 @@
 
 static lv_obj_t * active_screen = NULL;
 
+LV_FUNC_SECTION
 void setUp(void)
 {
     active_screen = lv_screen_active();
 }
 
+LV_FUNC_SECTION
 void tearDown(void)
 {
     lv_obj_clean(active_screen);
 }
 
+LV_FUNC_SECTION
 lv_obj_t * obj_create(lv_obj_t * parent, lv_color_t color)
 {
     lv_obj_t * obj = lv_obj_create(parent);
@@ -26,6 +29,7 @@ lv_obj_t * obj_create(lv_obj_t * parent, lv_color_t color)
     return obj;
 }
 
+LV_FUNC_SECTION
 void obj_set_margin(lv_obj_t * obj, int32_t left, int32_t top, int32_t right, int32_t bottom)
 {
     lv_obj_set_style_margin_left(obj, left, LV_PART_MAIN);
@@ -34,6 +38,7 @@ void obj_set_margin(lv_obj_t * obj, int32_t left, int32_t top, int32_t right, in
     lv_obj_set_style_margin_bottom(obj, bottom, LV_PART_MAIN);
 }
 
+LV_FUNC_SECTION
 void test_flex(void)
 {
 #define N 5
diff --git a/tests/src/test_cases/test_margin_grid.c b/tests/src/test_cases/test_margin_grid.c
index 57e8392ca..cb06d1110 100644
--- a/tests/src/test_cases/test_margin_grid.c
+++ b/tests/src/test_cases/test_margin_grid.c
@@ -6,16 +6,19 @@
 
 static lv_obj_t * active_screen = NULL;
 
+LV_FUNC_SECTION
 void setUp(void)
 {
     active_screen = lv_screen_active();
 }
 
+LV_FUNC_SECTION
 void tearDown(void)
 {
     lv_obj_clean(active_screen);
 }
 
+LV_FUNC_SECTION
 lv_obj_t * obj_create(lv_obj_t * parent, lv_color_t color)
 {
     lv_obj_t * obj = lv_obj_create(parent);
@@ -26,6 +29,7 @@ lv_obj_t * obj_create(lv_obj_t * parent, lv_color_t color)
     return obj;
 }
 
+LV_FUNC_SECTION
 void obj_set_margin(lv_obj_t * obj, int32_t left, int32_t top, int32_t right, int32_t bottom)
 {
     lv_obj_set_style_margin_left(obj, left, LV_PART_MAIN);
@@ -34,6 +38,7 @@ void obj_set_margin(lv_obj_t * obj, int32_t left, int32_t top, int32_t right, in
     lv_obj_set_style_margin_bottom(obj, bottom, LV_PART_MAIN);
 }
 
+LV_FUNC_SECTION
 void test_grid(void)
 {
 #define M 5
diff --git a/tests/src/test_cases/test_math.c b/tests/src/test_cases/test_math.c
index 880a0dc77..9e6d79ed3 100644
--- a/tests/src/test_cases/test_math.c
+++ b/tests/src/test_cases/test_math.c
@@ -7,6 +7,7 @@
 #define ERROR_THRESHOLD         5 /*5 in 1024, 0.5% max error allowed*/
 #define NEWTON_ITERATIONS       8
 
+LV_FUNC_SECTION
 static float do_cubic_bezier_f(float t, float a, float b, float c)
 {
     /*a*t^3 + b*t^2 + c*t*/
@@ -22,6 +23,7 @@ static float do_cubic_bezier_f(float t, float a, float b, float c)
  * @param y2 y of control point 2 in range of [0..1]
  * @return the value calculated
  */
+LV_FUNC_SECTION
 static float lv_cubic_bezier_f(float x, float x1, float y1, float x2, float y2)
 {
     float ax, bx, cx, ay, by, cy;
@@ -75,6 +77,7 @@ found:
     return do_cubic_bezier_f(t, ay, by, cy);
 }
 
+LV_FUNC_SECTION
 static int test_cubic_bezier_ease_functions(float fx1, float fy1, float fx2, float fy2)
 {
     int x1, y1, x2, y2, y;
@@ -97,6 +100,7 @@ static int test_cubic_bezier_ease_functions(float fx1, float fy1, float fx2, flo
     return 1;
 }
 
+LV_FUNC_SECTION
 static uint32_t lv_bezier3_legacy(uint32_t t, uint32_t u0, uint32_t u1, uint32_t u2, uint32_t u3)
 {
     uint32_t t_rem  = 1024 - t;
@@ -113,6 +117,7 @@ static uint32_t lv_bezier3_legacy(uint32_t t, uint32_t u0, uint32_t u1, uint32_t
     return v1 + v2 + v3 + v4;
 }
 
+LV_FUNC_SECTION
 void test_math_cubic_bezier_result_should_be_precise(void)
 {
     /*ease-in-out function*/
diff --git a/tests/src/test_cases/test_mem.c b/tests/src/test_cases/test_mem.c
index ddb998286..496026ff2 100644
--- a/tests/src/test_cases/test_mem.c
+++ b/tests/src/test_cases/test_mem.c
@@ -4,17 +4,20 @@
 
 #include "unity/unity.h"
 
+LV_FUNC_SECTION
 void setUp(void)
 {
     /* Function run before every test */
 }
 
+LV_FUNC_SECTION
 void tearDown(void)
 {
     /* Function run after every test */
 }
 
 /* #3324 */
+LV_FUNC_SECTION
 void test_mem_buf_realloc(void)
 {
 #ifdef LVGL_CI_USING_DEF_HEAP
diff --git a/tests/src/test_cases/test_observer.c b/tests/src/test_cases/test_observer.c
index ac7673834..30b7d408c 100644
--- a/tests/src/test_cases/test_observer.c
+++ b/tests/src/test_cases/test_observer.c
@@ -5,11 +5,13 @@
 #include "unity/unity.h"
 #include "lv_test_indev.h"
 
+LV_FUNC_SECTION
 void setUp(void)
 {
     /* Function run before every test */
 }
 
+LV_FUNC_SECTION
 void tearDown(void)
 {
     /* Function run after every test */
@@ -19,6 +21,7 @@ void tearDown(void)
 static int32_t prev_v;
 static int32_t current_v;
 
+LV_FUNC_SECTION
 static void observer_int(lv_observer_t * observer, lv_subject_t * subject)
 {
     LV_UNUSED(observer);
@@ -26,6 +29,7 @@ static void observer_int(lv_observer_t * observer, lv_subject_t * subject)
     current_v = lv_subject_get_int(subject);
 }
 
+LV_FUNC_SECTION
 void test_observer_add_remove(void)
 {
     static lv_subject_t subject;
@@ -48,6 +52,7 @@ void test_observer_add_remove(void)
     TEST_ASSERT_EQUAL_PTR(NULL, observer);   /*The observer must be NULL*/
 }
 
+LV_FUNC_SECTION
 void test_observer_int(void)
 {
     static lv_subject_t subject;
@@ -77,6 +82,7 @@ void test_observer_int(void)
     TEST_ASSERT_EQUAL(10, lv_subject_get_previous_int(&subject));
 }
 
+LV_FUNC_SECTION
 void test_observer_string(void)
 {
     char buf_current[32];
@@ -118,6 +124,7 @@ void test_observer_string(void)
     TEST_ASSERT_EQUAL_STRING("text to be clipped to 32 chars.", lv_subject_get_previous_string(&subject));
 }
 
+LV_FUNC_SECTION
 void test_observer_pointer(void)
 {
     static int32_t a[3] = {0};
@@ -149,6 +156,7 @@ void test_observer_pointer(void)
     TEST_ASSERT_EQUAL_PTR(&a[1], lv_subject_get_previous_pointer(&subject));
 }
 
+LV_FUNC_SECTION
 void test_observer_color(void)
 {
     static lv_subject_t subject;
@@ -181,6 +189,7 @@ void test_observer_color(void)
 
 static int32_t group_observer_called;
 
+LV_FUNC_SECTION
 static void group_observer_cb(lv_observer_t * observer, lv_subject_t * subject)
 {
     LV_UNUSED(observer);
@@ -188,6 +197,7 @@ static void group_observer_cb(lv_observer_t * observer, lv_subject_t * subject)
     group_observer_called++;
 }
 
+LV_FUNC_SECTION
 void test_observer_group(void)
 {
     static lv_subject_t subject_main;
@@ -215,6 +225,7 @@ void test_observer_group(void)
     TEST_ASSERT_EQUAL(3, group_observer_called);
 }
 
+LV_FUNC_SECTION
 void test_observer_obj_flag(void)
 {
     lv_obj_t * obj = lv_obj_create(lv_screen_active());
@@ -246,6 +257,7 @@ void test_observer_obj_flag(void)
     TEST_ASSERT_EQUAL(false, lv_obj_has_flag(obj, LV_OBJ_FLAG_CHECKABLE));
 }
 
+LV_FUNC_SECTION
 void test_observer_obj_state(void)
 {
     lv_obj_t * obj = lv_obj_create(lv_screen_active());
@@ -277,6 +289,7 @@ void test_observer_obj_state(void)
     TEST_ASSERT_EQUAL(false, lv_obj_has_state(obj, LV_STATE_DISABLED));
 }
 
+LV_FUNC_SECTION
 void test_observer_button_checked(void)
 {
     lv_obj_t * obj = lv_button_create(lv_screen_active());
@@ -304,6 +317,7 @@ void test_observer_button_checked(void)
     TEST_ASSERT_EQUAL(1, lv_subject_get_int(&subject));
 }
 
+LV_FUNC_SECTION
 void test_observer_label_text_normal(void)
 {
     lv_obj_t * obj = lv_label_create(lv_screen_active());
@@ -352,6 +366,7 @@ void test_observer_label_text_normal(void)
     TEST_ASSERT_EQUAL_STRING("WORLD", lv_label_get_text(obj));
 }
 
+LV_FUNC_SECTION
 void test_observer_label_text_formatted(void)
 {
     lv_obj_t * obj = lv_label_create(lv_screen_active());
@@ -408,6 +423,7 @@ void test_observer_label_text_formatted(void)
     TEST_ASSERT_EQUAL_STRING("pointer: WORLD", lv_label_get_text(obj));
 }
 
+LV_FUNC_SECTION
 void test_observer_arc_value(void)
 {
     lv_obj_t * obj = lv_arc_create(lv_screen_active());
@@ -434,6 +450,7 @@ void test_observer_arc_value(void)
     TEST_ASSERT_EQUAL(50, lv_subject_get_int(&subject));
 }
 
+LV_FUNC_SECTION
 void test_observer_slider_value(void)
 {
     lv_obj_t * obj = lv_slider_create(lv_screen_active());
@@ -464,6 +481,7 @@ void test_observer_slider_value(void)
     TEST_ASSERT_EQUAL(29, lv_subject_get_int(&subject));
 }
 
+LV_FUNC_SECTION
 void test_observer_roller_value(void)
 {
     lv_obj_t * obj = lv_roller_create(lv_screen_active());
@@ -484,6 +502,7 @@ void test_observer_roller_value(void)
     TEST_ASSERT_EQUAL(1, lv_subject_get_int(&subject));
 }
 
+LV_FUNC_SECTION
 void test_observer_dropdown_value(void)
 {
     lv_obj_t * obj = lv_dropdown_create(lv_screen_active());
@@ -505,6 +524,7 @@ void test_observer_dropdown_value(void)
     TEST_ASSERT_EQUAL(0, lv_subject_get_int(&subject));
 }
 
+LV_FUNC_SECTION
 void test_observer_deinit(void)
 {
     static lv_subject_t subject;
diff --git a/tests/src/test_cases/test_profiler.c b/tests/src/test_cases/test_profiler.c
index 4aef90d92..92aa724b4 100644
--- a/tests/src/test_cases/test_profiler.c
+++ b/tests/src/test_cases/test_profiler.c
@@ -12,11 +12,13 @@ static uint32_t profiler_tick = 0;
 static int output_line = 0;
 static char output_buf[OUTPUT_LINE_MAX][OUTPUT_BUF_MAX];
 
+LV_FUNC_SECTION
 static uint32_t get_tick_cb(void)
 {
     return profiler_tick++;
 }
 
+LV_FUNC_SECTION
 static void flush_cb(const char * buf)
 {
     TEST_ASSERT_LESS_THAN(OUTPUT_LINE_MAX, output_line);
@@ -26,6 +28,7 @@ static void flush_cb(const char * buf)
     output_line++;
 }
 
+LV_FUNC_SECTION
 void setUp(void)
 {
     lv_profiler_builtin_config_t config;
@@ -37,11 +40,13 @@ void setUp(void)
     lv_profiler_builtin_init(&config);
 }
 
+LV_FUNC_SECTION
 void tearDown(void)
 {
     lv_profiler_builtin_uninit();
 }
 
+LV_FUNC_SECTION
 void test_profiler_normal(void)
 {
     /* enable profiler */
@@ -70,6 +75,7 @@ void test_profiler_normal(void)
     TEST_ASSERT_EQUAL_STRING(output_buf[3], "   LVGL-1 [0] 3.000000: tracing_mark_write: E|1|custom_tag\n");
 }
 
+LV_FUNC_SECTION
 void test_profiler_disable(void)
 {
     /* disable profiler */
diff --git a/tests/src/test_cases/test_screen_load.c b/tests/src/test_cases/test_screen_load.c
index 7af5e5374..bfece9445 100644
--- a/tests/src/test_cases/test_screen_load.c
+++ b/tests/src/test_cases/test_screen_load.c
@@ -4,6 +4,7 @@
 
 #include "unity/unity.h"
 
+LV_FUNC_SECTION
 void test_screen_load_no_crash(void)
 {
     /*Delete active screen and load new screen should not crash*/
@@ -19,6 +20,7 @@ void test_screen_load_no_crash(void)
     lv_screen_load_anim(screen_with_anim_2, LV_SCR_LOAD_ANIM_OVER_RIGHT, 1000, 500, false);
 }
 
+LV_FUNC_SECTION
 void test_screen_load_with_delete_no_crash(void)
 {
     /*Delete active screen and load new screen should not crash*/
@@ -51,6 +53,7 @@ void test_screen_load_with_delete_no_crash(void)
     TEST_ASSERT_EQUAL(lv_obj_is_valid(screen_with_anim_3), true);
 }
 
+LV_FUNC_SECTION
 void test_screen_load_with_delete_no_crash2(void)
 {
     /*Delete active screen and load new screen should not crash*/
@@ -88,12 +91,14 @@ void test_screen_load_with_delete_no_crash2(void)
 
 static bool screen_1_unloaded_called = false;
 
+LV_FUNC_SECTION
 static void screen_with_anim_1_unloaded_cb(lv_event_t * e)
 {
     LV_UNUSED(e);
     screen_1_unloaded_called = true;
 }
 
+LV_FUNC_SECTION
 void test_screen_load_with_delete_event(void)
 {
     /*Delete active screen and load new screen should not crash*/
diff --git a/tests/src/test_cases/test_snapshot.c b/tests/src/test_cases/test_snapshot.c
index 462d18b07..eb7c4bdfa 100644
--- a/tests/src/test_cases/test_snapshot.c
+++ b/tests/src/test_cases/test_snapshot.c
@@ -8,6 +8,7 @@
 
 #define NUM_SNAPSHOTS 10
 
+LV_FUNC_SECTION
 void test_snapshot_should_not_leak_memory(void)
 {
     uint32_t idx = 0;
@@ -35,6 +36,7 @@ void test_snapshot_should_not_leak_memory(void)
     TEST_ASSERT_EQUAL(initial_available_memory, final_available_memory);
 }
 
+LV_FUNC_SECTION
 void test_snapshot_with_transform_should_not_leak_memory(void)
 {
     uint32_t idx = 0;
@@ -68,6 +70,7 @@ void test_snapshot_with_transform_should_not_leak_memory(void)
     TEST_ASSERT_EQUAL(initial_available_memory, final_available_memory);
 }
 
+LV_FUNC_SECTION
 void test_snapshot_take_snapshot_immediately_after_obj_create(void)
 {
     lv_obj_t * label = lv_label_create(lv_screen_active());
@@ -92,6 +95,7 @@ void test_snapshot_take_snapshot_immediately_after_obj_create(void)
     lv_draw_buf_destroy(draw_dsc);
 }
 
+LV_FUNC_SECTION
 void test_snapshot_take_snapshot_with_transform(void)
 {
     lv_obj_t * label = lv_label_create(lv_screen_active());
@@ -114,21 +118,25 @@ void test_snapshot_take_snapshot_with_transform(void)
 
 #else /*LV_USE_SNAPSHOT*/
 
+LV_FUNC_SECTION
 void test_snapshot_should_not_leak_memory(void)
 {
 
 }
 
+LV_FUNC_SECTION
 void test_snapshot_with_transform_should_not_leak_memory(void)
 {
 
 }
 
+LV_FUNC_SECTION
 void test_snapshot_take_snapshot_immediately_after_obj_create(void)
 {
 
 }
 
+LV_FUNC_SECTION
 void test_snapshot_take_snapshot_with_transform(void)
 {
 
diff --git a/tests/src/test_cases/test_style.c b/tests/src/test_cases/test_style.c
index 4454df892..94fc2e4ca 100644
--- a/tests/src/test_cases/test_style.c
+++ b/tests/src/test_cases/test_style.c
@@ -5,11 +5,13 @@
 #include "unity/unity.h"
 #include <unistd.h>
 
+LV_FUNC_SECTION
 static void obj_set_height_helper(void * obj, int32_t height)
 {
     lv_obj_set_height((lv_obj_t *)obj, (int32_t)height);
 }
 
+LV_FUNC_SECTION
 void test_gradient_vertical_misalignment(void)
 {
     /* Tests gradient caching as the height of widget changes.*/
@@ -42,6 +44,7 @@ void test_gradient_vertical_misalignment(void)
     }
 }
 
+LV_FUNC_SECTION
 void test_custom_prop_ids(void)
 {
     uint8_t fake_flag = 0;
@@ -79,6 +82,7 @@ const lv_style_const_prop_t const_style_props[] = {
 
 LV_STYLE_CONST_INIT(const_style, const_style_props);
 
+LV_FUNC_SECTION
 void test_const_style(void)
 {
     lv_obj_t * obj = lv_obj_create(lv_screen_active());
@@ -87,6 +91,7 @@ void test_const_style(void)
     TEST_ASSERT_EQUAL(50, lv_obj_get_style_height(obj, LV_PART_MAIN));
 }
 
+LV_FUNC_SECTION
 void test_style_replacement(void)
 {
     /*Define styles*/
@@ -118,6 +123,7 @@ void test_style_replacement(void)
     lv_style_reset(&style_blue);
 }
 
+LV_FUNC_SECTION
 void test_style_has_prop(void)
 {
     lv_style_t style;
diff --git a/tests/src/test_cases/test_txt.c b/tests/src/test_cases/test_txt.c
index 2d36a3984..621b2119c 100644
--- a/tests/src/test_cases/test_txt.c
+++ b/tests/src/test_cases/test_txt.c
@@ -6,6 +6,7 @@
 #include "../../../src/misc/lv_text_private.h"
 #include <string.h>
 
+LV_FUNC_SECTION
 void test_txt_should_insert_string_into_another(void)
 {
     const char * msg = "Hello ";
@@ -20,6 +21,7 @@ void test_txt_should_insert_string_into_another(void)
     TEST_ASSERT_EQUAL_STRING("Hello World", target);
 }
 
+LV_FUNC_SECTION
 void test_txt_should_handle_null_pointers_when_inserting(void)
 {
     const char * msg = "Hello ";
@@ -33,11 +35,13 @@ void test_txt_should_handle_null_pointers_when_inserting(void)
     TEST_ASSERT_EQUAL_STRING("Hello ", target);
 }
 
+LV_FUNC_SECTION
 void test_txt_cut_should_handle_null_pointer_to_txt(void)
 {
     lv_text_cut(NULL, 0, 6);
 }
 
+LV_FUNC_SECTION
 void test_txt_cut_happy_path(void)
 {
     char msg[] = "Hello World";
@@ -47,6 +51,7 @@ void test_txt_cut_happy_path(void)
     TEST_ASSERT_EQUAL_STRING("World", msg);
 }
 
+LV_FUNC_SECTION
 void test_txt_cut_should_handle_len_longer_than_string_length(void)
 {
     char msg[] = "Hello World";
@@ -56,6 +61,7 @@ void test_txt_cut_should_handle_len_longer_than_string_length(void)
     TEST_ASSERT_EQUAL_UINT8(msg[0], 0x00);
 }
 
+LV_FUNC_SECTION
 void test_txt_get_encoded_next_should_decode_valid_ascii(void)
 {
     char msg[] = "Hello World!";
@@ -66,6 +72,7 @@ void test_txt_get_encoded_next_should_decode_valid_ascii(void)
     TEST_ASSERT_EQUAL_UINT32((uint32_t) 'H', result);
 }
 
+LV_FUNC_SECTION
 void test_txt_get_encoded_next_detect_valid_2_byte_input(void)
 {
     char msg[] = "\xc3\xb1";
@@ -76,6 +83,7 @@ void test_txt_get_encoded_next_detect_valid_2_byte_input(void)
     TEST_ASSERT_EQUAL_UINT32(241, result);
 }
 
+LV_FUNC_SECTION
 void test_txt_get_encoded_next_detect_invalid_2_byte_input(void)
 {
     char msg[] = "\xc3\x28";
@@ -86,6 +94,7 @@ void test_txt_get_encoded_next_detect_invalid_2_byte_input(void)
     TEST_ASSERT_EQUAL_UINT32(0, result);
 }
 
+LV_FUNC_SECTION
 void test_txt_get_encoded_next_detect_valid_3_byte_input(void)
 {
     char msg[] = "\xe2\x82\xa1";
@@ -96,6 +105,7 @@ void test_txt_get_encoded_next_detect_valid_3_byte_input(void)
     TEST_ASSERT_EQUAL_UINT32(8353, result);
 }
 
+LV_FUNC_SECTION
 void test_txt_get_encoded_next_detect_invalid_3_byte_input(void)
 {
     char msg[] = "\xe2\x28\xa1";
@@ -106,6 +116,7 @@ void test_txt_get_encoded_next_detect_invalid_3_byte_input(void)
     TEST_ASSERT_EQUAL_UINT32(0, result);
 }
 
+LV_FUNC_SECTION
 void test_txt_get_encoded_next_detect_valid_4_byte_input(void)
 {
     char msg[] = "\xf0\x90\x8c\xbc";
@@ -116,6 +127,7 @@ void test_txt_get_encoded_next_detect_valid_4_byte_input(void)
     TEST_ASSERT_EQUAL_UINT32(66364, result);
 }
 
+LV_FUNC_SECTION
 void test_txt_get_encoded_next_detect_invalid_4_byte_input(void)
 {
     char msg[] = "\xf0\x28\x8c\x28";
@@ -127,6 +139,7 @@ void test_txt_get_encoded_next_detect_invalid_4_byte_input(void)
 }
 
 /* See #2615 for more information */
+LV_FUNC_SECTION
 void test_txt_next_line_should_handle_empty_string(void)
 {
     const lv_font_t * font_ptr = NULL;
diff --git a/tests/src/test_cases/widgets/test_animimg.c b/tests/src/test_cases/widgets/test_animimg.c
index 4bba8ebe5..903c57b4d 100644
--- a/tests/src/test_cases/widgets/test_animimg.c
+++ b/tests/src/test_cases/widgets/test_animimg.c
@@ -27,22 +27,26 @@ void test_animimg_set_duration(void);
 void test_animimg_set_repeat_count_infinite(void);
 void test_animimg_start(void);
 
+LV_FUNC_SECTION
 void setUp(void)
 {
     active_screen = lv_screen_active();
     animimg = lv_animimg_create(active_screen);
 }
 
+LV_FUNC_SECTION
 void tearDown(void)
 {
     lv_obj_clean(active_screen);
 }
 
+LV_FUNC_SECTION
 void test_animimg_successful_create(void)
 {
     TEST_ASSERT_NOT_NULL(animimg);
 }
 
+LV_FUNC_SECTION
 void test_animimg_set_src(void)
 {
     lv_animimg_set_src(animimg, (const void **) anim_imgs, 3);
@@ -50,6 +54,7 @@ void test_animimg_set_src(void)
     TEST_ASSERT_NOT_NULL(animimg);
 }
 
+LV_FUNC_SECTION
 void test_animimg_get_src(void)
 {
     lv_animimg_set_src(animimg, (const void **) anim_imgs, 3);
@@ -60,6 +65,7 @@ void test_animimg_get_src(void)
     TEST_ASSERT_EQUAL_PTR(actual_dsc, anim_imgs);
 }
 
+LV_FUNC_SECTION
 void test_animimg_get_src_count(void)
 {
     uint8_t expected_count = 3;
@@ -71,6 +77,7 @@ void test_animimg_get_src_count(void)
     TEST_ASSERT_EQUAL_UINT8(actual_count, expected_count);
 }
 
+LV_FUNC_SECTION
 void test_animimg_set_duration(void)
 {
     uint16_t expected_duration = 1000;
@@ -82,6 +89,7 @@ void test_animimg_set_duration(void)
     TEST_ASSERT_EQUAL_UINT16(actual_duration, expected_duration);
 }
 
+LV_FUNC_SECTION
 void test_animimg_set_repeat_count_infinite(void)
 {
     lv_animimg_set_repeat_count(animimg, LV_ANIM_REPEAT_INFINITE);
@@ -91,6 +99,7 @@ void test_animimg_set_repeat_count_infinite(void)
     TEST_ASSERT_EQUAL_UINT32(actual_count, LV_ANIM_REPEAT_INFINITE);
 }
 
+LV_FUNC_SECTION
 void test_animimg_start(void)
 {
     // for lv_animimg_start() to actually work,
diff --git a/tests/src/test_cases/widgets/test_arc.c b/tests/src/test_cases/widgets/test_arc.c
index ef82688ab..e674a225b 100644
--- a/tests/src/test_cases/widgets/test_arc.c
+++ b/tests/src/test_cases/widgets/test_arc.c
@@ -25,17 +25,20 @@ static uint32_t event_cnt2;
 static void dummy_event_cb(lv_event_t * e);
 static void dummy_event_cb2(lv_event_t * e);
 
+LV_FUNC_SECTION
 void setUp(void)
 {
     active_screen = lv_screen_active();
 }
 
+LV_FUNC_SECTION
 void tearDown(void)
 {
     lv_obj_clean(active_screen);
     lv_obj_set_style_layout(active_screen, LV_LAYOUT_NONE, 0);
 }
 
+LV_FUNC_SECTION
 void test_arc_creation_successful(void)
 {
     arc = lv_arc_create(active_screen);
@@ -43,6 +46,7 @@ void test_arc_creation_successful(void)
     TEST_ASSERT_NOT_NULL(arc);
 }
 
+LV_FUNC_SECTION
 void test_arc_basic_render(void)
 {
     arc = lv_arc_create(active_screen);
@@ -53,6 +57,7 @@ void test_arc_basic_render(void)
     TEST_ASSERT_EQUAL_SCREENSHOT("widgets/arc_1.png");
 }
 
+LV_FUNC_SECTION
 void test_arc_rgb565a8_image(void)
 {
 #if LV_BIN_DECODER_RAM_LOAD
@@ -71,6 +76,7 @@ void test_arc_rgb565a8_image(void)
 #endif
 }
 
+LV_FUNC_SECTION
 void test_arc_should_truncate_to_max_range_when_new_value_exceeds_it(void)
 {
     /* Default max range is 100 */
@@ -83,6 +89,7 @@ void test_arc_should_truncate_to_max_range_when_new_value_exceeds_it(void)
     TEST_ASSERT_EQUAL_INT16(value_after_truncation, lv_arc_get_value(arc));
 }
 
+LV_FUNC_SECTION
 void test_arc_should_truncate_to_min_range_when_new_value_is_inferior(void)
 {
     /* Default min range is 100 */
@@ -95,6 +102,7 @@ void test_arc_should_truncate_to_min_range_when_new_value_is_inferior(void)
     TEST_ASSERT_EQUAL_INT16(value_after_truncation, lv_arc_get_value(arc));
 }
 
+LV_FUNC_SECTION
 void test_arc_should_update_value_after_updating_range(void)
 {
     int16_t value_after_updating_max_range = 50;
@@ -113,6 +121,7 @@ void test_arc_should_update_value_after_updating_range(void)
     TEST_ASSERT_EQUAL_INT16(value_after_updating_min_range, lv_arc_get_value(arc));
 }
 
+LV_FUNC_SECTION
 void test_arc_should_update_angles_when_changing_to_symmetrical_mode(void)
 {
     int16_t expected_angle_start = 135;
@@ -126,6 +135,7 @@ void test_arc_should_update_angles_when_changing_to_symmetrical_mode(void)
     TEST_ASSERT_EQUAL_INT16(expected_angle_end, lv_arc_get_angle_end(arc));
 }
 
+LV_FUNC_SECTION
 void test_arc_should_update_angles_when_changing_to_symmetrical_mode_value_more_than_middle_range(void)
 {
     int16_t expected_angle_start = 270;
@@ -141,6 +151,7 @@ void test_arc_should_update_angles_when_changing_to_symmetrical_mode_value_more_
 }
 
 /* See #2522 for more information */
+LV_FUNC_SECTION
 void test_arc_angles_when_reversed(void)
 {
     uint16_t expected_start_angle = 54;
@@ -161,6 +172,7 @@ void test_arc_angles_when_reversed(void)
     TEST_ASSERT_EQUAL_INT16(expected_value, lv_arc_get_value(arcBlack));
 }
 
+LV_FUNC_SECTION
 void test_arc_click_area_with_adv_hittest(void)
 {
     arc = lv_arc_create(lv_screen_active());
@@ -197,6 +209,7 @@ void test_arc_click_area_with_adv_hittest(void)
 }
 
 /* Check value doesn't go to max when clicking on the other side of the arc */
+LV_FUNC_SECTION
 void test_arc_click_sustained_from_start_to_end_does_not_set_value_to_max(void)
 {
     arc = lv_arc_create(lv_screen_active());
@@ -239,6 +252,7 @@ void test_arc_click_sustained_from_start_to_end_does_not_set_value_to_max(void)
     TEST_ASSERT_EQUAL_SCREENSHOT("widgets/arc_3.png");
 }
 
+LV_FUNC_SECTION
 void test_two_overlapping_arcs_can_be_interacted_independently(void)
 {
     arc = lv_arc_create(lv_screen_active());
@@ -298,12 +312,14 @@ void test_two_overlapping_arcs_can_be_interacted_independently(void)
 }
 
 
+LV_FUNC_SECTION
 static void dummy_event_cb(lv_event_t * e)
 {
     LV_UNUSED(e);
     event_cnt++;
 }
 
+LV_FUNC_SECTION
 static void dummy_event_cb2(lv_event_t * e)
 {
     LV_UNUSED(e);
diff --git a/tests/src/test_cases/widgets/test_bar.c b/tests/src/test_cases/widgets/test_bar.c
index a6fa8f58f..30b770e67 100644
--- a/tests/src/test_cases/widgets/test_bar.c
+++ b/tests/src/test_cases/widgets/test_bar.c
@@ -9,17 +9,20 @@
 static lv_obj_t * g_active_screen = NULL;
 static lv_obj_t * g_bar = NULL;
 
+LV_FUNC_SECTION
 void setUp(void)
 {
     g_active_screen = lv_screen_active();
     g_bar = lv_bar_create(g_active_screen);
 }
 
+LV_FUNC_SECTION
 void tearDown(void)
 {
     lv_obj_clean(g_active_screen);
 }
 
+LV_FUNC_SECTION
 void test_bar_should_have_valid_default_attributes(void)
 {
     TEST_ASSERT_EQUAL(0, lv_bar_get_min_value(g_bar));
@@ -43,6 +46,7 @@ void test_bar_should_have_valid_default_attributes(void)
  * - max value: 100
  * - base direction: LTR
  */
+LV_FUNC_SECTION
 void test_bar_should_update_indicator_right_coordinate_based_on_bar_value(void)
 {
     lv_bar_t * bar_ptr = (lv_bar_t *) g_bar;
@@ -96,6 +100,7 @@ void test_bar_should_update_indicator_right_coordinate_based_on_bar_value(void)
  * - min value: 0
  * - max value: 100
  */
+LV_FUNC_SECTION
 void test_bar_rtl_should_update_indicator_left_coordinate_based_on_bar_value(void)
 {
     lv_bar_t * bar_ptr = (lv_bar_t *) g_bar;
@@ -136,6 +141,7 @@ void test_bar_rtl_should_update_indicator_left_coordinate_based_on_bar_value(voi
     TEST_ASSERT_EQUAL_INT32(expected_coord, actual_coord);
 }
 
+LV_FUNC_SECTION
 void test_bar_normal(void)
 {
     int32_t w = 300;
@@ -206,6 +212,7 @@ void test_bar_normal(void)
     TEST_ASSERT_EQUAL_SCREENSHOT("widgets/bar_1.png");
 }
 
+LV_FUNC_SECTION
 void test_bar_indicator_area_should_get_smaller_when_padding_is_increased(void)
 {
     lv_bar_t * bar_ptr = (lv_bar_t *) g_bar;
@@ -244,6 +251,7 @@ void test_bar_indicator_area_should_get_smaller_when_padding_is_increased(void)
     TEST_ASSERT_LESS_THAN_INT32(original_width, new_width);
 }
 
+LV_FUNC_SECTION
 void test_bar_start_value_should_only_change_when_in_range_mode(void)
 {
     int32_t new_start_value = 20u;
@@ -261,6 +269,7 @@ void test_bar_start_value_should_only_change_when_in_range_mode(void)
     TEST_ASSERT_EQUAL_INT32(new_start_value, lv_bar_get_start_value(g_bar));
 }
 
+LV_FUNC_SECTION
 void test_bar_start_value_should_be_smaller_than_current_value_in_range_mode(void)
 {
     /* Set bar in RANGE mode so we can edit the start value */
@@ -271,6 +280,7 @@ void test_bar_start_value_should_be_smaller_than_current_value_in_range_mode(voi
     TEST_ASSERT_EQUAL_INT32(lv_bar_get_value(g_bar), lv_bar_get_start_value(g_bar));
 }
 
+LV_FUNC_SECTION
 void test_bar_current_value_should_be_truncated_to_max_value_when_exceeds_it(void)
 {
     int32_t max_value = lv_bar_get_max_value(g_bar);
@@ -280,6 +290,7 @@ void test_bar_current_value_should_be_truncated_to_max_value_when_exceeds_it(voi
     TEST_ASSERT_EQUAL_INT32(max_value, lv_bar_get_value(g_bar));
 }
 
+LV_FUNC_SECTION
 void test_bar_current_value_should_be_truncated_to_min_value_when_it_is_below_it(void)
 {
     int32_t min_value = lv_bar_get_min_value(g_bar);
@@ -296,6 +307,7 @@ void test_bar_current_value_should_be_truncated_to_min_value_when_it_is_below_it
  * Bar properties assumed:
  * - base direction: LTR
  */
+LV_FUNC_SECTION
 void test_bar_indicator_should_be_drawn_towards_the_min_range_side_after_setting_a_more_negative_value(void)
 {
     lv_bar_t * bar_ptr = (lv_bar_t *) g_bar;
@@ -320,6 +332,7 @@ void test_bar_indicator_should_be_drawn_towards_the_min_range_side_after_setting
     TEST_ASSERT_LESS_THAN(original_pos, final_pos);
 }
 
+LV_FUNC_SECTION
 static lv_obj_t * styled_bar_create(bool ver, int32_t start_value, int32_t end_value, lv_grad_dir_t grad_dir,
                                     int32_t bg_radius, int32_t indic_radius, int32_t bg_pad)
 {
@@ -357,6 +370,7 @@ static lv_obj_t * styled_bar_create(bool ver, int32_t start_value, int32_t end_v
     return bar;
 }
 
+LV_FUNC_SECTION
 static void render_test_screen_create(bool ver, lv_grad_dir_t grad_dir, const char * ref_img_path)
 {
     lv_obj_t * active_screen = lv_screen_active();
@@ -391,6 +405,7 @@ static void render_test_screen_create(bool ver, lv_grad_dir_t grad_dir, const ch
     TEST_ASSERT_EQUAL_SCREENSHOT(ref_img_path);
 }
 
+LV_FUNC_SECTION
 void test_bar_render_corner(void)
 {
     render_test_screen_create(false, LV_GRAD_DIR_NONE, "widgets/bar_corner_1.png");
@@ -402,6 +417,7 @@ void test_bar_render_corner(void)
 }
 
 
+LV_FUNC_SECTION
 static lv_obj_t * bar_create_orientation(lv_bar_orientation_t orientation, int32_t w, int32_t h)
 {
     lv_obj_t * bar = lv_bar_create(g_active_screen);
@@ -413,6 +429,7 @@ static lv_obj_t * bar_create_orientation(lv_bar_orientation_t orientation, int32
 
 }
 
+LV_FUNC_SECTION
 void test_bar_orientation(void)
 {
     lv_obj_clean(g_active_screen);
diff --git a/tests/src/test_cases/widgets/test_btn.c b/tests/src/test_cases/widgets/test_btn.c
index c904af143..bf4ac9493 100644
--- a/tests/src/test_cases/widgets/test_btn.c
+++ b/tests/src/test_cases/widgets/test_btn.c
@@ -6,16 +6,19 @@
 
 static lv_obj_t * active_screen = NULL;
 
+LV_FUNC_SECTION
 void setUp(void)
 {
     active_screen = lv_screen_active();
 }
 
+LV_FUNC_SECTION
 void tearDown(void)
 {
     lv_obj_clean(active_screen);
 }
 
+LV_FUNC_SECTION
 void test_button_creation(void)
 {
     lv_obj_t * btn;
diff --git a/tests/src/test_cases/widgets/test_btnmatrix.c b/tests/src/test_cases/widgets/test_btnmatrix.c
index dbfb1b9cd..d089692bd 100644
--- a/tests/src/test_cases/widgets/test_btnmatrix.c
+++ b/tests/src/test_cases/widgets/test_btnmatrix.c
@@ -9,6 +9,7 @@ static lv_obj_t * btnm;
 static bool event_triggered = false;
 lv_event_code_t exp_evt_code;
 
+LV_FUNC_SECTION
 void setUp(void)
 {
     active_screen = lv_screen_active();
@@ -18,11 +19,13 @@ void setUp(void)
     exp_evt_code = 0;
 }
 
+LV_FUNC_SECTION
 void tearDown(void)
 {
     lv_obj_clean(active_screen);
 }
 
+LV_FUNC_SECTION
 void test_button_matrix_creation(void)
 {
     const char * const * map;
@@ -37,6 +40,7 @@ void test_button_matrix_creation(void)
     TEST_ASSERT_EQUAL_STRING(map[5], "Btn5");
 }
 
+LV_FUNC_SECTION
 void test_button_matrix_set_map_works(void)
 {
     const char * const * ret_map;
@@ -55,6 +59,7 @@ void test_button_matrix_set_map_works(void)
     TEST_ASSERT_EQUAL_SCREENSHOT("widgets/btnm_1.png");
 }
 
+LV_FUNC_SECTION
 void test_button_matrix_render_2(void)
 {
     static const char * btn_map[] = {"A", "B", "\n", "C", "D", ""};
@@ -127,6 +132,7 @@ void test_button_matrix_render_2(void)
     TEST_ASSERT_EQUAL_SCREENSHOT("widgets/btnm_2.png");
 }
 
+LV_FUNC_SECTION
 void test_button_matrix_set_ctrl_map_works(void)
 {
     static const char * btn_map[] = {"A", "B", "\n", "C", "D", ""};
@@ -153,6 +159,7 @@ void test_button_matrix_set_ctrl_map_works(void)
     TEST_ASSERT_FALSE(lv_buttonmatrix_has_button_ctrl(btnm, 4, LV_BUTTONMATRIX_CTRL_HIDDEN));
 }
 
+LV_FUNC_SECTION
 void test_button_matrix_set_button_ctrl_works(void)
 {
     static const char * btn_map[] = {"A", "B", "\n", "C", "D", ""};
@@ -178,6 +185,7 @@ void test_button_matrix_set_button_ctrl_works(void)
     TEST_ASSERT_FALSE(lv_buttonmatrix_has_button_ctrl(btnm, 4, LV_BUTTONMATRIX_CTRL_HIDDEN));
 }
 
+LV_FUNC_SECTION
 void test_button_matrix_clear_button_ctrl_works(void)
 {
     static const char * btn_map[] = {"A", "B", "\n", "C", "D", ""};
@@ -199,6 +207,7 @@ void test_button_matrix_clear_button_ctrl_works(void)
     TEST_ASSERT_FALSE(lv_buttonmatrix_has_button_ctrl(btnm, 3, LV_BUTTONMATRIX_CTRL_CHECKABLE));
 }
 
+LV_FUNC_SECTION
 void test_button_matrix_set_selected_button_works(void)
 {
     static const char * btn_map[] = {"A", "B", "\n", "C", "D", ""};
@@ -217,6 +226,7 @@ void test_button_matrix_set_selected_button_works(void)
     TEST_ASSERT_EQUAL_UINT16(1, lv_buttonmatrix_get_selected_button(btnm));
 }
 
+LV_FUNC_SECTION
 void test_button_matrix_set_button_ctrl_all_works(void)
 {
     static const char * btn_map[] = {"A", "B", "\n", "C", "D", ""};
@@ -230,6 +240,7 @@ void test_button_matrix_set_button_ctrl_all_works(void)
     TEST_ASSERT_TRUE(lv_buttonmatrix_has_button_ctrl(btnm, 3, LV_BUTTONMATRIX_CTRL_HIDDEN));
 }
 
+LV_FUNC_SECTION
 void test_button_matrix_clear_button_ctrl_all_works(void)
 {
     static const char * btn_map[] = {"A", "B", "\n", "C", "D", ""};
@@ -244,6 +255,7 @@ void test_button_matrix_clear_button_ctrl_all_works(void)
     TEST_ASSERT_FALSE(lv_buttonmatrix_has_button_ctrl(btnm, 3, LV_BUTTONMATRIX_CTRL_HIDDEN));
 }
 
+LV_FUNC_SECTION
 void test_button_matrix_set_button_width_works(void)
 {
     static const char * btn_map[] = {"A", "B", "\n", "C", "D", ""};
@@ -256,6 +268,7 @@ void test_button_matrix_set_button_width_works(void)
     TEST_ASSERT_TRUE(lv_buttonmatrix_has_button_ctrl(btnm, 2, 2));
 }
 
+LV_FUNC_SECTION
 void test_button_matrix_set_one_checked_works(void)
 {
     static const char * btn_map[] = {"A", "B", "\n", "C", "D", ""};
@@ -277,6 +290,7 @@ void test_button_matrix_set_one_checked_works(void)
     TEST_ASSERT_TRUE(lv_buttonmatrix_has_button_ctrl(btnm, 3, LV_BUTTONMATRIX_CTRL_CHECKED));
 }
 
+LV_FUNC_SECTION
 void test_button_matrix_get_button_text_works(void)
 {
     static const char * btn_map[] = {"A", "B", "\n", "C", "D", ""};
@@ -289,6 +303,7 @@ void test_button_matrix_get_button_text_works(void)
 }
 
 /* Common event handler for all the consecutive test cases. */
+__attribute__(( fptrgroup("lv_event_cb") ))
 static void event_handler(lv_event_t * e)
 {
     lv_event_code_t code = lv_event_get_code(e);
@@ -297,6 +312,7 @@ static void event_handler(lv_event_t * e)
     }
 }
 
+LV_FUNC_SECTION
 void test_button_matrix_pressed_event_works(void)
 {
     static const char * btn_map[] = {"A", "B", "\n", "C", "D", ""};
@@ -309,6 +325,7 @@ void test_button_matrix_pressed_event_works(void)
     TEST_ASSERT_TRUE(event_triggered);
 }
 
+LV_FUNC_SECTION
 void test_button_matrix_release_event_works(void)
 {
     static const char * btn_map[] = {"A", "B", "\n", "C", "D", ""};
@@ -330,6 +347,7 @@ void test_button_matrix_release_event_works(void)
     TEST_ASSERT_TRUE(event_triggered);
 }
 
+LV_FUNC_SECTION
 void test_button_matrix_key_event_works(void)
 {
     uint32_t keyCode;
@@ -380,6 +398,7 @@ void test_button_matrix_key_event_works(void)
     event_triggered = false;
 }
 
+LV_FUNC_SECTION
 void test_button_matrix_pressing_event_works(void)
 {
     lv_buttonmatrix_t * btnmObj = (lv_buttonmatrix_t *)btnm;
@@ -397,6 +416,7 @@ void test_button_matrix_pressing_event_works(void)
     TEST_ASSERT_TRUE(event_triggered);
 }
 
+LV_FUNC_SECTION
 void test_button_matrix_long_press_repeat_event_works(void)
 {
     lv_buttonmatrix_t * btnmObj = (lv_buttonmatrix_t *)btnm;
@@ -414,6 +434,7 @@ void test_button_matrix_long_press_repeat_event_works(void)
     TEST_ASSERT_TRUE(event_triggered);
 }
 
+LV_FUNC_SECTION
 void test_button_matrix_press_lost_event_works(void)
 {
     static const char * btn_map[] = {"A", "B", "\n", "C", "D", ""};
@@ -427,6 +448,7 @@ void test_button_matrix_press_lost_event_works(void)
     TEST_ASSERT_TRUE(event_triggered);
 }
 
+LV_FUNC_SECTION
 void test_button_matrix_defocused_event_works(void)
 {
     lv_buttonmatrix_t * btnmObj = (lv_buttonmatrix_t *)btnm;
@@ -444,6 +466,7 @@ void test_button_matrix_defocused_event_works(void)
     TEST_ASSERT_TRUE(event_triggered);
 }
 
+LV_FUNC_SECTION
 void test_button_matrix_focused_event_works(void)
 {
     static const char * btn_map[] = {"A", "B", "\n", "C", "D", ""};
diff --git a/tests/src/test_cases/widgets/test_calendar.c b/tests/src/test_cases/widgets/test_calendar.c
index 9df3ae2a5..a43cd8004 100644
--- a/tests/src/test_cases/widgets/test_calendar.c
+++ b/tests/src/test_cases/widgets/test_calendar.c
@@ -26,22 +26,26 @@ void test_calendar_get_btnmatrix(void);
 static lv_obj_t * g_active_screen = NULL;
 static lv_obj_t * g_calendar = NULL;
 
+LV_FUNC_SECTION
 void setUp(void)
 {
     g_active_screen = lv_screen_active();
     g_calendar = lv_calendar_create(g_active_screen);
 }
 
+LV_FUNC_SECTION
 void tearDown(void)
 {
     lv_obj_clean(g_active_screen);
 }
 
+LV_FUNC_SECTION
 void test_calendar_creation_successful(void)
 {
     TEST_ASSERT_NOT_NULL(g_calendar);
 }
 
+LV_FUNC_SECTION
 void test_calendar_set_today_date(void)
 {
     /* Work with 2022-09-21 as today (start of spring in Southern hemisphere) */
@@ -59,6 +63,7 @@ void test_calendar_set_today_date(void)
     TEST_ASSERT_EQUAL_INT16(today.day, date_after_test->day);
 }
 
+LV_FUNC_SECTION
 void test_calendar_set_today_date_gui(void)
 {
     /* Work with 2022-09-21 as today (start of spring in Southern hemisphere) */
@@ -73,6 +78,7 @@ void test_calendar_set_today_date_gui(void)
     TEST_ASSERT_EQUAL_SCREENSHOT("widgets/calendar_01.png");
 }
 
+LV_FUNC_SECTION
 void test_calendar_set_showed_date_gui(void)
 {
     lv_calendar_set_showed_date(g_calendar, 2022, 9);
@@ -80,6 +86,7 @@ void test_calendar_set_showed_date_gui(void)
     TEST_ASSERT_EQUAL_SCREENSHOT("widgets/calendar_02.png");
 }
 
+LV_FUNC_SECTION
 void test_calendar_set_highlighted_dates(void)
 {
     /*Highlight a few days*/
@@ -107,6 +114,7 @@ void test_calendar_set_highlighted_dates(void)
     }
 }
 
+LV_FUNC_SECTION
 void test_calendar_set_highlighted_dates_gui(void)
 {
     /*Highlight a few days*/
@@ -130,6 +138,7 @@ void test_calendar_set_highlighted_dates_gui(void)
     TEST_ASSERT_EQUAL_SCREENSHOT("widgets/calendar_03.png");
 }
 
+LV_FUNC_SECTION
 void test_calendar_set_day_names_gui(void)
 {
     static const char * day_names[7] = {"Do", "Lu", "Ma", "Mi", "Ju", "Vi", "Sa"};
@@ -141,6 +150,7 @@ void test_calendar_set_day_names_gui(void)
     TEST_ASSERT_EQUAL_SCREENSHOT("widgets/calendar_04.png");
 }
 
+LV_FUNC_SECTION
 void test_calendar_get_highlighted_dates_num(void)
 {
     /*Highlight a few days*/
@@ -162,6 +172,7 @@ void test_calendar_get_highlighted_dates_num(void)
     TEST_ASSERT_EQUAL_INT16(3, lv_calendar_get_highlighted_dates_num(g_calendar));
 }
 
+LV_FUNC_SECTION
 void test_calendar_header_dropdown_create_gui(void)
 {
     lv_calendar_header_dropdown_create(g_calendar);
@@ -171,6 +182,7 @@ void test_calendar_header_dropdown_create_gui(void)
     TEST_ASSERT_EQUAL_SCREENSHOT("widgets/calendar_05.png");
 }
 
+LV_FUNC_SECTION
 void test_calendar_header_arrow_create_gui(void)
 {
     lv_calendar_header_arrow_create(g_calendar);
@@ -180,6 +192,7 @@ void test_calendar_header_arrow_create_gui(void)
     TEST_ASSERT_EQUAL_SCREENSHOT("widgets/calendar_06.png");
 }
 
+LV_FUNC_SECTION
 void test_calendar_event_key_down_gui(void)
 {
     uint32_t key = LV_KEY_DOWN;
@@ -191,6 +204,7 @@ void test_calendar_event_key_down_gui(void)
     TEST_ASSERT_EQUAL_SCREENSHOT("widgets/calendar_07.png");
 }
 
+LV_FUNC_SECTION
 void test_calendar_get_pressed_date_null(void)
 {
     lv_calendar_set_showed_date(g_calendar, 2022, 9);
@@ -202,6 +216,7 @@ void test_calendar_get_pressed_date_null(void)
     TEST_ASSERT_EQUAL(result, LV_RESULT_INVALID);
 }
 
+LV_FUNC_SECTION
 void test_calendar_get_btnmatrix(void)
 {
     lv_obj_t * btnm = lv_calendar_get_btnmatrix(g_calendar);
@@ -209,6 +224,7 @@ void test_calendar_get_btnmatrix(void)
     TEST_ASSERT_NOT_NULL(btnm);
 }
 
+LV_FUNC_SECTION
 void test_calendar_custom_year_list(void)
 {
     lv_obj_t  * calendar = lv_calendar_create(lv_screen_active());
@@ -221,6 +237,7 @@ void test_calendar_custom_year_list(void)
     TEST_ASSERT_EQUAL_SCREENSHOT("widgets/calendar_08.png");
 }
 
+LV_FUNC_SECTION
 void test_calendar_chinese_calendar(void)
 {
     lv_obj_set_size(g_calendar, 400, 350);
diff --git a/tests/src/test_cases/widgets/test_canvas.c b/tests/src/test_cases/widgets/test_canvas.c
index 98689dbf8..032c24e8e 100644
--- a/tests/src/test_cases/widgets/test_canvas.c
+++ b/tests/src/test_cases/widgets/test_canvas.c
@@ -6,21 +6,25 @@
 
 static lv_obj_t * g_screen_active;
 
+LV_FUNC_SECTION
 void setUp(void)
 {
     g_screen_active = lv_screen_active();
 }
 
+LV_FUNC_SECTION
 void tearDown(void)
 {
     lv_obj_clean(g_screen_active);
 }
 
+LV_FUNC_SECTION
 static void draw_event_cb(lv_event_t * e)
 {
     int * draw_counter = lv_event_get_user_data(e);
     (*draw_counter)++;
 }
+LV_FUNC_SECTION
 void test_canvas_functions_invalidate(void)
 {
     lv_obj_t * canvas = lv_canvas_create(g_screen_active);
@@ -62,6 +66,7 @@ void test_canvas_functions_invalidate(void)
     TEST_ASSERT(draw_counter == 4);
 }
 
+LV_FUNC_SECTION
 void test_canvas_fill_and_set_px(void)
 {
     lv_obj_t * canvas = lv_canvas_create(lv_screen_active());
diff --git a/tests/src/test_cases/widgets/test_chart.c b/tests/src/test_cases/widgets/test_chart.c
index 264d59ef3..1c15bf199 100644
--- a/tests/src/test_cases/widgets/test_chart.c
+++ b/tests/src/test_cases/widgets/test_chart.c
@@ -9,6 +9,7 @@ static lv_obj_t * chart = NULL;
 
 static lv_color_t red_color;
 
+LV_FUNC_SECTION
 void setUp(void)
 {
     active_screen = lv_screen_active();
@@ -17,6 +18,7 @@ void setUp(void)
     red_color = lv_palette_main(LV_PALETTE_RED);
 }
 
+LV_FUNC_SECTION
 void tearDown(void)
 {
     /* Is there a way to destroy a chart without having to call remove_series for each of it series? */
@@ -24,6 +26,7 @@ void tearDown(void)
 }
 
 /* NOTE: Default chart type is LV_CHART_TYPE_LINE */
+LV_FUNC_SECTION
 void test_chart_add_series(void)
 {
     lv_chart_series_t * red_series;
@@ -36,6 +39,7 @@ void test_chart_add_series(void)
     lv_chart_remove_series(chart, red_series);
 }
 
+LV_FUNC_SECTION
 void test_chart_set_point_count_increments(void)
 {
     lv_chart_series_t * red_series;
@@ -50,6 +54,7 @@ void test_chart_set_point_count_increments(void)
     lv_chart_remove_series(chart, red_series);
 }
 
+LV_FUNC_SECTION
 void test_chart_set_point_count_decrements(void)
 {
     lv_chart_series_t * red_series;
@@ -64,6 +69,7 @@ void test_chart_set_point_count_decrements(void)
     lv_chart_remove_series(chart, red_series);
 }
 
+LV_FUNC_SECTION
 void test_chart_set_point_count_as_same(void)
 {
     lv_chart_series_t * red_series;
@@ -78,6 +84,7 @@ void test_chart_set_point_count_as_same(void)
     lv_chart_remove_series(chart, red_series);
 }
 
+LV_FUNC_SECTION
 void test_chart_set_new_point_count_as_zero(void)
 {
     lv_chart_series_t * red_series;
@@ -89,6 +96,7 @@ void test_chart_set_new_point_count_as_zero(void)
     lv_chart_remove_series(chart, red_series);
 }
 
+LV_FUNC_SECTION
 void test_chart_point_is_added_at_the_end_of_a_series(void)
 {
     lv_chart_series_t * red_series;
@@ -100,12 +108,14 @@ void test_chart_point_is_added_at_the_end_of_a_series(void)
     lv_chart_remove_series(chart, red_series);
 }
 
+LV_FUNC_SECTION
 void test_chart_one_point_when_setting_point_count_to_zero(void)
 {
     lv_chart_set_point_count(chart, 0u);
     TEST_ASSERT_EQUAL(1u, lv_chart_get_point_count(chart));
 }
 
+LV_FUNC_SECTION
 static void chart_event_cb(lv_event_t * e)
 {
     lv_event_code_t code = lv_event_get_code(e);
@@ -158,6 +168,7 @@ static void chart_event_cb(lv_event_t * e)
     }
 }
 
+LV_FUNC_SECTION
 void test_draw_task_hooking(void)
 {
     lv_obj_t * chart_wrapper = lv_obj_create(lv_screen_active());
diff --git a/tests/src/test_cases/widgets/test_checkbox.c b/tests/src/test_cases/widgets/test_checkbox.c
index cdfeed51f..ba87857cd 100644
--- a/tests/src/test_cases/widgets/test_checkbox.c
+++ b/tests/src/test_cases/widgets/test_checkbox.c
@@ -18,6 +18,7 @@ static lv_obj_t * checkbox = NULL;
 
 static volatile bool event_called = false;
 
+__attribute__(( fptrgroup("lv_event_cb") ))
 static void event_handler(lv_event_t * e)
 {
     lv_event_code_t code = lv_event_get_code(e);
@@ -27,6 +28,7 @@ static void event_handler(lv_event_t * e)
     }
 }
 
+LV_FUNC_SECTION
 void test_checkbox_creation_successful(void)
 {
     active_screen = lv_screen_active();
@@ -35,6 +37,7 @@ void test_checkbox_creation_successful(void)
     TEST_ASSERT_NOT_NULL(checkbox);
 }
 
+LV_FUNC_SECTION
 void test_checkbox_should_call_event_handler_on_click_when_enabled(void)
 {
     active_screen = lv_screen_active();
@@ -50,6 +53,7 @@ void test_checkbox_should_call_event_handler_on_click_when_enabled(void)
     event_called = false;
 }
 
+LV_FUNC_SECTION
 void test_checkbox_should_have_default_text_when_created(void)
 {
     const char * default_text = "Check box";
@@ -61,6 +65,7 @@ void test_checkbox_should_have_default_text_when_created(void)
     TEST_ASSERT_NOT_NULL(lv_checkbox_get_text(checkbox));
 }
 
+LV_FUNC_SECTION
 void test_checkbox_should_return_dynamically_allocated_text(void)
 {
     const char * message = "Hello World!";
@@ -74,6 +79,7 @@ void test_checkbox_should_return_dynamically_allocated_text(void)
     TEST_ASSERT_NOT_NULL(lv_checkbox_get_text(checkbox));
 }
 
+LV_FUNC_SECTION
 void test_checkbox_should_allocate_memory_for_static_text(void)
 {
     size_t initial_available_memory = 0;
@@ -95,6 +101,7 @@ void test_checkbox_should_allocate_memory_for_static_text(void)
     LV_HEAP_CHECK(TEST_ASSERT_LESS_THAN(initial_available_memory, m1.free_size));
 }
 
+LV_FUNC_SECTION
 void test_checkbox_rtl(void)
 {
     const char * message =
diff --git a/tests/src/test_cases/widgets/test_dropdown.c b/tests/src/test_cases/widgets/test_dropdown.c
index 6265d2745..d1ce7d39e 100644
--- a/tests/src/test_cases/widgets/test_dropdown.c
+++ b/tests/src/test_cases/widgets/test_dropdown.c
@@ -6,16 +6,19 @@
 #include "lv_test_indev.h"
 #include <string.h>
 
+LV_FUNC_SECTION
 void setUp(void)
 {
     /* Function run before every test */
 }
 
+LV_FUNC_SECTION
 void tearDown(void)
 {
     /* Function run after every test */
     lv_obj_clean(lv_screen_active());
 }
+LV_FUNC_SECTION
 void test_dropdown_create_delete(void)
 {
     lv_dropdown_create(lv_screen_active());
@@ -49,6 +52,7 @@ void test_dropdown_create_delete(void)
 
 }
 
+LV_FUNC_SECTION
 void test_dropdown_set_options(void)
 {
 
@@ -115,6 +119,7 @@ void test_dropdown_set_options(void)
     TEST_ASSERT_UINT_WITHIN(48, m1.free_size, m2.free_size);
 }
 
+LV_FUNC_SECTION
 void test_dropdown_select(void)
 {
     lv_obj_t * dd1 = lv_dropdown_create(lv_screen_active());
@@ -136,6 +141,7 @@ void test_dropdown_select(void)
     TEST_ASSERT_EQUAL(2, lv_dropdown_get_selected(dd1));
 }
 
+LV_FUNC_SECTION
 void test_dropdown_click(void)
 {
     lv_obj_clean(lv_screen_active());
@@ -154,12 +160,14 @@ void test_dropdown_click(void)
 }
 
 static uint32_t event_cnt;
+LV_FUNC_SECTION
 static void dd_event(lv_event_t * e)
 {
     LV_UNUSED(e);
     event_cnt++;
 }
 
+LV_FUNC_SECTION
 void test_dropdown_keypad(void)
 {
     lv_obj_clean(lv_screen_active());
@@ -262,6 +270,7 @@ void test_dropdown_keypad(void)
     lv_group_delete(g);
 }
 
+LV_FUNC_SECTION
 void test_dropdown_encoder(void)
 {
     lv_obj_clean(lv_screen_active());
@@ -318,6 +327,7 @@ void test_dropdown_encoder(void)
     lv_group_delete(g);
 }
 
+LV_FUNC_SECTION
 void test_dropdown_render_1(void)
 {
     lv_obj_clean(lv_screen_active());
@@ -363,6 +373,7 @@ void test_dropdown_render_1(void)
     TEST_ASSERT_EQUAL_SCREENSHOT("widgets/dropdown_1.png");
 }
 
+LV_FUNC_SECTION
 void test_dropdown_render_2(void)
 {
     lv_obj_clean(lv_screen_active());
@@ -424,6 +435,7 @@ void test_dropdown_render_2(void)
 }
 
 /* See #2893 */
+LV_FUNC_SECTION
 void test_dropdown_should_list_on_top(void)
 {
     lv_obj_t * cont1 = lv_obj_create(lv_screen_active());
@@ -442,6 +454,7 @@ void test_dropdown_should_list_on_top(void)
 }
 
 /* See #4191 */
+LV_FUNC_SECTION
 void test_dropdown_get_options_should_check_lengths(void)
 {
     lv_obj_t * dd = lv_dropdown_create(lv_screen_active());
@@ -453,6 +466,7 @@ void test_dropdown_get_options_should_check_lengths(void)
     TEST_ASSERT_EQUAL_INT(-1, lv_dropdown_get_option_index(dd, "Option "));
 }
 
+LV_FUNC_SECTION
 void test_dropdown_properties(void)
 {
 #if LV_USE_OBJ_PROPERTY
diff --git a/tests/src/test_cases/widgets/test_image.c b/tests/src/test_cases/widgets/test_image.c
index 9ca7c7bc2..aa75bd55a 100644
--- a/tests/src/test_cases/widgets/test_image.c
+++ b/tests/src/test_cases/widgets/test_image.c
@@ -7,17 +7,20 @@
 LV_IMAGE_DECLARE(test_img_lvgl_logo_png);
 LV_IMAGE_DECLARE(test_arc_bg);
 
+LV_FUNC_SECTION
 void setUp(void)
 {
 
 }
 
+LV_FUNC_SECTION
 void tearDown(void)
 {
     /* Function run after every test */
     lv_obj_clean(lv_screen_active());
 }
 
+LV_FUNC_SECTION
 static lv_obj_t * img_create(void)
 {
     lv_obj_t * img = lv_image_create(lv_screen_active());
@@ -29,6 +32,7 @@ static lv_obj_t * img_create(void)
     return img;
 }
 
+LV_FUNC_SECTION
 void test_image_rotated_pivot_center(void)
 {
     lv_obj_t * img;
@@ -43,6 +47,7 @@ void test_image_rotated_pivot_center(void)
     TEST_ASSERT_EQUAL_SCREENSHOT("widgets/image_rotate_pivot_center.png");
 }
 
+LV_FUNC_SECTION
 void test_image_rotated_pivot_top_left(void)
 {
     lv_obj_t * img;
@@ -57,6 +62,7 @@ void test_image_rotated_pivot_top_left(void)
     TEST_ASSERT_EQUAL_SCREENSHOT("widgets/image_rotate_pivot_top_left.png");
 }
 
+LV_FUNC_SECTION
 void test_image_scale_pivot_center(void)
 {
     lv_obj_t * img;
@@ -71,6 +77,7 @@ void test_image_scale_pivot_center(void)
     TEST_ASSERT_EQUAL_SCREENSHOT("widgets/image_scale_pivot_center.png");
 }
 
+LV_FUNC_SECTION
 void test_image_scale_pivot_top_left(void)
 {
     lv_obj_t * img;
@@ -85,6 +92,7 @@ void test_image_scale_pivot_top_left(void)
     TEST_ASSERT_EQUAL_SCREENSHOT("widgets/image_scale_pivot_top_left.png");
 }
 
+LV_FUNC_SECTION
 void test_image_scale_x_pivot_center(void)
 {
     lv_obj_t * img;
@@ -99,6 +107,7 @@ void test_image_scale_x_pivot_center(void)
     TEST_ASSERT_EQUAL_SCREENSHOT("widgets/image_scale_x_pivot_center.png");
 }
 
+LV_FUNC_SECTION
 void test_image_scale_x_pivot_top_left(void)
 {
     lv_obj_t * img;
@@ -113,6 +122,7 @@ void test_image_scale_x_pivot_top_left(void)
     TEST_ASSERT_EQUAL_SCREENSHOT("widgets/image_scale_x_pivot_top_left.png");
 }
 
+LV_FUNC_SECTION
 void test_image_scale_y_pivot_center(void)
 {
     lv_obj_t * img;
@@ -127,6 +137,7 @@ void test_image_scale_y_pivot_center(void)
     TEST_ASSERT_EQUAL_SCREENSHOT("widgets/image_scale_y_pivot_center.png");
 }
 
+LV_FUNC_SECTION
 void test_image_scale_y_pivot_top_left(void)
 {
     lv_obj_t * img;
@@ -141,6 +152,7 @@ void test_image_scale_y_pivot_top_left(void)
     TEST_ASSERT_EQUAL_SCREENSHOT("widgets/image_scale_y_pivot_top_left.png");
 }
 
+LV_FUNC_SECTION
 void test_image_rotate_and_scale_pivot_center(void)
 {
     lv_obj_t * img;
@@ -157,6 +169,7 @@ void test_image_rotate_and_scale_pivot_center(void)
     TEST_ASSERT_EQUAL_SCREENSHOT("widgets/image_rotate_and_scale_pivot_center.png");
 }
 
+LV_FUNC_SECTION
 void test_image_rotate_and_scale_pivot_top_left(void)
 {
     lv_obj_t * img;
@@ -173,6 +186,7 @@ void test_image_rotate_and_scale_pivot_top_left(void)
     TEST_ASSERT_EQUAL_SCREENSHOT("widgets/image_rotate_and_scale_pivot_top_left.png");
 }
 
+LV_FUNC_SECTION
 void test_image_normal_align(void)
 {
     lv_obj_t * img;
@@ -193,6 +207,7 @@ void test_image_normal_align(void)
     TEST_ASSERT_EQUAL_SCREENSHOT("widgets/image_normal_align.png");
 }
 
+LV_FUNC_SECTION
 void test_image_normal_align_offset(void)
 {
     lv_obj_t * img;
@@ -215,6 +230,7 @@ void test_image_normal_align_offset(void)
     TEST_ASSERT_EQUAL_SCREENSHOT("widgets/image_normal_align_offset.png");
 }
 
+LV_FUNC_SECTION
 void test_image_transform_align(void)
 {
     lv_obj_t * img;
@@ -238,6 +254,7 @@ void test_image_transform_align(void)
     TEST_ASSERT_EQUAL_SCREENSHOT("widgets/image_transform_align.png");
 }
 
+LV_FUNC_SECTION
 void test_image_transform_align_offset(void)
 {
     lv_obj_t * img;
@@ -263,6 +280,7 @@ void test_image_transform_align_offset(void)
     TEST_ASSERT_EQUAL_SCREENSHOT("widgets/image_transform_align_offset.png");
 }
 
+LV_FUNC_SECTION
 void test_image_stretch(void)
 {
     lv_obj_t * img;
@@ -284,6 +302,7 @@ void test_image_stretch(void)
     TEST_ASSERT_EQUAL_SCREENSHOT("widgets/image_stretch.png");
 }
 
+LV_FUNC_SECTION
 void test_image_tile(void)
 {
     lv_obj_t * img;
@@ -320,6 +339,7 @@ void test_image_tile(void)
     TEST_ASSERT_EQUAL_SCREENSHOT("widgets/image_tile.png");
 }
 
+LV_FUNC_SECTION
 void test_image_ignore_transformation_settings_when_stretched(void)
 {
     lv_obj_t * img = img_create();
@@ -343,6 +363,7 @@ void test_image_ignore_transformation_settings_when_stretched(void)
     TEST_ASSERT_EQUAL_INT(scale_y_original, lv_image_get_scale_y(img));
 }
 
+LV_FUNC_SECTION
 void test_image_ignore_transformation_settings_when_tiled(void)
 {
     lv_obj_t * img = img_create();
@@ -363,6 +384,7 @@ void test_image_ignore_transformation_settings_when_tiled(void)
     TEST_ASSERT_EQUAL_INT(LV_SCALE_NONE, lv_image_get_scale_y(img));
 }
 
+LV_FUNC_SECTION
 void test_image_clip_radius(void)
 {
     lv_obj_t * par = lv_obj_create(lv_screen_active());
@@ -387,6 +409,7 @@ void test_image_clip_radius(void)
     TEST_ASSERT_EQUAL_SCREENSHOT("widgets/image_clip_radius_circle_scaled_rotated.png");
 }
 
+LV_FUNC_SECTION
 void test_image_properties(void)
 {
 #if LV_USE_OBJ_PROPERTY
diff --git a/tests/src/test_cases/widgets/test_imagebutton.c b/tests/src/test_cases/widgets/test_imagebutton.c
index 3c6e310e5..cd57fdf12 100644
--- a/tests/src/test_cases/widgets/test_imagebutton.c
+++ b/tests/src/test_cases/widgets/test_imagebutton.c
@@ -3,17 +3,20 @@
 
 #include "unity/unity.h"
 
+LV_FUNC_SECTION
 void setUp(void)
 {
     /* Function run before every test */
 }
 
+LV_FUNC_SECTION
 void tearDown(void)
 {
     /* Function run after every test */
     lv_obj_clean(lv_screen_active());
 }
 
+LV_FUNC_SECTION
 void test_imagebutton_basic_appearance(void)
 {
     /**
diff --git a/tests/src/test_cases/widgets/test_imgfont.c b/tests/src/test_cases/widgets/test_imgfont.c
index de59b95af..6a1685daf 100644
--- a/tests/src/test_cases/widgets/test_imgfont.c
+++ b/tests/src/test_cases/widgets/test_imgfont.c
@@ -6,16 +6,19 @@
 
 static lv_obj_t * active_screen = NULL;
 
+LV_FUNC_SECTION
 void setUp(void)
 {
     active_screen = lv_screen_active();
 }
 
+LV_FUNC_SECTION
 void tearDown(void)
 {
     lv_obj_clean(active_screen);
 }
 
+LV_FUNC_SECTION
 static const void * get_imgfont_path(const lv_font_t * font, uint32_t unicode, uint32_t unicode_next,
                                      int32_t * offset_y, void * user_data)
 {
@@ -36,6 +39,7 @@ static const void * get_imgfont_path(const lv_font_t * font, uint32_t unicode, u
     return NULL;
 }
 
+LV_FUNC_SECTION
 void test_imgfont_creation(void)
 {
     lv_font_t * imgfont = lv_imgfont_create(80, get_imgfont_path, NULL);
diff --git a/tests/src/test_cases/widgets/test_keyboard.c b/tests/src/test_cases/widgets/test_keyboard.c
index 8ab1837ed..d89f904e8 100644
--- a/tests/src/test_cases/widgets/test_keyboard.c
+++ b/tests/src/test_cases/widgets/test_keyboard.c
@@ -6,16 +6,19 @@
 
 static lv_obj_t * active_screen = NULL;
 
+LV_FUNC_SECTION
 void setUp(void)
 {
     active_screen = lv_screen_active();
 }
 
+LV_FUNC_SECTION
 void tearDown(void)
 {
     lv_obj_clean(active_screen);
 }
 
+LV_FUNC_SECTION
 void test_keyboard_mode(void)
 {
     lv_obj_t * keyboard  = lv_keyboard_create(active_screen);
@@ -39,6 +42,7 @@ void test_keyboard_mode(void)
     TEST_ASSERT_EQUAL_SCREENSHOT("widgets/keyboard_4.png");
 }
 
+LV_FUNC_SECTION
 void test_keyboard_properties(void)
 {
 #if LV_USE_OBJ_PROPERTY
diff --git a/tests/src/test_cases/widgets/test_label.c b/tests/src/test_cases/widgets/test_label.c
index 3e5a11092..2f9be67fe 100644
--- a/tests/src/test_cases/widgets/test_label.c
+++ b/tests/src/test_cases/widgets/test_label.c
@@ -17,6 +17,7 @@ static lv_obj_t * long_label;
 static lv_obj_t * long_label_multiline;
 static lv_obj_t * empty_label;
 
+LV_FUNC_SECTION
 void setUp(void)
 {
     active_screen = lv_screen_active();
@@ -30,17 +31,20 @@ void setUp(void)
     lv_label_set_text(empty_label, empty_text);
 }
 
+LV_FUNC_SECTION
 void tearDown(void)
 {
     lv_obj_clean(lv_screen_active());
 }
 
+LV_FUNC_SECTION
 void test_label_creation(void)
 {
     TEST_ASSERT_EQUAL_STRING(lv_label_get_text(label), LV_LABEL_DEFAULT_TEXT);
     TEST_ASSERT_EQUAL(lv_label_get_long_mode(label), LV_LABEL_LONG_WRAP);
 }
 
+LV_FUNC_SECTION
 void test_label_set_text(void)
 {
     const char * new_text = "Hello world";
@@ -54,6 +58,7 @@ void test_label_set_text(void)
     TEST_ASSERT_EQUAL_STRING(lv_label_get_text(label), new_text);
 }
 
+LV_FUNC_SECTION
 void test_label_get_letter_pos_align_left(void)
 {
     lv_obj_set_style_text_align(label, LV_TEXT_ALIGN_LEFT, LV_STYLE_STATE_CMP_SAME);
@@ -82,6 +87,7 @@ void test_label_get_letter_pos_align_left(void)
     TEST_ASSERT_EQUAL(expected_last_letter_point.y, last_letter_point.y);
 }
 
+LV_FUNC_SECTION
 void test_label_get_letter_pos_align_left_on_empty_text(void)
 {
     lv_obj_set_style_text_align(empty_label, LV_TEXT_ALIGN_LEFT, LV_STYLE_STATE_CMP_SAME);
@@ -110,6 +116,7 @@ void test_label_get_letter_pos_align_left_on_empty_text(void)
     TEST_ASSERT_EQUAL(expected_last_letter_point.y, last_letter_point.y);
 }
 
+LV_FUNC_SECTION
 void test_label_long_text_multiline_get_letter_pos_align_left(void)
 {
     lv_obj_set_style_text_align(long_label_multiline, LV_TEXT_ALIGN_LEFT, LV_STYLE_STATE_CMP_SAME);
@@ -149,6 +156,7 @@ void test_label_long_text_multiline_get_letter_pos_align_left(void)
     TEST_ASSERT_EQUAL(expected_last_letter_after_new_line_point.y, last_letter_after_new_line_point.y);
 }
 
+LV_FUNC_SECTION
 void test_label_long_text_get_letter_pos_align_left(void)
 {
     lv_label_set_long_mode(long_label, LV_LABEL_LONG_WRAP);
@@ -181,6 +189,7 @@ void test_label_long_text_get_letter_pos_align_left(void)
     TEST_ASSERT_EQUAL(expected_last_letter_point.y, last_letter_point.y);
 }
 
+LV_FUNC_SECTION
 void test_label_get_letter_pos_align_right(void)
 {
     lv_obj_set_style_text_align(label, LV_TEXT_ALIGN_RIGHT, LV_STYLE_STATE_CMP_SAME);
@@ -209,6 +218,7 @@ void test_label_get_letter_pos_align_right(void)
     TEST_ASSERT_EQUAL(expected_last_letter_point.y, last_letter_point.y);
 }
 
+LV_FUNC_SECTION
 void test_label_get_letter_pos_align_right_on_empty_text(void)
 {
     lv_obj_set_style_text_align(empty_label, LV_TEXT_ALIGN_RIGHT, LV_STYLE_STATE_CMP_SAME);
@@ -237,6 +247,7 @@ void test_label_get_letter_pos_align_right_on_empty_text(void)
     TEST_ASSERT_EQUAL(expected_last_letter_point.y, last_letter_point.y);
 }
 
+LV_FUNC_SECTION
 void test_label_long_text_multiline_get_letter_pos_align_right(void)
 {
     lv_obj_set_style_text_align(long_label_multiline, LV_TEXT_ALIGN_RIGHT, LV_STYLE_STATE_CMP_SAME);
@@ -276,6 +287,7 @@ void test_label_long_text_multiline_get_letter_pos_align_right(void)
     TEST_ASSERT_EQUAL(expected_last_letter_after_new_line_point.y, last_letter_after_new_line_point.y);
 }
 
+LV_FUNC_SECTION
 void test_label_long_text_get_letter_pos_align_right(void)
 {
     lv_label_set_long_mode(long_label, LV_LABEL_LONG_WRAP);
@@ -308,6 +320,7 @@ void test_label_long_text_get_letter_pos_align_right(void)
     TEST_ASSERT_EQUAL(expected_last_letter_point.y, last_letter_point.y);
 }
 
+LV_FUNC_SECTION
 void test_label_get_letter_pos_align_center(void)
 {
     lv_obj_set_style_text_align(label, LV_TEXT_ALIGN_CENTER, LV_STYLE_STATE_CMP_SAME);
@@ -336,6 +349,7 @@ void test_label_get_letter_pos_align_center(void)
     TEST_ASSERT_EQUAL(expected_last_letter_point.y, last_letter_point.y);
 }
 
+LV_FUNC_SECTION
 void test_label_get_letter_pos_align_center_on_empty_text(void)
 {
     lv_obj_set_style_text_align(empty_label, LV_TEXT_ALIGN_CENTER, LV_STYLE_STATE_CMP_SAME);
@@ -364,6 +378,7 @@ void test_label_get_letter_pos_align_center_on_empty_text(void)
     TEST_ASSERT_EQUAL(expected_last_letter_point.y, last_letter_point.y);
 }
 
+LV_FUNC_SECTION
 void test_label_long_text_multiline_get_letter_pos_align_center(void)
 {
     lv_obj_set_style_text_align(long_label_multiline, LV_TEXT_ALIGN_CENTER, LV_STYLE_STATE_CMP_SAME);
@@ -403,6 +418,7 @@ void test_label_long_text_multiline_get_letter_pos_align_center(void)
     TEST_ASSERT_EQUAL(expected_last_letter_after_new_line_point.y, last_letter_after_new_line_point.y);
 }
 
+LV_FUNC_SECTION
 void test_label_long_text_get_letter_pos_align_center(void)
 {
     lv_label_set_long_mode(long_label, LV_LABEL_LONG_WRAP);
@@ -435,6 +451,7 @@ void test_label_long_text_get_letter_pos_align_center(void)
     TEST_ASSERT_EQUAL(expected_last_letter_point.y, last_letter_point.y);
 }
 
+LV_FUNC_SECTION
 void test_label_is_char_under_pos_align_left(void)
 {
     lv_obj_set_style_text_align(label, LV_TEXT_ALIGN_LEFT, LV_STYLE_STATE_CMP_SAME);
@@ -458,6 +475,7 @@ void test_label_is_char_under_pos_align_left(void)
     TEST_ASSERT_EQUAL(expected_result, result);
 }
 
+LV_FUNC_SECTION
 void test_label_is_char_under_pos_align_right(void)
 {
     lv_obj_set_style_text_align(label, LV_TEXT_ALIGN_RIGHT, LV_STYLE_STATE_CMP_SAME);
@@ -481,6 +499,7 @@ void test_label_is_char_under_pos_align_right(void)
     TEST_ASSERT_EQUAL(expected_result, result);
 }
 
+LV_FUNC_SECTION
 void test_label_is_char_under_pos_align_center(void)
 {
     lv_obj_set_style_text_align(label, LV_TEXT_ALIGN_CENTER, LV_STYLE_STATE_CMP_SAME);
@@ -504,6 +523,7 @@ void test_label_is_char_under_pos_align_center(void)
     TEST_ASSERT_EQUAL(expected_result, result);
 }
 
+LV_FUNC_SECTION
 void test_label_cut_text(void)
 {
     const char * expected_text = "Te";
@@ -513,6 +533,7 @@ void test_label_cut_text(void)
     TEST_ASSERT_EQUAL_STRING(expected_text, lv_label_get_text(label));
 }
 
+LV_FUNC_SECTION
 void test_label_get_letter_on_left(void)
 {
     lv_obj_set_style_text_align(label, LV_TEXT_ALIGN_LEFT, LV_STYLE_STATE_CMP_SAME);
@@ -526,6 +547,7 @@ void test_label_get_letter_on_left(void)
     TEST_ASSERT_EQUAL(last_letter_idx, letter_idx_result);
 }
 
+LV_FUNC_SECTION
 void test_label_get_letter_on_center(void)
 {
     lv_obj_set_style_text_align(label, LV_TEXT_ALIGN_CENTER, LV_STYLE_STATE_CMP_SAME);
@@ -539,6 +561,7 @@ void test_label_get_letter_on_center(void)
     TEST_ASSERT_EQUAL(last_letter_idx, letter_idx_result);
 }
 
+LV_FUNC_SECTION
 void test_label_get_letter_on_right(void)
 {
     lv_obj_set_style_text_align(label, LV_TEXT_ALIGN_RIGHT, LV_STYLE_STATE_CMP_SAME);
@@ -552,6 +575,7 @@ void test_label_get_letter_on_right(void)
     TEST_ASSERT_EQUAL(last_letter_idx, letter_idx_result);
 }
 
+LV_FUNC_SECTION
 void test_label_text_selection(void)
 {
     const uint32_t selection_start = 0;
@@ -567,6 +591,7 @@ void test_label_text_selection(void)
     TEST_ASSERT_EQUAL(selection_end, end);
 }
 
+LV_FUNC_SECTION
 void test_label_rtl_dot_long_mode(void)
 {
     const char * message =
@@ -591,6 +616,7 @@ void test_label_rtl_dot_long_mode(void)
     TEST_ASSERT_EQUAL_SCREENSHOT("widgets/label_rtl_dot_long_mode.png");
 }
 
+LV_FUNC_SECTION
 void test_label_max_width(void)
 {
     lv_obj_clean(lv_screen_active());
diff --git a/tests/src/test_cases/widgets/test_led.c b/tests/src/test_cases/widgets/test_led.c
index de52a162a..df3e97b37 100644
--- a/tests/src/test_cases/widgets/test_led.c
+++ b/tests/src/test_cases/widgets/test_led.c
@@ -6,16 +6,19 @@
 
 static lv_obj_t * active_screen = NULL;
 
+LV_FUNC_SECTION
 void setUp(void)
 {
     active_screen = lv_screen_active();
 }
 
+LV_FUNC_SECTION
 void tearDown(void)
 {
     lv_obj_clean(active_screen);
 }
 
+LV_FUNC_SECTION
 void test_led_render_1(void)
 {
     lv_obj_t * led  = lv_led_create(active_screen);
@@ -34,6 +37,7 @@ void test_led_render_1(void)
     TEST_ASSERT_EQUAL_SCREENSHOT("widgets/led_1.png");
 }
 
+LV_FUNC_SECTION
 void test_led_set_color_works(void)
 {
     lv_obj_t * led  = lv_led_create(active_screen);
@@ -50,6 +54,7 @@ void test_led_set_color_works(void)
     TEST_ASSERT_EQUAL_COLOR(lv_palette_main(LV_PALETTE_RED), ledObj->color);
 }
 
+LV_FUNC_SECTION
 void test_led_set_brightness_works(void)
 {
     lv_obj_t * led  = lv_led_create(active_screen);
@@ -65,6 +70,7 @@ void test_led_set_brightness_works(void)
     TEST_ASSERT_EQUAL(255, lv_led_get_brightness(led));
 }
 
+LV_FUNC_SECTION
 void test_led_on_off_works(void)
 {
     lv_obj_t * led  = lv_led_create(active_screen);
@@ -79,6 +85,7 @@ void test_led_on_off_works(void)
     TEST_ASSERT_EQUAL(LV_LED_BRIGHT_MAX, lv_led_get_brightness(led));
 }
 
+LV_FUNC_SECTION
 void test_led_toggle_works(void)
 {
     lv_obj_t * led  = lv_led_create(active_screen);
@@ -92,6 +99,7 @@ void test_led_toggle_works(void)
     TEST_ASSERT_EQUAL(LV_LED_BRIGHT_MIN, lv_led_get_brightness(led));
 }
 
+LV_FUNC_SECTION
 void test_led_get_brightness_works(void)
 {
     lv_obj_t * led  = lv_led_create(active_screen);
diff --git a/tests/src/test_cases/widgets/test_line.c b/tests/src/test_cases/widgets/test_line.c
index d4a6875b1..ba59b18d2 100644
--- a/tests/src/test_cases/widgets/test_line.c
+++ b/tests/src/test_cases/widgets/test_line.c
@@ -11,17 +11,20 @@ static const uint16_t default_point_num = 0U;
 static const int32_t initial_extra_draw_size = 5U;
 static const int32_t final_extra_draw_size = 10U;
 
+LV_FUNC_SECTION
 void setUp(void)
 {
     active_screen = lv_screen_active();
     line = lv_line_create(active_screen);
 }
 
+LV_FUNC_SECTION
 void tearDown(void)
 {
     lv_obj_clean(active_screen);
 }
 
+LV_FUNC_SECTION
 void test_line_should_have_valid_documented_default_values(void)
 {
     TEST_ASSERT_EQUAL_UINT16(default_point_num, lv_line_get_point_count(line));
@@ -33,12 +36,14 @@ void test_line_should_have_valid_documented_default_values(void)
     TEST_ASSERT_EQUAL_UINT16(0U, lv_obj_get_self_height(line));
 }
 
+LV_FUNC_SECTION
 void test_line_should_return_valid_y_invert(void)
 {
     lv_line_set_y_invert(line, true);
     TEST_ASSERT_TRUE(lv_line_get_y_invert(line));
 }
 
+LV_FUNC_SECTION
 void test_line_size_should_be_updated_after_adding_points(void)
 {
     static lv_point_precise_t points[] = { {5, 5} };
@@ -59,6 +64,7 @@ void test_line_size_should_be_updated_after_adding_points(void)
     TEST_ASSERT_EQUAL_UINT16(calculated_height, lv_obj_get_self_height(line));
 }
 
+LV_FUNC_SECTION
 static void line_event_cb(lv_event_t * e)
 {
     lv_event_code_t code = lv_event_get_code(e);
@@ -69,6 +75,7 @@ static void line_event_cb(lv_event_t * e)
     }
 }
 
+LV_FUNC_SECTION
 void test_line_should_update_extra_draw_size_based_on_style(void)
 {
     /* Setup an event handler for line extra draw size event */
@@ -88,6 +95,7 @@ void test_line_should_update_extra_draw_size_based_on_style(void)
     TEST_ASSERT_EQUAL(final_extra_draw_size, lv_obj_get_ext_draw_size(line));
 }
 
+LV_FUNC_SECTION
 void test_line_basic_render(void)
 {
     static lv_point_precise_t points[] = { {5, 5},
@@ -110,6 +118,7 @@ void test_line_basic_render(void)
     TEST_ASSERT_EQUAL_SCREENSHOT("widgets/line_1.png");
 }
 
+LV_FUNC_SECTION
 void test_line_dash_gap(void)
 {
     static lv_point_precise_t line_points1[3] = { {50, 50}, {250, 50}, {250, 250} };
@@ -145,6 +154,7 @@ void test_line_dash_gap(void)
     TEST_ASSERT_EQUAL_SCREENSHOT("widgets/line_2.png");
 }
 
+LV_FUNC_SECTION
 void test_line_point_array_getters_and_setters(void)
 {
     const lv_point_precise_t points[3] = {{10, 20}, {30, 40}, {50, 60}};
diff --git a/tests/src/test_cases/widgets/test_list.c b/tests/src/test_cases/widgets/test_list.c
index 64d01d9d6..4e9408fe7 100644
--- a/tests/src/test_cases/widgets/test_list.c
+++ b/tests/src/test_cases/widgets/test_list.c
@@ -6,16 +6,19 @@
 
 static lv_obj_t * list;
 
+LV_FUNC_SECTION
 void setUp(void)
 {
     list = lv_list_create(lv_screen_active());
 }
 
+LV_FUNC_SECTION
 void tearDown(void)
 {
 
 }
 
+LV_FUNC_SECTION
 void test_list_get_text_from_added_button(void)
 {
     const char * message = "LVGL Rocks!";
@@ -24,6 +27,7 @@ void test_list_get_text_from_added_button(void)
     TEST_ASSERT_EQUAL_STRING(message, lv_list_get_button_text(list, button_ok));
 }
 
+LV_FUNC_SECTION
 void test_list_get_text_from_button_without_symbol(void)
 {
     const char * message = "LVGL Rocks!";
@@ -32,6 +36,7 @@ void test_list_get_text_from_button_without_symbol(void)
     TEST_ASSERT_EQUAL_STRING(message, lv_list_get_button_text(list, button_ok));
 }
 
+LV_FUNC_SECTION
 void test_list_gets_empty_text_from_button_without_text(void)
 {
     const char * empty_text = "";
@@ -40,6 +45,7 @@ void test_list_gets_empty_text_from_button_without_text(void)
     TEST_ASSERT_EQUAL_STRING(empty_text, lv_list_get_button_text(list, button_ok));
 }
 
+LV_FUNC_SECTION
 void test_list_get_text_from_label(void)
 {
     const char * message = "LVGL Rocks!";
@@ -48,6 +54,7 @@ void test_list_get_text_from_label(void)
     TEST_ASSERT_EQUAL_STRING(message, lv_label_get_text(label));
 }
 
+LV_FUNC_SECTION
 void test_list_snapshot(void)
 {
     lv_obj_t * snapshot_list = lv_list_create(lv_screen_active());
diff --git a/tests/src/test_cases/widgets/test_lottie.c b/tests/src/test_cases/widgets/test_lottie.c
index 72ce2e312..7f4bbe51b 100644
--- a/tests/src/test_cases/widgets/test_lottie.c
+++ b/tests/src/test_cases/widgets/test_lottie.c
@@ -16,16 +16,19 @@ extern const size_t test_lottie_approve_size;
     #define TEST_ASSERT_EQUAL_SCREENSHOT(path) (void) path
 #endif
 
+LV_FUNC_SECTION
 void setUp(void)
 {
 
 }
 
+LV_FUNC_SECTION
 void tearDown(void)
 {
     lv_obj_clean(lv_screen_active());
 }
 
+LV_FUNC_SECTION
 void test_lottie_simple(void)
 {
     lv_obj_t * lottie = lv_lottie_create(lv_screen_active());
@@ -51,6 +54,7 @@ void test_lottie_simple(void)
     TEST_ASSERT_EQUAL_SCREENSHOT("widgets/lottie_2.png");
 }
 
+LV_FUNC_SECTION
 void test_lottie_load_from_file(void)
 {
     lv_obj_t * lottie = lv_lottie_create(lv_screen_active());
@@ -75,6 +79,7 @@ void test_lottie_load_from_file(void)
     TEST_ASSERT_EQUAL_SCREENSHOT("widgets/lottie_2.png");
 }
 
+LV_FUNC_SECTION
 void test_lottie_missing_settings(void)
 {
     uint32_t tmp_buf[CANVAS_WIDTH_TO_STRIDE(100, 4) * 100 + LV_DRAW_BUF_ALIGN];
@@ -99,6 +104,7 @@ void test_lottie_missing_settings(void)
     TEST_ASSERT_EQUAL_SCREENSHOT("widgets/lottie_3.png");
 }
 
+LV_FUNC_SECTION
 void test_lottie_rescale(void)
 {
     lv_obj_t * lottie = lv_lottie_create(lv_screen_active());
@@ -119,6 +125,7 @@ void test_lottie_rescale(void)
 }
 
 
+LV_FUNC_SECTION
 void test_lottie_non_uniform_shape(void)
 {
     lv_obj_t * lottie = lv_lottie_create(lv_screen_active());
@@ -130,6 +137,7 @@ void test_lottie_non_uniform_shape(void)
     TEST_ASSERT_EQUAL_SCREENSHOT("widgets/lottie_4.png");
 }
 
+LV_FUNC_SECTION
 void test_lottie_memory_leak(void)
 {
     size_t mem_before = lv_test_get_free_mem();
@@ -147,6 +155,7 @@ void test_lottie_memory_leak(void)
     TEST_ASSERT_MEM_LEAK_LESS_THAN(mem_before, 16);
 }
 
+LV_FUNC_SECTION
 void test_lottie_no_jump_when_visible_again(void)
 {
     lv_obj_t * lottie = lv_lottie_create(lv_screen_active());
diff --git a/tests/src/test_cases/widgets/test_msgbox.c b/tests/src/test_cases/widgets/test_msgbox.c
index a2f42339c..ffbd7e6b9 100644
--- a/tests/src/test_cases/widgets/test_msgbox.c
+++ b/tests/src/test_cases/widgets/test_msgbox.c
@@ -23,17 +23,20 @@ void test_msgbox_close_async_modal(void);
 static lv_obj_t * active_screen = NULL;
 static lv_obj_t * msgbox = NULL;
 
+LV_FUNC_SECTION
 void setUp(void)
 {
     active_screen = lv_screen_active();
 }
 
+LV_FUNC_SECTION
 void tearDown(void)
 {
     lv_obj_clean(active_screen);
     lv_obj_clean(lv_layer_top()); /*Modal message boxes are created on the top layer*/
 }
 
+LV_FUNC_SECTION
 void test_msgbox_creation_successful_with_close_button(void)
 {
     msgbox = lv_msgbox_create(active_screen);
@@ -49,6 +52,7 @@ void test_msgbox_creation_successful_with_close_button(void)
     TEST_ASSERT_EQUAL_SCREENSHOT("widgets/msgbox_ok_with_close_btn.png");
 }
 
+LV_FUNC_SECTION
 void test_msgbox_creation_successful_no_close_button(void)
 {
     msgbox = lv_msgbox_create(NULL);
@@ -63,6 +67,7 @@ void test_msgbox_creation_successful_no_close_button(void)
     TEST_ASSERT_EQUAL_SCREENSHOT("widgets/msgbox_ok_no_close_btn.png");
 }
 
+LV_FUNC_SECTION
 void test_msgbox_creation_successful_modal(void)
 {
     // If parent is NULL the message box will be modal
@@ -80,6 +85,7 @@ void test_msgbox_creation_successful_modal(void)
     lv_obj_clean(msgbox);
 }
 
+LV_FUNC_SECTION
 void test_msgbox_get_title(void)
 {
     const char * txt_title = "The title";
@@ -99,6 +105,7 @@ void test_msgbox_get_title(void)
     TEST_ASSERT_EQUAL_STRING(txt_title, lv_label_get_text(lbl_title));
 }
 
+LV_FUNC_SECTION
 void test_msgbox_get_content(void)
 {
     msgbox = lv_msgbox_create(active_screen);
@@ -106,6 +113,7 @@ void test_msgbox_get_content(void)
     TEST_ASSERT_NOT_NULL(lv_msgbox_get_content(msgbox));
 }
 
+LV_FUNC_SECTION
 void test_msgbox_close(void)
 {
     msgbox = lv_msgbox_create(active_screen);
@@ -117,6 +125,7 @@ void test_msgbox_close(void)
     TEST_ASSERT_NOT_NULL(msgbox);
 }
 
+LV_FUNC_SECTION
 void test_msgbox_close_modal(void)
 {
     msgbox = lv_msgbox_create(NULL);
@@ -128,6 +137,7 @@ void test_msgbox_close_modal(void)
     TEST_ASSERT_NOT_NULL(msgbox);
 }
 
+LV_FUNC_SECTION
 void test_msgbox_close_async(void)
 {
     msgbox = lv_msgbox_create(active_screen);
@@ -137,6 +147,7 @@ void test_msgbox_close_async(void)
     TEST_ASSERT_NOT_NULL(msgbox);
 }
 
+LV_FUNC_SECTION
 void test_msgbox_close_async_modal(void)
 {
     msgbox = lv_msgbox_create(NULL);
@@ -146,6 +157,7 @@ void test_msgbox_close_async_modal(void)
     TEST_ASSERT_NOT_NULL(msgbox);
 }
 
+LV_FUNC_SECTION
 void test_msgbox_content_auto_height(void)
 {
     /* If parent is NULL the message box will be modal*/
diff --git a/tests/src/test_cases/widgets/test_obj_flags.c b/tests/src/test_cases/widgets/test_obj_flags.c
index 88f6d7846..6034f0c47 100644
--- a/tests/src/test_cases/widgets/test_obj_flags.c
+++ b/tests/src/test_cases/widgets/test_obj_flags.c
@@ -5,28 +5,33 @@
 #include "unity/unity.h"
 #include "lv_test_indev.h"
 
+LV_FUNC_SECTION
 void setUp(void)
 {
     /* Function run before every test */
 }
 
+LV_FUNC_SECTION
 void tearDown(void)
 {
     /* Function run after every test */
     lv_obj_clean(lv_screen_active());
 }
 
+LV_FUNC_SECTION
 static void ext_draw_size_event_cb(lv_event_t * e)
 {
     lv_event_set_ext_draw_size(e, 100);
 }
 
+LV_FUNC_SECTION
 static void btn_clicked_event_cb(lv_event_t * e)
 {
     uint32_t * cnt = lv_event_get_user_data(e);
     (*cnt)++;
 }
 
+LV_FUNC_SECTION
 void test_obj_flag_overflow_visible_1(void)
 {
     lv_obj_t * obj_main = lv_obj_create(lv_screen_active());
diff --git a/tests/src/test_cases/widgets/test_obj_property.c b/tests/src/test_cases/widgets/test_obj_property.c
index 370ffa09e..92c2c0a7a 100644
--- a/tests/src/test_cases/widgets/test_obj_property.c
+++ b/tests/src/test_cases/widgets/test_obj_property.c
@@ -4,6 +4,7 @@
 
 #include "unity/unity.h"
 
+LV_FUNC_SECTION
 void test_obj_property_fail_on_invalid_id(void)
 {
 #if LV_USE_OBJ_PROPERTY
@@ -28,6 +29,7 @@ void test_obj_property_fail_on_invalid_id(void)
 #endif
 }
 
+LV_FUNC_SECTION
 void test_obj_property_set_get_should_match(void)
 {
 #if LV_USE_OBJ_PROPERTY
@@ -95,6 +97,7 @@ void test_obj_property_set_get_should_match(void)
 #endif
 }
 
+LV_FUNC_SECTION
 void test_obj_property_style_selector(void)
 {
 #if LV_USE_OBJ_PROPERTY
@@ -119,6 +122,7 @@ void test_obj_property_style_selector(void)
 #endif
 }
 
+LV_FUNC_SECTION
 void test_obj_property_flag(void)
 {
 #if LV_USE_OBJ_PROPERTY
@@ -185,6 +189,7 @@ void test_obj_property_flag(void)
 #endif
 }
 
+LV_FUNC_SECTION
 void test_obj_property_state(void)
 {
 #if LV_USE_OBJ_PROPERTY
@@ -233,6 +238,7 @@ void test_obj_property_state(void)
 #endif
 }
 
+LV_FUNC_SECTION
 void test_obj_property_type_point(void)
 {
 #if LV_USE_OBJ_PROPERTY
@@ -250,6 +256,7 @@ void test_obj_property_type_point(void)
 #endif
 }
 
+LV_FUNC_SECTION
 void test_obj_property_name(void)
 {
 #if LV_USE_OBJ_PROPERTY && LV_USE_OBJ_PROPERTY_NAME
@@ -272,6 +279,7 @@ void test_obj_property_name(void)
 #endif
 }
 
+LV_FUNC_SECTION
 void test_obj_class_property(void)
 {
 #if LV_USE_OBJ_PROPERTY && LV_USE_OBJ_PROPERTY_NAME
@@ -289,6 +297,7 @@ void test_obj_class_property(void)
 #endif
 }
 
+LV_FUNC_SECTION
 void test_label_properties(void)
 {
 #if LV_USE_OBJ_PROPERTY
diff --git a/tests/src/test_cases/widgets/test_obj_tree.c b/tests/src/test_cases/widgets/test_obj_tree.c
index 4aa21b694..d6d4de66a 100644
--- a/tests/src/test_cases/widgets/test_obj_tree.c
+++ b/tests/src/test_cases/widgets/test_obj_tree.c
@@ -7,11 +7,13 @@
 void test_obj_tree_1(void);
 void test_obj_tree_2(void);
 
+LV_FUNC_SECTION
 void test_obj_tree_1(void)
 {
     TEST_ASSERT_EQUAL(lv_obj_get_child_count(lv_screen_active()), 0);
 }
 
+LV_FUNC_SECTION
 void test_obj_tree_2(void)
 {
 
@@ -37,6 +39,7 @@ void test_obj_tree_2(void)
     //TEST_ASSERT_EQUAL_SCREENSHOT("widgets/scr1.png")
 }
 
+LV_FUNC_SECTION
 void test_obj_tree_3(void)
 {
     /* tests lv_obj_swap */
@@ -83,6 +86,7 @@ void test_obj_tree_3(void)
 
 /** lv_obj_move_to_index **/
 
+LV_FUNC_SECTION
 void test_obj_move_to_index_move_to_the_background(void)
 {
     lv_obj_t * parent = NULL;
@@ -101,6 +105,7 @@ void test_obj_move_to_index_move_to_the_background(void)
     TEST_ASSERT_EQUAL(0, lv_obj_get_index(child2));
 }
 
+LV_FUNC_SECTION
 void test_obj_move_to_index_move_forward(void)
 {
     lv_obj_t * parent = NULL;
@@ -120,6 +125,7 @@ void test_obj_move_to_index_move_forward(void)
 }
 
 /* Tests scenarios when no operation is performed */
+LV_FUNC_SECTION
 void test_obj_move_to_index_no_operation_when_parent_is_null(void)
 {
     lv_obj_t * parent = NULL;
@@ -133,6 +139,7 @@ void test_obj_move_to_index_no_operation_when_parent_is_null(void)
     TEST_ASSERT_EQUAL_INT32(0xFFFFFFFF, lv_obj_get_index(child1));
 }
 
+LV_FUNC_SECTION
 void test_obj_move_to_index_no_operation_when_index_is_same_or_bigger_than_parent_child_count(void)
 {
     lv_obj_t * parent = NULL;
@@ -147,6 +154,7 @@ void test_obj_move_to_index_no_operation_when_index_is_same_or_bigger_than_paren
     TEST_ASSERT_EQUAL(0, lv_obj_get_index(child1));
 }
 
+LV_FUNC_SECTION
 void test_obj_move_to_index_no_operation_when_new_index_is_the_same_as_previous_index(void)
 {
     lv_obj_t * parent = NULL;
@@ -165,6 +173,7 @@ void test_obj_move_to_index_no_operation_when_new_index_is_the_same_as_previous_
     TEST_ASSERT_EQUAL(1, lv_obj_get_index(child2));
 }
 
+LV_FUNC_SECTION
 void test_obj_move_to_index_no_operation_when_requested_negative_index_is_greater_than_child_count(void)
 {
     lv_obj_t * parent = NULL;
diff --git a/tests/src/test_cases/widgets/test_objid.c b/tests/src/test_cases/widgets/test_objid.c
index 013215df7..ca2112c59 100644
--- a/tests/src/test_cases/widgets/test_objid.c
+++ b/tests/src/test_cases/widgets/test_objid.c
@@ -5,6 +5,7 @@
 #include "unity/unity.h"
 #include <string.h>
 
+LV_FUNC_SECTION
 void test_obj_id_should_match_class_name(void)
 {
     char buf[128];
@@ -18,6 +19,7 @@ void test_obj_id_should_match_class_name(void)
     TEST_ASSERT_TRUE(strncmp("image", buf, strlen("image")) == 0);
 }
 
+LV_FUNC_SECTION
 void test_obj_id_should_grow_by_one(void)
 {
     uint32_t id1, id2;
@@ -28,6 +30,7 @@ void test_obj_id_should_grow_by_one(void)
     TEST_ASSERT_EQUAL(id1 + 1, id2);
 }
 
+LV_FUNC_SECTION
 void test_obj_id_get_child(void)
 {
     lv_obj_t * parent = lv_obj_create(lv_screen_active());
diff --git a/tests/src/test_cases/widgets/test_roller.c b/tests/src/test_cases/widgets/test_roller.c
index acfc47975..7889f7eac 100644
--- a/tests/src/test_cases/widgets/test_roller.c
+++ b/tests/src/test_cases/widgets/test_roller.c
@@ -20,6 +20,7 @@ static lv_group_t * mouse_g = NULL;
 static const char * default_roller_options = "One\nTwo\nThree";
 static const char * default_infinite_roller_options = "One\nTwo\nThree\nFour\nFive\nSix\nSeven\nEight\nNine\nTen";
 
+LV_FUNC_SECTION
 void setUp(void)
 {
     active_screen = lv_screen_active();
@@ -45,6 +46,7 @@ void setUp(void)
     lv_group_add_obj(mouse_g, roller_mouse);
 }
 
+LV_FUNC_SECTION
 void tearDown(void)
 {
     lv_group_remove_obj(roller);
@@ -53,11 +55,13 @@ void tearDown(void)
     lv_obj_clean(active_screen);
 }
 
+LV_FUNC_SECTION
 void test_roller_get_options(void)
 {
     TEST_ASSERT_EQUAL_STRING(default_roller_options, lv_roller_get_options(roller));
 }
 
+LV_FUNC_SECTION
 void test_roller_get_selected_option(void)
 {
     char actual_str[OPTION_BUFFER_SZ] = {0x00};
@@ -78,6 +82,7 @@ void test_roller_get_selected_option(void)
     TEST_ASSERT_EQUAL_STRING(expected_index_str, actual_str);
 }
 
+LV_FUNC_SECTION
 void test_roller_get_selected_option_truncated_buffer(void)
 {
     char actual_str[OPTION_SMALL_BUFFER_SZ] = {0x00};
@@ -93,6 +98,7 @@ void test_roller_get_selected_option_truncated_buffer(void)
     TEST_ASSERT_EQUAL_STRING(expected_index_str, actual_str);
 }
 
+LV_FUNC_SECTION
 void test_roller_infinite_mode_get_selected_option(void)
 {
     char actual_str[OPTION_BUFFER_SZ] = {0x00};
@@ -125,6 +131,7 @@ void test_roller_infinite_mode_get_selected_option(void)
     TEST_ASSERT_EQUAL_STRING("Two", actual_str);
 }
 
+LV_FUNC_SECTION
 void test_roller_keypad_events(void)
 {
     int16_t expected_index = 1;
@@ -163,6 +170,7 @@ void test_roller_keypad_events(void)
     TEST_ASSERT_EQUAL(expected_index, actual_index);
 }
 
+LV_FUNC_SECTION
 void test_roller_with_overlay_and_bubble_events_enabled(void)
 {
     lv_obj_t * overlay = lv_obj_create(roller);
@@ -247,6 +255,7 @@ void test_roller_with_overlay_and_bubble_events_enabled(void)
 //    TEST_ASSERT_NOT_EQUAL(0, lv_roller_get_selected(roller_mouse));
 //}
 
+LV_FUNC_SECTION
 void test_roller_appearance(void)
 {
     /* use a number, a symbol, a high letter, a low letter */
@@ -330,6 +339,7 @@ void test_roller_appearance(void)
     TEST_ASSERT_EQUAL_SCREENSHOT("widgets/roller_3.png");
 }
 
+LV_FUNC_SECTION
 void test_roller_properties(void)
 {
 #if LV_USE_OBJ_PROPERTY
diff --git a/tests/src/test_cases/widgets/test_scale.c b/tests/src/test_cases/widgets/test_scale.c
index 05ee4f577..96adfdaae 100644
--- a/tests/src/test_cases/widgets/test_scale.c
+++ b/tests/src/test_cases/widgets/test_scale.c
@@ -5,17 +5,20 @@
 #include "unity/unity.h"
 
 /* Function run before every test */
+LV_FUNC_SECTION
 void setUp(void)
 {
 }
 
 /* Function run after every test */
+LV_FUNC_SECTION
 void tearDown(void)
 {
     lv_obj_clean(lv_screen_active());
 }
 
 /* A simple horizontal scale */
+LV_FUNC_SECTION
 void test_scale_render_example_1(void)
 {
     lv_obj_t * scale = lv_scale_create(lv_screen_active());
@@ -36,6 +39,7 @@ void test_scale_render_example_1(void)
 }
 
 /* An vertical scale with section and custom styling */
+LV_FUNC_SECTION
 void test_scale_render_example_2(void)
 {
     lv_obj_t * scale = lv_scale_create(lv_screen_active());
@@ -121,6 +125,7 @@ void test_scale_render_example_2(void)
 }
 
 /* A simple round scale */
+LV_FUNC_SECTION
 void test_scale_render_example_3(void)
 {
     lv_obj_t * scale = lv_scale_create(lv_screen_active());
@@ -144,6 +149,7 @@ void test_scale_render_example_3(void)
 }
 
 /* A round scale with section and custom styling */
+LV_FUNC_SECTION
 void test_scale_render_example_4(void)
 {
     lv_obj_t * scale = lv_scale_create(lv_screen_active());
@@ -222,6 +228,7 @@ void test_scale_render_example_4(void)
     TEST_ASSERT_EQUAL_SCREENSHOT("widgets/scale_4.png");
 }
 
+LV_FUNC_SECTION
 static void draw_event_cb(lv_event_t * e)
 {
     lv_obj_t * obj = lv_event_get_target(e);
@@ -265,6 +272,7 @@ static void draw_event_cb(lv_event_t * e)
     }
 }
 
+LV_FUNC_SECTION
 void test_scale_render_example_7(void)
 {
     lv_obj_t * scale = lv_scale_create(lv_screen_active());
@@ -287,6 +295,7 @@ void test_scale_render_example_7(void)
     TEST_ASSERT_EQUAL_SCREENSHOT("widgets/scale_5.png");
 }
 
+LV_FUNC_SECTION
 void test_scale_set_style(void)
 {
     lv_obj_t * scale = lv_scale_create(lv_screen_active());
@@ -345,6 +354,7 @@ void test_scale_set_style(void)
 }
 
 /* The scale internally counts the number of custom labels until it finds the NULL sentinel */
+LV_FUNC_SECTION
 void test_scale_custom_labels_count(void)
 {
     lv_obj_t * scale = lv_scale_create(lv_screen_active());
@@ -363,6 +373,7 @@ void test_scale_custom_labels_count(void)
     TEST_ASSERT_EQUAL(2U, scale_widget->custom_label_cnt);
 }
 
+LV_FUNC_SECTION
 void test_scale_mode(void)
 {
     lv_obj_t * scale = lv_scale_create(lv_screen_active());
@@ -373,6 +384,7 @@ void test_scale_mode(void)
     TEST_ASSERT_EQUAL(mode, lv_scale_get_mode(scale));
 }
 
+LV_FUNC_SECTION
 void test_scale_total_tick_count(void)
 {
     lv_obj_t * scale = lv_scale_create(lv_screen_active());
@@ -383,6 +395,7 @@ void test_scale_total_tick_count(void)
     TEST_ASSERT_EQUAL(total_tick_count, lv_scale_get_total_tick_count(scale));
 }
 
+LV_FUNC_SECTION
 void test_scale_major_tick_every(void)
 {
     lv_obj_t * scale = lv_scale_create(lv_screen_active());
@@ -393,6 +406,7 @@ void test_scale_major_tick_every(void)
     TEST_ASSERT_EQUAL(major_tick_every, lv_scale_get_major_tick_every(scale));
 }
 
+LV_FUNC_SECTION
 void test_scale_label_show(void)
 {
     lv_obj_t * scale = lv_scale_create(lv_screen_active());
@@ -408,6 +422,7 @@ void test_scale_label_show(void)
     TEST_ASSERT_EQUAL(label_show, lv_scale_get_label_show(scale));
 }
 
+LV_FUNC_SECTION
 void test_scale_angle_range(void)
 {
     lv_obj_t * scale = lv_scale_create(lv_screen_active());
@@ -418,6 +433,7 @@ void test_scale_angle_range(void)
     TEST_ASSERT_EQUAL(angle_range, lv_scale_get_angle_range(scale));
 }
 
+LV_FUNC_SECTION
 void test_scale_range(void)
 {
     lv_obj_t * scale = lv_scale_create(lv_screen_active());
@@ -430,6 +446,7 @@ void test_scale_range(void)
     TEST_ASSERT_EQUAL(max_range, lv_scale_get_range_max_value(scale));
 }
 
+LV_FUNC_SECTION
 void test_scale_set_line_needle_value(void)
 {
     lv_obj_t * scale = lv_scale_create(lv_screen_active());
diff --git a/tests/src/test_cases/widgets/test_slider.c b/tests/src/test_cases/widgets/test_slider.c
index c79c4c4c7..cbcf64c9e 100644
--- a/tests/src/test_cases/widgets/test_slider.c
+++ b/tests/src/test_cases/widgets/test_slider.c
@@ -12,6 +12,7 @@ static lv_obj_t * sliderNormalMode = NULL;
 static lv_obj_t * sliderSymmetricalMode = NULL;
 static lv_group_t * g = NULL;
 
+LV_FUNC_SECTION
 void setUp(void)
 {
     active_screen = lv_screen_active();
@@ -28,11 +29,13 @@ void setUp(void)
     lv_indev_set_group(lv_test_encoder_indev, g);
 }
 
+LV_FUNC_SECTION
 void tearDown(void)
 {
     lv_obj_clean(active_screen);
 }
 
+LV_FUNC_SECTION
 void test_textarea_should_have_valid_documented_default_values(void)
 {
     int32_t objw = lv_obj_get_width(slider);
@@ -44,6 +47,7 @@ void test_textarea_should_have_valid_documented_default_values(void)
     TEST_ASSERT_FALSE(lv_obj_has_flag(slider, LV_OBJ_FLAG_SCROLLABLE));
 }
 
+LV_FUNC_SECTION
 void test_slider_event_keys_right_and_up_increment_value_by_one(void)
 {
     uint32_t key = LV_KEY_RIGHT;
@@ -60,6 +64,7 @@ void test_slider_event_keys_right_and_up_increment_value_by_one(void)
     TEST_ASSERT_EQUAL_INT32(new_value + 1, lv_slider_get_value(slider));
 }
 
+LV_FUNC_SECTION
 void test_slider_event_keys_left_and_down_decrement_value_by_one(void)
 {
     uint32_t key = LV_KEY_LEFT;
@@ -76,6 +81,7 @@ void test_slider_event_keys_left_and_down_decrement_value_by_one(void)
     TEST_ASSERT_EQUAL_INT32(new_value - 1, lv_slider_get_value(slider));
 }
 
+LV_FUNC_SECTION
 void test_slider_event_invalid_key_should_not_change_values(void)
 {
     uint32_t key = LV_KEY_ENTER;
@@ -87,6 +93,7 @@ void test_slider_event_invalid_key_should_not_change_values(void)
     TEST_ASSERT_EQUAL_INT32(value, lv_slider_get_value(slider));
 }
 
+LV_FUNC_SECTION
 void test_slider_range_mode_should_leave_edit_mode_if_released(void)
 {
     lv_slider_t * ptr = (lv_slider_t *) sliderRangeMode;
@@ -107,6 +114,7 @@ void test_slider_range_mode_should_leave_edit_mode_if_released(void)
     TEST_ASSERT_FALSE(lv_group_get_editing(g));
 }
 
+LV_FUNC_SECTION
 void test_slider_range_mode_should_not_leave_edit_mode_if_released_with_no_left_knob_focus(void)
 {
     lv_slider_t * ptr = (lv_slider_t *) sliderRangeMode;
@@ -126,6 +134,7 @@ void test_slider_range_mode_should_not_leave_edit_mode_if_released_with_no_left_
     TEST_ASSERT(lv_group_get_editing(g));
 }
 
+LV_FUNC_SECTION
 void test_slider_normal_mode_should_leave_edit_mode_if_released(void)
 {
     lv_slider_t * ptr = (lv_slider_t *) sliderNormalMode;
@@ -147,6 +156,7 @@ void test_slider_normal_mode_should_leave_edit_mode_if_released(void)
     TEST_ASSERT_FALSE(lv_group_get_editing(g));
 }
 
+LV_FUNC_SECTION
 void test_ranged_mode_adjust_with_encoder(void)
 {
     lv_slider_set_value(sliderRangeMode, 90, LV_ANIM_OFF);
@@ -174,6 +184,7 @@ void test_ranged_mode_adjust_with_encoder(void)
 
 }
 
+LV_FUNC_SECTION
 void test_normal_mode_slider_hit_test(void)
 {
     /* Validate if point 0,0 can click in the slider */
@@ -194,6 +205,7 @@ void test_normal_mode_slider_hit_test(void)
     TEST_ASSERT(info.res);
 }
 
+LV_FUNC_SECTION
 void test_slider_range_event_hit_test(void)
 {
     /* Validate if point 0,0 can click in the slider */
diff --git a/tests/src/test_cases/widgets/test_span.c b/tests/src/test_cases/widgets/test_span.c
index 44ee88690..6426219e8 100644
--- a/tests/src/test_cases/widgets/test_span.c
+++ b/tests/src/test_cases/widgets/test_span.c
@@ -7,11 +7,13 @@
 static lv_obj_t * spangroup = NULL;
 static lv_obj_t * active_screen = NULL;
 
+LV_FUNC_SECTION
 void setUp(void)
 {
     spangroup = lv_spangroup_create(NULL);
 }
 
+LV_FUNC_SECTION
 void tearDown(void)
 {
     lv_obj_delete(spangroup);
@@ -24,6 +26,7 @@ void tearDown(void)
     active_screen = NULL;
 }
 
+LV_FUNC_SECTION
 void test_spangroup_create_returns_not_null_object(void)
 {
     lv_obj_t * obj = lv_spangroup_create(NULL);
@@ -31,6 +34,7 @@ void test_spangroup_create_returns_not_null_object(void)
     TEST_ASSERT(NULL != obj);
 }
 
+LV_FUNC_SECTION
 void test_spangroup_new_span_with_null_parameter_returns_null_object(void)
 {
     lv_span_t * span = lv_spangroup_new_span(NULL);
@@ -39,6 +43,7 @@ void test_spangroup_new_span_with_null_parameter_returns_null_object(void)
     TEST_ASSERT_EQUAL_INT(0, lv_spangroup_get_span_count(spangroup));
 }
 
+LV_FUNC_SECTION
 void test_spangroup_new_span_with_valid_parameter_returns_not_null_object(void)
 {
     lv_span_t * span = lv_spangroup_new_span(spangroup);
@@ -47,6 +52,7 @@ void test_spangroup_new_span_with_valid_parameter_returns_not_null_object(void)
     TEST_ASSERT_EQUAL_INT(1, lv_spangroup_get_span_count(spangroup));
 }
 
+LV_FUNC_SECTION
 void test_spangroup_delete_span_span_is_null(void)
 {
     lv_span_t * span = lv_spangroup_new_span(spangroup);
@@ -56,6 +62,7 @@ void test_spangroup_delete_span_span_is_null(void)
     TEST_ASSERT_EQUAL_INT(0, lv_spangroup_get_span_count(spangroup));
 }
 
+LV_FUNC_SECTION
 void test_span_set_text(void)
 {
     const char * test_text = "Test Text";
@@ -66,6 +73,7 @@ void test_span_set_text(void)
     TEST_ASSERT_EQUAL_STRING(span->txt, test_text);
 }
 
+LV_FUNC_SECTION
 void test_span_set_text_with_bad_parameter_no_action_performed(void)
 {
     const char * test_text = "Test Text";
@@ -77,6 +85,7 @@ void test_span_set_text_with_bad_parameter_no_action_performed(void)
     TEST_ASSERT_EQUAL_STRING(span->txt, test_text);
 }
 
+LV_FUNC_SECTION
 void test_span_set_text_with_previous_test_overwrites(void)
 {
     const char * old_test_text = "Old Test Text";
@@ -89,6 +98,7 @@ void test_span_set_text_with_previous_test_overwrites(void)
     TEST_ASSERT_EQUAL_STRING(span->txt, new_test_text);
 }
 
+LV_FUNC_SECTION
 void test_span_set_text_static(void)
 {
     const char * test_text = "Test Text";
@@ -99,6 +109,7 @@ void test_span_set_text_static(void)
     TEST_ASSERT_EQUAL_STRING(span->txt, test_text);
 }
 
+LV_FUNC_SECTION
 void test_span_set_text_static_with_bad_parameter_no_action_performed(void)
 {
     const char * test_text = "Test Text";
@@ -110,6 +121,7 @@ void test_span_set_text_static_with_bad_parameter_no_action_performed(void)
     TEST_ASSERT_EQUAL_STRING(span->txt, test_text);
 }
 
+LV_FUNC_SECTION
 void test_span_set_text_static_with_previous_text_overwrites(void)
 {
     const char * old_test_text = "Old Test Text";
@@ -121,6 +133,7 @@ void test_span_set_text_static_with_previous_text_overwrites(void)
     TEST_ASSERT_EQUAL_STRING(span->txt, new_test_text);
 }
 
+LV_FUNC_SECTION
 void test_spangroup_set_align(void)
 {
     const lv_text_align_t align = LV_TEXT_ALIGN_CENTER;
@@ -129,6 +142,7 @@ void test_spangroup_set_align(void)
     TEST_ASSERT_EQUAL(align, lv_spangroup_get_align(spangroup));
 }
 
+LV_FUNC_SECTION
 void test_spangroup_set_overflow(void)
 {
     const lv_span_overflow_t overflow = LV_SPAN_OVERFLOW_ELLIPSIS;
@@ -137,6 +151,7 @@ void test_spangroup_set_overflow(void)
     TEST_ASSERT_EQUAL(overflow, lv_spangroup_get_overflow(spangroup));
 }
 
+LV_FUNC_SECTION
 void test_spangroup_set_overflow_invalid_parameters_overflow_not_changed(void)
 {
     lv_spangroup_set_overflow(spangroup, LV_SPAN_OVERFLOW_ELLIPSIS);
@@ -145,6 +160,7 @@ void test_spangroup_set_overflow_invalid_parameters_overflow_not_changed(void)
     TEST_ASSERT_EQUAL(LV_SPAN_OVERFLOW_ELLIPSIS, lv_spangroup_get_overflow(spangroup));
 }
 
+LV_FUNC_SECTION
 void test_spangroup_set_indent(void)
 {
     const int32_t indent = 100;
@@ -154,6 +170,7 @@ void test_spangroup_set_indent(void)
     TEST_ASSERT_EQUAL(indent, lv_spangroup_get_indent(spangroup));
 }
 
+LV_FUNC_SECTION
 void test_spangroup_set_mode(void)
 {
     lv_spangroup_set_mode(spangroup, LV_SPAN_MODE_EXPAND);
@@ -166,6 +183,7 @@ void test_spangroup_set_mode(void)
     TEST_ASSERT_EQUAL(LV_SPAN_MODE_FIXED, lv_spangroup_get_mode(spangroup));
 }
 
+LV_FUNC_SECTION
 void test_spangroup_set_mode_invalid_parameter_mode_not_changed(void)
 {
     lv_spangroup_set_mode(spangroup, LV_SPAN_MODE_EXPAND);
@@ -173,6 +191,7 @@ void test_spangroup_set_mode_invalid_parameter_mode_not_changed(void)
     TEST_ASSERT_EQUAL(LV_SPAN_MODE_EXPAND, lv_spangroup_get_mode(spangroup));
 }
 
+LV_FUNC_SECTION
 void test_spangroup_set_max_lines(void)
 {
     const int32_t lines = 100;
@@ -182,6 +201,7 @@ void test_spangroup_set_max_lines(void)
     TEST_ASSERT_EQUAL_INT32(lines, lv_spangroup_get_max_lines(spangroup));
 }
 
+LV_FUNC_SECTION
 void test_spangroup_get_max_lines_for_new_span_group(void)
 {
     int32_t lines;
@@ -197,6 +217,7 @@ void test_spangroup_get_max_lines_for_new_span_group(void)
     TEST_ASSERT_EQUAL_INT32(3, lines);
 }
 
+LV_FUNC_SECTION
 void test_spangroup_get_max_line_h(void)
 {
     int32_t max_line;
@@ -212,6 +233,7 @@ void test_spangroup_get_max_line_h(void)
     TEST_ASSERT_EQUAL(16, (uint32_t)max_line);
 }
 
+LV_FUNC_SECTION
 void test_spangroup_draw(void)
 {
     active_screen = lv_screen_active();
@@ -242,6 +264,7 @@ void test_spangroup_draw(void)
     TEST_ASSERT_EQUAL_SCREENSHOT("widgets/span_05.png");
 }
 
+LV_FUNC_SECTION
 void test_spangroup_get_child(void)
 {
     const int32_t span_1_idx = 0;
@@ -253,6 +276,7 @@ void test_spangroup_get_child(void)
     TEST_ASSERT_EQUAL_PTR(span_1, lv_spangroup_get_child(spangroup, span_1_idx));
 }
 
+LV_FUNC_SECTION
 void test_spangroup_get_child_count(void)
 {
     (void)lv_spangroup_new_span(spangroup);
@@ -263,6 +287,7 @@ void test_spangroup_get_child_count(void)
     TEST_ASSERT_EQUAL(2, cnt);
 }
 
+LV_FUNC_SECTION
 void test_spangroup_get_expand_width(void)
 {
     const uint32_t experimental_size = 232;
@@ -280,6 +305,7 @@ void test_spangroup_get_expand_width(void)
                           lv_spangroup_get_expand_width(spangroup, experimental_size));
 }
 
+LV_FUNC_SECTION
 void test_spangroup_newlines(void)
 {
     active_screen = lv_screen_active();
@@ -312,6 +338,7 @@ void test_spangroup_newlines(void)
 
 #if LV_USE_FREETYPE && __WORDSIZE == 64
 
+LV_FUNC_SECTION
 void test_spangroup_chinese_break_line(void)
 {
     lv_font_t * font = lv_freetype_font_create("src/test_files/fonts/noto/NotoSansSC-Regular.ttf",
@@ -351,12 +378,14 @@ void test_spangroup_chinese_break_line(void)
 
 #else
 
+LV_FUNC_SECTION
 void test_spangroup_chinese_break_line(void)
 {
 }
 
 #endif
 
+LV_FUNC_SECTION
 void test_spangroup_style_text_letter_space(void)
 {
     active_screen = lv_screen_active();
diff --git a/tests/src/test_cases/widgets/test_spinbox.c b/tests/src/test_cases/widgets/test_spinbox.c
index c404203e0..1c77cdf18 100644
--- a/tests/src/test_cases/widgets/test_spinbox.c
+++ b/tests/src/test_cases/widgets/test_spinbox.c
@@ -16,6 +16,7 @@ static const int32_t SPINBOX_ZERO_MIN_RANGE_VALUE = 0;
 static const int32_t SPINBOX_NEGATIVE_MAX_RANGE_VALUE = 12;
 static const uint8_t SPINBOX_DECIMAL_POSITION = 1U;
 
+LV_FUNC_SECTION
 void setUp(void)
 {
     active_screen = lv_screen_active();
@@ -30,6 +31,7 @@ void setUp(void)
     lv_indev_set_group(lv_test_encoder_indev, g);
 }
 
+LV_FUNC_SECTION
 void tearDown(void)
 {
     lv_group_remove_obj(spinbox_events);
@@ -42,6 +44,7 @@ void tearDown(void)
 }
 
 /* See issue #3559 for more info */
+LV_FUNC_SECTION
 void test_spinbox_decrement_when_min_range_is_negative(void)
 {
     /* Current spinbox value is 2 */
@@ -59,6 +62,7 @@ void test_spinbox_decrement_when_min_range_is_negative(void)
     TEST_ASSERT_EQUAL_INT32(expected_value, actual_value);
 }
 
+LV_FUNC_SECTION
 void test_spinbox_decrement_when_min_range_is_zero(void)
 {
     /* Current spinbox value is 2 */
@@ -76,6 +80,7 @@ void test_spinbox_decrement_when_min_range_is_zero(void)
     TEST_ASSERT_EQUAL_INT32(expected_value, actual_value);
 }
 
+LV_FUNC_SECTION
 void test_spinbox_position_selection(void)
 {
     /* Assert step is 1 when selecting the lowest possible position */
@@ -95,6 +100,7 @@ void test_spinbox_position_selection(void)
     lv_obj_clean(tmp);
 }
 
+LV_FUNC_SECTION
 void test_spinbox_set_range(void)
 {
     int32_t range_max = 40;
@@ -119,6 +125,7 @@ void test_spinbox_set_range(void)
     lv_obj_clean(tmp);
 }
 
+LV_FUNC_SECTION
 void test_spinbox_step_prev(void)
 {
     lv_obj_t * tmp = lv_spinbox_create(active_screen);
@@ -143,6 +150,7 @@ void test_spinbox_step_prev(void)
     lv_obj_clean(tmp);
 }
 
+LV_FUNC_SECTION
 void test_spinbox_rollover(void)
 {
     lv_obj_t * tmp = lv_spinbox_create(active_screen);
@@ -156,6 +164,7 @@ void test_spinbox_rollover(void)
     lv_obj_clean(tmp);
 }
 
+LV_FUNC_SECTION
 void test_spinbox_event_key(void)
 {
     /* Spinbox should increment it's value by one after receiving the LV_KEY_UP event */
@@ -186,6 +195,7 @@ void test_spinbox_event_key(void)
     TEST_ASSERT_EQUAL(step / 10, lv_spinbox_get_step(spinbox_events));
 }
 
+LV_FUNC_SECTION
 void test_spinbox_event_key_encoder_indev_turn_right(void)
 {
     /* Setup group and encoder indev */
@@ -200,6 +210,7 @@ void test_spinbox_event_key_encoder_indev_turn_right(void)
     TEST_ASSERT_EQUAL(1, lv_spinbox_get_value(spinbox_events));
 }
 
+LV_FUNC_SECTION
 void test_spinbox_event_key_encoder_indev_turn_left(void)
 {
     int32_t value = 10;
@@ -215,6 +226,7 @@ void test_spinbox_event_key_encoder_indev_turn_left(void)
     TEST_ASSERT_EQUAL(value - 1, lv_spinbox_get_value(spinbox_events));
 }
 
+LV_FUNC_SECTION
 void test_spinbox_event_key_encoder_indev_editing_group(void)
 {
     int32_t value = 10;
@@ -243,6 +255,7 @@ void test_spinbox_event_key_encoder_indev_editing_group(void)
     TEST_ASSERT_EQUAL(1, lv_spinbox_get_step(spinbox_events));
 }
 
+LV_FUNC_SECTION
 void test_spinbox_event_key_encoder_indev_editing_group_left_step_direction(void)
 {
     int32_t value = 10;
@@ -272,6 +285,7 @@ void test_spinbox_event_key_encoder_indev_editing_group_left_step_direction(void
     TEST_ASSERT_EQUAL(1, lv_spinbox_get_step(spinbox_events));
 }
 
+LV_FUNC_SECTION
 void test_spinbox_event_release(void)
 {
     lv_spinbox_set_value(spinbox_events, 0);
@@ -284,6 +298,7 @@ void test_spinbox_event_release(void)
     TEST_ASSERT_EQUAL(1, lv_spinbox_get_step(spinbox_events));
 }
 
+LV_FUNC_SECTION
 void test_spinbox_zero_crossing(void)
 {
     int32_t value = -13;
diff --git a/tests/src/test_cases/widgets/test_spinner.c b/tests/src/test_cases/widgets/test_spinner.c
index 74f54a552..1ef00c404 100644
--- a/tests/src/test_cases/widgets/test_spinner.c
+++ b/tests/src/test_cases/widgets/test_spinner.c
@@ -7,6 +7,7 @@
 static lv_obj_t * active_screen = NULL;
 static lv_obj_t * spinner = NULL;
 
+LV_FUNC_SECTION
 void setUp(void)
 {
     active_screen = lv_screen_active();
@@ -15,11 +16,13 @@ void setUp(void)
     lv_obj_center(spinner);
 }
 
+LV_FUNC_SECTION
 void tearDown(void)
 {
     lv_obj_clean(active_screen);
 }
 
+LV_FUNC_SECTION
 void test_spinner_spinning(void)
 {
     for(int i = 0; i < 10; ++i) {
diff --git a/tests/src/test_cases/widgets/test_switch.c b/tests/src/test_cases/widgets/test_switch.c
index aff45bf73..67e96e73b 100644
--- a/tests/src/test_cases/widgets/test_switch.c
+++ b/tests/src/test_cases/widgets/test_switch.c
@@ -13,6 +13,7 @@ uint8_t value_changed_event_cnt = 0;
 lv_obj_t * scr = NULL;
 lv_obj_t * sw = NULL;
 
+LV_FUNC_SECTION
 void setUp(void)
 {
     /* Function run before every test */
@@ -20,17 +21,20 @@ void setUp(void)
     sw = lv_switch_create(scr);
 }
 
+LV_FUNC_SECTION
 void tearDown(void)
 {
     /* Function run after every test */
     value_changed_event_cnt = 0;
 }
 
+LV_FUNC_SECTION
 static void mouse_click_on_switch(void)
 {
     lv_test_mouse_click_at(sw->coords.x1, sw->coords.y1);
 }
 
+__attribute__(( fptrgroup("lv_event_cb") ))
 static void event_handler(lv_event_t * e)
 {
     lv_event_code_t event = lv_event_get_code(e);
@@ -41,12 +45,14 @@ static void event_handler(lv_event_t * e)
 
 }
 
+LV_FUNC_SECTION
 void test_switch_should_have_default_state_after_being_created(void)
 {
     lv_state_t state = lv_obj_get_state(sw);
     TEST_ASSERT_EQUAL(state, LV_STATE_DEFAULT);
 }
 
+LV_FUNC_SECTION
 void test_switch_should_not_leak_memory_after_deletion(void)
 {
     size_t idx = 0;
@@ -67,6 +73,7 @@ void test_switch_should_not_leak_memory_after_deletion(void)
     LV_HEAP_CHECK(TEST_ASSERT_MEM_LEAK_LESS_THAN(initial_available_memory, 24));
 }
 
+LV_FUNC_SECTION
 void test_switch_animation(void)
 {
     lv_switch_t * anim_sw = (lv_switch_t *) sw;
@@ -88,6 +95,7 @@ void test_switch_animation(void)
     TEST_ASSERT_FALSE(lv_obj_has_state(sw, LV_STATE_CHECKED));
 }
 
+LV_FUNC_SECTION
 void test_switch_should_not_have_extra_draw_size_at_creation(void)
 {
     int32_t extra_size = lv_obj_get_ext_draw_size(sw);
@@ -95,6 +103,7 @@ void test_switch_should_not_have_extra_draw_size_at_creation(void)
     TEST_ASSERT_EQUAL(0, extra_size);
 }
 
+LV_FUNC_SECTION
 void test_switch_should_update_extra_draw_size_after_editing_padding(void)
 {
     int32_t pad = 6;
@@ -116,6 +125,7 @@ void test_switch_should_update_extra_draw_size_after_editing_padding(void)
 }
 
 /* See #2330 for context */
+LV_FUNC_SECTION
 void test_switch_should_trigger_value_changed_event_only_once(void)
 {
     lv_obj_add_event_cb(sw, event_handler, LV_EVENT_ALL, NULL);
@@ -125,6 +135,7 @@ void test_switch_should_trigger_value_changed_event_only_once(void)
 }
 
 /* See #2785 for context */
+LV_FUNC_SECTION
 void test_switch_should_state_change_when_event_bubbling_is_enabled(void)
 {
     lv_obj_add_flag(sw, LV_OBJ_FLAG_EVENT_BUBBLE);
diff --git a/tests/src/test_cases/widgets/test_table.c b/tests/src/test_cases/widgets/test_table.c
index bbe145bc1..0b5de1261 100644
--- a/tests/src/test_cases/widgets/test_table.c
+++ b/tests/src/test_cases/widgets/test_table.c
@@ -7,17 +7,20 @@
 static lv_obj_t * scr = NULL;
 static lv_obj_t * table = NULL;
 
+LV_FUNC_SECTION
 void setUp(void)
 {
     scr = lv_screen_active();
     table = lv_table_create(scr);
 }
 
+LV_FUNC_SECTION
 void tearDown(void)
 {
     lv_obj_clean(lv_screen_active());
 }
 
+LV_FUNC_SECTION
 void test_table_should_set_row_count_to_zero(void)
 {
     lv_table_set_row_count(table, 0);
@@ -25,6 +28,7 @@ void test_table_should_set_row_count_to_zero(void)
     TEST_ASSERT_EQUAL_UINT32(0, lv_table_get_row_count(table));
 }
 
+LV_FUNC_SECTION
 void test_table_should_return_assigned_cell_value(void)
 {
     uint16_t row = 0;
@@ -36,6 +40,7 @@ void test_table_should_return_assigned_cell_value(void)
     TEST_ASSERT_EQUAL_STRING(value, lv_table_get_cell_value(table, row, column));
 }
 
+LV_FUNC_SECTION
 void test_table_should_grow_columns_automatically_when_setting_formatted_cell_value(void)
 {
     /* Newly created tables have 1 column and 1 row */
@@ -50,6 +55,7 @@ void test_table_should_grow_columns_automatically_when_setting_formatted_cell_va
     TEST_ASSERT_EQUAL_UINT16(expected_column_count, lv_table_get_column_count(table));
 }
 
+LV_FUNC_SECTION
 void test_table_should_identify_cell_with_ctrl(void)
 {
     bool has_ctrl = false;
@@ -63,6 +69,7 @@ void test_table_should_identify_cell_with_ctrl(void)
     TEST_ASSERT_TRUE(has_ctrl);
 }
 
+LV_FUNC_SECTION
 void test_table_should_clear_selected_cell_ctrl(void)
 {
     bool has_ctrl = false;
@@ -76,6 +83,7 @@ void test_table_should_clear_selected_cell_ctrl(void)
     TEST_ASSERT_FALSE(has_ctrl);
 }
 
+LV_FUNC_SECTION
 void test_table_should_keep_not_selected_cell_ctrl(void)
 {
     bool has_ctrl = false;
@@ -91,11 +99,13 @@ void test_table_should_keep_not_selected_cell_ctrl(void)
 }
 
 /* We're using a newly created table */
+LV_FUNC_SECTION
 void test_table_cell_value_should_return_empty_string_when_cell_is_empty(void)
 {
     TEST_ASSERT_EQUAL_STRING("", lv_table_get_cell_value(table, 0, 0));
 }
 
+LV_FUNC_SECTION
 void test_table_row_height_should_increase_with_multiline_cell_value(void)
 {
     lv_table_t * table_ptr = (lv_table_t *) table;
@@ -111,6 +121,7 @@ void test_table_row_height_should_increase_with_multiline_cell_value(void)
     TEST_ASSERT_GREATER_THAN(singleline_row_height, multiline_row_height);
 }
 
+LV_FUNC_SECTION
 void test_table_should_wrap_long_texts(void)
 {
     lv_table_t * table_ptr = (lv_table_t *) table;
@@ -129,6 +140,7 @@ void test_table_should_wrap_long_texts(void)
     TEST_ASSERT_GREATER_THAN(row_height, wrapped_row_height);
 }
 
+LV_FUNC_SECTION
 static void draw_part_event_cb(lv_event_t * e)
 {
     lv_draw_task_t * draw_task = lv_event_get_draw_task(e);
@@ -169,6 +181,7 @@ static void draw_part_event_cb(lv_event_t * e)
     }
 }
 
+LV_FUNC_SECTION
 void test_table_rendering(void)
 {
     lv_obj_center(table);
@@ -206,6 +219,7 @@ void test_table_rendering(void)
 }
 
 /* See #3120 for context */
+LV_FUNC_SECTION
 void test_table_should_reduce_cells(void)
 {
     const uint16_t initial_col_num = 8;
@@ -236,6 +250,7 @@ void test_table_should_reduce_cells(void)
 }
 
 /* See #3120 for context */
+LV_FUNC_SECTION
 void test_table_should_reduce_cells_with_more_than_one_row(void)
 {
     const uint16_t initial_col_num = 8;
@@ -265,6 +280,7 @@ void test_table_should_reduce_cells_with_more_than_one_row(void)
     }
 }
 
+LV_FUNC_SECTION
 void test_table_should_set_selected_cell(void)
 {
     lv_table_set_row_count(table, 2);
@@ -281,6 +297,7 @@ void test_table_should_set_selected_cell(void)
     TEST_ASSERT_EQUAL_UINT32(1, selected_column);
 }
 
+LV_FUNC_SECTION
 void test_table_cell_select_should_not_exceed_table_bounds(void)
 {
     lv_table_set_row_count(table, 2);
@@ -297,6 +314,7 @@ void test_table_cell_select_should_not_exceed_table_bounds(void)
     TEST_ASSERT_EQUAL_UINT32(1, selected_column);
 }
 
+LV_FUNC_SECTION
 void test_table_cell_select_should_not_allow_set_on_table_with_no_rows(void)
 {
     lv_table_set_row_count(table, 0);
diff --git a/tests/src/test_cases/widgets/test_tabview.c b/tests/src/test_cases/widgets/test_tabview.c
index e31fff1f1..a0e0cc5d7 100644
--- a/tests/src/test_cases/widgets/test_tabview.c
+++ b/tests/src/test_cases/widgets/test_tabview.c
@@ -27,16 +27,19 @@ void test_tabview_update_on_external_scroll(void);
 static lv_obj_t * active_screen = NULL;
 static lv_obj_t * tabview = NULL;
 
+LV_FUNC_SECTION
 void setUp(void)
 {
     active_screen = lv_screen_active();
 }
 
+LV_FUNC_SECTION
 void tearDown(void)
 {
     lv_obj_clean(active_screen);
 }
 
+LV_FUNC_SECTION
 void test_tabview_create_successful_dir_top(void)
 {
     tabview = lv_tabview_create(active_screen);
@@ -47,6 +50,7 @@ void test_tabview_create_successful_dir_top(void)
     TEST_ASSERT_EQUAL_SCREENSHOT("widgets/tabview_01.png");
 }
 
+LV_FUNC_SECTION
 void test_tabview_create_successful_dir_bottom(void)
 {
     tabview = lv_tabview_create(active_screen);
@@ -58,6 +62,7 @@ void test_tabview_create_successful_dir_bottom(void)
     TEST_ASSERT_EQUAL_SCREENSHOT("widgets/tabview_02.png");
 }
 
+LV_FUNC_SECTION
 void test_tabview_create_successful_dir_left(void)
 {
     tabview = lv_tabview_create(active_screen);
@@ -69,6 +74,7 @@ void test_tabview_create_successful_dir_left(void)
     TEST_ASSERT_EQUAL_SCREENSHOT("widgets/tabview_03.png");
 }
 
+LV_FUNC_SECTION
 void test_tabview_create_successful_dir_right(void)
 {
     tabview = lv_tabview_create(active_screen);
@@ -80,6 +86,7 @@ void test_tabview_create_successful_dir_right(void)
     TEST_ASSERT_EQUAL_SCREENSHOT("widgets/tabview_04.png");
 }
 
+LV_FUNC_SECTION
 void test_tabview_add_one_tab_empty(void)
 {
     tabview = lv_tabview_create(active_screen);
@@ -91,6 +98,7 @@ void test_tabview_add_one_tab_empty(void)
     TEST_ASSERT_NOT_NULL(tab1);
 }
 
+LV_FUNC_SECTION
 void test_tabview_add_one_tab_empty_hor(void)
 {
     tabview = lv_tabview_create(active_screen);
@@ -102,6 +110,7 @@ void test_tabview_add_one_tab_empty_hor(void)
     TEST_ASSERT_NOT_NULL(tab1);
 }
 
+LV_FUNC_SECTION
 void test_tabview_add_one_tab_no_scroll(void)
 {
     tabview = lv_tabview_create(active_screen);
@@ -117,6 +126,7 @@ void test_tabview_add_one_tab_no_scroll(void)
     TEST_ASSERT_EQUAL_SCREENSHOT("widgets/tabview_05.png");
 }
 
+LV_FUNC_SECTION
 void test_tabview_add_one_tab_with_scroll(void)
 {
     tabview = lv_tabview_create(active_screen);
@@ -145,6 +155,7 @@ void test_tabview_add_one_tab_with_scroll(void)
     TEST_ASSERT_EQUAL_SCREENSHOT("widgets/tabview_06.png");
 }
 
+LV_FUNC_SECTION
 void test_tabview_add_several_tabs_no_scroll(void)
 {
     tabview = lv_tabview_create(active_screen);
@@ -165,6 +176,7 @@ void test_tabview_add_several_tabs_no_scroll(void)
     TEST_ASSERT_EQUAL_SCREENSHOT("widgets/tabview_07.png");
 }
 
+LV_FUNC_SECTION
 void test_tabview_rename_tab(void)
 {
     tabview = lv_tabview_create(active_screen);
@@ -186,6 +198,7 @@ void test_tabview_rename_tab(void)
     TEST_ASSERT_EQUAL_SCREENSHOT("widgets/tabview_08.png");
 }
 
+LV_FUNC_SECTION
 void test_tabview_add_several_tabs_hor(void)
 {
     tabview = lv_tabview_create(active_screen);
@@ -206,6 +219,7 @@ void test_tabview_add_several_tabs_hor(void)
     TEST_ASSERT_EQUAL_SCREENSHOT("widgets/tabview_09.png");
 }
 
+LV_FUNC_SECTION
 void test_tabview_get_content(void)
 {
     tabview = lv_tabview_create(active_screen);
@@ -215,6 +229,7 @@ void test_tabview_get_content(void)
     TEST_ASSERT_NOT_NULL(content);
 }
 
+LV_FUNC_SECTION
 void test_tabview_get_tab_bar(void)
 {
     tabview = lv_tabview_create(active_screen);
@@ -224,6 +239,7 @@ void test_tabview_get_tab_bar(void)
     TEST_ASSERT_NOT_NULL(tab_bar);
 }
 
+LV_FUNC_SECTION
 void test_tabview_set_act_non_existent(void)
 {
     tabview = lv_tabview_create(active_screen);
@@ -233,6 +249,7 @@ void test_tabview_set_act_non_existent(void)
     TEST_ASSERT_EQUAL_SCREENSHOT("widgets/tabview_10.png");
 }
 
+LV_FUNC_SECTION
 void test_tabview_tab2_selected_event(void)
 {
     tabview = lv_tabview_create(active_screen);
@@ -251,6 +268,7 @@ void test_tabview_tab2_selected_event(void)
     TEST_ASSERT_EQUAL_UINT16(1, lv_tabview_get_tab_active(tabview));
 }
 
+LV_FUNC_SECTION
 void test_tabview_update_on_external_scroll(void)
 {
     tabview = lv_tabview_create(active_screen);
diff --git a/tests/src/test_cases/widgets/test_textarea.c b/tests/src/test_cases/widgets/test_textarea.c
index 11ab8d8fc..7a89c5a25 100644
--- a/tests/src/test_cases/widgets/test_textarea.c
+++ b/tests/src/test_cases/widgets/test_textarea.c
@@ -9,17 +9,20 @@ static lv_obj_t * textarea = NULL;
 
 static const char * textarea_default_text = "";
 
+LV_FUNC_SECTION
 void setUp(void)
 {
     active_screen = lv_screen_active();
     textarea = lv_textarea_create(active_screen);
 }
 
+LV_FUNC_SECTION
 void tearDown(void)
 {
     lv_obj_clean(active_screen);
 }
 
+LV_FUNC_SECTION
 void test_textarea_should_have_valid_documented_default_values(void)
 {
     TEST_ASSERT(lv_textarea_get_cursor_click_pos(textarea));
@@ -31,6 +34,7 @@ void test_textarea_should_have_valid_documented_default_values(void)
 
 /* When in password mode the lv_textarea_get_text function returns
  * the actual text, not the bullet characters. */
+LV_FUNC_SECTION
 void test_textarea_should_return_actual_text_when_password_mode_is_enabled(void)
 {
     const char * text = "Hello LVGL!";
@@ -42,6 +46,7 @@ void test_textarea_should_return_actual_text_when_password_mode_is_enabled(void)
     TEST_ASSERT_EQUAL_STRING(text, lv_textarea_get_text(textarea));
 }
 
+LV_FUNC_SECTION
 void test_textarea_should_update_label_style_with_one_line_enabled(void)
 {
     lv_textarea_t * txt_ptr = (lv_textarea_t *) textarea;
@@ -59,6 +64,7 @@ void test_textarea_should_update_label_style_with_one_line_enabled(void)
     TEST_ASSERT_EQUAL_UINT16(lv_pct(100), lv_obj_get_style_min_width(txt_ptr->label, LV_PART_MAIN));
 }
 
+LV_FUNC_SECTION
 void test_textarea_cursor_click_pos_field_update(void)
 {
     lv_textarea_set_cursor_click_pos(textarea, false);
@@ -66,6 +72,7 @@ void test_textarea_cursor_click_pos_field_update(void)
     TEST_ASSERT_FALSE(lv_textarea_get_cursor_click_pos(textarea));
 }
 
+LV_FUNC_SECTION
 void test_textarea_should_update_placeholder_text(void)
 {
     const char * new_placeholder = "LVGL Rocks!!!!!";
@@ -84,6 +91,7 @@ void test_textarea_should_update_placeholder_text(void)
     TEST_ASSERT_EQUAL_STRING("", lv_textarea_get_placeholder_text(textarea));
 }
 
+LV_FUNC_SECTION
 void test_textarea_should_keep_only_accepted_chars(void)
 {
     const char * accepted_list = "abcd";
@@ -94,6 +102,7 @@ void test_textarea_should_keep_only_accepted_chars(void)
     TEST_ASSERT_EQUAL_STRING(accepted_list, lv_textarea_get_text(textarea));
 }
 
+LV_FUNC_SECTION
 void test_textarea_in_one_line_mode_should_ignore_line_break_characters(void)
 {
     lv_textarea_set_one_line(textarea, true);
@@ -105,6 +114,7 @@ void test_textarea_in_one_line_mode_should_ignore_line_break_characters(void)
     TEST_ASSERT_EQUAL_STRING(textarea_default_text, lv_textarea_get_text(textarea));
 }
 
+LV_FUNC_SECTION
 void test_textarea_should_hide_password_characters(void)
 {
     lv_textarea_set_password_mode(textarea, true);
@@ -134,6 +144,7 @@ void test_textarea_should_hide_password_characters(void)
     TEST_ASSERT_EQUAL_STRING("OO", lv_label_get_text(lv_textarea_get_label(textarea)));
 }
 
+LV_FUNC_SECTION
 void test_textarea_properties(void)
 {
 #if LV_USE_OBJ_PROPERTY
diff --git a/tests/src/test_cases/widgets/test_win.c b/tests/src/test_cases/widgets/test_win.c
index 0e8647fad..5bc40335b 100644
--- a/tests/src/test_cases/widgets/test_win.c
+++ b/tests/src/test_cases/widgets/test_win.c
@@ -10,16 +10,19 @@ static lv_obj_t * content = NULL;
 
 const char * dummy_text = "Hello LVGL!";
 
+LV_FUNC_SECTION
 void setUp(void)
 {
     active_screen = lv_screen_active();
 }
 
+LV_FUNC_SECTION
 void tearDown(void)
 {
     lv_obj_clean(active_screen);
 }
 
+LV_FUNC_SECTION
 void test_win_should_have_valid_documented_default_values(void)
 {
     // Create the win object and update layout
@@ -46,6 +49,7 @@ void test_win_should_have_valid_documented_default_values(void)
     TEST_ASSERT_EQUAL(0, lv_obj_get_child_count(content));
 }
 
+LV_FUNC_SECTION
 void test_win_add_title_single(void)
 {
     // Create the win object, get the header and update layout
@@ -67,6 +71,7 @@ void test_win_add_title_single(void)
     TEST_ASSERT_EQUAL(1, lv_label_get_long_mode(title));
 }
 
+LV_FUNC_SECTION
 void test_win_add_title_multiple(void)
 {
     // Create the win object, get the header and update layout
@@ -84,6 +89,7 @@ void test_win_add_title_multiple(void)
     TEST_ASSERT_EQUAL(2, lv_obj_get_child_count(header));
 }
 
+LV_FUNC_SECTION
 void test_win_add_button(void)
 {
     int win_button_width = 50;
@@ -111,6 +117,7 @@ void test_win_add_button(void)
     TEST_ASSERT_EQUAL_SCREENSHOT("widgets/win_01.png");
 }
 
+LV_FUNC_SECTION
 void test_win_add_multiple_elements(void)
 {
     lv_obj_t * btn;
diff --git a/tests/src/test_libs/rnd_unicodes/lv_rnd_unicodes.c b/tests/src/test_libs/rnd_unicodes/lv_rnd_unicodes.c
index 9f83c4dc2..3af8f2c3e 100644
--- a/tests/src/test_libs/rnd_unicodes/lv_rnd_unicodes.c
+++ b/tests/src/test_libs/rnd_unicodes/lv_rnd_unicodes.c
@@ -51,11 +51,13 @@ const uint32_t LV_RND_UNICODE_ALPHANUM_AND_CJK_TABLE_LEN = sizeof(LV_RND_UNICODE
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 uint32_t RANDOM_CALL_PROCESS(void)
 {
     return lv_rand(0, UNICODE_MAX_VALUE);
 }
 
+LV_FUNC_SECTION
 int lv_random_utf8_chars(uint8_t * buf, int buf_len, const uint32_t * ranges, uint32_t range_num, int char_num)
 {
     return random_utf8_chars(buf, buf_len, ranges, range_num, char_num);
diff --git a/tests/src/test_libs/rnd_unicodes/rnd_unicodes/src/library.c b/tests/src/test_libs/rnd_unicodes/rnd_unicodes/src/library.c
index 6ebcded6a..4e3e2c410 100644
--- a/tests/src/test_libs/rnd_unicodes/rnd_unicodes/src/library.c
+++ b/tests/src/test_libs/rnd_unicodes/rnd_unicodes/src/library.c
@@ -25,6 +25,7 @@
 
 #include "library.h"
 
+LV_FUNC_SECTION
 __attribute__((weak)) uint32_t RANDOM_CALL_PROCESS(void)
 {
     /*Algorithm "xor" from p. 4 of Marsaglia, "Xorshift RNGs"*/
@@ -56,6 +57,7 @@ const uint32_t ALPHANUM_TABLE[] = {
 };
 const uint32_t ALPHANUM_TABLE_LEN = sizeof(ALPHANUM_TABLE) / sizeof(unicode_t) / 2;
 
+LV_FUNC_SECTION
 static int unicode_to_utf8_bytes_len(unicode_t unicode)
 {
     if(unicode < 0x80) {
@@ -78,6 +80,7 @@ static int unicode_to_utf8_bytes_len(unicode_t unicode)
     }
 }
 
+LV_FUNC_SECTION
 static int unicode_to_uft8(utf8_t * buf, uint32_t buf_len, unicode_t unicode)
 {
     uint32_t unicode_len = unicode_to_utf8_bytes_len(unicode);
@@ -127,6 +130,7 @@ static int unicode_to_uft8(utf8_t * buf, uint32_t buf_len, unicode_t unicode)
     return buf_index;
 }
 
+LV_FUNC_SECTION
 static int random_one_utf8_char(utf8_t * buf, int buf_len, unicode_t char_range_min, unicode_t char_range_max)
 {
     if(buf_len < 1) {
@@ -138,6 +142,7 @@ static int random_one_utf8_char(utf8_t * buf, int buf_len, unicode_t char_range_
     return unicode_to_uft8(buf, buf_len, r);
 }
 
+LV_FUNC_SECTION
 int random_utf8_chars(utf8_t * buf, int buf_len, const unicode_t * ranges, uint32_t range_num, int char_num)
 {
     if(buf_len < char_num) {
diff --git a/tests/unity/unity.c b/tests/unity/unity.c
index b0fd37349..c61376435 100644
--- a/tests/unity/unity.c
+++ b/tests/unity/unity.c
@@ -74,6 +74,7 @@ static const char UNITY_PROGMEM UnityStrDetail2Name[]            = " " UNITY_DET
 
 /*-----------------------------------------------*/
 /* Local helper function to print characters. */
+LV_FUNC_SECTION
 static void UnityPrintChar(const char* pch)
 {
     /* printable characters plus CR & LF are printed */
@@ -105,6 +106,7 @@ static void UnityPrintChar(const char* pch)
 /*-----------------------------------------------*/
 /* Local helper function to print ANSI escape strings e.g. "\033[42m". */
 #ifdef UNITY_OUTPUT_COLOR
+LV_FUNC_SECTION
 static UNITY_UINT UnityPrintAnsiEscapeString(const char* string)
 {
     const char* pch = string;
@@ -124,6 +126,7 @@ static UNITY_UINT UnityPrintAnsiEscapeString(const char* string)
 #endif
 
 /*-----------------------------------------------*/
+LV_FUNC_SECTION
 void UnityPrint(const char* string)
 {
     const char* pch = string;
@@ -146,6 +149,7 @@ void UnityPrint(const char* string)
     }
 }
 /*-----------------------------------------------*/
+LV_FUNC_SECTION
 void UnityPrintLen(const char* string, const UNITY_UINT32 length)
 {
     const char* pch = string;
@@ -184,6 +188,7 @@ void UnityPrintLen(const char* string, const UNITY_UINT32 length)
 }
 
 /*-----------------------------------------------*/
+LV_FUNC_SECTION
 void UnityPrintNumberByStyle(const UNITY_INT number, const UNITY_DISPLAY_STYLE_T style)
 {
     if ((style & UNITY_DISPLAY_RANGE_INT) == UNITY_DISPLAY_RANGE_INT)
@@ -235,6 +240,7 @@ void UnityPrintNumberByStyle(const UNITY_INT number, const UNITY_DISPLAY_STYLE_T
 }
 
 /*-----------------------------------------------*/
+LV_FUNC_SECTION
 void UnityPrintNumber(const UNITY_INT number_to_print)
 {
     UNITY_UINT number = (UNITY_UINT)number_to_print;
@@ -250,6 +256,7 @@ void UnityPrintNumber(const UNITY_INT number_to_print)
 
 /*-----------------------------------------------
  * basically do an itoa using as little ram as possible */
+LV_FUNC_SECTION
 void UnityPrintNumberUnsigned(const UNITY_UINT number)
 {
     UNITY_UINT divisor = 1;
@@ -269,6 +276,7 @@ void UnityPrintNumberUnsigned(const UNITY_UINT number)
 }
 
 /*-----------------------------------------------*/
+LV_FUNC_SECTION
 void UnityPrintNumberHex(const UNITY_UINT number, const char nibbles_to_print)
 {
     int nibble;
@@ -295,6 +303,7 @@ void UnityPrintNumberHex(const UNITY_UINT number, const char nibbles_to_print)
 }
 
 /*-----------------------------------------------*/
+LV_FUNC_SECTION
 void UnityPrintMask(const UNITY_UINT mask, const UNITY_UINT number)
 {
     UNITY_UINT current_bit = (UNITY_UINT)1 << (UNITY_INT_WIDTH - 1);
@@ -330,6 +339,7 @@ void UnityPrintMask(const UNITY_UINT mask, const UNITY_UINT number)
  * in single-precision operation (for that level of accuracy, a more
  * complicated algorithm would be needed).
  */
+LV_FUNC_SECTION
 void UnityPrintFloat(const UNITY_DOUBLE input_number)
 {
 #ifdef UNITY_INCLUDE_DOUBLE
@@ -491,6 +501,7 @@ void UnityPrintFloat(const UNITY_DOUBLE input_number)
 #endif /* ! UNITY_EXCLUDE_FLOAT_PRINT */
 
 /*-----------------------------------------------*/
+LV_FUNC_SECTION
 static void UnityTestResultsBegin(const char* file, const UNITY_LINE_TYPE line)
 {
 #ifdef UNITY_OUTPUT_FOR_ECLIPSE
@@ -534,6 +545,7 @@ static void UnityTestResultsBegin(const char* file, const UNITY_LINE_TYPE line)
 }
 
 /*-----------------------------------------------*/
+LV_FUNC_SECTION
 static void UnityTestResultsFailBegin(const UNITY_LINE_TYPE line)
 {
     UnityTestResultsBegin(Unity.TestFile, line);
@@ -542,6 +554,7 @@ static void UnityTestResultsFailBegin(const UNITY_LINE_TYPE line)
 }
 
 /*-----------------------------------------------*/
+LV_FUNC_SECTION
 void UnityConcludeTest(void)
 {
     if (Unity.CurrentTestIgnored)
@@ -566,6 +579,7 @@ void UnityConcludeTest(void)
 }
 
 /*-----------------------------------------------*/
+LV_FUNC_SECTION
 static void UnityAddMsgIfSpecified(const char* msg)
 {
 #ifdef UNITY_PRINT_TEST_CONTEXT
@@ -593,6 +607,7 @@ static void UnityAddMsgIfSpecified(const char* msg)
 }
 
 /*-----------------------------------------------*/
+LV_FUNC_SECTION
 static void UnityPrintExpectedAndActualStrings(const char* expected, const char* actual)
 {
     UnityPrint(UnityStrExpected);
@@ -620,6 +635,7 @@ static void UnityPrintExpectedAndActualStrings(const char* expected, const char*
 }
 
 /*-----------------------------------------------*/
+LV_FUNC_SECTION
 static void UnityPrintExpectedAndActualStringsLen(const char* expected,
                                                   const char* actual,
                                                   const UNITY_UINT32 length)
@@ -653,6 +669,7 @@ static void UnityPrintExpectedAndActualStringsLen(const char* expected,
  *-----------------------------------------------*/
 
 /*-----------------------------------------------*/
+LV_FUNC_SECTION
 static int UnityIsOneArrayNull(UNITY_INTERNAL_PTR expected,
                                UNITY_INTERNAL_PTR actual,
                                const UNITY_LINE_TYPE lineNumber,
@@ -687,6 +704,7 @@ static int UnityIsOneArrayNull(UNITY_INTERNAL_PTR expected,
  *-----------------------------------------------*/
 
 /*-----------------------------------------------*/
+LV_FUNC_SECTION
 void UnityAssertBits(const UNITY_INT mask,
                      const UNITY_INT expected,
                      const UNITY_INT actual,
@@ -708,6 +726,7 @@ void UnityAssertBits(const UNITY_INT mask,
 }
 
 /*-----------------------------------------------*/
+LV_FUNC_SECTION
 void UnityAssertEqualNumber(const UNITY_INT expected,
                             const UNITY_INT actual,
                             const char* msg,
@@ -729,6 +748,7 @@ void UnityAssertEqualNumber(const UNITY_INT expected,
 }
 
 /*-----------------------------------------------*/
+LV_FUNC_SECTION
 void UnityAssertGreaterOrLessOrEqualNumber(const UNITY_INT threshold,
                                            const UNITY_INT actual,
                                            const UNITY_COMPARISON_T compare,
@@ -777,6 +797,7 @@ do {                                       \
 } while (0)
 
 /*-----------------------------------------------*/
+LV_FUNC_SECTION
 void UnityAssertEqualIntArray(UNITY_INTERNAL_PTR expected,
                               UNITY_INTERNAL_PTR actual,
                               const UNITY_UINT32 num_elements,
@@ -922,6 +943,7 @@ void UnityAssertEqualIntArray(UNITY_INTERNAL_PTR expected,
 #endif /* UNITY_EXCLUDE_FLOAT_PRINT */
 
 /*-----------------------------------------------*/
+LV_FUNC_SECTION
 static int UnityFloatsWithin(UNITY_FLOAT delta, UNITY_FLOAT expected, UNITY_FLOAT actual)
 {
     UNITY_FLOAT diff;
@@ -929,6 +951,7 @@ static int UnityFloatsWithin(UNITY_FLOAT delta, UNITY_FLOAT expected, UNITY_FLOA
 }
 
 /*-----------------------------------------------*/
+LV_FUNC_SECTION
 void UnityAssertWithinFloatArray(const UNITY_FLOAT delta,
                                  UNITY_PTR_ATTRIBUTE const UNITY_FLOAT* expected,
                                  UNITY_PTR_ATTRIBUTE const UNITY_FLOAT* actual,
@@ -1009,6 +1032,7 @@ void UnityAssertWithinFloatArray(const UNITY_FLOAT delta,
 }
 
 /*-----------------------------------------------*/
+LV_FUNC_SECTION
 void UnityAssertFloatsWithin(const UNITY_FLOAT delta,
                              const UNITY_FLOAT expected,
                              const UNITY_FLOAT actual,
@@ -1028,6 +1052,7 @@ void UnityAssertFloatsWithin(const UNITY_FLOAT delta,
 }
 
 /*-----------------------------------------------*/
+LV_FUNC_SECTION
 void UnityAssertFloatsNotWithin(const UNITY_FLOAT delta,
                                 const UNITY_FLOAT expected,
                                 const UNITY_FLOAT actual,
@@ -1049,6 +1074,7 @@ void UnityAssertFloatsNotWithin(const UNITY_FLOAT delta,
 }
 
 /*-----------------------------------------------*/
+LV_FUNC_SECTION
 void UnityAssertGreaterOrLessFloat(const UNITY_FLOAT threshold,
                                    const UNITY_FLOAT actual,
                                    const UNITY_COMPARISON_T compare,
@@ -1082,6 +1108,7 @@ void UnityAssertGreaterOrLessFloat(const UNITY_FLOAT threshold,
 }
 
 /*-----------------------------------------------*/
+LV_FUNC_SECTION
 void UnityAssertFloatSpecial(const UNITY_FLOAT actual,
                              const char* msg,
                              const UNITY_LINE_TYPE lineNumber,
@@ -1150,6 +1177,7 @@ void UnityAssertFloatSpecial(const UNITY_FLOAT actual,
 
 /*-----------------------------------------------*/
 #ifndef UNITY_EXCLUDE_DOUBLE
+LV_FUNC_SECTION
 static int UnityDoublesWithin(UNITY_DOUBLE delta, UNITY_DOUBLE expected, UNITY_DOUBLE actual)
 {
     UNITY_DOUBLE diff;
@@ -1157,6 +1185,7 @@ static int UnityDoublesWithin(UNITY_DOUBLE delta, UNITY_DOUBLE expected, UNITY_D
 }
 
 /*-----------------------------------------------*/
+LV_FUNC_SECTION
 void UnityAssertWithinDoubleArray(const UNITY_DOUBLE delta,
                                   UNITY_PTR_ATTRIBUTE const UNITY_DOUBLE* expected,
                                   UNITY_PTR_ATTRIBUTE const UNITY_DOUBLE* actual,
@@ -1237,6 +1266,7 @@ void UnityAssertWithinDoubleArray(const UNITY_DOUBLE delta,
 }
 
 /*-----------------------------------------------*/
+LV_FUNC_SECTION
 void UnityAssertDoublesWithin(const UNITY_DOUBLE delta,
                               const UNITY_DOUBLE expected,
                               const UNITY_DOUBLE actual,
@@ -1255,6 +1285,7 @@ void UnityAssertDoublesWithin(const UNITY_DOUBLE delta,
 }
 
 /*-----------------------------------------------*/
+LV_FUNC_SECTION
 void UnityAssertDoublesNotWithin(const UNITY_DOUBLE delta,
                                  const UNITY_DOUBLE expected,
                                  const UNITY_DOUBLE actual,
@@ -1276,6 +1307,7 @@ void UnityAssertDoublesNotWithin(const UNITY_DOUBLE delta,
 }
 
 /*-----------------------------------------------*/
+LV_FUNC_SECTION
 void UnityAssertGreaterOrLessDouble(const UNITY_DOUBLE threshold,
                                     const UNITY_DOUBLE actual,
                                     const UNITY_COMPARISON_T compare,
@@ -1309,6 +1341,7 @@ void UnityAssertGreaterOrLessDouble(const UNITY_DOUBLE threshold,
 }
 
 /*-----------------------------------------------*/
+LV_FUNC_SECTION
 void UnityAssertDoubleSpecial(const UNITY_DOUBLE actual,
                               const char* msg,
                               const UNITY_LINE_TYPE lineNumber,
@@ -1376,6 +1409,7 @@ void UnityAssertDoubleSpecial(const UNITY_DOUBLE actual,
 #endif /* not UNITY_EXCLUDE_DOUBLE */
 
 /*-----------------------------------------------*/
+LV_FUNC_SECTION
 void UnityAssertNumbersWithin(const UNITY_UINT delta,
                               const UNITY_INT expected,
                               const UNITY_INT actual,
@@ -1423,6 +1457,7 @@ void UnityAssertNumbersWithin(const UNITY_UINT delta,
 }
 
 /*-----------------------------------------------*/
+LV_FUNC_SECTION
 void UnityAssertNumbersArrayWithin(const UNITY_UINT delta,
                                    UNITY_INTERNAL_PTR expected,
                                    UNITY_INTERNAL_PTR actual,
@@ -1587,6 +1622,7 @@ void UnityAssertNumbersArrayWithin(const UNITY_UINT delta,
 }
 
 /*-----------------------------------------------*/
+LV_FUNC_SECTION
 void UnityAssertEqualString(const char* expected,
                             const char* actual,
                             const char* msg,
@@ -1626,6 +1662,7 @@ void UnityAssertEqualString(const char* expected,
 }
 
 /*-----------------------------------------------*/
+LV_FUNC_SECTION
 void UnityAssertEqualStringLen(const char* expected,
                                const char* actual,
                                const UNITY_UINT32 length,
@@ -1666,6 +1703,7 @@ void UnityAssertEqualStringLen(const char* expected,
 }
 
 /*-----------------------------------------------*/
+LV_FUNC_SECTION
 void UnityAssertEqualStringArray(UNITY_INTERNAL_PTR expected,
                                  const char** actual,
                                  const UNITY_UINT32 num_elements,
@@ -1749,6 +1787,7 @@ void UnityAssertEqualStringArray(UNITY_INTERNAL_PTR expected,
 }
 
 /*-----------------------------------------------*/
+LV_FUNC_SECTION
 void UnityAssertEqualMemory(UNITY_INTERNAL_PTR expected,
                             UNITY_INTERNAL_PTR actual,
                             const UNITY_UINT32 length,
@@ -1838,6 +1877,7 @@ static union
 #endif
 } UnityQuickCompare;
 
+LV_FUNC_SECTION
 UNITY_INTERNAL_PTR UnityNumToPtr(const UNITY_INT num, const UNITY_UINT8 size)
 {
     switch(size)
@@ -1864,6 +1904,7 @@ UNITY_INTERNAL_PTR UnityNumToPtr(const UNITY_INT num, const UNITY_UINT8 size)
 
 #ifndef UNITY_EXCLUDE_FLOAT
 /*-----------------------------------------------*/
+LV_FUNC_SECTION
 UNITY_INTERNAL_PTR UnityFloatToPtr(const float num)
 {
     UnityQuickCompare.f = num;
@@ -1873,6 +1914,7 @@ UNITY_INTERNAL_PTR UnityFloatToPtr(const float num)
 
 #ifndef UNITY_EXCLUDE_DOUBLE
 /*-----------------------------------------------*/
+LV_FUNC_SECTION
 UNITY_INTERNAL_PTR UnityDoubleToPtr(const double num)
 {
     UnityQuickCompare.d = num;
@@ -1915,6 +1957,7 @@ do {                                                               \
     }                                                              \
 } while (0)
 
+LV_FUNC_SECTION
 static enum UnityLengthModifier UnityLengthModifierGet(const char *pch, int *length)
 {
     enum UnityLengthModifier length_mod;
@@ -1970,6 +2013,7 @@ static enum UnityLengthModifier UnityLengthModifierGet(const char *pch, int *len
 /*-----------------------------------------------
  * printf helper function
  *-----------------------------------------------*/
+LV_FUNC_SECTION
 static void UnityPrintFVA(const char* format, va_list va)
 {
     const char* pch = format;
@@ -2098,6 +2142,7 @@ static void UnityPrintFVA(const char* format, va_list va)
     }
 }
 
+LV_FUNC_SECTION
 void UnityPrintF(const UNITY_LINE_TYPE line, const char* format, ...)
 {
     UnityTestResultsBegin(Unity.TestFile, line);
@@ -2120,6 +2165,7 @@ void UnityPrintF(const UNITY_LINE_TYPE line, const char* format, ...)
  *-----------------------------------------------*/
 
 /*-----------------------------------------------*/
+LV_FUNC_SECTION
 void UnityFail(const char* msg, const UNITY_LINE_TYPE line)
 {
     RETURN_IF_FAIL_OR_IGNORE;
@@ -2157,6 +2203,7 @@ void UnityFail(const char* msg, const UNITY_LINE_TYPE line)
 }
 
 /*-----------------------------------------------*/
+LV_FUNC_SECTION
 void UnityIgnore(const char* msg, const UNITY_LINE_TYPE line)
 {
     RETURN_IF_FAIL_OR_IGNORE;
@@ -2173,6 +2220,7 @@ void UnityIgnore(const char* msg, const UNITY_LINE_TYPE line)
 }
 
 /*-----------------------------------------------*/
+LV_FUNC_SECTION
 void UnityMessage(const char* msg, const UNITY_LINE_TYPE line)
 {
     UnityTestResultsBegin(Unity.TestFile, line);
@@ -2189,6 +2237,7 @@ void UnityMessage(const char* msg, const UNITY_LINE_TYPE line)
 /*-----------------------------------------------*/
 /* If we have not defined our own test runner, then include our default test runner to make life easier */
 #ifndef UNITY_SKIP_DEFAULT_RUNNER
+LV_FUNC_SECTION
 void UnityDefaultTestRun(UnityTestFunction Func, const char* FuncName, const int FuncLineNum)
 {
     Unity.CurrentTestName = FuncName;
@@ -2211,12 +2260,14 @@ void UnityDefaultTestRun(UnityTestFunction Func, const char* FuncName, const int
 #endif
 
 /*-----------------------------------------------*/
+LV_FUNC_SECTION
 void UnitySetTestFile(const char* filename)
 {
     Unity.TestFile = filename;
 }
 
 /*-----------------------------------------------*/
+LV_FUNC_SECTION
 void UnityBegin(const char* filename)
 {
     Unity.TestFile = filename;
@@ -2233,6 +2284,7 @@ void UnityBegin(const char* filename)
 }
 
 /*-----------------------------------------------*/
+LV_FUNC_SECTION
 int UnityEnd(void)
 {
     UNITY_PRINT_EOL();
@@ -2272,6 +2324,7 @@ char* UnityOptionExcludeNamed = NULL;
 int UnityVerbosity            = 1;
 
 /*-----------------------------------------------*/
+LV_FUNC_SECTION
 int UnityParseOptions(int argc, char** argv)
 {
     int i;
@@ -2350,6 +2403,7 @@ int UnityParseOptions(int argc, char** argv)
 }
 
 /*-----------------------------------------------*/
+LV_FUNC_SECTION
 int IsStringInBiggerString(const char* longstring, const char* shortstring)
 {
     const char* lptr = longstring;
@@ -2395,6 +2449,7 @@ int IsStringInBiggerString(const char* longstring, const char* shortstring)
 }
 
 /*-----------------------------------------------*/
+LV_FUNC_SECTION
 int UnityStringArgumentMatches(const char* str)
 {
     int retval;
@@ -2458,6 +2513,7 @@ int UnityStringArgumentMatches(const char* str)
 }
 
 /*-----------------------------------------------*/
+LV_FUNC_SECTION
 int UnityTestMatches(void)
 {
     /* Check if this test name matches the included test pattern */
diff --git a/tests/unity/unity_support.c b/tests/unity/unity_support.c
index 25f11d729..05c4e7f95 100644
--- a/tests/unity/unity_support.c
+++ b/tests/unity/unity_support.c
@@ -81,6 +81,7 @@ static void create_folders_if_needed(const char * path) ;
  *   GLOBAL FUNCTIONS
  **********************/
 
+LV_FUNC_SECTION
 bool lv_test_assert_image_eq(const char * fn_ref)
 {
     bool pass;
@@ -141,6 +142,7 @@ static uint8_t screen_buf_xrgb8888[800 * 480 * 4];
  * @param mode          arbitrary string to tell more about the compare
  * @return  true: test passed; false: test failed
  */
+LV_FUNC_SECTION
 static bool screenshot_compare(const char * fn_ref, const char * mode, uint8_t tolerance)
 {
 
@@ -219,6 +221,7 @@ static bool screenshot_compare(const char * fn_ref, const char * mode, uint8_t t
 
 }
 
+LV_FUNC_SECTION
 static int read_png_file(png_image_t * p, const char * file_name)
 {
     char header[8];    // 8 is the maximum size that can be checked
@@ -283,6 +286,7 @@ static int read_png_file(png_image_t * p, const char * file_name)
     return 0;
 }
 
+LV_FUNC_SECTION
 static int write_png_file(void * raw_img, uint32_t width, uint32_t height, char * file_name)
 {
     png_structp png_ptr;
@@ -367,6 +371,7 @@ static int write_png_file(void * raw_img, uint32_t width, uint32_t height, char
     return 0;
 }
 
+LV_FUNC_SECTION
 static void png_release(png_image_t * p)
 {
     int y;
@@ -377,6 +382,7 @@ static void png_release(png_image_t * p)
     png_destroy_read_struct(&p->png_ptr, &p->info_ptr, NULL);
 }
 
+LV_FUNC_SECTION
 static void buf_to_xrgb8888(const lv_draw_buf_t * draw_buf, uint8_t * buf_out)
 {
     uint32_t stride = draw_buf->header.stride;
@@ -482,6 +488,7 @@ static void buf_to_xrgb8888(const lv_draw_buf_t * draw_buf, uint8_t * buf_out)
     }
 }
 
+LV_FUNC_SECTION
 static void create_folders_if_needed(const char * path)
 {
     char * ptr;
